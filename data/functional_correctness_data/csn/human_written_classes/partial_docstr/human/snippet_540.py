import posixpath
import re
from sphinx.search import js_index
from sphinx.errors import ExtensionError
from pathlib import Path
import os

class SphinxDocLinkResolver:
    """Resolve documentation links using searchindex.js generated by Sphinx.

    Parameters
    ----------
    doc_url : str
        The base URL of the project website.
    relative : bool
        Return relative links (only useful for links to documentation of this
        package).
    """

    def __init__(self, config, doc_url, gallery_dir, relative=False):
        self.config = config
        self.doc_url = doc_url
        self.gallery_dir = gallery_dir
        self.relative = relative
        self._link_cache = {}
        if isinstance(doc_url, Path):
            index_url = os.path.join(doc_url, 'index.html')
            searchindex_url = os.path.join(doc_url, 'searchindex.js')
            docopts_url = os.path.join(doc_url, '_static', 'documentation_options.js')
        else:
            if relative:
                raise ExtensionError('Relative links are only supported for local URLs (doc_url cannot be absolute)')
            index_url = doc_url + '/'
            searchindex_url = doc_url + '/searchindex.js'
            docopts_url = doc_url + '/_static/documentation_options.js'
        if os.name.lower() == 'nt' and isinstance(doc_url, Path):
            if not relative:
                raise ExtensionError('You have to use relative=True for the local package on a Windows system.')
            self._is_windows = True
        else:
            self._is_windows = False
        index = get_data(index_url, gallery_dir)
        if 'var DOCUMENTATION_OPTIONS' in index:
            self._docopts = parse_sphinx_docopts(index)
        else:
            docopts = get_data(docopts_url, gallery_dir)
            self._docopts = parse_sphinx_docopts(docopts)
        sindex = get_data(searchindex_url, gallery_dir)
        self._searchindex = js_index.loads(sindex)

    def _get_index_match(self, first, second):
        try:
            match = self._searchindex['objects'][first]
        except KeyError:
            return None
        else:
            if isinstance(match, dict):
                try:
                    match = match[second]
                except KeyError:
                    return None
            elif isinstance(match, (list, tuple)):
                try:
                    for item in match:
                        if item[4] == second:
                            match = item[:4]
                            break
                    else:
                        return None
                except Exception:
                    return None
        return match

    def _get_link_type(self, cobj, use_full_module=False):
        """Get a valid link and type_, False if not found."""
        module_type = 'module' if use_full_module else 'module_short'
        first, second = (cobj[module_type], cobj['name'])
        match = self._get_index_match(first, second)
        if match is None and '.' in second:
            first, second = second.split('.', 1)
            first = '.'.join([cobj[module_type], first])
            match = self._get_index_match(first, second)
        if match is None:
            link = type_ = None
        else:
            fname_idx = match[0]
            objname_idx = str(match[1])
            anchor = match[3]
            type_ = self._searchindex['objtypes'][objname_idx]
            fname = self._searchindex['filenames'][fname_idx]
            ext = self._docopts.get('FILE_SUFFIX', '.rst.html')
            fname = os.path.splitext(fname)[0] + ext
            if self._is_windows:
                fname = fname.replace('/', '\\')
                link = os.path.join(self.doc_url, fname)
            else:
                link = posixpath.join(self.doc_url, fname)
            fullname = '.'.join([first, second])
            if anchor == '':
                anchor = fullname
            elif anchor == '-':
                anchor = self._searchindex['objnames'][objname_idx][1] + '-' + fullname
            link = link + '#' + anchor
        return (link, type_)

    def resolve(self, cobj, this_url, return_type=False):
        """Resolve the link to the documentation, returns None if not found.

        Parameters
        ----------
        cobj : Dict[str, Any]
            Dict with information about the "code object" for which we are
            resolving a link.

                - cobj['name'] : function or class name (str)
                - cobj['module'] : module name (str)
                - cobj['module_short'] : shortened module name (str)
                - cobj['is_class'] : whether object is class (bool)
                - cobj['is_explicit'] : whether object is an explicit
                  backreference (referred to by sphinx markup) (bool)
        this_url: str
            URL of the current page. Needed to construct relative URLs
            (only used if relative=True in constructor).
        return_type : bool
            If True, return the type as well.

        Returns
        -------
        link : str or None
            The link (URL) to the documentation.
        type_ : str
            The type. Only returned if return_type is True.
        """
        full_name = cobj['module_short'] + '.' + cobj['name']
        if full_name not in self._link_cache:
            use_full_module = False
            for pattern in self.config['prefer_full_module']:
                if re.search(pattern, cobj['module'] + '.' + cobj['name']):
                    use_full_module = True
                    break
            self._link_cache[full_name] = self._get_link_type(cobj, use_full_module)
        link, type_ = self._link_cache[full_name]
        if self.relative and link is not None:
            link = os.path.relpath(link, start=this_url)
            if self._is_windows:
                link = link.replace('\\', '/')
            link = link[3:]
        return (link, type_) if return_type else link