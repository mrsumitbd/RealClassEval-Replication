
from PIL import Image
import numpy as np
from typing import List, Union, Tuple


class LoadPilAndNumpy:
    '''
    Load images from PIL and Numpy arrays for batch processing.
    This class manages loading and pre-processing of image data from both PIL and Numpy formats. It performs basic
    validation and format conversion to ensure that the images are in the required format for downstream processing.
    Attributes:
        paths (List[str]): List of image paths or autogenerated filenames.
        im0 (List[np.ndarray]): List of images stored as Numpy arrays.
        mode (str): Type of data being processed, set to 'image'.
        bs (int): Batch size, equivalent to the length of `im0`.
    Methods:
        _single_check: Validate and format a single image to a Numpy array.
    Examples:
        >>> from PIL import Image
        >>> import numpy as np
        >>> pil_img = Image.new("RGB", (100, 100))
        >>> np_img = np.random.randint(0, 255, (100, 100, 3), dtype=np.uint8)
        >>> loader = LoadPilAndNumpy([pil_img, np_img])
        >>> paths, images, _ = next(iter(loader))
        >>> print(f"Loaded {len(images)} images")
        Loaded 2 images
    '''

    def __init__(self, im0: List[Union[Image.Image, np.ndarray]]):
        '''Initializes a loader for PIL and Numpy images, converting inputs to a standardized format.'''
        self.paths = [f'image_{i}' for i in range(len(im0))]
        self.im0 = [self._single_check(im) for im in im0]
        self.mode = 'image'
        self.bs = len(self.im0)

    @staticmethod
    def _single_check(im: Union[Image.Image, np.ndarray]) -> np.ndarray:
        if isinstance(im, Image.Image):
            return np.array(im)
        elif isinstance(im, np.ndarray):
            if im.dtype != np.uint8:
                raise ValueError("Numpy array must have dtype uint8")
            if im.ndim != 3 or im.shape[2] not in [1, 3]:
                raise ValueError(
                    "Numpy array must be of shape (height, width, channels) with channels 1 or 3")
            return im
        else:
            raise TypeError("Input must be a PIL Image or a Numpy array")

    def __len__(self) -> int:
        '''Returns the length of the 'im0' attribute, representing the number of loaded images.'''
        return self.bs

    def __next__(self) -> Tuple[List[str], List[np.ndarray], str]:
        '''Returns the next batch of images, paths, and metadata for processing.'''
        if not self.im0:
            raise StopIteration
        images = self.im0
        paths = self.paths
        metadata = self.mode
        self.im0 = []
        self.paths = []
        return paths, images, metadata

    def __iter__(self):
        '''Iterates through PIL/numpy images, yielding paths, raw images, and metadata for processing.'''
        return self
