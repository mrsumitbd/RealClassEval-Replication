from pathlib import Path
from typing import Optional, Union, List
import datetime
import re


class ConfigSpaceHexFormatter:
    '''
    Formats PCI configuration space data into hex files for FPGA initialization.
    This class handles:
    - Converting configuration space bytes to little-endian 32-bit words
    - Generating properly formatted hex files for Vivado $readmemh
    - Adding debug comments with register offsets
    - Ensuring proper alignment and padding
    '''

    def __init__(self):
        '''Initialize the hex formatter.'''
        self._standard_registers = {
            0x00: "Vendor ID / Device ID",
            0x04: "Command / Status",
            0x08: "Revision ID / ProgIF / Subclass / Class Code",
            0x0C: "Cache Line Size / Latency Timer / Header Type / BIST",
            0x10: "BAR0",
            0x14: "BAR1",
            0x18: "BAR2 (Type 0) or Primary/Secondary/Subordinate Bus Numbers (Type 1)",
            0x1C: "BAR3 (Type 0) or I/O Base/Limit (Type 1)",
            0x20: "BAR4 (Type 0) or Secondary Status / Memory Base/Limit (Type 1)",
            0x24: "BAR5 (Type 0) or Prefetchable Memory Base/Limit (Type 1)",
            0x28: "CardBus CIS Pointer (Type 0) or Prefetchable Base Upper 32 (Type 1)",
            0x2C: "Subsystem Vendor ID / Subsystem ID (Type 0) or Prefetchable Limit Upper 32 (Type 1)",
            0x30: "Expansion ROM Base Address (Type 0) or I/O Base/Limit Upper 16 (Type 1)",
            0x34: "Capabilities Pointer",
            0x38: "Reserved (Type 0) or Expansion ROM Base Address (Type 1)",
            0x3C: "Interrupt Line / Interrupt Pin / Min_Gnt / Max_Lat (Type 0) or Bridge Control (Type 1)",
        }

    def format_config_space_to_hex(self, config_space_data: bytes, include_comments: bool = True, words_per_line: int = 1, vendor_id: Optional[str] = None, device_id: Optional[str] = None, class_code: Optional[str] = None, board: Optional[str] = None) -> str:
        '''
        Convert configuration space data to hex format.
        Args:
            config_space_data: Raw configuration space bytes
            include_comments: Whether to include offset/register comments
            words_per_line: Number of 32-bit words per line (default: 1)
        Returns:
            Formatted hex string suitable for $readmemh
        Raises:
            ValueError: If config space data is invalid
        '''
        if not isinstance(config_space_data, (bytes, bytearray, memoryview)):
            raise ValueError("config_space_data must be bytes-like.")
        if len(config_space_data) == 0:
            raise ValueError("config_space_data cannot be empty.")
        if not isinstance(words_per_line, int) or words_per_line < 1:
            raise ValueError("words_per_line must be an integer >= 1.")

        dwords = self.convert_to_dword_list(config_space_data)

        lines: List[str] = []

        if include_comments:
            now = datetime.datetime.utcnow().isoformat(timespec="seconds") + "Z"
            lines.append("// PCI configuration space init file for $readmemh")
            lines.append(f"// Generated by ConfigSpaceHexFormatter on {now}")
            lines.append(
                f"// Length: {len(dwords) * 4} bytes; Words: {len(dwords)}; Words/line: {words_per_line}")
            meta_parts = []
            if vendor_id is not None:
                meta_parts.append(f"VendorID={vendor_id}")
            if device_id is not None:
                meta_parts.append(f"DeviceID={device_id}")
            if class_code is not None:
                meta_parts.append(f"ClassCode={class_code}")
            if board is not None:
                meta_parts.append(f"Board={board}")
            if meta_parts:
                lines.append("// " + " | ".join(meta_parts))
            lines.append("//")

        for base_index in range(0, len(dwords), words_per_line):
            chunk = dwords[base_index:base_index + words_per_line]
            word_text = " ".join(f"{w:08x}" for w in chunk)
            if include_comments:
                # Build a comment that includes offsets and known register names
                comment_segments = []
                for j, _ in enumerate(chunk):
                    off = (base_index + j) * 4
                    desc = self._get_register_comment(off)
                    if desc:
                        comment_segments.append(f"0x{off:08x}: {desc}")
                    else:
                        comment_segments.append(f"0x{off:08x}")
                comment = " // " + " | ".join(comment_segments)
                lines.append(word_text + comment)
            else:
                lines.append(word_text)

        return "\n".join(lines) + "\n"

    def _get_register_comment(self, offset: int) -> Optional[str]:
        '''
        Get a descriptive comment for a register offset.
        Args:
            offset: Register offset in configuration space
        Returns:
            Register description or None if no standard register
        '''
        return self._standard_registers.get(offset)

    def write_hex_file(self, config_space_data: bytes, output_path: Union[str, Path], include_comments: bool = True) -> Path:
        '''
        Write configuration space data to a hex file.
        Args:
            config_space_data: Raw configuration space bytes
            output_path: Path where hex file should be written
            include_comments: Whether to include offset/register comments
        Returns:
            Path to the written hex file
        Raises:
            IOError: If file cannot be written
        '''
        hex_str = self.format_config_space_to_hex(
            config_space_data, include_comments=include_comments)
        path = Path(output_path)
        try:
            if path.parent:
                path.parent.mkdir(parents=True, exist_ok=True)
            path.write_text(hex_str, encoding="utf-8")
        except OSError as e:
            raise IOError(str(e))
        return path

    def validate_hex_file(self, hex_file_path: Union[str, Path]) -> bool:
        '''
        Validate a hex file for proper formatting.
        Args:
            hex_file_path: Path to hex file to validate
        Returns:
            True if valid, False otherwise
        '''
        path = Path(hex_file_path)
        if not path.is_file():
            return False

        hex_token_re = re.compile(r"^[0-9A-Fa-f]{1,8}$")
        has_data = False

        try:
            for raw_line in path.read_text(encoding="utf-8").splitlines():
                line = raw_line.strip()
                if not line:
                    continue
                if line.startswith("//"):
                    continue
                # Remove inline comment
                if "//" in line:
                    line = line.split("//", 1)[0].rstrip()
                if not line:
                    # nothing but comment
                    continue
                tokens = line.split()
                if not tokens:
                    continue
                for tok in tokens:
                    # $readmemh tokens should not be 0x-prefixed, must be hex digits
                    if tok.startswith(("0x", "0X")):
                        return False
                    if not hex_token_re.fullmatch(tok):
                        return False
                has_data = True
        except OSError:
            return False

        return has_data

    def convert_to_dword_list(self, config_space_data: bytes) -> List[int]:
        '''
        Convert configuration space bytes to a list of 32-bit dwords.
        Args:
            config_space_data: Raw configuration space bytes
        Returns:
            List of 32-bit integers in little-endian format
        '''
        if not isinstance(config_space_data, (bytes, bytearray, memoryview)):
            raise ValueError("config_space_data must be bytes-like.")
        data = bytes(config_space_data)
        if len(data) == 0:
            return []
        pad = (-len(data)) % 4
        if pad:
            data += b"\x00" * pad
        dwords: List[int] = []
        for i in range(0, len(data), 4):
            dwords.append(int.from_bytes(
                data[i:i+4], byteorder="little", signed=False))
        return dwords
