import numpy as np
from typing import List, Union

try:
    from PIL import Image
    _PIL_AVAILABLE = True
except Exception:
    _PIL_AVAILABLE = False


class LoadPilAndNumpy:
    '''
    Load images from PIL and Numpy arrays for batch processing.
    This class manages loading and pre-processing of image data from both PIL and Numpy formats. It performs basic
    validation and format conversion to ensure that the images are in the required format for downstream processing.
    Attributes:
        paths (List[str]): List of image paths or autogenerated filenames.
        im0 (List[np.ndarray]): List of images stored as Numpy arrays.
        mode (str): Type of data being processed, set to 'image'.
        bs (int): Batch size, equivalent to the length of `im0`.
    Methods:
        _single_check: Validate and format a single image to a Numpy array.
    Examples:
        >>> from PIL import Image
        >>> import numpy as np
        >>> pil_img = Image.new("RGB", (100, 100))
        >>> np_img = np.random.randint(0, 255, (100, 100, 3), dtype=np.uint8)
        >>> loader = LoadPilAndNumpy([pil_img, np_img])
        >>> paths, images, _ = next(iter(loader))
        >>> print(f"Loaded {len(images)} images")
        Loaded 2 images
    '''

    def __init__(self, im0: Union[np.ndarray, "Image.Image", List[Union[np.ndarray, "Image.Image"]]]):
        '''Initializes a loader for PIL and Numpy images, converting inputs to a standardized format.'''
        if im0 is None:
            raise ValueError(
                "im0 must be a PIL.Image.Image, a numpy.ndarray, or a list of them.")

        # Normalize to list
        if isinstance(im0, (list, tuple)):
            inputs = list(im0)
        else:
            inputs = [im0]

        if len(inputs) == 0:
            raise ValueError("Empty input list provided to LoadPilAndNumpy.")

        self.im0: List[np.ndarray] = []
        self.paths: List[str] = []

        for i, src in enumerate(inputs):
            arr = self._single_check(src)
            self.im0.append(arr)

            # Derive a path-like name
            name = None
            if _PIL_AVAILABLE and isinstance(src, Image.Image):
                # Prefer filename if available
                name = getattr(src, "filename", None) or None
            if not name:
                prefix = "pil_image" if (_PIL_AVAILABLE and isinstance(
                    src, Image.Image)) else "numpy_image"
                name = f"{prefix}_{i}.jpg"
            self.paths.append(str(name))

        self.mode = 'image'
        self.bs = len(self.im0)
        self._iterated = False

    @staticmethod
    def _single_check(im):
        '''Validate and format an image to numpy array, ensuring RGB order and contiguous memory.'''
        if im is None:
            raise ValueError("Input image is None.")

        # PIL Image
        if _PIL_AVAILABLE and isinstance(im, Image.Image):
            im = im.convert("RGB")
            arr = np.asarray(im, dtype=np.uint8)

        # numpy array
        elif isinstance(im, np.ndarray):
            arr = im
            # Ensure numeric array
            if not np.issubdtype(arr.dtype, np.number):
                raise TypeError(f"Unsupported numpy dtype: {arr.dtype}")

            # Convert channel-first to channel-last if needed
            if arr.ndim == 3 and arr.shape[0] in (1, 3, 4) and arr.shape[0] != arr.shape[-1]:
                arr = np.transpose(arr, (1, 2, 0))

            # Handle grayscale (H,W) or (H,W,1)
            if arr.ndim == 2:
                arr = np.stack([arr, arr, arr], axis=-1)
            elif arr.ndim == 3 and arr.shape[-1] == 1:
                arr = np.concatenate([arr, arr, arr], axis=-1)
            elif arr.ndim == 3 and arr.shape[-1] == 4:
                # Drop alpha channel
                arr = arr[..., :3]

            # Validate shape
            if arr.ndim != 3 or arr.shape[-1] != 3:
                raise ValueError(
                    f"Expected image with 3 channels in HWC format, got shape {arr.shape}")

            # Ensure dtype uint8
            if arr.dtype != np.uint8:
                if np.issubdtype(arr.dtype, np.floating):
                    maxv = float(np.nanmax(arr)) if arr.size else 1.0
                    scale_255 = maxv <= 1.0
                    arr = np.nan_to_num(arr, nan=0.0, posinf=255.0, neginf=0.0)
                    if scale_255:
                        arr = (arr * 255.0).round()
                    arr = np.clip(arr, 0, 255).astype(np.uint8)
                else:
                    arr = np.clip(arr, 0, 255).astype(np.uint8)

        else:
            raise TypeError(
                "Unsupported image type. Expected PIL.Image.Image or numpy.ndarray.")

        # Ensure contiguous memory
        arr = np.ascontiguousarray(arr)
        return arr

    def __len__(self):
        '''Returns the length of the 'im0' attribute, representing the number of loaded images.'''
        return self.bs

    def __next__(self):
        '''Returns the next batch of images, paths, and metadata for processing.'''
        if self._iterated:
            raise StopIteration
        self._iterated = True
        return self.paths, self.im0, None

    def __iter__(self):
        '''Iterates through PIL/numpy images, yielding paths, raw images, and metadata for processing.'''
        self._iterated = False
        return self
