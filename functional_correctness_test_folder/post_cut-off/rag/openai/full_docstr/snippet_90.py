
import numpy as np
from PIL import Image
from typing import List, Tuple, Any, Iterator, Union


class LoadPilAndNumpy:
    '''
    Load images from PIL and Numpy arrays for batch processing.
    This class manages loading and pre-processing of image data from both PIL and Numpy formats. It performs basic
    validation and format conversion to ensure that the images are in the required format for downstream processing.
    Attributes:
        paths (List[str]): List of image paths or autogenerated filenames.
        im0 (List[np.ndarray]): List of images stored as Numpy arrays.
        mode (str): Type of data being processed, set to 'image'.
        bs (int): Batch size, equivalent to the length of `im0`.
    Methods:
        _single_check: Validate and format a single image to a Numpy array.
    Examples:
        >>> from PIL import Image
        >>> import numpy as np
        >>> pil_img = Image.new("RGB", (100, 100))
        >>> np_img = np.random.randint(0, 255, (100, 100, 3), dtype=np.uint8)
        >>> loader = LoadPilAndNumpy([pil_img, np_img])
        >>> paths, images, _ = next(iter(loader))
        >>> print(f"Loaded {len(images)} images")
        Loaded 2 images
    '''

    def __init__(self, im0: List[Union[Image.Image, np.ndarray, str]]):
        '''Initializes a loader for PIL and Numpy images, converting inputs to a standardized format.'''
        if not isinstance(im0, list):
            raise TypeError(f"im0 must be a list, got {type(im0)}")
        self.paths: List[str] = []
        self.im0: List[np.ndarray] = []
        for idx, im in enumerate(im0):
            if isinstance(im, str):
                # treat as a file path
                self.paths.append(im)
                # load the image from disk
                try:
                    pil_img = Image.open(im)
                except Exception as e:
                    raise ValueError(
                        f"Unable to open image file '{im}': {e}") from e
                arr = self._single_check(pil_img)
                self.im0.append(arr)
            else:
                # generate an autogenerated filename
                self.paths.append(f"image_{idx}")
                arr = self._single_check(im)
                self.im0.append(arr)
        self.mode = 'image'
        self.bs = len(self.im0)
        self._iterated = False

    @staticmethod
    def _single_check(im: Union[Image.Image, np.ndarray]) -> np.ndarray:
        '''Validate and format an image to numpy array, ensuring RGB order and contiguous memory.'''
        if isinstance(im, Image.Image):
            # Convert to RGB if necessary
            if im.mode != 'RGB':
                im = im.convert('RGB')
            arr = np.array(im)
        elif isinstance(im, np.ndarray):
            arr = im
        else:
            raise TypeError(
                f"Unsupported image type {type(im)}; expected PIL.Image or np.ndarray")

        # Ensure 3 channels
        if arr.ndim == 2:
            # Grayscale -> replicate channels
            arr = np.stack([arr] * 3, axis=-1)
        elif arr.ndim == 3 and arr.shape[2] == 1:
            arr = np.concatenate([arr] * 3, axis=2)
        elif arr.ndim != 3 or arr.shape[2] not in (3, 4):
            raise ValueError(
                f"Image array must have shape (H, W, 3) or (H, W, 4), got {arr.shape}")

        # If 4 channels, drop alpha
        if arr.shape[2] == 4:
            arr = arr[:, :, :3]

        # Ensure dtype uint8
        if arr.dtype != np.uint8:
            arr = arr.astype(np.uint8)

        # Ensure contiguous memory
        arr = np.ascontiguousarray(arr)
        return arr

    def __len__(self) -> int:
        '''Returns the length of the 'im0' attribute, representing the number of loaded images.'''
        return len(self.im0)

    def __next__(self) -> Tuple[List[str], List[np.ndarray], Any]:
        '''Returns the next batch of images, paths, and metadata for processing.'''
        if self._iterated:
            raise StopIteration
        self._iterated = True
        # Metadata placeholder; can be extended as needed
        metadata = {}
        return self.paths, self.im0, metadata

    def __iter__(self) -> Iterator[Tuple[List[str], List[np.ndarray], Any]]:
        '''Iterates through PIL/numpy images, yielding paths, raw images, and metadata for processing.'''
        return self
