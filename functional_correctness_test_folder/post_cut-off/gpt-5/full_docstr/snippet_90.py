import numpy as np
from typing import List, Sequence, Union
try:
    from PIL import Image as _PILImage
except Exception:  # PIL may not be installed in some environments
    _PILImage = None


class LoadPilAndNumpy:
    '''
    Load images from PIL and Numpy arrays for batch processing.
    This class manages loading and pre-processing of image data from both PIL and Numpy formats. It performs basic
    validation and format conversion to ensure that the images are in the required format for downstream processing.
    Attributes:
        paths (List[str]): List of image paths or autogenerated filenames.
        im0 (List[np.ndarray]): List of images stored as Numpy arrays.
        mode (str): Type of data being processed, set to 'image'.
        bs (int): Batch size, equivalent to the length of `im0`.
    Methods:
        _single_check: Validate and format a single image to a Numpy array.
    Examples:
        >>> from PIL import Image
        >>> import numpy as np
        >>> pil_img = Image.new("RGB", (100, 100))
        >>> np_img = np.random.randint(0, 255, (100, 100, 3), dtype=np.uint8)
        >>> loader = LoadPilAndNumpy([pil_img, np_img])
        >>> paths, images, _ = next(iter(loader))
        >>> print(f"Loaded {len(images)} images")
        Loaded 2 images
    '''

    def __init__(self, im0):
        '''Initializes a loader for PIL and Numpy images, converting inputs to a standardized format.'''
        # Normalize input to a sequence
        if isinstance(im0, (list, tuple)):
            inputs = list(im0)
        else:
            inputs = [im0]

        self.im0: List[np.ndarray] = []
        self.paths: List[str] = []

        for i, im in enumerate(inputs):
            arr = self._single_check(im)
            self.im0.append(arr)

            # Derive a path-like name if available; else autogenerate
            name = None
            if _PILImage is not None and isinstance(im, _PILImage):
                # PIL Images may have a filename attribute
                name = getattr(im, "filename", None) or None
            if isinstance(im, np.ndarray):
                name = None  # numpy arrays typically have no filename

            if not name:
                name = f"image_{i:05d}.jpg"
            self.paths.append(str(name))

        self.mode = "image"
        self.bs = len(self.im0)
        self._iterated = False

    @staticmethod
    def _single_check(im):
        '''Validate and format an image to numpy array, ensuring RGB order and contiguous memory.'''
        # PIL Image
        if _PILImage is not None and isinstance(im, _PILImage):
            if im.mode not in ("RGB", "RGBA", "L"):
                im = im.convert("RGB")
            else:
                # Ensure RGB (drop alpha if present)
                if im.mode == "RGBA":
                    im = im.convert("RGB")
                elif im.mode == "L":
                    im = im.convert("RGB")
            arr = np.array(im, copy=False)
        # NumPy array
        elif isinstance(im, np.ndarray):
            arr = im
        else:
            raise TypeError(
                "Unsupported image type. Expected PIL.Image.Image or numpy.ndarray.")

        # Ensure array is uint8 RGB HxWxC
        if arr.ndim == 2:
            # Grayscale HxW -> HxWx3
            arr = np.stack([arr] * 3, axis=-1)
        elif arr.ndim == 3:
            h, w, c = arr.shape[0], arr.shape[1], arr.shape[2]
            # If channel is first (CHW), transpose to HWC
            if arr.shape[0] in (1, 3, 4) and arr.shape[2] not in (1, 3, 4):
                arr = np.transpose(arr, (1, 2, 0))
                h, w, c = arr.shape
            # If 4 channels, drop alpha
            if c == 4:
                arr = arr[:, :, :3]
            elif c == 1:
                arr = np.repeat(arr, 3, axis=2)
            elif c not in (3,):
                raise ValueError(
                    f"Unsupported channel configuration: {arr.shape}")
        else:
            raise ValueError(f"Unsupported image shape: {arr.shape}")

        # Convert dtype to uint8
        if arr.dtype == np.uint8:
            pass
        elif np.issubdtype(arr.dtype, np.floating):
            # Assume range [0,1] or [0,255]
            maxv = float(np.nanmax(arr)) if arr.size else 1.0
            if maxv <= 1.0:
                arr = (arr * 255.0).round()
            arr = np.clip(arr, 0, 255).astype(np.uint8)
        else:
            # Integer types
            arr = np.clip(arr, 0, 255).astype(np.uint8)

        # Ensure contiguous memory
        arr = np.ascontiguousarray(arr)
        return arr

    def __len__(self):
        '''Returns the length of the 'im0' attribute, representing the number of loaded images.'''
        return len(self.im0)

    def __next__(self):
        '''Returns the next batch of images, paths, and metadata for processing.'''
        if self._iterated:
            raise StopIteration
        self._iterated = True
        return self.paths, self.im0, None

    def __iter__(self):
        '''Iterates through PIL/numpy images, yielding paths, raw images, and metadata for processing.'''
        self._iterated = False
        return self
