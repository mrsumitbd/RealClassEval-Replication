import numpy as np
from typing import List, Sequence, Tuple, Union, Optional

try:
    from PIL import Image as PILImage
except Exception:  # PIL is optional at runtime
    PILImage = None


class LoadPilAndNumpy:
    '''
    Load images from PIL and Numpy arrays for batch processing.
    This class manages loading and pre-processing of image data from both PIL and Numpy formats. It performs basic
    validation and format conversion to ensure that the images are in the required format for downstream processing.
    Attributes:
        paths (List[str]): List of image paths or autogenerated filenames.
        im0 (List[np.ndarray]): List of images stored as Numpy arrays.
        mode (str): Type of data being processed, set to 'image'.
        bs (int): Batch size, equivalent to the length of `im0`.
    Methods:
        _single_check: Validate and format a single image to a Numpy array.
    Examples:
        >>> from PIL import Image
        >>> import numpy as np
        >>> pil_img = Image.new("RGB", (100, 100))
        >>> np_img = np.random.randint(0, 255, (100, 100, 3), dtype=np.uint8)
        >>> loader = LoadPilAndNumpy([pil_img, np_img])
        >>> paths, images, _ = next(iter(loader))
        >>> print(f"Loaded {len(images)} images")
        Loaded 2 images
    '''

    def __init__(self, im0):
        if isinstance(im0, (list, tuple)):
            items = list(im0)
        else:
            items = [im0]

        self.im0: List[np.ndarray] = []
        self.paths: List[str] = []

        for i, im in enumerate(items):
            arr = self._single_check(im)
            self.im0.append(arr)
            # Autogenerate a friendly path-like identifier
            if PILImage is not None and isinstance(im, PILImage.Image):
                name = getattr(im, "filename", None)
                if name and isinstance(name, str) and len(name) > 0:
                    self.paths.append(name)
                else:
                    self.paths.append(f"pil_image_{i}.png")
            elif isinstance(im, np.ndarray):
                self.paths.append(f"numpy_image_{i}.png")
            else:
                self.paths.append(f"image_{i}.png")

        self.mode: str = "image"
        self.bs: int = len(self.im0)
        self._yielded: bool = False

    @staticmethod
    def _single_check(im):
        # PIL Image -> numpy uint8 HWC RGB
        if PILImage is not None and isinstance(im, PILImage.Image):
            # Convert to RGB (drop alpha if present)
            if im.mode not in ("RGB", "L"):
                im = im.convert("RGB")
            elif im.mode == "L":
                im = im.convert("RGB")
            arr = np.array(im)
        elif isinstance(im, np.ndarray):
            arr = im
        else:
            raise TypeError(
                "Input must be a PIL.Image.Image or a numpy.ndarray")

        if arr is None:
            raise ValueError("Invalid image: None")

        # Handle shape and channel order
        if arr.ndim == 2:
            # grayscale -> 3-channel
            arr = np.stack([arr, arr, arr], axis=-1)
        elif arr.ndim == 3:
            # could be HWC or CHW
            if arr.shape[0] in (1, 3, 4) and arr.shape[-1] not in (1, 3, 4):
                # Likely CHW -> HWC
                arr = np.transpose(arr, (1, 2, 0))
        else:
            raise ValueError(
                f"Unsupported image ndim={arr.ndim}; expected 2 or 3")

        # Ensure channels are 3 by converting from 1 or 4
        if arr.shape[-1] == 1:
            arr = np.concatenate([arr, arr, arr], axis=-1)
        elif arr.shape[-1] == 4:
            # drop alpha
            arr = arr[..., :3]
        elif arr.shape[-1] != 3:
            raise ValueError(
                f"Unsupported number of channels: {arr.shape[-1]}")

        # Convert dtype to uint8
        if arr.dtype == np.uint8:
            pass
        elif np.issubdtype(arr.dtype, np.floating):
            # assume 0..1 or 0..255
            maxv = float(np.nanmax(arr)) if arr.size > 0 else 1.0
            scale = 255.0 if maxv <= 1.0 else 1.0
            arr = np.clip(arr * scale, 0, 255).astype(np.uint8)
        else:
            arr = np.clip(arr, 0, 255).astype(np.uint8)

        # Ensure C contiguous
        if not arr.flags["C_CONTIGUOUS"]:
            arr = np.ascontiguousarray(arr)

        return arr

    def __len__(self):
        return self.bs

    def __next__(self):
        if self._yielded:
            raise StopIteration
        self._yielded = True
        return self.paths, self.im0, None

    def __iter__(self):
        self._yielded = False
        return self
