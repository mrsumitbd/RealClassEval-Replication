import numpy as np


class LoadPilAndNumpy:
    '''
    Load images from PIL and Numpy arrays for batch processing.
    This class manages loading and pre-processing of image data from both PIL and Numpy formats. It performs basic
    validation and format conversion to ensure that the images are in the required format for downstream processing.
    Attributes:
        paths (List[str]): List of image paths or autogenerated filenames.
        im0 (List[np.ndarray]): List of images stored as Numpy arrays.
        mode (str): Type of data being processed, set to 'image'.
        bs (int): Batch size, equivalent to the length of `im0`.
    Methods:
        _single_check: Validate and format a single image to a Numpy array.
    Examples:
        >>> from PIL import Image
        >>> import numpy as np
        >>> pil_img = Image.new("RGB", (100, 100))
        >>> np_img = np.random.randint(0, 255, (100, 100, 3), dtype=np.uint8)
        >>> loader = LoadPilAndNumpy([pil_img, np_img])
        >>> paths, images, _ = next(iter(loader))
        >>> print(f"Loaded {len(images)} images")
        Loaded 2 images
    '''

    def __init__(self, im0):
        '''Initializes a loader for PIL and Numpy images, converting inputs to a standardized format.'''
        # Normalize input to list
        if im0 is None:
            self.im0 = []
        elif isinstance(im0, (list, tuple)):
            self.im0 = list(im0)
        else:
            self.im0 = [im0]

        # Process images and collect paths
        processed = []
        paths = []
        for i, item in enumerate(self.im0):
            path = None
            img = item

            # If tuple-like (img, path)
            if isinstance(item, (list, tuple)) and len(item) == 2:
                img, path = item

            # Try to obtain filename from PIL image if available
            try:
                from PIL import Image as _Image
                if isinstance(img, _Image.Image):
                    if not path:
                        # Some PIL images may have .filename set
                        path = getattr(img, "filename", None) or None
            except Exception:
                pass

            if not path or not isinstance(path, str) or not path:
                path = f"image_{i}.jpg"

            img_np = self._single_check(img)
            processed.append(img_np)
            paths.append(path)

        self.im0 = processed
        self.paths = paths
        self.mode = 'image'
        self.bs = len(self.im0)
        self._iterated = False

    @staticmethod
    def _single_check(im):
        # Convert PIL Image to numpy array (RGB)
        try:
            from PIL import Image as _Image
            if isinstance(im, _Image.Image):
                if im.mode not in ("RGB", "RGBA", "L"):
                    im = im.convert("RGB")
                elif im.mode == "RGBA":
                    im = im.convert("RGB")
                elif im.mode == "L":
                    im = im.convert("RGB")
                im = np.asarray(im)
        except Exception:
            # PIL not installed or other issues; continue if already numpy
            pass

        if not isinstance(im, np.ndarray):
            raise TypeError(
                "Unsupported image type. Expected PIL.Image.Image or numpy.ndarray.")

        arr = im

        # Handle dtype
        if arr.dtype == np.uint8:
            pass
        elif np.issubdtype(arr.dtype, np.floating):
            # Assume range [0,1] if max <=1, else clip to [0,255]
            if arr.size > 0 and np.nanmax(arr) <= 1.0:
                arr = (arr * 255.0)
            arr = np.clip(arr, 0, 255).astype(np.uint8)
        else:
            arr = np.clip(arr, 0, 255).astype(np.uint8)

        # Handle shape/channel ordering
        if arr.ndim == 2:
            # Grayscale -> RGB
            arr = np.stack([arr, arr, arr], axis=-1)
        elif arr.ndim == 3:
            h, w, c = arr.shape[0], arr.shape[1], arr.shape[2]
            # If channels-first
            if arr.shape[0] in (1, 3, 4) and arr.shape[0] < min(arr.shape[1], arr.shape[2]):
                # Assume CHW
                c, h, w = arr.shape
                arr = np.transpose(arr, (1, 2, 0))
            # Now HWC
            if arr.shape[2] == 1:
                arr = np.repeat(arr, 3, axis=2)
            elif arr.shape[2] == 4:
                # Drop alpha
                arr = arr[:, :, :3]
            elif arr.shape[2] == 3:
                pass
            else:
                # Unsupported channel count; attempt to take first 3
                arr = arr[:, :, :3] if arr.shape[2] > 3 else np.repeat(
                    arr[:, :, :1], 3, axis=2)
        else:
            raise ValueError(
                "Unsupported image array shape. Expected 2D or 3D array.")

        # Ensure contiguous uint8
        if arr.dtype != np.uint8:
            arr = arr.astype(np.uint8)
        if not arr.flags['C_CONTIGUOUS']:
            arr = np.ascontiguousarray(arr)

        return arr

    def __len__(self):
        '''Returns the length of the 'im0' attribute, representing the number of loaded images.'''
        return len(self.im0)

    def __next__(self):
        '''Returns the next batch of images, paths, and metadata for processing.'''
        if self._iterated:
            raise StopIteration
        self._iterated = True
        return self.paths, self.im0, None

    def __iter__(self):
        '''Iterates through PIL/numpy images, yielding paths, raw images, and metadata for processing.'''
        self._iterated = False
        return self
