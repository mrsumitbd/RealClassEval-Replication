
import numpy as np
from PIL import Image
from typing import List, Tuple, Any, Iterator, Union


class LoadPilAndNumpy:
    '''
    Load images from PIL and Numpy arrays for batch processing.
    This class manages loading and pre-processing of image data from both PIL and Numpy formats.
    It performs basic validation and format conversion to ensure that the images are in the required
    format for downstream processing.
    Attributes:
        paths (List[str]): List of image paths or autogenerated filenames.
        im0 (List[np.ndarray]): List of images stored as Numpy arrays.
        mode (str): Type of data being processed, set to 'image'.
        bs (int): Batch size, equivalent to the length of `im0`.
    Methods:
        _single_check: Validate and format a single image to a Numpy array.
    Examples:
        >>> from PIL import Image
        >>> import numpy as np
        >>> pil_img = Image.new("RGB", (100, 100))
        >>> np_img = np.random.randint(0, 255, (100, 100, 3), dtype=np.uint8)
        >>> loader = LoadPilAndNumpy([pil_img, np_img])
        >>> paths, images, _ = next(iter(loader))
        >>> print(f"Loaded {len(images)} images")
        Loaded 2 images
    '''

    def __init__(self, im0: Union[List[Any], Any]):
        '''Initializes a loader for PIL and Numpy images, converting inputs to a standardized format.'''
        # Ensure we have a list
        if not isinstance(im0, list):
            im0 = [im0]

        self.paths: List[str] = []
        self.im0: List[np.ndarray] = []

        for idx, item in enumerate(im0):
            # If item is a string path
            if isinstance(item, str):
                try:
                    img = Image.open(item)
                except Exception as e:
                    raise ValueError(
                        f"Cannot open image at path '{item}': {e}") from e
                path = item
            # If item is a PIL Image
            elif isinstance(item, Image.Image):
                img = item
                path = f'image_{idx}'
            # If item is a numpy array
            elif isinstance(item, np.ndarray):
                img = item
                path = f'image_{idx}'
            else:
                raise TypeError(f"Unsupported image type: {type(item)}")

            # Convert to numpy array if needed
            if isinstance(img, Image.Image):
                img_np = np.array(img)
            else:
                img_np = img

            # Validate and format
            img_np = self._single_check(img_np)

            self.paths.append(path)
            self.im0.append(img_np)

        self.mode = 'image'
        self.bs = len(self.im0)
        self._iter_index = 0

    @staticmethod
    def _single_check(im: np.ndarray) -> np.ndarray:
        '''Validate and format an image to numpy array, ensuring RGB order and contiguous memory.'''
        if not isinstance(im, np.ndarray):
            raise TypeError(f"Image must be a numpy array, got {type(im)}")

        # Ensure dtype is uint8
        if im.dtype != np.uint8:
            im = im.astype(np.uint8)

        # Handle grayscale images
        if im.ndim == 2:
            # (H, W) -> (H, W, 1)
            im = im[:, :, None]
        if im.ndim == 3 and im.shape[2] == 1:
            # (H, W, 1) -> (H, W, 3)
            im = np.repeat(im, 3, axis=2)

        # Ensure 3 channels
        if im.ndim != 3 or im.shape[2] != 3:
            raise ValueError(
                f"Image must have 3 channels, got shape {im.shape}")

        # Ensure contiguous
        im = np.ascontiguousarray(im)

        return im

    def __len__(self) -> int:
        '''Returns the length of the 'im0' attribute, representing the number of loaded images.'''
        return self.bs

    def __next__(self) -> Tuple[List[str], List[np.ndarray], Any]:
        '''Returns the next batch of images, paths, and metadata for processing.'''
        if self._iter_index >= self.bs:
            raise StopIteration

        # For this simple loader, we return all images in one batch
        batch_paths = self.paths
        batch_images = self.im0
        batch_meta = None

        self._iter_index = self.bs  # Ensure next call raises StopIteration
        return batch_paths, batch_images, batch_meta

    def __iter__(self) -> Iterator[Tuple[List[str], List[np.ndarray], Any]]:
        '''Iterates through PIL/numpy images, yielding paths, raw images, and metadata for processing.'''
        self._iter_index = 0
        return self
