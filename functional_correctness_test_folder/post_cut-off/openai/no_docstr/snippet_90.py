
import numpy as np
from PIL import Image


class LoadPilAndNumpy:
    '''
    Load images from PIL and Numpy arrays for batch processing.
    This class manages loading and pre-processing of image data from both PIL and Numpy formats. It performs basic
    validation and format conversion to ensure that the images are in the required format for downstream processing.
    Attributes:
        paths (List[str]): List of image paths or autogenerated filenames.
        im0 (List[np.ndarray]): List of images stored as Numpy arrays.
        mode (str): Type of data being processed, set to 'image'.
        bs (int): Batch size, equivalent to the length of `im0`.
    Methods:
        _single_check: Validate and format a single image to a Numpy array.
    Examples:
        >>> from PIL import Image
        >>> import numpy as np
        >>> pil_img = Image.new("RGB", (100, 100))
        >>> np_img = np.random.randint(0, 255, (100, 100, 3), dtype=np.uint8)
        >>> loader = LoadPilAndNumpy([pil_img, np_img])
        >>> paths, images, _ = next(iter(loader))
        >>> print(f"Loaded {len(images)} images")
        Loaded 2 images
    '''

    def __init__(self, im0):
        # Validate input list
        if not isinstance(im0, (list, tuple)):
            raise TypeError(f"im0 must be a list or tuple, got {type(im0)}")
        self.im0 = []
        self.paths = []
        for idx, im in enumerate(im0):
            arr = self._single_check(im)
            self.im0.append(arr)
            # generate a simple filename
            self.paths.append(f'image_{idx}.jpg')
        self.mode = 'image'
        self.bs = len(self.im0)
        self._idx = 0

    @staticmethod
    def _single_check(im):
        """
        Validate and convert a single image to a numpy array.
        Accepts PIL.Image or numpy.ndarray.
        Returns a numpy.ndarray of dtype uint8.
        """
        if isinstance(im, Image.Image):
            # Convert to RGB and then to numpy array
            im = im.convert('RGB')
            arr = np.array(im)
        elif isinstance(im, np.ndarray):
            arr = im
        else:
            raise TypeError(f"Unsupported image type: {type(im)}")

        # Ensure dtype is uint8
        if arr.dtype != np.uint8:
            arr = arr.astype(np.uint8)

        # Ensure shape is HxWxC
        if arr.ndim == 2:
            # Grayscale: expand to 3 channels
            arr = np.stack([arr]*3, axis=-1)
        elif arr.ndim == 3 and arr.shape[2] not in (1, 3):
            raise ValueError(f"Unsupported channel number: {arr.shape[2]}")
        elif arr.ndim != 3:
            raise ValueError(f"Unsupported image shape: {arr.shape}")

        return arr

    def __len__(self):
        return self.bs

    def __iter__(self):
        return self

    def __next__(self):
        if self._idx >= self.bs:
            raise StopIteration
        # Return the entire batch each time
        result = (self.paths, self.im0, self.mode)
        self._idx += 1
        return result
