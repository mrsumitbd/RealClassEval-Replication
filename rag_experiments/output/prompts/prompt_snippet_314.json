[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass CSFileSystem(file_system.FileSystem):\n    '''File system that uses pyfvde.'''\n\n    def __init__(self, resolver_context, path_spec):\n        '''Initializes a file system.\n        Args:\n          resolver_context (Context): resolver context.\n          path_spec (PathSpec): a path specification.\n        '''\n        pass\n\n    def _Close(self):\n        '''Closes the file system.\n        Raises:\n          IOError: if the close failed.\n        '''\n        pass\n\n    def _Open(self, mode='rb'):\n        '''Opens the file system defined by path specification.\n        Args:\n          mode (Optional[str]): file access mode. The default is 'rb'\n              read-only binary.\n        Raises:\n          AccessError: if the access to open the file was denied.\n          IOError: if the file system could not be opened.\n          PathSpecError: if the path specification is incorrect.\n          ValueError: if the path specification is invalid.\n        '''\n        pass\n\n    def FileEntryExistsByPathSpec(self, path_spec):\n        '''Determines if a file entry for a path specification exists.\n        Args:\n          path_spec (PathSpec): path specification.\n        Returns:\n          bool: True if the file entry exists.\n        '''\n        pass\n\n    def GetFileEntryByPathSpec(self, path_spec):\n        '''Retrieves a file entry for a path specification.\n        Args:\n          path_spec (PathSpec): path specification.\n        Returns:\n          CSFileEntry: a file entry or None if not available.\n        '''\n        pass\n\n    def GetFVDELogicalVolumeByPathSpec(self, path_spec):\n        '''Retrieves a Core Storage logical volume for a path specification.\n        Args:\n          path_spec (PathSpec): path specification.\n        Returns:\n          pyfvde.logical_volume: a Core Storage logical volume or None if not\n              available.\n        '''\n        pass\n\n    def GetFVDEVolumeGroup(self):\n        '''Retrieves the Core Storage volume group.\n        Returns:\n          pyfvde.volume_group: a Core Storage volume group.\n        '''\n        pass\n\n    def GetRootFileEntry(self):\n        '''Retrieves the root file entry.\n        Returns:\n          CSFileEntry: root file entry or None if not available.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom dfvfs.lib import errors\nfrom dfvfs.lib import definitions\nimport pyfvde\nfrom dfvfs.path import cs_path_spec\nfrom dfvfs.resolver import resolver\nfrom dfvfs.vfs import cs_file_entry\nfrom dfvfs.lib import cs_helper\nfrom dfvfs.vfs import file_system\n\nclass CSFileSystem(file_system.FileSystem):\n    \"\"\"File system that uses pyfvde.\"\"\"\n    TYPE_INDICATOR = definitions.TYPE_INDICATOR_CS\n\n    def __init__(self, resolver_context, path_spec):\n        \"\"\"Initializes a file system.\n\n        Args:\n          resolver_context (Context): resolver context.\n          path_spec (PathSpec): a path specification.\n        \"\"\"\n        super(CSFileSystem, self).__init__(resolver_context, path_spec)\n        self._fvde_volume = None\n        self._fvde_volume_group = None\n        self._file_object = None\n\n    def _Close(self):\n        \"\"\"Closes the file system.\n\n        Raises:\n          IOError: if the close failed.\n        \"\"\"\n        self._fvde_volume_group = None\n        self._fvde_volume.close()\n        self._fvde_volume = None\n        self._file_object = None\n\n    def _Open(self, mode='rb'):\n        \"\"\"Opens the file system defined by path specification.\n\n        Args:\n          mode (Optional[str]): file access mode. The default is 'rb'\n              read-only binary.\n\n        Raises:\n          AccessError: if the access to open the file was denied.\n          IOError: if the file system could not be opened.\n          PathSpecError: if the path specification is incorrect.\n          ValueError: if the path specification is invalid.\n        \"\"\"\n        if not self._path_spec.HasParent():\n            raise errors.PathSpecError('Unsupported path specification without parent.')\n        resolver.Resolver.key_chain.ExtractCredentialsFromPathSpec(self._path_spec)\n        file_object = resolver.Resolver.OpenFileObject(self._path_spec.parent, resolver_context=self._resolver_context)\n        fvde_volume = pyfvde.volume()\n        encrypted_root_plist = resolver.Resolver.key_chain.GetCredential(self._path_spec, 'encrypted_root_plist')\n        if encrypted_root_plist:\n            fvde_volume.read_encrypted_root_plist(encrypted_root_plist)\n        fvde_volume.open_file_object(file_object)\n        fvde_volume.open_physical_volume_files_as_file_objects([file_object])\n        fvde_volume_group = fvde_volume.get_volume_group()\n        self._file_object = file_object\n        self._fvde_volume = fvde_volume\n        self._fvde_volume_group = fvde_volume_group\n\n    def FileEntryExistsByPathSpec(self, path_spec):\n        \"\"\"Determines if a file entry for a path specification exists.\n\n        Args:\n          path_spec (PathSpec): path specification.\n\n        Returns:\n          bool: True if the file entry exists.\n        \"\"\"\n        volume_index = cs_helper.CSPathSpecGetVolumeIndex(path_spec)\n        if volume_index is None:\n            location = getattr(path_spec, 'location', None)\n            return location is not None and location == self.LOCATION_ROOT\n        return 0 <= volume_index < self._fvde_volume_group.number_of_logical_volumes\n\n    def GetFileEntryByPathSpec(self, path_spec):\n        \"\"\"Retrieves a file entry for a path specification.\n\n        Args:\n          path_spec (PathSpec): path specification.\n\n        Returns:\n          CSFileEntry: a file entry or None if not available.\n        \"\"\"\n        volume_index = cs_helper.CSPathSpecGetVolumeIndex(path_spec)\n        if volume_index is None:\n            location = getattr(path_spec, 'location', None)\n            if location is None or location != self.LOCATION_ROOT:\n                return None\n            return cs_file_entry.CSFileEntry(self._resolver_context, self, path_spec, is_root=True, is_virtual=True)\n        if volume_index < 0 or volume_index >= self._fvde_volume_group.number_of_logical_volumes:\n            return None\n        return cs_file_entry.CSFileEntry(self._resolver_context, self, path_spec)\n\n    def GetFVDELogicalVolumeByPathSpec(self, path_spec):\n        \"\"\"Retrieves a Core Storage logical volume for a path specification.\n\n        Args:\n          path_spec (PathSpec): path specification.\n\n        Returns:\n          pyfvde.logical_volume: a Core Storage logical volume or None if not\n              available.\n        \"\"\"\n        volume_index = cs_helper.CSPathSpecGetVolumeIndex(path_spec)\n        if volume_index is None:\n            return None\n        return self._fvde_volume_group.get_logical_volume(volume_index)\n\n    def GetFVDEVolumeGroup(self):\n        \"\"\"Retrieves the Core Storage volume group.\n\n        Returns:\n          pyfvde.volume_group: a Core Storage volume group.\n        \"\"\"\n        return self._fvde_volume_group\n\n    def GetRootFileEntry(self):\n        \"\"\"Retrieves the root file entry.\n\n        Returns:\n          CSFileEntry: root file entry or None if not available.\n        \"\"\"\n        path_spec = cs_path_spec.CSPathSpec(location=self.LOCATION_ROOT, parent=self._path_spec.parent)\n        return self.GetFileEntryByPathSpec(path_spec)\n\nExample skeleton:\n\n\nclass AuthProvider(metaclass=abc.ABCMeta):\n    '''Authentication provider for a specific kind of credential.'''\n\n    def authenticate(self, environ):\n        '''Produce an opaque auth token from a WSGI request environment.\n        Args:\n          environ: A WSGI environment `dict`; see PEP 3333.\n        Returns:\n          A Python object representing an auth token. The representation\n          and semantics depend on the particular `AuthProvider`\n          implementation.\n        Raises:\n          Exception: Any error, usually `tensorboard.errors.PublicError`\n            subclasses (like `PermissionDenied`) but also possibly a\n            custom error type that should propagate to a WSGI middleware\n            for effecting a redirect-driven auth flow.\n        '''\n        pass\nCorresponding class implementation:\n\nimport abc\n\nclass AuthProvider(metaclass=abc.ABCMeta):\n    \"\"\"Authentication provider for a specific kind of credential.\"\"\"\n\n    def authenticate(self, environ):\n        \"\"\"Produce an opaque auth token from a WSGI request environment.\n\n        Args:\n          environ: A WSGI environment `dict`; see PEP 3333.\n\n        Returns:\n          A Python object representing an auth token. The representation\n          and semantics depend on the particular `AuthProvider`\n          implementation.\n\n        Raises:\n          Exception: Any error, usually `tensorboard.errors.PublicError`\n            subclasses (like `PermissionDenied`) but also possibly a\n            custom error type that should propagate to a WSGI middleware\n            for effecting a redirect-driven auth flow.\n        \"\"\"\n        pass\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass DiscoveryMixin:\n    '''\n    Mixin class for BedrockServerManager that handles server discovery and validation.\n        '''\n\n    def validate_server(self, server_name: str, app_context: Optional[AppContext]=None) -> bool:\n        '''Validates if a given server name corresponds to a valid installation.\n        This method checks for the existence and basic integrity of a server\n        installation. It instantiates a :class:`~.core.bedrock_server.BedrockServer`\n        object for the given ``server_name`` and then calls its\n        :meth:`~.core.bedrock_server.BedrockServer.is_installed` method.\n        Any exceptions raised during the instantiation or validation process (e.g.,\n        :class:`~.error.InvalidServerNameError`, :class:`~.error.ConfigurationError`)\n        are caught, logged as a warning, and result in a ``False`` return value,\n        making this a safe check.\n        Args:\n            server_name (str): The name of the server to validate. This should\n                correspond to a subdirectory within the main server base directory.\n        Returns:\n            bool: ``True`` if the server exists and is a valid installation\n            (i.e., its directory and executable are found), ``False`` otherwise.\n        Raises:\n            MissingArgumentError: If ``server_name`` is an empty string.\n        '''\n        pass\n\n    def get_servers_data(self, app_context: Optional['AppContext']=None) -> Tuple[List[Dict[str, Any]], List[str]]:\n        '''Discovers and retrieves status data for all valid server instances.\n        This method scans the main server base directory (defined by\n        ``settings['paths.servers']``) for subdirectories that represent server\n        installations. For each potential server, it:\n            1. Instantiates a :class:`~.core.bedrock_server.BedrockServer` object.\n            2. Validates the installation using the server's :meth:`~.core.bedrock_server.BedrockServer.is_installed` method.\n            3. If valid, it queries the server's status and version using\n               :meth:`~.core.bedrock_server.BedrockServer.get_status` and\n               :meth:`~.core.bedrock_server.BedrockServer.get_version`.\n        Errors encountered while processing individual servers are collected and\n        returned separately, allowing the method to succeed even if some server\n        directories are corrupted or misconfigured. The final list of server\n        data is sorted alphabetically by server name.\n        Returns:\n            Tuple[List[Dict[str, Any]], List[str]]: A tuple containing two lists:\n                - The first list contains dictionaries, one for each successfully\n                  processed server. Each dictionary has the keys:\n                    - ``\"name\"`` (str): The name of the server.\n                    - ``\"status\"`` (str): The server's current status (e.g., \"RUNNING\", \"STOPPED\").\n                    - ``\"version\"`` (str): The detected version of the server.\n                - The second list contains string messages describing any errors that\n                  occurred while processing specific server candidates.\n        Raises:\n            AppFileNotFoundError: If the main server base directory\n                (``settings['paths.servers']``) is not configured or does not exist.\n        '''\n        pass"
  }
]