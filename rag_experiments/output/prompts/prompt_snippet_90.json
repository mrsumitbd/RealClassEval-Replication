[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Qwen2_5_VLProcessor(Qwen2VLProcessor):\n    '''\n    Constructs a Qwen2.5-VL processor which wraps a Qwen2.5-VL image processor and a Qwen2 tokenizer into a single processor.\n    [`Qwen2_5_VLProcessor`] offers all the functionalities of [`Qwen2VLImageProcessor`] and [`Qwen2TokenizerFast`]. See the\n    [`~Qwen2_5_VLProcessor.__call__`] and [`~Qwen2_5_VLProcessor.decode`] for more information.\n    Args:\n        image_processor ([`Qwen2VLImageProcessor`], *optional*):\n            The image processor is a required input.\n        tokenizer ([`Qwen2TokenizerFast`], *optional*):\n            The tokenizer is a required input.\n        video_processor ([`Qwen2_5_VLVideoProcessor`], *optional*):\n            The video processor is a required input.\n        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n            in a chat into a tokenizable string.\n    '''\n    @property\n    def model_input_names(self):\n        pass\n\n    def __call__(self, images: Optional[ImageInput]=None, text: Union[TextInput, PreTokenizedInput, list[TextInput], list[PreTokenizedInput]]=None, videos: Optional[VideoInput]=None, **kwargs: Unpack[Qwen2_5_VLProcessorKwargs]) -> BatchFeature:\n        '''\n        Main method to prepare for the model one or several sequences(s) and image(s). This method forwards the `text`\n        and `kwargs` arguments to Qwen2TokenizerFast's [`~Qwen2TokenizerFast.__call__`] if `text` is not `None` to encode\n        the text. To prepare the vision inputs, this method forwards the `vision_infos` and `kwargs` arguments to\n        Qwen2VLImageProcessor's [`~Qwen2VLImageProcessor.__call__`] if `vision_infos` is not `None`.\n        Args:\n            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `list[PIL.Image.Image]`, `list[np.ndarray]`, `list[torch.Tensor]`):\n                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n                tensor. Both channels-first and channels-last formats are supported.\n            text (`str`, `list[str]`, `list[list[str]]`):\n                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n            videos (`np.ndarray`, `torch.Tensor`, `list[np.ndarray]`, `list[torch.Tensor]`):\n                The image or batch of videos to be prepared. Each video can be a 4D NumPy array or PyTorch\n                tensor, or a nested list of 3D frames. Both channels-first and channels-last formats are supported.\n            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n                If set, will return tensors of a particular framework. Acceptable values are:\n                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n                - `'np'`: Return NumPy `np.ndarray` objects.\n        Returns:\n            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n            - **input_ids** -- List of token ids to be fed to a model. Returned when `text` is not `None`.\n            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n              `None`).\n            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n            - **pixel_values_videos** -- Pixel values of videos to be fed to a model. Returned when `videos` is not `None`.\n            - **image_grid_thw** -- List of image 3D grid in LLM. Returned when `images` is not `None`.\n            - **video_grid_thw** -- List of video 3D grid in LLM. Returned when `videos` is not `None`.\n            - **second_per_grid_ts** -- List of video seconds per time grid. Returned when `videos` is not `None`.\n        '''\n        pass\n\n    def _get_num_multimodal_tokens(self, image_sizes=None, video_sizes=None, **kwargs):\n        '''\n        Computes the number of placeholder tokens needed for multimodal inputs with the given sizes.\n        Args:\n            image_sizes (`list[list[int]]`, *optional*):\n                The input sizes formatted as (height, width) per each image.\n            video_sizes (`list[list[int]]`, *optional*):\n                The input sizes formatted as (num_frames, height, width) per each video.\n        Returns:\n            `MultiModalData`: A `MultiModalData` object holding number of tokens per each of the provided\n            input modalities, along with other useful data.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom transformers.models.qwen2_vl.processing_qwen2_vl import Qwen2VLImagesKwargs, Qwen2VLProcessor\nfrom ...tokenization_utils_base import PreTokenizedInput, TextInput\nimport numpy as np\nfrom ...feature_extraction_utils import BatchFeature\nfrom ...processing_utils import MultiModalData, ProcessingKwargs, Unpack, VideosKwargs\nfrom ...video_utils import VideoInput\nfrom ...image_utils import ImageInput\nfrom typing import Optional, Union\n\nclass Qwen2_5_VLProcessor(Qwen2VLProcessor):\n    \"\"\"\n    Constructs a Qwen2.5-VL processor which wraps a Qwen2.5-VL image processor and a Qwen2 tokenizer into a single processor.\n    [`Qwen2_5_VLProcessor`] offers all the functionalities of [`Qwen2VLImageProcessor`] and [`Qwen2TokenizerFast`]. See the\n    [`~Qwen2_5_VLProcessor.__call__`] and [`~Qwen2_5_VLProcessor.decode`] for more information.\n    Args:\n        image_processor ([`Qwen2VLImageProcessor`], *optional*):\n            The image processor is a required input.\n        tokenizer ([`Qwen2TokenizerFast`], *optional*):\n            The tokenizer is a required input.\n        video_processor ([`Qwen2_5_VLVideoProcessor`], *optional*):\n            The video processor is a required input.\n        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n            in a chat into a tokenizable string.\n    \"\"\"\n    image_processor_class = 'AutoImageProcessor'\n\n    @property\n    def model_input_names(self):\n        tokenizer_input_names = self.tokenizer.model_input_names\n        image_processor_input_names = self.image_processor.model_input_names\n        names_from_processor = list(dict.fromkeys(tokenizer_input_names + image_processor_input_names))\n        return names_from_processor + ['second_per_grid_ts']\n\n    def __call__(self, images: Optional[ImageInput]=None, text: Union[TextInput, PreTokenizedInput, list[TextInput], list[PreTokenizedInput]]=None, videos: Optional[VideoInput]=None, **kwargs: Unpack[Qwen2_5_VLProcessorKwargs]) -> BatchFeature:\n        \"\"\"\n        Main method to prepare for the model one or several sequences(s) and image(s). This method forwards the `text`\n        and `kwargs` arguments to Qwen2TokenizerFast's [`~Qwen2TokenizerFast.__call__`] if `text` is not `None` to encode\n        the text. To prepare the vision inputs, this method forwards the `vision_infos` and `kwargs` arguments to\n        Qwen2VLImageProcessor's [`~Qwen2VLImageProcessor.__call__`] if `vision_infos` is not `None`.\n\n        Args:\n            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `list[PIL.Image.Image]`, `list[np.ndarray]`, `list[torch.Tensor]`):\n                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n                tensor. Both channels-first and channels-last formats are supported.\n            text (`str`, `list[str]`, `list[list[str]]`):\n                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n            videos (`np.ndarray`, `torch.Tensor`, `list[np.ndarray]`, `list[torch.Tensor]`):\n                The image or batch of videos to be prepared. Each video can be a 4D NumPy array or PyTorch\n                tensor, or a nested list of 3D frames. Both channels-first and channels-last formats are supported.\n            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n                If set, will return tensors of a particular framework. Acceptable values are:\n                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n                - `'np'`: Return NumPy `np.ndarray` objects.\n\n        Returns:\n            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n\n            - **input_ids** -- List of token ids to be fed to a model. Returned when `text` is not `None`.\n            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n              `None`).\n            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n            - **pixel_values_videos** -- Pixel values of videos to be fed to a model. Returned when `videos` is not `None`.\n            - **image_grid_thw** -- List of image 3D grid in LLM. Returned when `images` is not `None`.\n            - **video_grid_thw** -- List of video 3D grid in LLM. Returned when `videos` is not `None`.\n            - **second_per_grid_ts** -- List of video seconds per time grid. Returned when `videos` is not `None`.\n        \"\"\"\n        output_kwargs = self._merge_kwargs(Qwen2_5_VLProcessorKwargs, tokenizer_init_kwargs=self.tokenizer.init_kwargs, **kwargs)\n        image_inputs = videos_inputs = {}\n        if images is not None:\n            image_inputs = self.image_processor(images=images, **output_kwargs['images_kwargs'])\n            image_grid_thw = image_inputs['image_grid_thw']\n        if videos is not None:\n            fps = output_kwargs['videos_kwargs'].get('fps', 2.0)\n            videos_inputs = self.video_processor(videos=videos, **output_kwargs['videos_kwargs'])\n            video_grid_thw = videos_inputs['video_grid_thw']\n            if isinstance(fps, (int, float)):\n                second_per_grid_ts = [self.video_processor.temporal_patch_size / fps] * len(video_grid_thw)\n            elif hasattr(fps, '__len__') and len(fps) == len(video_grid_thw):\n                second_per_grid_ts = [self.video_processor.temporal_patch_size / tmp for tmp in fps]\n            else:\n                raise ValueError(f\"The length of fps ({(len(fps) if hasattr(fps, '__len__') else fps)}) must be equal to the length of video_grid_thw ({len(video_grid_thw)}) or fps should be a single number.\")\n            videos_inputs.update({'second_per_grid_ts': second_per_grid_ts})\n        if not isinstance(text, list):\n            text = [text]\n        text = text.copy()\n        if images is not None:\n            merge_length = self.image_processor.merge_size ** 2\n            index = 0\n            for i in range(len(text)):\n                while self.image_token in text[i]:\n                    num_image_tokens = image_grid_thw[index].prod() // merge_length\n                    text[i] = text[i].replace(self.image_token, '<|placeholder|>' * num_image_tokens, 1)\n                    index += 1\n                text[i] = text[i].replace('<|placeholder|>', self.image_token)\n        if videos is not None:\n            merge_length = self.video_processor.merge_size ** 2\n            index = 0\n            for i in range(len(text)):\n                while self.video_token in text[i]:\n                    num_video_tokens = video_grid_thw[index].prod() // merge_length\n                    text[i] = text[i].replace(self.video_token, '<|placeholder|>' * num_video_tokens, 1)\n                    index += 1\n                text[i] = text[i].replace('<|placeholder|>', self.video_token)\n        return_tensors = output_kwargs['text_kwargs'].pop('return_tensors', None)\n        return_mm_token_type_ids = output_kwargs['text_kwargs'].pop('return_mm_token_type_ids', None)\n        text_inputs = self.tokenizer(text, **output_kwargs['text_kwargs'])\n        self._check_special_mm_tokens(text, text_inputs, modalities=['image', 'video'])\n        if return_mm_token_type_ids:\n            array_ids = np.array(text_inputs['input_ids'])\n            mm_token_type_ids = np.zeros_like(text_inputs['input_ids'])\n            mm_token_type_ids[array_ids == self.image_token_id] = 1\n            text_inputs['mm_token_type_ids'] = mm_token_type_ids.tolist()\n        return BatchFeature(data={**text_inputs, **image_inputs, **videos_inputs}, tensor_type=return_tensors)\n\n    def _get_num_multimodal_tokens(self, image_sizes=None, video_sizes=None, **kwargs):\n        \"\"\"\n        Computes the number of placeholder tokens needed for multimodal inputs with the given sizes.\n        Args:\n            image_sizes (`list[list[int]]`, *optional*):\n                The input sizes formatted as (height, width) per each image.\n            video_sizes (`list[list[int]]`, *optional*):\n                The input sizes formatted as (num_frames, height, width) per each video.\n        Returns:\n            `MultiModalData`: A `MultiModalData` object holding number of tokens per each of the provided\n            input modalities, along with other useful data.\n        \"\"\"\n        vision_data = {}\n        if image_sizes is not None:\n            images_kwargs = Qwen2_5_VLProcessorKwargs._defaults.get('images_kwargs', {})\n            images_kwargs.update(kwargs)\n            merge_size = images_kwargs.get('merge_size', None) or self.image_processor.merge_size\n            num_image_patches = [self.image_processor.get_number_of_image_patches(*image_size, images_kwargs) for image_size in image_sizes]\n            num_image_tokens = [num_patches // merge_size ** 2 for num_patches in num_image_patches]\n            vision_data.update({'num_image_tokens': num_image_tokens, 'num_image_patches': num_image_patches})\n        if video_sizes is not None:\n            videos_kwargs = Qwen2_5_VLProcessorKwargs._defaults.get('videos_kwargs', {})\n            videos_kwargs.update(kwargs)\n            num_video_patches = [self.video_processor.get_number_of_video_patches(*video_size, videos_kwargs) for video_size in video_sizes]\n            num_video_tokens = [num_patches // merge_size ** 2 for num_patches in num_video_patches]\n            vision_data['num_video_tokens'] = num_video_tokens\n        return MultiModalData(**vision_data)\n\nExample skeleton:\n\n\nclass DatasetBatches(ImageBatchesBase):\n    '''Class which stores batches of images from the dataset.'''\n\n    def __init__(self, datastore_client, storage_client, dataset_name):\n        '''Initializes DatasetBatches.\n        Args:\n          datastore_client: instance of CompetitionDatastoreClient\n          storage_client: instance of CompetitionStorageClient\n          dataset_name: name of the dataset ('dev' or 'final')\n        '''\n        pass\n\n    def _read_image_list(self, skip_image_ids=None):\n        '''Reads list of dataset images from the datastore.'''\n        pass\n\n    def init_from_storage_write_to_datastore(self, batch_size=100, allowed_epsilon=None, skip_image_ids=None, max_num_images=None):\n        '''Initializes dataset batches from the list of images in the datastore.\n        Args:\n          batch_size: batch size\n          allowed_epsilon: list of allowed epsilon or None to use default\n          skip_image_ids: list of image ids to skip\n          max_num_images: maximum number of images to read\n        '''\n        pass\nCorresponding class implementation:\n\nimport zipfile\nimport os\nfrom io import BytesIO\nimport copy\nimport logging\n\nclass DatasetBatches(ImageBatchesBase):\n    \"\"\"Class which stores batches of images from the dataset.\"\"\"\n\n    def __init__(self, datastore_client, storage_client, dataset_name):\n        \"\"\"Initializes DatasetBatches.\n\n        Args:\n          datastore_client: instance of CompetitionDatastoreClient\n          storage_client: instance of CompetitionStorageClient\n          dataset_name: name of the dataset ('dev' or 'final')\n        \"\"\"\n        super(DatasetBatches, self).__init__(datastore_client=datastore_client, entity_kind_batches=KIND_DATASET_BATCH, entity_kind_images=KIND_DATASET_IMAGE)\n        self._storage_client = storage_client\n        self._dataset_name = dataset_name\n\n    def _read_image_list(self, skip_image_ids=None):\n        \"\"\"Reads list of dataset images from the datastore.\"\"\"\n        if skip_image_ids is None:\n            skip_image_ids = []\n        images = self._storage_client.list_blobs(prefix=os.path.join('dataset', self._dataset_name) + '/')\n        zip_files = [i for i in images if i.endswith('.zip')]\n        if len(zip_files) == 1:\n            zip_name = zip_files[0]\n            logging.info('Reading list of images from zip file %s', zip_name)\n            blob = self._storage_client.get_blob(zip_name)\n            buf = BytesIO()\n            logging.info('Downloading zip')\n            blob.download_to_file(buf)\n            buf.seek(0)\n            logging.info('Reading content of the zip')\n            with zipfile.ZipFile(buf) as f:\n                images = [os.path.join(zip_name, os.path.basename(n)) for n in f.namelist() if n.endswith('.png')]\n            buf.close()\n            logging.info('Found %d images', len(images))\n        else:\n            logging.info('Reading list of images from png files in storage')\n            images = [i for i in images if i.endswith('.png')]\n            logging.info('Found %d images', len(images))\n        images = [i for i in images if os.path.basename(i)[:-4] not in skip_image_ids]\n        images = [(DATASET_IMAGE_ID_PATTERN.format(idx), i) for idx, i in enumerate(sorted(images))]\n        return images\n\n    def init_from_storage_write_to_datastore(self, batch_size=100, allowed_epsilon=None, skip_image_ids=None, max_num_images=None):\n        \"\"\"Initializes dataset batches from the list of images in the datastore.\n\n        Args:\n          batch_size: batch size\n          allowed_epsilon: list of allowed epsilon or None to use default\n          skip_image_ids: list of image ids to skip\n          max_num_images: maximum number of images to read\n        \"\"\"\n        if allowed_epsilon is None:\n            allowed_epsilon = copy.copy(DEFAULT_EPSILON)\n        self._dataset_batches = {}\n        images = self._read_image_list(skip_image_ids)\n        if max_num_images:\n            images = images[:max_num_images]\n        for batch_idx, batch_start in enumerate(range(0, len(images), batch_size)):\n            batch = images[batch_start:batch_start + batch_size]\n            batch_id = DATASET_BATCH_ID_PATTERN.format(batch_idx)\n            batch_epsilon = allowed_epsilon[batch_idx % len(allowed_epsilon)]\n            self.add_batch(batch_id, {'epsilon': batch_epsilon})\n            for image_id, image_path in batch:\n                self.add_image(batch_id, image_id, {'dataset_image_id': os.path.basename(image_path)[:-4], 'image_path': image_path})\n        self.write_to_datastore()\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass LoadPilAndNumpy:\n    '''\n    Load images from PIL and Numpy arrays for batch processing.\n    This class manages loading and pre-processing of image data from both PIL and Numpy formats. It performs basic\n    validation and format conversion to ensure that the images are in the required format for downstream processing.\n    Attributes:\n        paths (List[str]): List of image paths or autogenerated filenames.\n        im0 (List[np.ndarray]): List of images stored as Numpy arrays.\n        mode (str): Type of data being processed, set to 'image'.\n        bs (int): Batch size, equivalent to the length of `im0`.\n    Methods:\n        _single_check: Validate and format a single image to a Numpy array.\n    Examples:\n        >>> from PIL import Image\n        >>> import numpy as np\n        >>> pil_img = Image.new(\"RGB\", (100, 100))\n        >>> np_img = np.random.randint(0, 255, (100, 100, 3), dtype=np.uint8)\n        >>> loader = LoadPilAndNumpy([pil_img, np_img])\n        >>> paths, images, _ = next(iter(loader))\n        >>> print(f\"Loaded {len(images)} images\")\n        Loaded 2 images\n    '''\n\n    def __init__(self, im0):\n        '''Initializes a loader for PIL and Numpy images, converting inputs to a standardized format.'''\n        pass\n    @staticmethod\n    def _single_check(im):\n        '''Validate and format an image to numpy array, ensuring RGB order and contiguous memory.'''\n        pass\n\n    def __len__(self):\n        '''Returns the length of the 'im0' attribute, representing the number of loaded images.'''\n        pass\n\n    def __next__(self):\n        '''Returns the next batch of images, paths, and metadata for processing.'''\n        pass\n\n    def __iter__(self):\n        '''Iterates through PIL/numpy images, yielding paths, raw images, and metadata for processing.'''\n        pass"
  }
]