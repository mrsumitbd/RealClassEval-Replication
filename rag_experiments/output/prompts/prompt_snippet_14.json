[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass ScatterPlot(PluginInterface):\n    '''A Scatter Plot Plugin for Feature Sets.'''\n\n    def __init__(self, show_axes: bool=True):\n        '''Initialize the Scatter Plot Plugin\n        Args:\n            show_axes (bool): Whether to show the axes and grid. Default is True.\n        '''\n        pass\n\n    def create_component(self, component_id: str) -> html.Div:\n        '''Create a Dash Graph Component without any data.\n        Args:\n            component_id (str): The ID of the web component.\n        Returns:\n            html.Div: A Dash Div Component containing the graph and dropdowns.\n        '''\n        pass\n\n    def update_properties(self, input_data: pd.DataFrame, **kwargs) -> list:\n        '''Update the property values for the plugin component.\n        Args:\n            input_data (pd.DataFrame): The input data object.\n            **kwargs: Additional keyword arguments (plugins can define their own arguments).\n                      Note: The current kwargs processed are:\n                            - x: The default x-axis column\n                            - y: The default y-axis column\n                            - color: The default color column\n                            - dropdown_columns: The columns to use for the x and y options\n                            - hover_columns: The columns to show when hovering over a point\n                            - suppress_hover_display: Suppress hover display (default: False)\n                            - custom_data: Custom data that get passed to hoverData callbacks\n        Returns:\n            list: A list of updated property values (figure, x options, y options, color options,\n                                                    label options, x default, y default,\n                                                    color default).\n        '''\n        pass\n\n    def create_scatter_plot(self, df: pd.DataFrame, x_col: str, y_col: str, color_col: str, label_col: str, regression_line: bool=False, marker_size: int=15) -> go.Figure:\n        '''Create a Plotly Scatter Plot figure.\n        Args:\n            df (pd.DataFrame): The dataframe containing the data.\n            x_col (str): The column to use for the x-axis.\n            y_col (str): The column to use for the y-axis.\n            color_col (str): The column to use for the color scale.\n            label_col (str): The column to use for point labels.\n            regression_line (bool): Whether to include a regression line.\n            marker_size (int): Size of the markers. Default is 15.\n        Returns:\n            go.Figure: A Plotly Figure object.\n        '''\n        pass\n\n        def generate_hover_text(row):\n                pass\n\n    def register_internal_callbacks(self):\n        '''Register any internal callbacks for the plugin.'''\n        pass\n        @callback(Output(f'{self.component_id}-graph', 'figure', allow_duplicate=True), [Input(f'{self.component_id}-x-dropdown', 'value'), Input(f'{self.component_id}-y-dropdown', 'value'), Input(f'{self.component_id}-color-dropdown', 'value'), Input(f'{self.component_id}-label-dropdown', 'value'), Input(f'{self.component_id}-regression-line', 'value')], prevent_initial_call=True)\n        def _update_scatter_plot(x_value, y_value, color_value, label_value, regression_line):\n                '''Update the Scatter Plot Graph based on the dropdown values.'''\n                pass\n        @callback(Output(f'{self.component_id}-overlay', 'show'), Output(f'{self.component_id}-overlay', 'bbox'), Output(f'{self.component_id}-overlay', 'children'), Input(f'{self.component_id}-graph', 'hoverData'))\n        def _scatter_overlay(hover_data):\n                pass\nCorresponding class implementation:\n\nfrom workbench.utils.theme_manager import ThemeManager\nfrom dash import dcc, html, callback, Input, Output, no_update\nimport plotly.express as px\nimport base64\nimport pandas as pd\nfrom dash.exceptions import PreventUpdate\nfrom workbench.utils.plot_utils import prediction_intervals\nimport plotly.graph_objects as go\nfrom workbench.web_interface.components.plugin_interface import PluginInterface, PluginPage, PluginInputType\n\nclass ScatterPlot(PluginInterface):\n    \"\"\"A Scatter Plot Plugin for Feature Sets.\"\"\"\n    auto_load_page = PluginPage.NONE\n    plugin_input_type = PluginInputType.DATAFRAME\n\n    def __init__(self, show_axes: bool=True):\n        \"\"\"Initialize the Scatter Plot Plugin\n\n        Args:\n            show_axes (bool): Whether to show the axes and grid. Default is True.\n        \"\"\"\n        self.component_id = None\n        self.hover_columns = []\n        self.df = None\n        self.show_axes = show_axes\n        self.theme_manager = ThemeManager()\n        self.colorscale = self.theme_manager.colorscale()\n        super().__init__()\n\n    def create_component(self, component_id: str) -> html.Div:\n        \"\"\"Create a Dash Graph Component without any data.\n\n        Args:\n            component_id (str): The ID of the web component.\n\n        Returns:\n            html.Div: A Dash Div Component containing the graph and dropdowns.\n        \"\"\"\n        self.component_id = component_id\n        self.properties = [(f'{component_id}-graph', 'figure'), (f'{component_id}-x-dropdown', 'options'), (f'{component_id}-y-dropdown', 'options'), (f'{component_id}-color-dropdown', 'options'), (f'{component_id}-label-dropdown', 'options'), (f'{component_id}-x-dropdown', 'value'), (f'{component_id}-y-dropdown', 'value'), (f'{component_id}-color-dropdown', 'value')]\n        self.signals = [(f'{component_id}-graph', 'hoverData'), (f'{component_id}-graph', 'clickData')]\n        return html.Div(children=[dcc.Graph(id=f'{component_id}-graph', figure=self.display_text('Waiting for Data...'), config={'scrollZoom': True}, style={'height': '100%'}, clear_on_unhover=True), html.Div([html.Label('X', style={'marginLeft': '40px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-x-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, clearable=False), html.Label('Y', style={'marginLeft': '30px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-y-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, clearable=False), html.Label('Color', style={'marginLeft': '30px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-color-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, clearable=False), html.Label('Label', style={'marginLeft': '30px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-label-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, options=[{'label': 'None', 'value': 'none'}], value='none', clearable=False), dcc.Checklist(id=f'{component_id}-regression-line', options=[{'label': ' Diagonal', 'value': 'show'}], value=[], style={'margin': '10px'})], style={'padding': '0px 0px 10px 0px', 'display': 'flex', 'gap': '10px'}), dcc.Tooltip(id=f'{component_id}-overlay', background_color='rgba(0,0,0,0)', border_color='rgba(0,0,0,0)', direction='bottom', loading_text='')], style={'height': '100%', 'display': 'flex', 'flexDirection': 'column'})\n\n    def update_properties(self, input_data: pd.DataFrame, **kwargs) -> list:\n        \"\"\"Update the property values for the plugin component.\n\n        Args:\n            input_data (pd.DataFrame): The input data object.\n            **kwargs: Additional keyword arguments (plugins can define their own arguments).\n                      Note: The current kwargs processed are:\n                            - x: The default x-axis column\n                            - y: The default y-axis column\n                            - color: The default color column\n                            - dropdown_columns: The columns to use for the x and y options\n                            - hover_columns: The columns to show when hovering over a point\n                            - suppress_hover_display: Suppress hover display (default: False)\n                            - custom_data: Custom data that get passed to hoverData callbacks\n\n        Returns:\n            list: A list of updated property values (figure, x options, y options, color options,\n                                                    label options, x default, y default,\n                                                    color default).\n        \"\"\"\n        limit = kwargs.get('limit', 20000)\n        if isinstance(input_data, pd.DataFrame):\n            self.df = input_data.sample(n=limit) if len(input_data) > limit else input_data\n        else:\n            raise ValueError('The input data must be a Pandas DataFrame.')\n        aws_cols = ['write_time', 'api_invocation_time', 'is_deleted', 'event_time']\n        self.df = self.df.drop(columns=aws_cols, errors='ignore')\n        self.hover_columns = kwargs.get('hover_columns', self.df.columns.tolist()[:10])\n        self.suppress_hover_display = kwargs.get('suppress_hover_display', False)\n        self.custom_data = kwargs.get('custom_data', [])\n        numeric_columns = self.df.select_dtypes(include='number').columns.tolist()\n        if len(numeric_columns) < 3:\n            raise ValueError('At least three numeric columns are required for x, y, and color.')\n        x_default = kwargs.get('x', numeric_columns[0])\n        y_default = kwargs.get('y', numeric_columns[1])\n        color_default = kwargs.get('color', numeric_columns[2])\n        regression_line = kwargs.get('regression_line', False)\n        figure = self.create_scatter_plot(self.df, x_default, y_default, color_default, 'none', regression_line)\n        dropdown_columns = kwargs.get('dropdown_columns', numeric_columns)\n        x_options = [{'label': col, 'value': col} for col in dropdown_columns]\n        y_options = x_options.copy()\n        cat_columns = self.df.select_dtypes(include=['object', 'string', 'category']).columns.tolist()\n        cat_columns = [col for col in cat_columns if self.df[col].astype(str).nunique() < 20]\n        color_columns = numeric_columns + cat_columns\n        color_options = [{'label': col, 'value': col} for col in color_columns]\n        label_options = [{'label': 'None', 'value': 'none'}]\n        label_options.extend([{'label': col, 'value': col} for col in self.df.columns])\n        return [figure, x_options, y_options, color_options, label_options, x_default, y_default, color_default]\n\n    def create_scatter_plot(self, df: pd.DataFrame, x_col: str, y_col: str, color_col: str, label_col: str, regression_line: bool=False, marker_size: int=15) -> go.Figure:\n        \"\"\"Create a Plotly Scatter Plot figure.\n\n        Args:\n            df (pd.DataFrame): The dataframe containing the data.\n            x_col (str): The column to use for the x-axis.\n            y_col (str): The column to use for the y-axis.\n            color_col (str): The column to use for the color scale.\n            label_col (str): The column to use for point labels.\n            regression_line (bool): Whether to include a regression line.\n            marker_size (int): Size of the markers. Default is 15.\n\n        Returns:\n            go.Figure: A Plotly Figure object.\n        \"\"\"\n        show_labels = label_col != 'none' and len(df) < 1000\n\n        def generate_hover_text(row):\n            return '<br>'.join([f'{col}: {row[col]}' for col in self.hover_columns])\n        hovertext = df.apply(generate_hover_text, axis=1)\n        hovertemplate = '%{hovertext}<extra></extra>'\n        hoverinfo = 'none' if self.suppress_hover_display else None\n        if pd.api.types.is_numeric_dtype(df[color_col]):\n            marker_color = df[color_col]\n            colorbar = dict(title=color_col, thickness=10)\n            data = [go.Scattergl(x=df[x_col], y=df[y_col], mode='markers', text=df[label_col].astype(str) if show_labels else None, textposition='top center', hoverinfo=hoverinfo, hovertext=hovertext, hovertemplate=hovertemplate, customdata=df[self.custom_data], marker=dict(size=marker_size, color=marker_color, colorscale=self.colorscale, colorbar=colorbar, opacity=0.8, line=dict(color='rgba(0,0,0,0.25)', width=1)))]\n            showlegend = False\n        else:\n            categories = sorted(df[color_col].astype(str).unique())\n            discrete_colors = px.colors.qualitative.Plotly\n            data = []\n            for i, cat in enumerate(categories):\n                sub_df = df[df[color_col] == cat]\n                sub_hovertext = hovertext.loc[sub_df.index]\n                trace = go.Scattergl(x=sub_df[x_col], y=sub_df[y_col], mode='markers', text=sub_df[label_col] if show_labels else None, textposition='top center', name=cat, hoverinfo=hoverinfo, hovertext=sub_hovertext, hovertemplate=hovertemplate, customdata=sub_df[self.custom_data], marker=dict(size=marker_size, color=discrete_colors[i % len(discrete_colors)], opacity=0.8, line=dict(color='rgba(0,0,0,0.25)', width=1)))\n                data.append(trace)\n            showlegend = True\n        figure = go.Figure()\n        if y_col == 'prediction' or x_col == 'prediction':\n            figure = prediction_intervals(df, figure, x_col)\n        if regression_line:\n            axis_min = min(df[x_col].min(), df[y_col].min())\n            axis_max = max(df[x_col].max(), df[y_col].max())\n            figure.add_shape(type='line', line=dict(width=4, color='rgba(128, 128, 128, 1.0)'), x0=axis_min, x1=axis_max, y0=axis_min, y1=axis_max)\n        figure.add_traces(data)\n        if self.show_axes:\n            xaxis = dict(title=dict(text=x_col, font=dict(size=16), standoff=15), tickformat='.2f', tickfont=dict(size=10))\n            yaxis = dict(title=dict(text=y_col, font=dict(size=16), standoff=25), tickformat='.2f', tickfont=dict(size=10))\n        else:\n            xaxis = dict(visible=False)\n            yaxis = dict(visible=False)\n        figure.update_layout(margin={'t': 20, 'b': 55, 'r': 0, 'l': 35, 'pad': 0}, xaxis=xaxis, yaxis=yaxis, showlegend=showlegend, dragmode='pan', modebar={'bgcolor': 'rgba(0, 0, 0, 0)'}, uirevision='constant')\n        return figure\n\n    def register_internal_callbacks(self):\n        \"\"\"Register any internal callbacks for the plugin.\"\"\"\n\n        @callback(Output(f'{self.component_id}-graph', 'figure', allow_duplicate=True), [Input(f'{self.component_id}-x-dropdown', 'value'), Input(f'{self.component_id}-y-dropdown', 'value'), Input(f'{self.component_id}-color-dropdown', 'value'), Input(f'{self.component_id}-label-dropdown', 'value'), Input(f'{self.component_id}-regression-line', 'value')], prevent_initial_call=True)\n        def _update_scatter_plot(x_value, y_value, color_value, label_value, regression_line):\n            \"\"\"Update the Scatter Plot Graph based on the dropdown values.\"\"\"\n            if not self.df.empty and x_value and y_value and color_value:\n                figure = self.create_scatter_plot(self.df, x_value, y_value, color_value, label_value, regression_line)\n                return figure\n            raise PreventUpdate\n\n        @callback(Output(f'{self.component_id}-overlay', 'show'), Output(f'{self.component_id}-overlay', 'bbox'), Output(f'{self.component_id}-overlay', 'children'), Input(f'{self.component_id}-graph', 'hoverData'))\n        def _scatter_overlay(hover_data):\n            if hover_data is None:\n                return (False, no_update, no_update)\n            bbox = hover_data['points'][0]['bbox']\n            svg = '\\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\" style=\"overflow: visible;\">\\n                <!-- Circle for the node -->\\n                <circle cx=\"50\" cy=\"50\" r=\"10\" stroke=\"rgba(255, 255, 255, 1)\" stroke-width=\"3\" fill=\"none\" />\\n            </svg>\\n            '\n            encoded_svg = base64.b64encode(svg.encode('utf-8')).decode('utf-8')\n            data_uri = f'data:image/svg+xml;base64,{encoded_svg}'\n            svg_image = html.Img(src=data_uri, style={'width': '100px', 'height': '100px'})\n            center_x = (bbox['x0'] + bbox['x1']) / 2\n            center_y = (bbox['y0'] + bbox['y1']) / 2\n            adjusted_bbox = {'x0': center_x - 50, 'x1': center_x + 50, 'y0': center_y - 162, 'y1': center_y - 62}\n            return (True, adjusted_bbox, [svg_image])\n\nExample skeleton:\n\n\nclass Request(Generic[sanic_type, ctx_type]):\n    '''State of HTTP request.\n    Args:\n        url_bytes (bytes): Raw URL bytes.\n        headers (Header): Request headers.\n        version (str): HTTP version.\n        method (str): HTTP method.\n        transport (TransportProtocol): Transport protocol.\n        app (Sanic): Sanic instance.\n        head (bytes, optional): Request head. Defaults to `b\"\"`.\n        stream_id (int, optional): HTTP/3 stream ID. Defaults to `0`.\n    '''\n\n    def __init__(self, url_bytes: bytes, headers: Header, version: str, method: str, transport: TransportProtocol, app: sanic_type, head: bytes=b'', stream_id: int=0):\n        pass\n\n    def __repr__(self):\n        pass\n    @staticmethod\n    def make_context() -> ctx_type:\n        '''Create a new context object.\n        This method is called when a new request context is pushed. It is\n        a great candidate for overriding in a subclass if you want to\n        control the type of context object that is created.\n        By default, it returns a `types.SimpleNamespace` instance.\n        Returns:\n            ctx_type: A new context object.\n        '''\n        pass\n    @classmethod\n    def get_current(cls) -> Request:\n        '''Retrieve the current request object\n        This implements [Context Variables](https://docs.python.org/3/library/contextvars.html)\n        to allow for accessing the current request from anywhere.\n        A typical usecase is when you want to access the current request\n        from a function that is not a handler, such as a logging function:\n        ```python\n        import logging\n        class LoggingFormater(logging.Formatter):\n            def format(self, record):\n                request = Request.get_current()\n                record.url = request.url\n                record.ip = request.ip\n                return super().format(record)\n        ```\n        Returns:\n            Request: The current request object\n        Raises:\n            sanic.exceptions.ServerError: If it is outside of a request\n                lifecycle.\n                        '''\n                        pass\n    @classmethod\n    def generate_id(*_) -> Union[uuid.UUID, str, int]:\n        '''Generate a unique ID for the request.\n        This method is called to generate a unique ID for each request.\n        By default, it returns a `uuid.UUID` instance.\n        Returns:\n            Union[uuid.UUID, str, int]: A unique ID for the request.\n        '''\n        pass\n    @property\n    def ctx(self) -> ctx_type:\n        '''The current request context.\n        This is a context object for the current request. It is created\n        by `Request.make_context` and is a great place to store data\n        that you want to be accessible during the request lifecycle.\n        Returns:\n            ctx_type: The current request context.\n        '''\n        pass\n    @property\n    def stream_id(self) -> int:\n        '''Access the HTTP/3 stream ID.\n        Raises:\n            sanic.exceptions.ServerError: If the request is not HTTP/3.\n        Returns:\n            int: The HTTP/3 stream ID.\n        '''\n        pass\n\n    def reset_response(self) -> None:\n        '''Reset the response object.\n        This clears much of the state of the object. It should\n        generally not be called directly, but is called automatically as\n        part of the request lifecycle.\n        Raises:\n            sanic.exceptions.ServerError: If the response has already been\n                sent.\n        '''\n        pass\n\n    async def respond(self, response: Optional[BaseHTTPResponse]=None, *, status: int=200, headers: Optional[Union[Header, dict[str, str]]]=None, content_type: Optional[str]=None):\n        '''Respond to the request without returning.\n        This method can only be called once, as you can only respond once.\n        If no ``response`` argument is passed, one will be created from the\n        ``status``, ``headers`` and ``content_type`` arguments.\n        **The first typical usecase** is if you wish to respond to the\n        request without returning from the handler:\n        ```python\n        @app.get(\"/\")\n        async def handler(request: Request):\n            data = ...  # Process something\n            json_response = json({\"data\": data})\n            await request.respond(json_response)\n        @app.on_response\n        async def add_header(_, response: HTTPResponse):\n            # Middlewares still get executed as expected\n            response.headers[\"one\"] = \"two\"\n        ```\n        **The second possible usecase** is for when you want to directly\n        respond to the request:\n        ```python\n        response = await request.respond(content_type=\"text/csv\")\n        await response.send(\"foo,\")\n        await response.send(\"bar\")\n        # You can control the completion of the response by calling\n        # the 'eof()' method:\n        await response.eof()\n        ```\n        Args:\n            response (ResponseType): Response instance to send.\n            status (int): Status code to return in the response.\n            headers (Optional[Dict[str, str]]): Headers to return in the response, defaults to None.\n            content_type (Optional[str]): Content-Type header of the response, defaults to None.\n        Returns:\n            FinalResponseType: Final response being sent (may be different from the\n                \"response\" parameter because of middlewares), which can be\n                used to manually send data.\n        '''\n        pass\n\n    async def receive_body(self):\n        '''Receive request.body, if not already received.\n        Streaming handlers may call this to receive the full body. Sanic calls\n        this function before running any handlers of non-streaming routes.\n        Custom request classes can override this for custom handling of both\n        streaming and non-streaming routes.\n        '''\n        pass\n    @property\n    def name(self) -> Optional[str]:\n        '''The route name\n        In the following pattern:\n        ```\n        <AppName>.[<BlueprintName>.]<HandlerName>\n        ```\n        Returns:\n            Optional[str]: The route name\n        '''\n        pass\n    @property\n    def endpoint(self) -> Optional[str]:\n        '''Alias of `sanic.request.Request.name`\n        Returns:\n            Optional[str]: The route name\n        '''\n        pass\n    @property\n    def uri_template(self) -> Optional[str]:\n        '''The defined URI template\n        Returns:\n            Optional[str]: The defined URI template\n        '''\n        pass\n    @property\n    def protocol(self) -> TransportProtocol:\n        '''The HTTP protocol instance\n        Returns:\n            Protocol: The HTTP protocol instance\n        '''\n        pass\n    @property\n    def raw_headers(self) -> bytes:\n        '''The unparsed HTTP headers\n        Returns:\n            bytes: The unparsed HTTP headers\n        '''\n        pass\n    @property\n    def request_line(self) -> bytes:\n        '''The first line of a HTTP request\n        Returns:\n            bytes: The first line of a HTTP request\n        '''\n        pass\n    @property\n    def id(self) -> Optional[Union[uuid.UUID, str, int]]:\n        '''A request ID passed from the client, or generated from the backend.\n        By default, this will look in a request header defined at:\n        `self.app.config.REQUEST_ID_HEADER`. It defaults to\n        `X-Request-ID`. Sanic will try to cast the ID into a `UUID` or an\n        `int`.\n        If there is not a UUID from the client, then Sanic will try\n        to generate an ID by calling `Request.generate_id()`. The default\n        behavior is to generate a `UUID`. You can customize this behavior\n        by subclassing `Request` and overwriting that method.\n        ```python\n        from sanic import Request, Sanic\n        from itertools import count\n        class IntRequest(Request):\n            counter = count()\n            def generate_id(self):\n                return next(self.counter)\n        app = Sanic(\"MyApp\", request_class=IntRequest)\n        ```\n        Returns:\n            Optional[Union[uuid.UUID, str, int]]: A request ID passed from the\n                client, or generated from the backend.\n                        '''\n                        pass\n    @property\n    def json(self) -> Any:\n        '''The request body parsed as JSON\n        Returns:\n            Any: The request body parsed as JSON\n        '''\n        pass\n\n    def load_json(self, loads=None) -> Any:\n        '''Load the request body as JSON\n        Args:\n            loads (Callable, optional): A custom JSON loader. Defaults to None.\n        Raises:\n            BadRequest: If the request body cannot be parsed as JSON\n        Returns:\n            Any: The request body parsed as JSON\n        '''\n        pass\n    @property\n    def accept(self) -> AcceptList:\n        '''Accepted response content types.\n        A convenience handler for easier RFC-compliant matching of MIME types,\n        parsed as a list that can match wildcards and includes */* by default.\n        Returns:\n            AcceptList: Accepted response content types\n        '''\n        pass\n    @property\n    def token(self) -> Optional[str]:\n        '''Attempt to return the auth header token.\n        Returns:\n            Optional[str]: The auth header token\n        '''\n        pass\n    @property\n    def credentials(self) -> Optional[Credentials]:\n        '''Attempt to return the auth header value.\n        Covers NoAuth, Basic Auth, Bearer Token, Api Token authentication\n        schemas.\n        Returns:\n            Optional[Credentials]: A Credentials object with token, or username\n                and password related to the request\n        '''\n        pass\n\n    def get_form(self, keep_blank_values: bool=False) -> Optional[RequestParameters]:\n        '''Method to extract and parse the form data from a request.\n        Args:\n            keep_blank_values (bool): Whether to discard blank values from the form data.\n        Returns:\n            Optional[RequestParameters]: The parsed form data.\n        '''\n        pass\n            @property\n            def format(self, record):\n                '''The request body parsed as form data\n        Returns:\n            Optional[RequestParameters]: The request body parsed as form data\n                        '''\n                        pass\n    @property\n    def files(self) -> Optional[RequestParameters]:\n        '''The request body parsed as uploaded files\n        Returns:\n            Optional[RequestParameters]: The request body parsed as uploaded files\n        '''\n        pass\n\n    def get_args(self, keep_blank_values: bool=False, strict_parsing: bool=False, encoding: str='utf-8', errors: str='replace') -> RequestParameters:\n        '''Parse `query_string` using `urllib.parse.parse_qs`.\n        This methods is used by the `args` property, but it also\n        can be used directly if you need to change default parameters.\n        Args:\n            keep_blank_values (bool): Flag indicating whether blank values in\n                percent-encoded queries should be treated as blank strings.\n                A `True` value indicates that blanks should be retained as\n                blank strings. The default `False` value indicates that\n                blank values are to be ignored and treated as if they were\n                not included.\n            strict_parsing (bool): Flag indicating what to do with parsing\n                errors. If `False` (the default), errors are silently ignored.\n                If `True`, errors raise a `ValueError` exception.\n            encoding (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n            errors (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n        Returns:\n            RequestParameters: A dictionary containing the parsed arguments.\n        '''\n        pass\n\n    def get_query_args(self, keep_blank_values: bool=False, strict_parsing: bool=False, encoding: str='utf-8', errors: str='replace') -> list:\n        '''Parse `query_string` using `urllib.parse.parse_qsl`.\n        This methods is used by `query_args` propertyn but can be used\n        directly if you need to change default parameters.\n        Args:\n            keep_blank_values (bool): Flag indicating whether blank values in\n                percent-encoded queries should be treated as blank strings.\n                A `True` value indicates that blanks should be retained as\n                blank strings. The default `False` value indicates that\n                blank values are to be ignored and treated as if they were\n                not included.\n            strict_parsing (bool): Flag indicating what to do with\n                parsing errors. If `False` (the default), errors are\n                silently ignored. If `True`, errors raise a\n                `ValueError` exception.\n            encoding (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n            errors (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n        Returns:\n            list: A list of tuples containing the parsed arguments.\n        '''\n        pass\n\n    def get_cookies(self) -> RequestParameters:\n        pass\n    @property\n    def cookies(self) -> RequestParameters:\n        '''Incoming cookies on the request\n        Returns:\n            RequestParameters: Incoming cookies on the request\n        '''\n        pass\n    @property\n    def content_type(self) -> str:\n        '''Content-Type header form the request\n        Returns:\n            str: Content-Type header form the request\n        '''\n        pass\n    @property\n    def match_info(self) -> dict[str, Any]:\n        '''Matched path parameters after resolving route\n        Returns:\n            Dict[str, Any]: Matched path parameters after resolving route\n        '''\n        pass\n    @match_info.setter\n    def match_info(self) -> dict[str, Any]:\n        pass\n    @property\n    def ip(self) -> str:\n        '''Peer ip of the socket\n        Returns:\n            str: Peer ip of the socket\n        '''\n        pass\n    @property\n    def port(self) -> int:\n        '''Peer port of the socket\n        Returns:\n            int: Peer port of the socket\n        '''\n        pass\n    @property\n    def socket(self) -> Union[tuple[str, int], tuple[None, None]]:\n        '''Information about the connected socket if available\n        Returns:\n            Tuple[Optional[str], Optional[int]]: Information about the\n                connected socket if available, in the form of a tuple of\n                (ip, port)\n        '''\n        pass\n    @property\n    def path(self) -> str:\n        '''Path of the local HTTP request\n        Returns:\n            str: Path of the local HTTP request\n        '''\n        pass\n    @property\n    def network_paths(self) -> Optional[list[Any]]:\n        '''Access the network paths if available\n        Returns:\n            Optional[List[Any]]: Access the network paths if available\n        '''\n        pass\n    @property\n    def forwarded(self) -> Options:\n        '''Active proxy information obtained from request headers, as specified in Sanic configuration.\n        Field names by, for, proto, host, port and path are normalized.\n        - for and by IPv6 addresses are bracketed\n        - port (int) is only set by port headers, not from host.\n        - path is url-unencoded\n        Additional values may be available from new style Forwarded headers.\n        Returns:\n            Options: proxy information from request headers\n        '''\n        pass\n    @property\n    def remote_addr(self) -> str:\n        '''Client IP address, if available from proxy.\n        Returns:\n            str: IPv4, bracketed IPv6, UNIX socket name or arbitrary string\n        '''\n        pass\n    @property\n    def client_ip(self) -> str:\n        '''\n        Client IP address.\n        1. proxied remote address `self.forwarded['for']`\n        2. local peer address `self.ip`\n        New in Sanic 23.6. Prefer this over `remote_addr` for determining the\n        client address regardless of whether the service runs behind a proxy\n        or not (proxy deployment needs separate configuration).\n        Returns:\n            str: IPv4, bracketed IPv6, UNIX socket name or arbitrary string\n        '''\n        pass\n    @property\n    def scheme(self) -> str:\n        '''Determine request scheme.\n        1. `config.SERVER_NAME` if in full URL format\n        2. proxied proto/scheme\n        3. local connection protocol\n        Returns:\n            str: http|https|ws|wss or arbitrary value given by the headers.\n        '''\n        pass\n    @property\n    def host(self) -> str:\n        '''The currently effective server 'host' (hostname or hostname:port).\n        1. `config.SERVER_NAME` overrides any client headers\n        2. proxied host of original request\n        3. request host header\n        hostname and port may be separated by\n        `sanic.headers.parse_host(request.host)`.\n        Returns:\n            str: the first matching host found, or empty string\n        '''\n        pass\n    @property\n    def server_name(self) -> str:\n        '''hostname the client connected to, by `request.host`\n        Returns:\n            str: hostname the client connected to, by `request.host`\n        '''\n        pass\n    @property\n    def server_port(self) -> int:\n        '''The port the client connected to, by forwarded `port` or `request.host`.\n        Default port is returned as 80 and 443 based on `request.scheme`.\n        Returns:\n            int: The port the client connected to, by forwarded `port` or `request.host`.\n        '''\n        pass\n    @property\n    def server_path(self) -> str:\n        '''Full path of current URL; uses proxied or local path\n        Returns:\n            str: Full path of current URL; uses proxied or local path\n        '''\n        pass\n    @property\n    def query_string(self) -> str:\n        '''Representation of the requested query\n        Returns:\n            str: Representation of the requested query\n        '''\n        pass\n    @property\n    def url(self) -> str:\n        '''The URL\n        Returns:\n            str: The URL\n        '''\n        pass\n\n    def url_for(self, view_name: str, **kwargs) -> str:\n        '''Retrieve a URL for a given view name.\n        Same as `sanic.Sanic.url_for`, but automatically determine `scheme`\n        and `netloc` base on the request. Since this method is aiming\n        to generate correct schema & netloc, `_external` is implied.\n        Args:\n            view_name (str): The view name to generate URL for.\n            **kwargs: Arbitrary keyword arguments to build URL query string.\n        Returns:\n            str: The generated URL.\n        '''\n        pass\n    @property\n    def scope(self) -> ASGIScope:\n        '''The ASGI scope of the request.\n        Returns:\n            ASGIScope: The ASGI scope of the request.\n        Raises:\n            NotImplementedError: If the app isn't an ASGI app.\n        '''\n        pass\n    @property\n    def is_safe(self) -> bool:\n        '''Whether the HTTP method is safe.\n        See https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.1\n        Returns:\n            bool: Whether the HTTP method is safe.\n        '''\n        pass\n    @property\n    def is_idempotent(self) -> bool:\n        '''Whether the HTTP method is iempotent.\n        See https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.2\n        Returns:\n            bool: Whether the HTTP method is iempotent.\n        '''\n        pass\n    @property\n    def is_cacheable(self) -> bool:\n        '''Whether the HTTP method is cacheable.\n        See https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.3\n        Returns:\n            bool: Whether the HTTP method is cacheable.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom types import SimpleNamespace\nfrom inspect import isawaitable\nfrom sanic.headers import AcceptList, Options, parse_accept, parse_content_header, parse_credentials, parse_forwarded, parse_host, parse_xforwarded\nfrom sanic_routing.route import Route\nimport uuid\nfrom sanic.models.asgi import ASGIScope\nfrom sanic.exceptions import BadRequest, BadURL, ServerError\nfrom .form import parse_multipart_form\nfrom sanic.http import Stage\nfrom sanic.cookies.request import CookieRequestParameters, parse_cookie\nfrom urllib.parse import parse_qs, parse_qsl, urlunparse\nfrom sanic.http.stream import Stream\nfrom httptools.parser.errors import HttpParserInvalidURLError\nfrom httptools import parse_url\nfrom contextvars import ContextVar\nfrom .parameters import RequestParameters\nfrom sanic.constants import CACHEABLE_HTTP_METHODS, DEFAULT_HTTP_CONTENT_TYPE, IDEMPOTENT_HTTP_METHODS, SAFE_HTTP_METHODS\nfrom sanic.compat import CancelledErrors, Header\nfrom sanic.models.http_types import Credentials\nfrom sanic.models.protocol_types import TransportProtocol\nfrom sanic.log import error_logger\nfrom sanic.http.constants import HTTP\nfrom sanic.response import BaseHTTPResponse, HTTPResponse\nfrom asyncio import BaseProtocol\nfrom collections import defaultdict\nfrom typing import TYPE_CHECKING, Any, DefaultDict, Generic, Optional, Union, cast\n\nclass Request(Generic[sanic_type, ctx_type]):\n    \"\"\"State of HTTP request.\n\n    Args:\n        url_bytes (bytes): Raw URL bytes.\n        headers (Header): Request headers.\n        version (str): HTTP version.\n        method (str): HTTP method.\n        transport (TransportProtocol): Transport protocol.\n        app (Sanic): Sanic instance.\n        head (bytes, optional): Request head. Defaults to `b\"\"`.\n        stream_id (int, optional): HTTP/3 stream ID. Defaults to `0`.\n    \"\"\"\n    _current: ContextVar[Request] = ContextVar('request')\n    _loads = json_loads\n    __slots__ = ('__weakref__', '_cookies', '_ctx', '_id', '_ip', '_parsed_url', '_port', '_protocol', '_remote_addr', '_request_middleware_started', '_response_middleware_started', '_scheme', '_socket', '_stream_id', '_match_info', '_name', 'app', 'body', 'conn_info', 'head', 'headers', 'method', 'parsed_accept', 'parsed_args', 'parsed_cookies', 'parsed_credentials', 'parsed_files', 'parsed_form', 'parsed_forwarded', 'parsed_json', 'parsed_not_grouped_args', 'parsed_token', 'raw_url', 'responded', 'route', 'stream', 'transport', 'version')\n\n    def __init__(self, url_bytes: bytes, headers: Header, version: str, method: str, transport: TransportProtocol, app: sanic_type, head: bytes=b'', stream_id: int=0):\n        self.raw_url = url_bytes\n        try:\n            self._parsed_url = parse_url(url_bytes)\n        except HttpParserInvalidURLError:\n            url = url_bytes.decode(errors='backslashreplace')\n            raise BadURL(f'Bad URL: {url}')\n        self._id: Optional[Union[uuid.UUID, str, int]] = None\n        self._name: Optional[str] = None\n        self._stream_id = stream_id\n        self.app = app\n        self.headers = Header(headers)\n        self.version = version\n        self.method = method\n        self.transport = transport\n        self.head = head\n        self.body = b''\n        self.conn_info: Optional[ConnInfo] = None\n        self._ctx: Optional[ctx_type] = None\n        self.parsed_accept: Optional[AcceptList] = None\n        self.parsed_args: DefaultDict[tuple[bool, bool, str, str], RequestParameters] = defaultdict(RequestParameters)\n        self.parsed_cookies: Optional[RequestParameters] = None\n        self.parsed_credentials: Optional[Credentials] = None\n        self.parsed_files: Optional[RequestParameters] = None\n        self.parsed_form: Optional[RequestParameters] = None\n        self.parsed_forwarded: Optional[Options] = None\n        self.parsed_json = None\n        self.parsed_not_grouped_args: DefaultDict[tuple[bool, bool, str, str], list[tuple[str, str]]] = defaultdict(list)\n        self.parsed_token: Optional[str] = None\n        self._request_middleware_started = False\n        self._response_middleware_started = False\n        self.responded: bool = False\n        self.route: Optional[Route] = None\n        self.stream: Optional[Stream] = None\n        self._match_info: dict[str, Any] = {}\n        self._protocol: Optional[BaseProtocol] = None\n\n    def __repr__(self):\n        class_name = self.__class__.__name__\n        return f'<{class_name}: {self.method} {self.path}>'\n\n    @staticmethod\n    def make_context() -> ctx_type:\n        \"\"\"Create a new context object.\n\n        This method is called when a new request context is pushed. It is\n        a great candidate for overriding in a subclass if you want to\n        control the type of context object that is created.\n\n        By default, it returns a `types.SimpleNamespace` instance.\n\n        Returns:\n            ctx_type: A new context object.\n        \"\"\"\n        return cast(ctx_type, SimpleNamespace())\n\n    @classmethod\n    def get_current(cls) -> Request:\n        \"\"\"Retrieve the current request object\n\n        This implements [Context Variables](https://docs.python.org/3/library/contextvars.html)\n        to allow for accessing the current request from anywhere.\n\n        A typical usecase is when you want to access the current request\n        from a function that is not a handler, such as a logging function:\n\n        ```python\n        import logging\n\n        class LoggingFormater(logging.Formatter):\n            def format(self, record):\n                request = Request.get_current()\n                record.url = request.url\n                record.ip = request.ip\n                return super().format(record)\n        ```\n\n        Returns:\n            Request: The current request object\n\n        Raises:\n            sanic.exceptions.ServerError: If it is outside of a request\n                lifecycle.\n        \"\"\"\n        request = cls._current.get(None)\n        if not request:\n            raise ServerError('No current request')\n        return request\n\n    @classmethod\n    def generate_id(*_) -> Union[uuid.UUID, str, int]:\n        \"\"\"Generate a unique ID for the request.\n\n        This method is called to generate a unique ID for each request.\n        By default, it returns a `uuid.UUID` instance.\n\n        Returns:\n            Union[uuid.UUID, str, int]: A unique ID for the request.\n        \"\"\"\n        return uuid.uuid4()\n\n    @property\n    def ctx(self) -> ctx_type:\n        \"\"\"The current request context.\n\n        This is a context object for the current request. It is created\n        by `Request.make_context` and is a great place to store data\n        that you want to be accessible during the request lifecycle.\n\n        Returns:\n            ctx_type: The current request context.\n        \"\"\"\n        if not self._ctx:\n            self._ctx = self.make_context()\n        return self._ctx\n\n    @property\n    def stream_id(self) -> int:\n        \"\"\"Access the HTTP/3 stream ID.\n\n        Raises:\n            sanic.exceptions.ServerError: If the request is not HTTP/3.\n\n        Returns:\n            int: The HTTP/3 stream ID.\n        \"\"\"\n        if self.protocol.version is not HTTP.VERSION_3:\n            raise ServerError('Stream ID is only a property of a HTTP/3 request')\n        return self._stream_id\n\n    def reset_response(self) -> None:\n        \"\"\"Reset the response object.\n\n        This clears much of the state of the object. It should\n        generally not be called directly, but is called automatically as\n        part of the request lifecycle.\n\n        Raises:\n            sanic.exceptions.ServerError: If the response has already been\n                sent.\n        \"\"\"\n        try:\n            if self.stream is not None and self.stream.stage is not Stage.HANDLER:\n                raise ServerError('Cannot reset response because previous response was sent.')\n            self.stream.response.stream = None\n            self.stream.response = None\n            self.responded = False\n        except AttributeError:\n            pass\n\n    async def respond(self, response: Optional[BaseHTTPResponse]=None, *, status: int=200, headers: Optional[Union[Header, dict[str, str]]]=None, content_type: Optional[str]=None):\n        \"\"\"Respond to the request without returning.\n\n        This method can only be called once, as you can only respond once.\n        If no ``response`` argument is passed, one will be created from the\n        ``status``, ``headers`` and ``content_type`` arguments.\n\n        **The first typical usecase** is if you wish to respond to the\n        request without returning from the handler:\n\n        ```python\n        @app.get(\"/\")\n        async def handler(request: Request):\n            data = ...  # Process something\n\n            json_response = json({\"data\": data})\n            await request.respond(json_response)\n\n        @app.on_response\n        async def add_header(_, response: HTTPResponse):\n            # Middlewares still get executed as expected\n            response.headers[\"one\"] = \"two\"\n        ```\n\n        **The second possible usecase** is for when you want to directly\n        respond to the request:\n\n        ```python\n        response = await request.respond(content_type=\"text/csv\")\n        await response.send(\"foo,\")\n        await response.send(\"bar\")\n\n        # You can control the completion of the response by calling\n        # the 'eof()' method:\n        await response.eof()\n        ```\n\n        Args:\n            response (ResponseType): Response instance to send.\n            status (int): Status code to return in the response.\n            headers (Optional[Dict[str, str]]): Headers to return in the response, defaults to None.\n            content_type (Optional[str]): Content-Type header of the response, defaults to None.\n\n        Returns:\n            FinalResponseType: Final response being sent (may be different from the\n                \"response\" parameter because of middlewares), which can be\n                used to manually send data.\n        \"\"\"\n        try:\n            if self.stream is not None and self.stream.response:\n                raise ServerError('Second respond call is not allowed.')\n        except AttributeError:\n            pass\n        if response is None:\n            response = HTTPResponse(status=status, headers=headers, content_type=content_type)\n        if isinstance(response, BaseHTTPResponse) and self.stream:\n            response = self.stream.respond(response)\n            if isawaitable(response):\n                response = await response\n        try:\n            middleware = self.route and self.route.extra.response_middleware or self.app.response_middleware\n            if middleware and (not self._response_middleware_started):\n                self._response_middleware_started = True\n                response = await self.app._run_response_middleware(self, response, middleware)\n        except CancelledErrors:\n            raise\n        except Exception:\n            error_logger.exception('Exception occurred in one of response middleware handlers')\n        self.responded = True\n        return response\n\n    async def receive_body(self):\n        \"\"\"Receive request.body, if not already received.\n\n        Streaming handlers may call this to receive the full body. Sanic calls\n        this function before running any handlers of non-streaming routes.\n\n        Custom request classes can override this for custom handling of both\n        streaming and non-streaming routes.\n        \"\"\"\n        if not self.body:\n            self.body = b''.join([data async for data in self.stream])\n\n    @property\n    def name(self) -> Optional[str]:\n        \"\"\"The route name\n\n        In the following pattern:\n\n        ```\n        <AppName>.[<BlueprintName>.]<HandlerName>\n        ```\n\n        Returns:\n            Optional[str]: The route name\n        \"\"\"\n        if self._name:\n            return self._name\n        elif self.route:\n            return self.route.name\n        return None\n\n    @property\n    def endpoint(self) -> Optional[str]:\n        \"\"\"Alias of `sanic.request.Request.name`\n\n        Returns:\n            Optional[str]: The route name\n        \"\"\"\n        return self.name\n\n    @property\n    def uri_template(self) -> Optional[str]:\n        \"\"\"The defined URI template\n\n        Returns:\n            Optional[str]: The defined URI template\n        \"\"\"\n        if self.route:\n            return f'/{self.route.path}'\n        return None\n\n    @property\n    def protocol(self) -> TransportProtocol:\n        \"\"\"The HTTP protocol instance\n\n        Returns:\n            Protocol: The HTTP protocol instance\n        \"\"\"\n        if not self._protocol:\n            self._protocol = self.transport.get_protocol()\n        return self._protocol\n\n    @property\n    def raw_headers(self) -> bytes:\n        \"\"\"The unparsed HTTP headers\n\n        Returns:\n            bytes: The unparsed HTTP headers\n        \"\"\"\n        _, headers = self.head.split(b'\\r\\n', 1)\n        return bytes(headers)\n\n    @property\n    def request_line(self) -> bytes:\n        \"\"\"The first line of a HTTP request\n\n        Returns:\n            bytes: The first line of a HTTP request\n        \"\"\"\n        reqline, _ = self.head.split(b'\\r\\n', 1)\n        return bytes(reqline)\n\n    @property\n    def id(self) -> Optional[Union[uuid.UUID, str, int]]:\n        \"\"\"A request ID passed from the client, or generated from the backend.\n\n        By default, this will look in a request header defined at:\n        `self.app.config.REQUEST_ID_HEADER`. It defaults to\n        `X-Request-ID`. Sanic will try to cast the ID into a `UUID` or an\n        `int`.\n\n        If there is not a UUID from the client, then Sanic will try\n        to generate an ID by calling `Request.generate_id()`. The default\n        behavior is to generate a `UUID`. You can customize this behavior\n        by subclassing `Request` and overwriting that method.\n\n        ```python\n        from sanic import Request, Sanic\n        from itertools import count\n\n        class IntRequest(Request):\n            counter = count()\n\n            def generate_id(self):\n                return next(self.counter)\n\n        app = Sanic(\"MyApp\", request_class=IntRequest)\n        ```\n\n        Returns:\n            Optional[Union[uuid.UUID, str, int]]: A request ID passed from the\n                client, or generated from the backend.\n        \"\"\"\n        if not self._id:\n            self._id = self.headers.getone(self.app.config.REQUEST_ID_HEADER, self.__class__.generate_id(self))\n            if isinstance(self._id, str):\n                try:\n                    self._id = uuid.UUID(self._id)\n                except ValueError:\n                    try:\n                        self._id = int(self._id)\n                    except ValueError:\n                        ...\n        return self._id\n\n    @property\n    def json(self) -> Any:\n        \"\"\"The request body parsed as JSON\n\n        Returns:\n            Any: The request body parsed as JSON\n        \"\"\"\n        if self.parsed_json is None:\n            self.load_json()\n        return self.parsed_json\n\n    def load_json(self, loads=None) -> Any:\n        \"\"\"Load the request body as JSON\n\n        Args:\n            loads (Callable, optional): A custom JSON loader. Defaults to None.\n\n        Raises:\n            BadRequest: If the request body cannot be parsed as JSON\n\n        Returns:\n            Any: The request body parsed as JSON\n        \"\"\"\n        try:\n            if not loads:\n                loads = self.__class__._loads\n            self.parsed_json = loads(self.body)\n        except Exception:\n            if not self.body:\n                return None\n            raise BadRequest('Failed when parsing body as json')\n        return self.parsed_json\n\n    @property\n    def accept(self) -> AcceptList:\n        \"\"\"Accepted response content types.\n\n        A convenience handler for easier RFC-compliant matching of MIME types,\n        parsed as a list that can match wildcards and includes */* by default.\n\n        Returns:\n            AcceptList: Accepted response content types\n        \"\"\"\n        if self.parsed_accept is None:\n            self.parsed_accept = parse_accept(self.headers.get('accept'))\n        return self.parsed_accept\n\n    @property\n    def token(self) -> Optional[str]:\n        \"\"\"Attempt to return the auth header token.\n\n        Returns:\n            Optional[str]: The auth header token\n        \"\"\"\n        if self.parsed_token is None:\n            prefixes = ('Bearer', 'Token')\n            _, token = parse_credentials(self.headers.getone('authorization', None), prefixes)\n            self.parsed_token = token\n        return self.parsed_token\n\n    @property\n    def credentials(self) -> Optional[Credentials]:\n        \"\"\"Attempt to return the auth header value.\n\n        Covers NoAuth, Basic Auth, Bearer Token, Api Token authentication\n        schemas.\n\n        Returns:\n            Optional[Credentials]: A Credentials object with token, or username\n                and password related to the request\n        \"\"\"\n        if self.parsed_credentials is None:\n            try:\n                prefix, credentials = parse_credentials(self.headers.getone('authorization', None))\n                if credentials:\n                    self.parsed_credentials = Credentials(auth_type=prefix, token=credentials)\n            except ValueError:\n                pass\n        return self.parsed_credentials\n\n    def get_form(self, keep_blank_values: bool=False) -> Optional[RequestParameters]:\n        \"\"\"Method to extract and parse the form data from a request.\n\n        Args:\n            keep_blank_values (bool): Whether to discard blank values from the form data.\n\n        Returns:\n            Optional[RequestParameters]: The parsed form data.\n        \"\"\"\n        self.parsed_form = RequestParameters()\n        self.parsed_files = RequestParameters()\n        content_type = self.headers.getone('content-type', DEFAULT_HTTP_CONTENT_TYPE)\n        content_type, parameters = parse_content_header(content_type)\n        try:\n            if content_type == 'application/x-www-form-urlencoded':\n                self.parsed_form = RequestParameters(parse_qs(self.body.decode('utf-8'), keep_blank_values=keep_blank_values))\n            elif content_type == 'multipart/form-data':\n                boundary = parameters['boundary'].encode('utf-8')\n                self.parsed_form, self.parsed_files = parse_multipart_form(self.body, boundary)\n        except Exception:\n            error_logger.exception('Failed when parsing form')\n        return self.parsed_form\n\n    @property\n    def form(self) -> Optional[RequestParameters]:\n        \"\"\"The request body parsed as form data\n\n        Returns:\n            Optional[RequestParameters]: The request body parsed as form data\n        \"\"\"\n        if self.parsed_form is None:\n            self.get_form()\n        return self.parsed_form\n\n    @property\n    def files(self) -> Optional[RequestParameters]:\n        \"\"\"The request body parsed as uploaded files\n\n        Returns:\n            Optional[RequestParameters]: The request body parsed as uploaded files\n        \"\"\"\n        if self.parsed_files is None:\n            self.form\n        return self.parsed_files\n\n    def get_args(self, keep_blank_values: bool=False, strict_parsing: bool=False, encoding: str='utf-8', errors: str='replace') -> RequestParameters:\n        \"\"\"Parse `query_string` using `urllib.parse.parse_qs`.\n\n        This methods is used by the `args` property, but it also\n        can be used directly if you need to change default parameters.\n\n        Args:\n            keep_blank_values (bool): Flag indicating whether blank values in\n                percent-encoded queries should be treated as blank strings.\n                A `True` value indicates that blanks should be retained as\n                blank strings. The default `False` value indicates that\n                blank values are to be ignored and treated as if they were\n                not included.\n            strict_parsing (bool): Flag indicating what to do with parsing\n                errors. If `False` (the default), errors are silently ignored.\n                If `True`, errors raise a `ValueError` exception.\n            encoding (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n            errors (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n\n        Returns:\n            RequestParameters: A dictionary containing the parsed arguments.\n        \"\"\"\n        if (keep_blank_values, strict_parsing, encoding, errors) not in self.parsed_args:\n            if self.query_string:\n                self.parsed_args[keep_blank_values, strict_parsing, encoding, errors] = RequestParameters(parse_qs(qs=self.query_string, keep_blank_values=keep_blank_values, strict_parsing=strict_parsing, encoding=encoding, errors=errors))\n        return self.parsed_args[keep_blank_values, strict_parsing, encoding, errors]\n    args = property(get_args)\n    'Convenience property to access `Request.get_args` with default values.\\n    '\n\n    def get_query_args(self, keep_blank_values: bool=False, strict_parsing: bool=False, encoding: str='utf-8', errors: str='replace') -> list:\n        \"\"\"Parse `query_string` using `urllib.parse.parse_qsl`.\n\n        This methods is used by `query_args` propertyn but can be used\n        directly if you need to change default parameters.\n\n        Args:\n            keep_blank_values (bool): Flag indicating whether blank values in\n                percent-encoded queries should be treated as blank strings.\n                A `True` value indicates that blanks should be retained as\n                blank strings. The default `False` value indicates that\n                blank values are to be ignored and treated as if they were\n                not included.\n            strict_parsing (bool): Flag indicating what to do with\n                parsing errors. If `False` (the default), errors are\n                silently ignored. If `True`, errors raise a\n                `ValueError` exception.\n            encoding (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n            errors (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n\n        Returns:\n            list: A list of tuples containing the parsed arguments.\n        \"\"\"\n        if (keep_blank_values, strict_parsing, encoding, errors) not in self.parsed_not_grouped_args:\n            if self.query_string:\n                self.parsed_not_grouped_args[keep_blank_values, strict_parsing, encoding, errors] = parse_qsl(qs=self.query_string, keep_blank_values=keep_blank_values, strict_parsing=strict_parsing, encoding=encoding, errors=errors)\n        return self.parsed_not_grouped_args[keep_blank_values, strict_parsing, encoding, errors]\n    query_args = property(get_query_args)\n    'Convenience property to access `Request.get_query_args` with default values.\\n    '\n\n    def get_cookies(self) -> RequestParameters:\n        cookie = self.headers.getone('cookie', '')\n        self.parsed_cookies = CookieRequestParameters(parse_cookie(cookie))\n        return self.parsed_cookies\n\n    @property\n    def cookies(self) -> RequestParameters:\n        \"\"\"Incoming cookies on the request\n\n        Returns:\n            RequestParameters: Incoming cookies on the request\n        \"\"\"\n        if self.parsed_cookies is None:\n            self.get_cookies()\n        return cast(CookieRequestParameters, self.parsed_cookies)\n\n    @property\n    def content_type(self) -> str:\n        \"\"\"Content-Type header form the request\n\n        Returns:\n            str: Content-Type header form the request\n        \"\"\"\n        return self.headers.getone('content-type', DEFAULT_HTTP_CONTENT_TYPE)\n\n    @property\n    def match_info(self) -> dict[str, Any]:\n        \"\"\"Matched path parameters after resolving route\n\n        Returns:\n            Dict[str, Any]: Matched path parameters after resolving route\n        \"\"\"\n        return self._match_info\n\n    @match_info.setter\n    def match_info(self, value):\n        self._match_info = value\n\n    @property\n    def ip(self) -> str:\n        \"\"\"Peer ip of the socket\n\n        Returns:\n            str: Peer ip of the socket\n        \"\"\"\n        return self.conn_info.client_ip if self.conn_info else ''\n\n    @property\n    def port(self) -> int:\n        \"\"\"Peer port of the socket\n\n        Returns:\n            int: Peer port of the socket\n        \"\"\"\n        return self.conn_info.client_port if self.conn_info else 0\n\n    @property\n    def socket(self) -> Union[tuple[str, int], tuple[None, None]]:\n        \"\"\"Information about the connected socket if available\n\n        Returns:\n            Tuple[Optional[str], Optional[int]]: Information about the\n                connected socket if available, in the form of a tuple of\n                (ip, port)\n        \"\"\"\n        return self.conn_info.peername if self.conn_info and self.conn_info.peername else (None, None)\n\n    @property\n    def path(self) -> str:\n        \"\"\"Path of the local HTTP request\n\n        Returns:\n            str: Path of the local HTTP request\n        \"\"\"\n        return self._parsed_url.path.decode('utf-8')\n\n    @property\n    def network_paths(self) -> Optional[list[Any]]:\n        \"\"\"Access the network paths if available\n\n        Returns:\n            Optional[List[Any]]: Access the network paths if available\n        \"\"\"\n        if self.conn_info is None:\n            return None\n        return self.conn_info.network_paths\n\n    @property\n    def forwarded(self) -> Options:\n        \"\"\"Active proxy information obtained from request headers, as specified in Sanic configuration.\n\n        Field names by, for, proto, host, port and path are normalized.\n        - for and by IPv6 addresses are bracketed\n        - port (int) is only set by port headers, not from host.\n        - path is url-unencoded\n\n        Additional values may be available from new style Forwarded headers.\n\n        Returns:\n            Options: proxy information from request headers\n        \"\"\"\n        if self.parsed_forwarded is None:\n            self.parsed_forwarded = parse_forwarded(self.headers, self.app.config) or parse_xforwarded(self.headers, self.app.config) or {}\n        return self.parsed_forwarded\n\n    @property\n    def remote_addr(self) -> str:\n        \"\"\"Client IP address, if available from proxy.\n\n        Returns:\n            str: IPv4, bracketed IPv6, UNIX socket name or arbitrary string\n        \"\"\"\n        if not hasattr(self, '_remote_addr'):\n            self._remote_addr = str(self.forwarded.get('for', ''))\n        return self._remote_addr\n\n    @property\n    def client_ip(self) -> str:\n        \"\"\"\n        Client IP address.\n        1. proxied remote address `self.forwarded['for']`\n        2. local peer address `self.ip`\n\n        New in Sanic 23.6. Prefer this over `remote_addr` for determining the\n        client address regardless of whether the service runs behind a proxy\n        or not (proxy deployment needs separate configuration).\n\n        Returns:\n            str: IPv4, bracketed IPv6, UNIX socket name or arbitrary string\n        \"\"\"\n        return self.remote_addr or self.ip\n\n    @property\n    def scheme(self) -> str:\n        \"\"\"Determine request scheme.\n\n        1. `config.SERVER_NAME` if in full URL format\n        2. proxied proto/scheme\n        3. local connection protocol\n\n        Returns:\n            str: http|https|ws|wss or arbitrary value given by the headers.\n        \"\"\"\n        if not hasattr(self, '_scheme'):\n            if self.app.websocket_enabled and self.headers.upgrade.lower() == 'websocket':\n                scheme = 'ws'\n            else:\n                scheme = 'http'\n            proto = None\n            sp = self.app.config.get('SERVER_NAME', '').split('://', 1)\n            if len(sp) == 2:\n                proto = sp[0]\n            elif 'proto' in self.forwarded:\n                proto = str(self.forwarded['proto'])\n            if proto:\n                scheme = proto.replace('http', scheme)\n            elif self.conn_info and self.conn_info.ssl:\n                scheme += 's'\n            self._scheme = scheme\n        return self._scheme\n\n    @property\n    def host(self) -> str:\n        \"\"\"The currently effective server 'host' (hostname or hostname:port).\n\n        1. `config.SERVER_NAME` overrides any client headers\n        2. proxied host of original request\n        3. request host header\n        hostname and port may be separated by\n        `sanic.headers.parse_host(request.host)`.\n\n        Returns:\n            str: the first matching host found, or empty string\n        \"\"\"\n        server_name = self.app.config.get('SERVER_NAME')\n        if server_name:\n            return server_name.split('//', 1)[-1].split('/', 1)[0]\n        return str(self.forwarded.get('host') or self.headers.getone('host', ''))\n\n    @property\n    def server_name(self) -> str:\n        \"\"\"hostname the client connected to, by `request.host`\n\n        Returns:\n            str: hostname the client connected to, by `request.host`\n        \"\"\"\n        return parse_host(self.host)[0] or ''\n\n    @property\n    def server_port(self) -> int:\n        \"\"\"The port the client connected to, by forwarded `port` or `request.host`.\n\n        Default port is returned as 80 and 443 based on `request.scheme`.\n\n        Returns:\n            int: The port the client connected to, by forwarded `port` or `request.host`.\n        \"\"\"\n        port = self.forwarded.get('port') or parse_host(self.host)[1]\n        return int(port or (80 if self.scheme in ('http', 'ws') else 443))\n\n    @property\n    def server_path(self) -> str:\n        \"\"\"Full path of current URL; uses proxied or local path\n\n        Returns:\n            str: Full path of current URL; uses proxied or local path\n        \"\"\"\n        return str(self.forwarded.get('path') or self.path)\n\n    @property\n    def query_string(self) -> str:\n        \"\"\"Representation of the requested query\n\n        Returns:\n            str: Representation of the requested query\n        \"\"\"\n        if self._parsed_url.query:\n            return self._parsed_url.query.decode('utf-8')\n        else:\n            return ''\n\n    @property\n    def url(self) -> str:\n        \"\"\"The URL\n\n        Returns:\n            str: The URL\n        \"\"\"\n        return urlunparse((self.scheme, self.host, self.path, None, self.query_string, None))\n\n    def url_for(self, view_name: str, **kwargs) -> str:\n        \"\"\"Retrieve a URL for a given view name.\n\n        Same as `sanic.Sanic.url_for`, but automatically determine `scheme`\n        and `netloc` base on the request. Since this method is aiming\n        to generate correct schema & netloc, `_external` is implied.\n\n        Args:\n            view_name (str): The view name to generate URL for.\n            **kwargs: Arbitrary keyword arguments to build URL query string.\n\n        Returns:\n            str: The generated URL.\n        \"\"\"\n        try:\n            sp = self.app.config.get('SERVER_NAME', '').split('://', 1)\n            if len(sp) == 2:\n                return self.app.url_for(view_name, _external=True, **kwargs)\n        except AttributeError:\n            pass\n        scheme = self.scheme\n        host = self.server_name\n        port = self.server_port\n        if scheme.lower() in ('http', 'ws') and port == 80 or (scheme.lower() in ('https', 'wss') and port == 443):\n            netloc = host\n        else:\n            netloc = f'{host}:{port}'\n        return self.app.url_for(view_name, _external=True, _scheme=scheme, _server=netloc, **kwargs)\n\n    @property\n    def scope(self) -> ASGIScope:\n        \"\"\"The ASGI scope of the request.\n\n        Returns:\n            ASGIScope: The ASGI scope of the request.\n\n        Raises:\n            NotImplementedError: If the app isn't an ASGI app.\n        \"\"\"\n        if not self.app.asgi:\n            raise NotImplementedError(\"App isn't running in ASGI mode. Scope is only available for ASGI apps.\")\n        return self.transport.scope\n\n    @property\n    def is_safe(self) -> bool:\n        \"\"\"Whether the HTTP method is safe.\n\n        See https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.1\n\n        Returns:\n            bool: Whether the HTTP method is safe.\n        \"\"\"\n        return self.method in SAFE_HTTP_METHODS\n\n    @property\n    def is_idempotent(self) -> bool:\n        \"\"\"Whether the HTTP method is iempotent.\n\n        See https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.2\n\n        Returns:\n            bool: Whether the HTTP method is iempotent.\n        \"\"\"\n        return self.method in IDEMPOTENT_HTTP_METHODS\n\n    @property\n    def is_cacheable(self) -> bool:\n        \"\"\"Whether the HTTP method is cacheable.\n\n        See https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.3\n\n        Returns:\n            bool: Whether the HTTP method is cacheable.\n        \"\"\"\n        return self.method in CACHEABLE_HTTP_METHODS\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass templater:\n    '''Class for generating templates for question and answer generation.\n    This class handles the creation of templates for generating both questions\n    and answers based on predefined rules and configurations.\n        '''\n\n    def __init__(self, q_dict: dict, a_dict: dict, user_name: str='', global_bio: str='', is_cot: bool=True):\n        '''Initialize the templater with question and answer dictionaries.\n        Args:\n            q_dict: Dictionary containing question type configurations.\n            a_dict: Dictionary containing answer type configurations.\n            user_name: Name of the user for personalization.\n            global_bio: Global biography for context.\n        '''\n        pass\n\n    def get_A_template(self, question_type: str) -> tuple:\n        '''Generate the answer template for a specific question type.\n        Args:\n            question_type: The type of question to generate an answer for.\n        Returns:\n            A tuple containing the answer template and a list of chosen optional types.\n        '''\n        pass\n\n    def get_Q_template(self, question_type_prompt: str) -> str:\n        '''Generate the question template based on the provided prompt.\n        Args:\n            question_type_prompt: The prompt describing the question type.\n        Returns:\n            The question generation template with the question type filled in.\n        '''\n        pass"
  }
]