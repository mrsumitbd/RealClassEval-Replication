[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass StateTransitionWrapper(Generic[_P, _R, _T]):\n    '''\n    Wraps :class:`StateTransition` with the context of the object it is accessed from.\n    Automatically constructed by :class:`StateTransition`.\n        '''\n\n    def __init__(self, statetransition: StateTransition[_P, _R], obj: _T) -> None:\n        pass\n    @property\n    def data(self) -> dict[str, Any]:\n        '''Return data as provided to the :meth:`~StateManager.transition` decorator.'''\n        pass\n\n    def _validate_available(self) -> Optional[tuple[StateManager, Any, Any]]:\n        '''\n        If the state is invalid for the transition, return details on what didn't match.\n        :return: Tuple of (state manager, current state, label for current state)\n        '''\n        pass\n    @property\n    def is_available(self) -> bool:\n        '''Property that indicates whether this transition is currently available.'''\n        pass\n\n    def __getattr__(self, name: str) -> Any:\n        pass\n\n    def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -> _R:\n        '''Perform the state transition.'''\n        pass\nCorresponding class implementation:\n\nfrom typing import TYPE_CHECKING, Any, Callable, Generic, NoReturn, Optional, Union, cast, overload\nfrom ..utils import LabeledEnum, NameTitle, is_collection\n\nclass StateTransitionWrapper(Generic[_P, _R, _T]):\n    \"\"\"\n    Wraps :class:`StateTransition` with the context of the object it is accessed from.\n\n    Automatically constructed by :class:`StateTransition`.\n    \"\"\"\n\n    def __init__(self, statetransition: StateTransition[_P, _R], obj: _T) -> None:\n        self.statetransition = statetransition\n        self.obj = obj\n\n    @property\n    def data(self) -> dict[str, Any]:\n        \"\"\"Return data as provided to the :meth:`~StateManager.transition` decorator.\"\"\"\n        return self.statetransition.data\n\n    def _validate_available(self) -> Optional[tuple[StateManager, Any, Any]]:\n        \"\"\"\n        If the state is invalid for the transition, return details on what didn't match.\n\n        :return: Tuple of (state manager, current state, label for current state)\n        \"\"\"\n        for statemanager, conditions in self.statetransition.transitions.items():\n            current_state_value = statemanager._get_state_value(self.obj)\n            if conditions.from_ is None:\n                state_valid = True\n            else:\n                mstate = conditions.from_.get(current_state_value)\n                state_valid = mstate is not None and mstate.is_current_in(self.obj)\n            if not state_valid:\n                return (statemanager, current_state_value, statemanager.lenum.get(current_state_value))\n        return None\n\n    @property\n    def is_available(self) -> bool:\n        \"\"\"Property that indicates whether this transition is currently available.\"\"\"\n        return not self._validate_available()\n\n    def __getattr__(self, name: str) -> Any:\n        return getattr(self.statetransition, name)\n\n    def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -> _R:\n        \"\"\"Perform the state transition.\"\"\"\n        state_invalid = self._validate_available()\n        if state_invalid:\n            transition_error.send(self.obj, transition=self.statetransition, statemanager=state_invalid[0])\n            label = state_invalid[2]\n            if isinstance(label, NameTitle):\n                label = label.title\n            raise StateTransitionError(f'Invalid state for transition {self.statetransition.name}: {state_invalid[0]!r} = {label}')\n        transition_before.send(self.obj, transition=self.statetransition)\n        try:\n            result = self.statetransition.func(self.obj, *args, **kwargs)\n        except AbortTransition as e:\n            transition_exception.send(self.obj, transition=self.statetransition, exception=e)\n            return e.result\n        except Exception as e:\n            transition_exception.send(self.obj, transition=self.statetransition, exception=e)\n            raise\n        for statemanager, conditions in self.statetransition.transitions.items():\n            if conditions.to is not None:\n                statemanager._set_state_value(self.obj, conditions.to.value)\n        transition_after.send(self.obj, transition=self.statetransition)\n        return result\n\nExample skeleton:\n\n\nclass DeferSigint(contextlib.AbstractContextManager):\n    '''Context manager that defers SIGINT signals until the context is left.'''\n\n    def __init__(self):\n        pass\n    @classmethod\n    def create_if_main_thread(cls) -> contextlib.AbstractContextManager:\n        '''Creates a DeferSigint context manager if running on the main thread,\n        returns a no-op context manager otherwise.\n        '''\n        pass\n\n    def _set_signal_received(self, signum, frame):\n        '''SIGINT handler that defers the signal.'''\n        pass\n\n    def _signal_monkey_patch(self, signum, handler):\n        '''Monkey patch for signal.signal that defers the setting of new signal\n        handler after the DeferSigint context exits.'''\n        pass\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, exc_type, exc, exc_tb):\n        pass\nCorresponding class implementation:\n\nimport threading\nimport signal\nimport contextlib\n\nclass DeferSigint(contextlib.AbstractContextManager):\n    \"\"\"Context manager that defers SIGINT signals until the context is left.\"\"\"\n\n    def __init__(self):\n        self.signal_received = False\n        self.overridden_sigint_handler = None\n        self.orig_signal = None\n\n    @classmethod\n    def create_if_main_thread(cls) -> contextlib.AbstractContextManager:\n        \"\"\"Creates a DeferSigint context manager if running on the main thread,\n        returns a no-op context manager otherwise.\n        \"\"\"\n        if threading.current_thread() == threading.main_thread():\n            return cls()\n        else:\n            return contextlib.nullcontext()\n\n    def _set_signal_received(self, signum, frame):\n        \"\"\"SIGINT handler that defers the signal.\"\"\"\n        self.signal_received = True\n\n    def _signal_monkey_patch(self, signum, handler):\n        \"\"\"Monkey patch for signal.signal that defers the setting of new signal\n        handler after the DeferSigint context exits.\"\"\"\n        if threading.current_thread() == threading.main_thread() and signum == signal.SIGINT:\n            orig_sigint_handler = self.overridden_sigint_handler\n            self.overridden_sigint_handler = handler\n            return orig_sigint_handler\n        return self.orig_signal(signum, handler)\n\n    def __enter__(self):\n        self.overridden_sigint_handler = signal.getsignal(signal.SIGINT)\n        signal.signal(signal.SIGINT, self._set_signal_received)\n        self.orig_signal = signal.signal\n        signal.signal = self._signal_monkey_patch\n        return self\n\n    def __exit__(self, exc_type, exc, exc_tb):\n        assert self.overridden_sigint_handler is not None\n        assert self.orig_signal is not None\n        signal.signal = self.orig_signal\n        signal.signal(signal.SIGINT, self.overridden_sigint_handler)\n        if exc_type is None and self.signal_received:\n            self.overridden_sigint_handler(signal.SIGINT, None)\n        else:\n            return False\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass SuppressOutput:\n    '''Context manager to suppress output in console or Jupyter notebook.'''\n\n    def __enter__(self) -> 'SuppressOutput':\n        '''Enter the context manager.'''\n        pass\n\n    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None:\n        '''Exit the context manager.'''\n        pass"
  }
]