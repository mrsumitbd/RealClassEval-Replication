[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass WinLnkParser(interface.FileObjectParser):\n    '''Windows Shortcut (LNK) file parser.'''\n\n    def __init__(self):\n        '''Initializes a Windows Shortcut (LNK) file parser.'''\n        pass\n\n    def _GetDateTime(self, filetime):\n        '''Retrieves the date and time from a FILETIME timestamp.\n        Args:\n          filetime (int): FILETIME timestamp.\n        Returns:\n          dfdatetime.DateTimeValues: date and time or None if not set.\n        '''\n        pass\n\n    def _GetSanitizedPathString(self, path):\n        '''Retrieves a sanitize path string.\n        Args:\n          path (str): path.\n        Returns:\n          str: sanitized path string.\n        '''\n        pass\n    @classmethod\n    def GetFormatSpecification(cls):\n        '''Retrieves the format specification.\n        Returns:\n          FormatSpecification: format specification.\n        '''\n        pass\n\n    def _ParseDistributedTrackingIdentifier(self, parser_mediator, uuid_string, origin):\n        '''Extracts data from a Distributed Tracking identifier.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          uuid_string (str): UUID string of the Distributed Tracking identifier.\n          origin (str): origin of the event (event source).\n        '''\n        pass\n\n    def ParseFileObject(self, parser_mediator, file_object):\n        '''Parses a Windows Shortcut (LNK) file-like object.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): file-like object.\n        '''\n        pass\n\n    def ParseFileLNKFile(self, parser_mediator, file_object, display_name):\n        '''Parses a Windows Shortcut (LNK) file-like object.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): file-like object.\n          display_name (str): display name.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom plaso.lib import specification\nfrom dfdatetime import filetime as dfdatetime_filetime\nfrom plaso.containers import windows_events\nimport uuid\nfrom plaso.parsers.shared import shell_items\nfrom plaso.parsers import interface\nfrom plaso.lib import definitions\nimport pylnk\n\nclass WinLnkParser(interface.FileObjectParser):\n    \"\"\"Windows Shortcut (LNK) file parser.\"\"\"\n    _INITIAL_FILE_OFFSET = None\n    _PATH_ESCAPE_CHARACTERS = {'\\\\': '\\\\\\\\'}\n    _PATH_ESCAPE_CHARACTERS.update(definitions.NON_PRINTABLE_CHARACTERS)\n    NAME = 'lnk'\n    DATA_FORMAT = 'Windows Shortcut (LNK) file'\n\n    def __init__(self):\n        \"\"\"Initializes a Windows Shortcut (LNK) file parser.\"\"\"\n        super(WinLnkParser, self).__init__()\n        self._path_escape_characters = str.maketrans(self._PATH_ESCAPE_CHARACTERS)\n\n    def _GetDateTime(self, filetime):\n        \"\"\"Retrieves the date and time from a FILETIME timestamp.\n\n        Args:\n          filetime (int): FILETIME timestamp.\n\n        Returns:\n          dfdatetime.DateTimeValues: date and time or None if not set.\n        \"\"\"\n        if not filetime:\n            return None\n        return dfdatetime_filetime.Filetime(timestamp=filetime)\n\n    def _GetSanitizedPathString(self, path):\n        \"\"\"Retrieves a sanitize path string.\n\n        Args:\n          path (str): path.\n\n        Returns:\n          str: sanitized path string.\n        \"\"\"\n        if not path:\n            return None\n        return path.translate(self._path_escape_characters)\n\n    @classmethod\n    def GetFormatSpecification(cls):\n        \"\"\"Retrieves the format specification.\n\n        Returns:\n          FormatSpecification: format specification.\n        \"\"\"\n        format_specification = specification.FormatSpecification(cls.NAME)\n        format_specification.AddNewSignature(b'\\x01\\x14\\x02\\x00\\x00\\x00\\x00\\x00\\xc0\\x00\\x00\\x00\\x00\\x00\\x00F', offset=4)\n        return format_specification\n\n    def _ParseDistributedTrackingIdentifier(self, parser_mediator, uuid_string, origin):\n        \"\"\"Extracts data from a Distributed Tracking identifier.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          uuid_string (str): UUID string of the Distributed Tracking identifier.\n          origin (str): origin of the event (event source).\n        \"\"\"\n        uuid_object = uuid.UUID(uuid_string)\n        if uuid_object.version == 1:\n            event_data = windows_events.WindowsDistributedLinkTrackingEventData(uuid_object, origin)\n            parser_mediator.ProduceEventData(event_data)\n\n    def ParseFileObject(self, parser_mediator, file_object):\n        \"\"\"Parses a Windows Shortcut (LNK) file-like object.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): file-like object.\n        \"\"\"\n        display_name = parser_mediator.GetDisplayName()\n        self.ParseFileLNKFile(parser_mediator, file_object, display_name)\n\n    def ParseFileLNKFile(self, parser_mediator, file_object, display_name):\n        \"\"\"Parses a Windows Shortcut (LNK) file-like object.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): file-like object.\n          display_name (str): display name.\n        \"\"\"\n        code_page = parser_mediator.GetCodePage()\n        lnk_file = pylnk.file()\n        lnk_file.set_ascii_codepage(code_page)\n        try:\n            lnk_file.open_file_object(file_object)\n        except IOError as exception:\n            parser_mediator.ProduceExtractionWarning('unable to open file with error: {0!s}'.format(exception))\n            return\n        link_target = None\n        if lnk_file.link_target_identifier_data:\n            display_name = parser_mediator.GetFilename()\n            shell_items_parser = shell_items.ShellItemsParser(display_name)\n            shell_items_parser.ParseByteStream(parser_mediator, lnk_file.link_target_identifier_data, codepage=code_page)\n            link_target = shell_items_parser.CopyToPath()\n        access_time = lnk_file.get_file_access_time_as_integer()\n        creation_time = lnk_file.get_file_creation_time_as_integer()\n        modification_time = lnk_file.get_file_modification_time_as_integer()\n        event_data = WinLnkLinkEventData()\n        event_data.access_time = self._GetDateTime(access_time)\n        event_data.birth_droid_file_identifier = lnk_file.birth_droid_file_identifier\n        event_data.birth_droid_volume_identifier = lnk_file.birth_droid_volume_identifier\n        event_data.command_line_arguments = self._GetSanitizedPathString(lnk_file.command_line_arguments)\n        event_data.creation_time = self._GetDateTime(creation_time)\n        event_data.description = self._GetSanitizedPathString(lnk_file.description)\n        event_data.drive_serial_number = lnk_file.drive_serial_number\n        event_data.drive_type = lnk_file.drive_type\n        event_data.droid_file_identifier = lnk_file.droid_file_identifier\n        event_data.droid_volume_identifier = lnk_file.droid_volume_identifier\n        event_data.env_var_location = self._GetSanitizedPathString(lnk_file.environment_variables_location)\n        event_data.file_attribute_flags = lnk_file.file_attribute_flags\n        event_data.file_size = lnk_file.file_size\n        event_data.icon_location = self._GetSanitizedPathString(lnk_file.icon_location)\n        event_data.link_target = link_target\n        event_data.local_path = self._GetSanitizedPathString(lnk_file.local_path)\n        event_data.modification_time = self._GetDateTime(modification_time)\n        event_data.network_path = self._GetSanitizedPathString(lnk_file.network_path)\n        event_data.relative_path = self._GetSanitizedPathString(lnk_file.relative_path)\n        event_data.volume_label = lnk_file.volume_label\n        event_data.working_directory = self._GetSanitizedPathString(lnk_file.working_directory)\n        parser_mediator.ProduceEventData(event_data)\n        if lnk_file.droid_file_identifier:\n            try:\n                self._ParseDistributedTrackingIdentifier(parser_mediator, lnk_file.droid_file_identifier, display_name)\n            except (TypeError, ValueError) as exception:\n                parser_mediator.ProduceExtractionWarning('unable to read droid file identifier with error: {0!s}.'.format(exception))\n        if lnk_file.birth_droid_file_identifier and lnk_file.birth_droid_file_identifier != lnk_file.droid_file_identifier:\n            try:\n                self._ParseDistributedTrackingIdentifier(parser_mediator, lnk_file.birth_droid_file_identifier, display_name)\n            except (TypeError, ValueError) as exception:\n                parser_mediator.ProduceExtractionWarning('unable to read birth droid file identifier with error: {0!s}.'.format(exception))\n        lnk_file.close()\n\nExample skeleton:\n\nclass AnalyzersManager(object):\n    '''Class that implements the analyzers manager.'''\n    @classmethod\n    def DeregisterAnalyzer(cls, analyzer_class):\n        '''Deregisters a analyzer class.\n        The analyzer classes are identified based on their lower case name.\n        Args:\n          analyzer_class (type): class object of the analyzer.\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzersInformation(cls):\n        '''Retrieves the analyzers information.\n        Returns:\n          list[tuple]: containing:\n            str: analyzer name.\n            str: analyzer description.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzerInstance(cls, analyzer_name):\n        '''Retrieves an instance of a specific analyzer.\n        Args:\n          analyzer_name (str): name of the analyzer to retrieve.\n        Returns:\n          BaseAnalyzer: analyzer instance.\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzerInstances(cls, analyzer_names):\n        '''Retrieves instances for all the specified analyzers.\n        Args:\n          analyzer_names (list[str]): names of the analyzers to retrieve.\n        Returns:\n          list[BaseAnalyzer]: analyzer instances.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzerNames(cls):\n        '''Retrieves the names of all loaded analyzers.\n        Returns:\n          list[str]: of analyzer names.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzersInformation(cls):\n        '''Retrieves the registered analyzers.\n        Yields:\n          tuple: containing:\n            str: the uniquely identifying name of the analyzer\n            type: the analyzer class.\n        '''\n        pass\n    @classmethod\n    def RegisterAnalyzer(cls, analyzer_class):\n        '''Registers a analyzer class.\n        The analyzer classes are identified by their lower case name.\n        Args:\n          analyzer_class (type): the analyzer class to register.\n        Raises:\n          KeyError: if analyzer class is already set for the corresponding name.\n        '''\n        pass\nCorresponding class implementation:\n\nclass AnalyzersManager(object):\n    \"\"\"Class that implements the analyzers manager.\"\"\"\n    _analyzer_classes = {}\n\n    @classmethod\n    def DeregisterAnalyzer(cls, analyzer_class):\n        \"\"\"Deregisters a analyzer class.\n\n        The analyzer classes are identified based on their lower case name.\n\n        Args:\n          analyzer_class (type): class object of the analyzer.\n\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        \"\"\"\n        analyzer_name = analyzer_class.NAME.lower()\n        if analyzer_name not in cls._analyzer_classes:\n            raise KeyError(f'analyzer class not set for name: {analyzer_class.NAME:s}')\n        del cls._analyzer_classes[analyzer_name]\n\n    @classmethod\n    def GetAnalyzersInformation(cls):\n        \"\"\"Retrieves the analyzers information.\n\n        Returns:\n          list[tuple]: containing:\n\n            str: analyzer name.\n            str: analyzer description.\n        \"\"\"\n        analyzer_information = []\n        for _, analyzer_class in cls.GetAnalyzers():\n            description = getattr(analyzer_class, 'DESCRIPTION', '')\n            analyzer_information.append((analyzer_class.NAME, description))\n        return analyzer_information\n\n    @classmethod\n    def GetAnalyzerInstance(cls, analyzer_name):\n        \"\"\"Retrieves an instance of a specific analyzer.\n\n        Args:\n          analyzer_name (str): name of the analyzer to retrieve.\n\n        Returns:\n          BaseAnalyzer: analyzer instance.\n\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        \"\"\"\n        analyzer_name = analyzer_name.lower()\n        if analyzer_name not in cls._analyzer_classes:\n            raise KeyError(f'analyzer class not set for name: {analyzer_name:s}.')\n        analyzer_class = cls._analyzer_classes[analyzer_name]\n        return analyzer_class()\n\n    @classmethod\n    def GetAnalyzerInstances(cls, analyzer_names):\n        \"\"\"Retrieves instances for all the specified analyzers.\n\n        Args:\n          analyzer_names (list[str]): names of the analyzers to retrieve.\n\n        Returns:\n          list[BaseAnalyzer]: analyzer instances.\n        \"\"\"\n        analyzer_instances = []\n        for analyzer_name, analyzer_class in cls.GetAnalyzers():\n            if analyzer_name in analyzer_names:\n                analyzer_instances.append(analyzer_class())\n        return analyzer_instances\n\n    @classmethod\n    def GetAnalyzerNames(cls):\n        \"\"\"Retrieves the names of all loaded analyzers.\n\n        Returns:\n          list[str]: of analyzer names.\n        \"\"\"\n        return cls._analyzer_classes.keys()\n\n    @classmethod\n    def GetAnalyzers(cls):\n        \"\"\"Retrieves the registered analyzers.\n\n        Yields:\n          tuple: containing:\n\n            str: the uniquely identifying name of the analyzer\n            type: the analyzer class.\n        \"\"\"\n        for analyzer_name, analyzer_class in cls._analyzer_classes.items():\n            yield (analyzer_name, analyzer_class)\n\n    @classmethod\n    def RegisterAnalyzer(cls, analyzer_class):\n        \"\"\"Registers a analyzer class.\n\n        The analyzer classes are identified by their lower case name.\n\n        Args:\n          analyzer_class (type): the analyzer class to register.\n\n        Raises:\n          KeyError: if analyzer class is already set for the corresponding name.\n        \"\"\"\n        analyzer_name = analyzer_class.NAME.lower()\n        if analyzer_name in cls._analyzer_classes:\n            raise KeyError(f'analyzer class already set for name: {analyzer_class.NAME:s}.')\n        cls._analyzer_classes[analyzer_name] = analyzer_class\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass KafkaProducerPort:\n    '''Interface for Kafka producer operations.\n    This interface defines the contract for producing messages to Kafka topics.\n        '''\n    @abstractmethod\n    def produce(self, message: str | bytes) -> None:\n        '''Produces a message to the configured topic.\n        Args:\n            message (str | bytes): The message to produce.\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        '''\n        pass\n    @abstractmethod\n    def flush(self, timeout: int | None) -> None:\n        '''Flushes any pending messages to the broker.\n        Args:\n            timeout (int | None): Maximum time to wait for messages to be delivered.\n                If None, wait indefinitely.\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        '''\n        pass\n    @abstractmethod\n    def validate_healthiness(self) -> None:\n        '''Validates the health of the producer connection.\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        '''\n        pass\n    @abstractmethod\n    def list_topics(self, topic: str | None, timeout: int) -> ClusterMetadata:\n        '''Lists Kafka topics.\n        Args:\n            topic (str | None): Specific topic to list. If None, lists all topics.\n            timeout (int): Timeout in seconds for the operation.\n        Returns:\n            ClusterMetadata: Metadata about the Kafka cluster and topics.\n        Raises:\n            NotImplementedError: If the method is not implemented by the concrete class.\n        '''\n        pass"
  }
]