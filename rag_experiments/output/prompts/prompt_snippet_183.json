[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass CommandLineParser:\n\n    def __init__(self, sslyze_version: str) -> None:\n        '''Generate SSLyze's command line parser.'''\n        pass\n\n    def parse_command_line(self) -> ParsedCommandLine:\n        '''Parses the command line used to launch SSLyze.'''\n        pass\n\n    def _add_default_options(self) -> None:\n        '''Add default command line options to the parser.'''\n        pass\n    @staticmethod\n    def _get_plugin_scan_commands() -> List[OptParseCliOption]:\n        '''Retrieve the list of command line options implemented by the plugins currently available.'''\n        pass\nCorresponding class implementation:\n\nimport pydantic\nfrom typing import Set, List, Optional, Dict\nfrom argparse import ArgumentParser\nfrom sslyze.cli.server_string_parser import InvalidServerStringError, CommandLineServerStringParser\nfrom typing import Tuple\nfrom sslyze.plugins.certificate_info.trust_stores.trust_store_repository import TrustStoresRepository\nfrom sslyze.plugins.plugin_base import OptParseCliOption\nfrom sslyze.server_setting import HttpProxySettings, ServerNetworkLocation, ServerNetworkConfiguration, InvalidServerNetworkConfigurationError, ServerHostnameCouldNotBeResolved, ClientAuthenticationCredentials\nfrom sslyze.connection_helpers.opportunistic_tls_helpers import ProtocolWithOpportunisticTlsEnum\nfrom sslyze.mozilla_tls_profile.tls_config_checker import TlsConfigurationAsJson, MozillaTlsConfiguration, TlsConfigurationEnum, SCAN_COMMANDS_NEEDED_BY_MOZILLA_CHECKER\nfrom sslyze.plugins import plugin_base\nfrom nassl.ssl_client import OpenSslFileTypeEnum\nfrom sslyze.plugins.scan_commands import ScanCommand, ScanCommandsRepository\nfrom pathlib import Path\nfrom sslyze.scanner.models import ScanCommandsExtraArguments\n\nclass CommandLineParser:\n\n    def __init__(self, sslyze_version: str) -> None:\n        \"\"\"Generate SSLyze's command line parser.\"\"\"\n        self._parser = ArgumentParser(prog='sslyze', description=f'SSLyze version {sslyze_version}')\n        self._add_default_options()\n        scan_commands_group = self._parser.add_argument_group('Scan commands')\n        for scan_option in self._get_plugin_scan_commands():\n            scan_commands_group.add_argument(f'--{scan_option.option}', help=scan_option.help, action=scan_option.action)\n        self._parser.add_argument('--custom_tls_config', help=\"Path to a JSON file containing a specific TLS configuration to check the server against, following Mozilla's format. Cannot be used with --mozilla_config.\", dest='custom_tls_config', type=str, default=None)\n        self._parser.add_argument('--mozilla_config', action='store', dest='mozilla_config', choices=['modern', 'intermediate', 'old', 'disable'], help='Shortcut to queue various scan commands needed to check the server\\'s TLS configurations against one of Mozilla\\'s recommended TLS configurations. Set to \"intermediate\" by default. Use \"disable\" to disable this check.')\n        self._parser.add_argument(dest='target', default=[], nargs='*', help='The list of servers to scan.')\n\n    def parse_command_line(self) -> ParsedCommandLine:\n        \"\"\"Parses the command line used to launch SSLyze.\"\"\"\n        args_command_list = self._parser.parse_args()\n        args_target_list = []\n        if args_command_list.update_trust_stores:\n            TrustStoresRepository.update_default()\n            raise TrustStoresUpdateCompleted()\n        if args_command_list.targets_in:\n            try:\n                with open(args_command_list.targets_in) as f:\n                    for target in f.readlines():\n                        if target.strip():\n                            if not target.startswith('#'):\n                                args_target_list.append(target.strip())\n            except IOError:\n                raise CommandLineParsingError(f\"Can't read targets from input file '{args_command_list.targets_in}'\")\n        for target in args_command_list.target:\n            args_target_list.append(target)\n        if not args_target_list:\n            raise CommandLineParsingError('No targets to scan.')\n        if args_command_list.custom_tls_config and args_command_list.mozilla_config:\n            raise CommandLineParsingError('Cannot use --custom_tls_config and --mozilla_config. Please specify one of the two.')\n        tls_config_to_check_against_as_enum: Optional[TlsConfigurationEnum] = None\n        tls_config_to_check_against: Optional[TlsConfigurationAsJson] = None\n        if args_command_list.custom_tls_config:\n            tls_config_to_check_against_as_enum = TlsConfigurationEnum.CUSTOM\n            json_tls_config_path = Path(args_command_list.custom_tls_config).absolute()\n            if not json_tls_config_path.exists():\n                raise CommandLineParsingError(f\"Custom TLS profile file '{json_tls_config_path}' does not exist\")\n            try:\n                tls_config_to_check_against = TlsConfigurationAsJson.model_validate_json(json_tls_config_path.read_text())\n            except pydantic.ValidationError:\n                raise CommandLineParsingError(f\"Could not parse custom TLS configuration file '{json_tls_config_path}'\")\n        elif args_command_list.mozilla_config:\n            mozilla_config_map = {'modern': TlsConfigurationEnum.MOZILLA_MODERN, 'intermediate': TlsConfigurationEnum.MOZILLA_INTERMEDIATE, 'old': TlsConfigurationEnum.MOZILLA_OLD, 'disable': None}\n            try:\n                tls_config_to_check_against_as_enum = mozilla_config_map[args_command_list.mozilla_config]\n            except KeyError:\n                raise CommandLineParsingError(f'Unknown value for --mozilla_config: {args_command_list.mozilla_config}')\n            if tls_config_to_check_against_as_enum is not None:\n                tls_config_to_check_against = MozillaTlsConfiguration.get(tls_config_to_check_against_as_enum)\n        else:\n            did_user_enable_some_scan_commands = False\n            for scan_command in ScanCommandsRepository.get_all_scan_commands():\n                cli_connector_cls = ScanCommandsRepository.get_implementation_cls(scan_command).cli_connector_cls\n                is_scan_cmd_enabled, _ = cli_connector_cls.find_cli_options_in_command_line(args_command_list.__dict__)\n                if is_scan_cmd_enabled:\n                    did_user_enable_some_scan_commands = True\n                    break\n            if not did_user_enable_some_scan_commands:\n                tls_config_to_check_against_as_enum = TlsConfigurationEnum.MOZILLA_INTERMEDIATE\n                tls_config_to_check_against = MozillaTlsConfiguration.get(tls_config_to_check_against_as_enum)\n        if tls_config_to_check_against_as_enum:\n            for scan_cmd in SCAN_COMMANDS_NEEDED_BY_MOZILLA_CHECKER:\n                cli_connector_cls = ScanCommandsRepository.get_implementation_cls(scan_cmd).cli_connector_cls\n                setattr(args_command_list, cli_connector_cls._cli_option, True)\n        should_print_json_to_console = False\n        json_path_out: Optional[Path] = None\n        if args_command_list.json_file:\n            if args_command_list.json_file == '-':\n                if args_command_list.quiet:\n                    raise CommandLineParsingError('Cannot use --quiet with --json_out -.')\n                should_print_json_to_console = True\n            else:\n                json_path_out = Path(args_command_list.json_file).absolute()\n        client_auth_creds = None\n        if bool(args_command_list.cert) ^ bool(args_command_list.key):\n            raise CommandLineParsingError('No private key or certificate file were given. See --cert and --key.')\n        elif args_command_list.cert:\n            if args_command_list.keyform == 'DER':\n                key_type = OpenSslFileTypeEnum.ASN1\n            elif args_command_list.keyform == 'PEM':\n                key_type = OpenSslFileTypeEnum.PEM\n            try:\n                client_auth_creds = ClientAuthenticationCredentials(certificate_chain_path=Path(args_command_list.cert), key_path=Path(args_command_list.key), key_password=args_command_list.keypass, key_type=key_type)\n            except ValueError as e:\n                raise CommandLineParsingError('Invalid client authentication settings: {}.'.format(e.args[0]))\n        http_proxy_settings = None\n        if args_command_list.https_tunnel:\n            try:\n                http_proxy_settings = HttpProxySettings.from_url(args_command_list.https_tunnel)\n            except ValueError as e:\n                raise CommandLineParsingError('Invalid proxy URL for --https_tunnel: {}.'.format(e.args[0]))\n        good_servers: List[Tuple[ServerNetworkLocation, ServerNetworkConfiguration]] = []\n        invalid_server_strings: List[InvalidServerStringError] = []\n        for server_string in args_target_list:\n            try:\n                hostname, ip_address, port = CommandLineServerStringParser.parse_server_string(server_string)\n            except InvalidServerStringError as e:\n                invalid_server_strings.append(e)\n                continue\n            final_port = port if port else 443\n            server_location: ServerNetworkLocation\n            if http_proxy_settings:\n                server_location = ServerNetworkLocation(hostname=hostname, port=final_port, http_proxy_settings=http_proxy_settings)\n            elif ip_address:\n                server_location = ServerNetworkLocation(hostname=hostname, port=final_port, ip_address=ip_address)\n            else:\n                try:\n                    server_location = ServerNetworkLocation(hostname=hostname, port=final_port)\n                except ServerHostnameCouldNotBeResolved:\n                    invalid_server_strings.append(InvalidServerStringError(server_string=f'{hostname}:{final_port}', error_message=f'Could not resolve hostname {hostname}'))\n                    continue\n            opportunistic_tls: Optional[ProtocolWithOpportunisticTlsEnum] = None\n            if args_command_list.starttls:\n                if args_command_list.starttls == 'auto':\n                    opportunistic_tls = ProtocolWithOpportunisticTlsEnum.from_default_port(final_port)\n                elif args_command_list.starttls in _STARTTLS_PROTOCOL_DICT:\n                    opportunistic_tls = _STARTTLS_PROTOCOL_DICT[args_command_list.starttls]\n                else:\n                    raise CommandLineParsingError(f\"StartTLS should be one of: auto, {', '.join(_STARTTLS_PROTOCOL_DICT.keys())}.\")\n            try:\n                sni_hostname = args_command_list.sni if args_command_list.sni else hostname\n                network_config = ServerNetworkConfiguration(tls_opportunistic_encryption=opportunistic_tls, tls_server_name_indication=sni_hostname, tls_client_auth_credentials=client_auth_creds, xmpp_to_hostname=args_command_list.xmpp_to)\n                good_servers.append((server_location, network_config))\n            except InvalidServerNetworkConfigurationError as e:\n                raise CommandLineParsingError(e.args[0])\n        concurrent_server_scans_limit = None\n        per_server_concurrent_connections_limit = None\n        if args_command_list.https_tunnel:\n            concurrent_server_scans_limit = 1\n        if args_command_list.slow_connection:\n            per_server_concurrent_connections_limit = 2\n        scan_commands: Set[ScanCommand] = set()\n        scan_commands_extra_arguments_dict: Dict[ScanCommand, plugin_base.ScanCommandExtraArgument] = {}\n        for scan_command in ScanCommandsRepository.get_all_scan_commands():\n            cli_connector_cls = ScanCommandsRepository.get_implementation_cls(scan_command).cli_connector_cls\n            is_scan_cmd_enabled, extra_args = cli_connector_cls.find_cli_options_in_command_line(args_command_list.__dict__)\n            if is_scan_cmd_enabled:\n                scan_commands.add(scan_command)\n                if extra_args:\n                    scan_commands_extra_arguments_dict[scan_command] = extra_args\n        scan_commands_extra_arguments = ScanCommandsExtraArguments(**scan_commands_extra_arguments_dict)\n        return ParsedCommandLine(invalid_servers=invalid_server_strings, servers_to_scans=good_servers, scan_commands=scan_commands, scan_commands_extra_arguments=scan_commands_extra_arguments, should_print_json_to_console=should_print_json_to_console, json_path_out=json_path_out, should_disable_console_output=args_command_list.quiet or args_command_list.json_file == '-', concurrent_server_scans_limit=concurrent_server_scans_limit, per_server_concurrent_connections_limit=per_server_concurrent_connections_limit, tls_config_to_check_against_as_enum=tls_config_to_check_against_as_enum, tls_config_to_check_against=tls_config_to_check_against)\n\n    def _add_default_options(self) -> None:\n        \"\"\"Add default command line options to the parser.\"\"\"\n        trust_stores_group = self._parser.add_argument_group('Trust stores options')\n        trust_stores_group.add_argument('--update_trust_stores', help='Update the default trust stores used by SSLyze. The latest stores will be downloaded from https://github.com/nabla-c0d3/trust_stores_observatory. This option is meant to be used separately, and will silence any other command line option supplied to SSLyze.', dest='update_trust_stores', action='store_true')\n        client_certificate_group = self._parser.add_argument_group('Client certificate options')\n        client_certificate_group.add_argument('--cert', metavar='CERTIFICATE_FILE', help=\"Client certificate chain filename. The certificates must be in PEM format and must be sorted starting with the subject's client certificate, followed by intermediate CA certificates if applicable.\", dest='cert')\n        client_certificate_group.add_argument('--key', metavar='KEY_FILE', help='Client private key filename.', dest='key')\n        client_certificate_group.add_argument('--keyform', metavar='KEY_FORMAT', choices=['DER', 'PEM'], help='Client private key format. DER or PEM (default).', dest='keyform', default='PEM')\n        client_certificate_group.add_argument('--pass', metavar='PASSPHRASE', help='Client private key passphrase.', dest='keypass', default='')\n        input_and_output_group = self._parser.add_argument_group('Input and output options')\n        input_and_output_group.add_argument('--json_out', metavar='JSON_FILE', help=\"Write the scan results as a JSON document to the file JSON_FILE. If JSON_FILE is set to '-', the JSON output will instead be printed to stdout. The resulting JSON file is a serialized version of the ScanResult objects described in SSLyze's Python API: the nodes and attributes will be the same. See https://nabla-c0d3.github.io/sslyze/documentation/available-scan-commands.html for more details.\", dest='json_file', default=None)\n        input_and_output_group.add_argument('--targets_in', metavar='TARGET_FILE', help='Read the list of targets to scan from the file TARGET_FILE. It should contain one host:port per line.', dest='targets_in', default=None)\n        input_and_output_group.add_argument('--quiet', action='store_true', dest='quiet', help='Do not output anything to stdout; useful when using --json_out.')\n        connectivity_group = self._parser.add_argument_group('Connectivity options')\n        connectivity_group.add_argument('--slow_connection', help='Greatly reduce the number of concurrent connections initiated by SSLyze. This will make the scans slower but more reliable if the connection between your host and the server is slow, or if the server cannot handle many concurrent connections. Enable this option if you are getting a lot of timeouts or errors.', action='store_true', dest='slow_connection')\n        connectivity_group.add_argument('--https_tunnel', metavar='PROXY_SETTINGS', help=\"Tunnel all traffic to the target server(s) through an HTTP CONNECT proxy. HTTP_TUNNEL should be the proxy's URL: 'http://USER:PW@HOST:PORT/'. For proxies requiring authentication, only Basic Authentication is supported.\", dest='https_tunnel', default=None)\n        connectivity_group.add_argument('--starttls', metavar='PROTOCOL', help=f\"Perform a StartTLS handshake when connecting to the target server(s). StartTLS should be one of: auto, {', '.join(_STARTTLS_PROTOCOL_DICT.keys())}. The 'auto' option will cause SSLyze to deduce the protocol (ftp, imap, etc.) from the supplied port number, for each target server.\", dest='starttls', default=None)\n        connectivity_group.add_argument('--xmpp_to', metavar='HOSTNAME', help=\"Optional setting for STARTTLS XMPP. XMPP_TO should be the hostname to be put in the 'to' attribute of the XMPP stream. Default is the server's hostname.\", dest='xmpp_to', default=None)\n        connectivity_group.add_argument('--sni', metavar='SERVER_NAME_INDICATION', help='Use Server Name Indication to specify the hostname to connect to. Will only affect TLS 1.0+ connections.', dest='sni', default=None)\n\n    @staticmethod\n    def _get_plugin_scan_commands() -> List[OptParseCliOption]:\n        \"\"\"Retrieve the list of command line options implemented by the plugins currently available.\"\"\"\n        scan_commands_options = []\n        for scan_command in ScanCommandsRepository.get_all_scan_commands():\n            cli_connector_cls = ScanCommandsRepository.get_implementation_cls(scan_command).cli_connector_cls\n            scan_commands_options.extend(cli_connector_cls.get_cli_options())\n        return scan_commands_options\n\nExample skeleton:\n\n\nclass ProjectContext(threading.local):\n    '''A configuration class to hold global configuration.'''\n\n    def __init__(self) -> None:\n        pass\n\n    def __del__(self):\n        pass\n    @property\n    def database(self) -> 'Database':\n        '''Current database.'''\n        pass\n    @property\n    def database_path(self) -> Path:\n        '''Path to the metadata storage directory.'''\n        pass\n    @property\n    def datadir(self) -> str:\n        '''Define a name of the folder for storing datasets.'''\n        pass\n    @datadir.setter\n    def datadir(self) -> str:\n        '''Set the current datadir.'''\n        pass\n    @property\n    def dataset_images_path(self) -> Path:\n        '''Return a ``Path`` instance of Renku dataset metadata folder.'''\n        pass\n    @property\n    def project_image_pathname(self) -> Path:\n        '''Return the path to the project's image file.'''\n        pass\n    @property\n    def dockerfile_path(self) -> Path:\n        '''Path to the Dockerfile.'''\n        pass\n    @property\n    def ssh_authorized_keys_path(self) -> Path:\n        '''Path to SSH authorized keys.'''\n        pass\n    @property\n    def global_config_dir(self) -> str:\n        '''Return user's config directory.'''\n        pass\n    @property\n    def global_config_path(self) -> Path:\n        '''Renku global (user's) config path.'''\n        pass\n    @property\n    def latest_agent(self) -> Optional[str]:\n        '''Returns latest agent version used in the repository.'''\n        pass\n    @property\n    def local_config_path(self) -> Path:\n        '''Renku local (project) config path.'''\n        pass\n    @property\n    def lock(self):\n        '''Create a Renku config lock.'''\n        pass\n    @property\n    def metadata_path(self) -> Path:\n        '''Current project's metadata (RENKU_HOME) path.'''\n        pass\n    @property\n    def path(self) -> Path:\n        '''Current project path.'''\n        pass\n    @property\n    def pointers_path(self) -> Path:\n        '''Return a ``Path`` instance of Renku pointer files folder.'''\n        pass\n    @property\n    def project_image_pathname(self) -> Path:\n        '''Return the Project instance.'''\n        pass\n    @property\n    def remote(self) -> 'ProjectRemote':\n        '''Return host, owner and name of the remote if it exists.'''\n        pass\n    @property\n    def repository(self) -> 'Repository':\n        '''Return current context's repository.'''\n        pass\n    @repository.setter\n    def repository(self) -> 'Repository':\n        '''Set the current repository.'''\n        pass\n    @property\n    def template_checksums_path(self):\n        '''Return a ``Path`` instance to the template checksums file.'''\n        pass\n    @property\n    def transaction_id(self) -> str:\n        '''Get a transaction id for the current context to be used for grouping git commits.'''\n        pass\n    @property\n    def _top(self) -> 'ProjectProperties':\n        '''Return current context.'''\n        pass\n\n    def has_context(self, path: Optional[Union[Path, str]]=None) -> bool:\n        '''Return if at least one context which is equal to path (if not None) is pushed.'''\n        pass\n\n    def clear(self) -> None:\n        '''Remove all contexts and reset the state without committing intermediate changes.\n        NOTE: This method should be used only in tests.\n        '''\n        pass\n\n    def pop_context(self) -> 'ProjectProperties':\n        '''Pop current project context from stack.\n        Returns:\n            Path: the popped project path.\n        '''\n        pass\n\n    def push_path(self, path: Union[Path, str], save_changes: bool=False) -> None:\n        '''Push a new project path to the stack.\n        Arguments:\n            path(Union[Path, str]): The path to push.\n            save_changes(bool): Whether to save changes to the database or not.\n        '''\n        pass\n\n    def replace_path(self, path: Union[Path, str]):\n        '''Replace the current project path with a new one if they are different.\n        Arguments:\n            path(Union[Path, str]): The path to replace with.\n        '''\n        pass\n    @contextlib.contextmanager\n    def with_path(self, path: Union[Path, str], save_changes: bool=False) -> Generator['ProjectProperties', None, None]:\n        '''Temporarily push a new project path to the stack.\n        Arguments:\n            path(Union[Path, str]): The path to push.\n            save_changes(bool): Whether to save changes to the database or not.\n        '''\n        pass\n    @contextlib.contextmanager\n    def with_rollback(self) -> Generator[None, None, None]:\n        '''Rollback to the current state.\n        NOTE: This won't work correctly if the current context is popped or swapped.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom typing import TYPE_CHECKING, Generator, List, NamedTuple, Optional, Union\nfrom pathlib import Path\nimport threading\nfrom renku.core.constant import APP_NAME, CONFIG_NAME, DATA_DIR_CONFIG_KEY, DATABASE_PATH, DATASET_IMAGES, DEFAULT_DATA_DIR, DOCKERFILE, IMAGES, LOCK_SUFFIX, POINTERS, RENKU_HOME, TEMPLATE_CHECKSUMS\nfrom renku.core import errors\nimport uuid\nimport contextlib\n\nclass ProjectContext(threading.local):\n    \"\"\"A configuration class to hold global configuration.\"\"\"\n    external_storage_requested = True\n    'External storage (e.g. LFS) requested for Renku command.'\n\n    def __init__(self) -> None:\n        self._context_stack: List[ProjectProperties] = []\n\n    def __del__(self):\n        self.clear()\n\n    @property\n    def database(self) -> 'Database':\n        \"\"\"Current database.\"\"\"\n        if not self._top.database:\n            from renku.infrastructure.database import Database\n            self._top.database = Database.from_path(self.database_path)\n        return self._top.database\n\n    @property\n    def database_path(self) -> Path:\n        \"\"\"Path to the metadata storage directory.\"\"\"\n        return self.metadata_path / DATABASE_PATH\n\n    @property\n    def datadir(self) -> str:\n        \"\"\"Define a name of the folder for storing datasets.\"\"\"\n        from renku.core.config import get_value\n        from renku.domain_model.enums import ConfigFilter\n        if not self._top.datadir:\n            datadir = get_value('renku', DATA_DIR_CONFIG_KEY, config_filter=ConfigFilter.LOCAL_ONLY)\n            self._top.datadir = datadir or DEFAULT_DATA_DIR\n        return self._top.datadir\n\n    @datadir.setter\n    def datadir(self, value: str):\n        \"\"\"Set the current datadir.\"\"\"\n        self._top.datadir = value\n\n    @property\n    def dataset_images_path(self) -> Path:\n        \"\"\"Return a ``Path`` instance of Renku dataset metadata folder.\"\"\"\n        return self.path / RENKU_HOME / DATASET_IMAGES\n\n    @property\n    def project_image_pathname(self) -> Path:\n        \"\"\"Return the path to the project's image file.\"\"\"\n        return self.path / RENKU_HOME / IMAGES / 'project' / '0.png'\n\n    @property\n    def dockerfile_path(self) -> Path:\n        \"\"\"Path to the Dockerfile.\"\"\"\n        return self.path / DOCKERFILE\n\n    @property\n    def ssh_authorized_keys_path(self) -> Path:\n        \"\"\"Path to SSH authorized keys.\"\"\"\n        return self.path / '.ssh' / 'authorized_keys'\n\n    @property\n    def global_config_dir(self) -> str:\n        \"\"\"Return user's config directory.\"\"\"\n        import click\n        return click.get_app_dir(APP_NAME, force_posix=True)\n\n    @property\n    def global_config_path(self) -> Path:\n        \"\"\"Renku global (user's) config path.\"\"\"\n        config = Path(self.global_config_dir)\n        if not config.exists():\n            config.mkdir(parents=True)\n        return config / CONFIG_NAME\n\n    @property\n    def latest_agent(self) -> Optional[str]:\n        \"\"\"Returns latest agent version used in the repository.\"\"\"\n        try:\n            return self.project.agent_version\n        except ValueError as e:\n            if 'Project name not set' in str(e):\n                return None\n            raise\n\n    @property\n    def local_config_path(self) -> Path:\n        \"\"\"Renku local (project) config path.\"\"\"\n        return self.metadata_path / CONFIG_NAME\n\n    @property\n    def lock(self):\n        \"\"\"Create a Renku config lock.\"\"\"\n        from renku.core.util.contexts import Lock\n        return Lock(filename=self.metadata_path.with_suffix(LOCK_SUFFIX), mode='exclusive')\n\n    @property\n    def metadata_path(self) -> Path:\n        \"\"\"Current project's metadata (RENKU_HOME) path.\"\"\"\n        return self.path / RENKU_HOME\n\n    @property\n    def path(self) -> Path:\n        \"\"\"Current project path.\"\"\"\n        return self._top.path\n\n    @property\n    def pointers_path(self) -> Path:\n        \"\"\"Return a ``Path`` instance of Renku pointer files folder.\"\"\"\n        path = self.path / RENKU_HOME / POINTERS\n        path.mkdir(exist_ok=True)\n        return path\n\n    @property\n    def project(self) -> 'Project':\n        \"\"\"Return the Project instance.\"\"\"\n        from renku.command.command_builder.command import inject\n        from renku.core.interface.project_gateway import IProjectGateway\n        project_gateway = inject.instance(IProjectGateway)\n        return project_gateway.get_project()\n\n    @property\n    def remote(self) -> 'ProjectRemote':\n        \"\"\"Return host, owner and name of the remote if it exists.\"\"\"\n        from renku.core.util.git import get_remote\n        repository = self.repository\n        remote = get_remote(repository=repository)\n        if not remote and len(repository.remotes) > 1:\n            remote = repository.remotes.get('origin')\n        return ProjectRemote.from_remote(remote=remote)\n\n    @property\n    def repository(self) -> 'Repository':\n        \"\"\"Return current context's repository.\"\"\"\n        if not self._top.repository:\n            from renku.infrastructure.repository import Repository\n            try:\n                self._top.repository = Repository(project_context.path)\n            except errors.GitError as e:\n                raise ValueError from e\n        return self._top.repository\n\n    @repository.setter\n    def repository(self, value: Optional['Repository']):\n        \"\"\"Set the current repository.\"\"\"\n        self._top.repository = value\n\n    @property\n    def template_checksums_path(self):\n        \"\"\"Return a ``Path`` instance to the template checksums file.\"\"\"\n        return self.metadata_path / TEMPLATE_CHECKSUMS\n\n    @property\n    def transaction_id(self) -> str:\n        \"\"\"Get a transaction id for the current context to be used for grouping git commits.\"\"\"\n        if not self._top.transaction_id:\n            self._top.transaction_id = uuid.uuid4().hex\n        return f'\\n\\nrenku-transaction: {self._top.transaction_id}'\n\n    @property\n    def _top(self) -> 'ProjectProperties':\n        \"\"\"Return current context.\"\"\"\n        if self._context_stack:\n            return self._context_stack[-1]\n        raise errors.ProjectContextError('No project context was pushed')\n\n    def has_context(self, path: Optional[Union[Path, str]]=None) -> bool:\n        \"\"\"Return if at least one context which is equal to path (if not None) is pushed.\"\"\"\n        return True if self._context_stack and (path is None or self.path == Path(path).resolve()) else False\n\n    def clear(self) -> None:\n        \"\"\"Remove all contexts and reset the state without committing intermediate changes.\n\n        NOTE: This method should be used only in tests.\n        \"\"\"\n        while self._context_stack:\n            if self._top.repository:\n                self._top.repository.close()\n            self._context_stack.pop()\n        self.external_storage_requested = True\n\n    def pop_context(self) -> 'ProjectProperties':\n        \"\"\"Pop current project context from stack.\n\n        Returns:\n            Path: the popped project path.\n        \"\"\"\n        if self._context_stack:\n            if self._top.save_changes and self._top.database:\n                self._top.database.commit()\n            if self._top.repository:\n                self._top.repository.close()\n            return self._context_stack.pop()\n        else:\n            raise IndexError('No more context to pop.')\n\n    def push_path(self, path: Union[Path, str], save_changes: bool=False) -> None:\n        \"\"\"Push a new project path to the stack.\n\n        Arguments:\n            path(Union[Path, str]): The path to push.\n            save_changes(bool): Whether to save changes to the database or not.\n        \"\"\"\n        path = Path(path).resolve()\n        self._context_stack.append(ProjectProperties(path=path, save_changes=save_changes))\n\n    def replace_path(self, path: Union[Path, str]):\n        \"\"\"Replace the current project path with a new one if they are different.\n\n        Arguments:\n            path(Union[Path, str]): The path to replace with.\n        \"\"\"\n        path = Path(path).resolve()\n        if not self._context_stack:\n            self.push_path(path)\n        elif self._top.path != path:\n            self._context_stack[-1] = ProjectProperties(path=path)\n\n    @contextlib.contextmanager\n    def with_path(self, path: Union[Path, str], save_changes: bool=False) -> Generator['ProjectProperties', None, None]:\n        \"\"\"Temporarily push a new project path to the stack.\n\n        Arguments:\n            path(Union[Path, str]): The path to push.\n            save_changes(bool): Whether to save changes to the database or not.\n        \"\"\"\n        with self.with_rollback():\n            self.push_path(path=path, save_changes=save_changes)\n            yield self._top\n\n    @contextlib.contextmanager\n    def with_rollback(self) -> Generator[None, None, None]:\n        \"\"\"Rollback to the current state.\n\n        NOTE: This won't work correctly if the current context is popped or swapped.\n        \"\"\"\n        before_top = self._top if self._context_stack else None\n        try:\n            yield\n        finally:\n            could_rollback = False\n            while self._context_stack:\n                if self._top == before_top:\n                    could_rollback = True\n                    break\n                self.pop_context()\n            if not could_rollback and before_top is not None:\n                raise errors.ProjectContextError(f'Cannot rollback to {before_top.path}.')\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n@dataclass\nclass InferenceConfig:\n    '''Configuration for inference runs.'''\n\n    def __post_init__(self):\n        '''Validate and adjust configuration after initialization.'''\n        pass\n\n    def to_dict(self) -> Dict[str, Any]:\n        '''Convert the configuration to a dictionary.'''\n        pass\n    @classmethod\n    def from_dict(cls, config_dict: Dict[str, Any]) -> 'InferenceConfig':\n        '''Create a configuration instance from a dictionary.'''\n        pass\n    @classmethod\n    def from_yaml(cls, yaml_path: str) -> 'InferenceConfig':\n        '''Load configuration from a YAML file.'''\n        pass\n\n    def save_yaml(self, yaml_path: str) -> None:\n        '''Save configuration to a YAML file.'''\n        pass"
  }
]