[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass OutputSTACMixin:\n    '''Adds STAC related features.'''\n    @property\n    def stac_path(self) -> MPath:\n        '''Return path to STAC JSON file.'''\n        pass\n    @property\n    def stac_item_id(self) -> str:\n        '''\n        Return STAC item ID according to configuration.\n        Defaults to path basename.\n        '''\n        pass\n    @property\n    def stac_item_metadata(self):\n        '''Custom STAC metadata.'''\n        pass\n    @property\n    def stac_asset_type(self):\n        '''Asset MIME type.'''\n        pass\nCorresponding class implementation:\n\nfrom mapchete.path import MPath\n\nclass OutputSTACMixin:\n    \"\"\"Adds STAC related features.\"\"\"\n    path: MPath\n    output_params: dict\n\n    @property\n    def stac_path(self) -> MPath:\n        \"\"\"Return path to STAC JSON file.\"\"\"\n        return self.path / f'{self.stac_item_id}.json'\n\n    @property\n    def stac_item_id(self) -> str:\n        \"\"\"\n        Return STAC item ID according to configuration.\n\n        Defaults to path basename.\n        \"\"\"\n        return self.output_params.get('stac', {}).get('id') or self.path.stem\n\n    @property\n    def stac_item_metadata(self):\n        \"\"\"Custom STAC metadata.\"\"\"\n        return self.output_params.get('stac', {})\n\n    @property\n    def stac_asset_type(self):\n        \"\"\"Asset MIME type.\"\"\"\n        raise ValueError('no MIME type set for this output')\n\nExample skeleton:\n\n\nclass Converter(ABC):\n    '''XMP <-> DocumentInfo converter.'''\n    @staticmethod\n    @abstractmethod\n    def xmp_from_docinfo(docinfo_val: str | None) -> Any:\n        '''Derive XMP metadata from a DocumentInfo string.'''\n        pass\n    @staticmethod\n    @abstractmethod\n    def docinfo_from_xmp(xmp_val: Any) -> str | None:\n        '''Derive a DocumentInfo value from equivalent XMP metadata.'''\n        pass\nCorresponding class implementation:\n\nfrom abc import ABC, abstractmethod\nfrom typing import TYPE_CHECKING, Any, Callable, NamedTuple\n\nclass Converter(ABC):\n    \"\"\"XMP <-> DocumentInfo converter.\"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def xmp_from_docinfo(docinfo_val: str | None) -> Any:\n        \"\"\"Derive XMP metadata from a DocumentInfo string.\"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def docinfo_from_xmp(xmp_val: Any) -> str | None:\n        \"\"\"Derive a DocumentInfo value from equivalent XMP metadata.\"\"\"\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass OCIUtils:\n    '''Utility functions for OCI Generative AI integration.'''\n    @staticmethod\n    def is_pydantic_class(obj: Any) -> bool:\n        '''Check if an object is a Pydantic BaseModel subclass.'''\n        pass\n    @staticmethod\n    def remove_signature_from_tool_description(name: str, description: str) -> str:\n        '''\n        Remove the tool signature and Args section from a tool description.\n        The signature is typically prefixed to the description and followed\n        by an Args section.\n        '''\n        pass\n    @staticmethod\n    def convert_oci_tool_call_to_langchain(tool_call: Any) -> ToolCall:\n        '''Convert an OCI tool call to a LangChain ToolCall.'''\n        pass"
  }
]