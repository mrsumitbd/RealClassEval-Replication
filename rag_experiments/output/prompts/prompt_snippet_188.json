[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass CustomQueueHandler(QueueHandler):\n\n    def __init__(self, queue: Queue[Any], webhook_base: str, api_token: str) -> None:\n        pass\n\n    def _set_webhook_url(self):\n        pass\n\n    def get_connection(self):\n        '''establish an HTTP[S] connection to the jellyfish webhook service'''\n        pass\n\n    def post_logs_to_jellyfish(self, now: datetime) -> bool:\n        '''post a list of log data to the jellyfish webhook service. we are using the lower-level\n        HTTP[S]Client as opposed to something like the requests library as these clients do not do\n        any logging. generating logs at this point will send us into an infinite loop.'''\n        pass\n\n    def handle(self, record: Union[logging.LogRecord, int]) -> None:\n        pass\n\n    def test_connection_to_jf_endpoint(self) -> bool:\n        '''\n        Test the connection to the Jellyfish endpoint\n        Returns:\n            bool: True if the connection was successful, False otherwise\n        '''\n        pass\nCorresponding class implementation:\n\nfrom queue import Queue\nfrom typing import Any, List, Optional, Union\nimport json\nfrom http.client import HTTPConnection, HTTPSConnection\nfrom urllib.parse import urlparse\nfrom datetime import datetime, timedelta\nimport logging\nfrom logging.handlers import QueueHandler, QueueListener\n\nclass CustomQueueHandler(QueueHandler):\n\n    def __init__(self, queue: Queue[Any], webhook_base: str, api_token: str) -> None:\n        super().__init__(queue)\n        if not webhook_base.startswith('https://') and (not webhook_base.startswith('http://')):\n            raise ValueError('No protocol provided in jellyfish webhook base.')\n        self.webhook_base = webhook_base\n        self.api_token = api_token\n        self.messages_to_send = []\n        self.last_message_send_time = datetime.now()\n        self._sentinel = -1\n        self.initiated_at = datetime.strftime(datetime.now(), '%Y-%m-%d-%H-%M-%S')\n        self.webhook_path = '/agent-logs'\n        self.secure = True\n        self.post_errors = 0\n        self.post_error_threshold = 10\n        self.batches_sent = 0\n        self.req_timeout = 10.0\n        self._set_webhook_url()\n\n    def _set_webhook_url(self):\n        parsed = urlparse(self.webhook_base)\n        self.secure = parsed.scheme == 'https'\n        if parsed.path:\n            self.webhook_path = parsed.path + self.webhook_path\n        self.webhook_base = parsed.scheme + '://' + parsed.netloc\n\n    def get_connection(self):\n        \"\"\"establish an HTTP[S] connection to the jellyfish webhook service\"\"\"\n        conn = HTTPSConnection(self.webhook_base[8:], timeout=self.req_timeout) if self.secure else HTTPConnection(self.webhook_base[7:], timeout=self.req_timeout)\n        return conn\n\n    def post_logs_to_jellyfish(self, now: datetime) -> bool:\n        \"\"\"post a list of log data to the jellyfish webhook service. we are using the lower-level\n        HTTP[S]Client as opposed to something like the requests library as these clients do not do\n        any logging. generating logs at this point will send us into an infinite loop.\"\"\"\n        headers = {'Content-Type': 'application/json', 'X-JF-API-Token': self.api_token}\n        conn = self.get_connection()\n        try:\n            conn.request('POST', self.webhook_path, body=json.dumps({'logs': self.messages_to_send, 'create_stream': self.batches_sent == 0}), headers=headers)\n            resp = conn.getresponse()\n            if resp.status == 200:\n                self.batches_sent += 1\n                self.messages_to_send = []\n                self.last_message_send_time = now\n        except:\n            self.post_errors += 1\n            if self.post_errors < self.post_error_threshold:\n                print('Error: could not post logs to Jellyfish. Queue was not cleared and another attempt will be made.')\n            elif self.post_errors == self.post_error_threshold:\n                print('Max errors when posting logs to Jellyfish. Giving up, but continuing with the agent run.')\n            return\n\n    def handle(self, record: Union[logging.LogRecord, int]) -> None:\n        now = datetime.now()\n        if record != self._sentinel:\n            msg = _standardize_log_msg(self.format(record))\n            self.messages_to_send.append({'message': msg, 'timestamp': int(record.created * 1000), 'initiated_at': self.initiated_at})\n        if self.post_errors >= self.post_error_threshold:\n            self.messages_to_send = []\n        elif record == self._sentinel or len(self.messages_to_send) >= 100 or now - self.last_message_send_time > timedelta(minutes=5):\n            self.post_logs_to_jellyfish(now)\n\n    def test_connection_to_jf_endpoint(self) -> bool:\n        \"\"\"\n        Test the connection to the Jellyfish endpoint\n\n        Returns:\n            bool: True if the connection was successful, False otherwise\n        \"\"\"\n        headers = {'Content-Type': 'application/json', 'X-JF-API-Token': self.api_token}\n        now = datetime.now()\n        test_msg = [{'message': 'Testing connection from agent', 'timestamp': int(now.timestamp()), 'initiated_at': self.initiated_at}]\n        try:\n            conn = self.get_connection()\n            conn.request('POST', self.webhook_path, body=json.dumps({'logs': test_msg, 'create_stream': True}), headers=headers)\n            resp = conn.getresponse()\n            if not 200 <= resp.status < 300:\n                raise Exception(f'Received non-success HTTP status code: {resp.status}')\n        except Exception as e:\n            full_url = f'{self.webhook_base}{self.webhook_path}'\n            print(f'Unsuccessful connection to Jellyfish logging endpoint {full_url}: {e}')\n            return False\n        return True\n\nExample skeleton:\n\n\nclass TestCase(NcpSupportMixin, unittest.TestCase):\n    '''The base class for all thread certification test cases.\n    The `topology` member of sub-class is used to create test topology.\n        '''\n\n    def __init__(self, *args, **kwargs):\n        pass\n\n    def skipTest(self, reason: Any) -> None:\n        pass\n\n    def setUp(self):\n        pass\n\n    def _setUp(self):\n        '''Create simulator, nodes and apply configurations.\n        '''\n        pass\n\n    def _set_up_active_dataset(self, node, params):\n        pass\n\n    def inspect(self):\n        pass\n\n    def tearDown(self):\n        '''Destroy nodes and simulator.\n        '''\n        pass\n\n    def flush_all(self):\n        '''Flush away all captured messages of all nodes.\n        '''\n        pass\n\n    def flush_nodes(self, nodes):\n        '''Flush away all captured messages of specified nodes.\n        Args:\n            nodes (list): nodes whose messages to flush.\n        '''\n        pass\n\n    def _clean_up_tmp(self):\n        '''\n        Clean up node files in tmp directory\n        '''\n        pass\n\n    def _verify_packets(self, test_info_path: str):\n        pass\n    @property\n    def test_name(self):\n        pass\n\n    def collect_ipaddrs(self):\n        pass\n\n    def collect_rloc16s(self):\n        pass\n\n    def collect_rlocs(self):\n        pass\n\n    def collect_omrs(self):\n        pass\n\n    def collect_duas(self):\n        pass\n\n    def collect_leader_aloc(self, node):\n        pass\n\n    def collect_extra_vars(self, **vars):\n        pass\n\n    def _collect_test_info_after_setup(self):\n        '''\n        Collect test info after setUp\n        '''\n        pass\n\n    def _construct_backbone_network_name(self, backbone_network_id) -> str:\n        '''\n        Construct the name of the backbone network based on the given backbone network id from TOPOLOGY. If the\n        backbone_network_id is not defined in TOPOLOGY, use the default backbone network id.\n        '''\n        pass\n\n    def _output_test_info(self):\n        '''\n        Output test info to json file after tearDown\n        '''\n        pass\n\n    def _get_thread_pcap_filename(self):\n        pass\n\n    def assure_run_ok(self, cmd, shell=False):\n        pass\n\n    def _parse_params(self, params: Optional[dict]) -> dict:\n        pass\n\n    def _has_backbone_traffic(self):\n        pass\n\n    def _prepare_backbone_network(self):\n        '''\n        Creates one or more backbone networks (Docker bridge networks) based on the TOPOLOGY definition.\n        * If `backbone_network_id` is defined in the TOPOLOGY:\n            * Network name:   `backbone{PORT_OFFSET}.{backbone_network_id}`      (e.g., \"backbone0.0\", \"backbone0.1\")\n            * Network prefix: `backbone{PORT_OFFSET}:{backbone_network_id}::/64` (e.g., \"9100:0::/64\", \"9100:1::/64\")\n        * If `backbone_network_id` is undefined:\n            * Network name:   `backbone{PORT_OFFSET}.0`    (e.g., \"backbone0.0\")\n            * Network prefix: `backbone{PORT_OFFSET}::/64` (e.g., \"9100::/64\")\n        '''\n        pass\n\n    def _remove_backbone_network(self):\n        pass\n\n    def _start_backbone_sniffer(self):\n        pass\n\n    def _get_backbone_pcap_filename(self):\n        pass\n\n    def _get_merged_pcap_filename(self):\n        pass\n\n    def _stop_backbone_sniffer(self):\n        pass\n\n    def _merge_thread_backbone_pcaps(self):\n        pass\n\n    def wait_until(self, cond: Callable[[], bool], timeout: int, go_interval: int=1):\n        pass\n\n    def wait_node_state(self, node: Union[int, Node], state: str, timeout: int):\n        pass\n\n    def wait_route_established(self, node1: int, node2: int, timeout=10):\n        pass\n\n    def assertDictIncludes(self, actual: Mapping[str, str], expected: Mapping[str, str]):\n        ''' Asserts the `actual` dict includes the `expected` dict.\n        Args:\n            actual: A dict for checking.\n            expected: The expected items that the actual dict should contains.\n        '''\n        pass\nCorresponding class implementation:\n\nimport subprocess\nimport config\nimport os\nimport sys\nimport logging\nfrom pktverify import utils as pvutils\nimport json\nfrom typing import Optional, Callable, Union, Mapping, Any\nimport stat\nimport signal\nimport unittest\nimport debug\nimport traceback\nimport time\nfrom node import Node, OtbrNode, HostNode\n\nclass TestCase(NcpSupportMixin, unittest.TestCase):\n    \"\"\"The base class for all thread certification test cases.\n\n    The `topology` member of sub-class is used to create test topology.\n    \"\"\"\n    USE_MESSAGE_FACTORY = True\n    TOPOLOGY = {}\n    CASE_WIRESHARK_PREFS = None\n    SUPPORT_THREAD_1_1 = True\n    PACKET_VERIFICATION = config.PACKET_VERIFICATION_DEFAULT\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')\n        self._start_time = None\n        self._do_packet_verification = PACKET_VERIFICATION and hasattr(self, 'verify') and (self.PACKET_VERIFICATION == PACKET_VERIFICATION)\n        self._backbone_network_names = []\n\n    def skipTest(self, reason: Any) -> None:\n        self._testSkipped = True\n        super(TestCase, self).skipTest(reason)\n\n    def setUp(self):\n        self._testSkipped = False\n        if ENV_THREAD_VERSION == '1.1' and (not self.SUPPORT_THREAD_1_1):\n            self.skipTest('Thread 1.1 not supported.')\n        try:\n            self._setUp()\n        except:\n            traceback.print_exc()\n            for node in list(self.nodes.values()):\n                try:\n                    node.destroy()\n                except Exception:\n                    traceback.print_exc()\n            raise\n\n    def _setUp(self):\n        \"\"\"Create simulator, nodes and apply configurations.\n        \"\"\"\n        self._clean_up_tmp()\n        key_manager = config.create_default_thread_key_manager()\n        self.simulator = config.create_default_simulator(config.create_default_thread_message_factory(key_manager) if self.USE_MESSAGE_FACTORY else None)\n        self.nodes = {}\n        os.environ['LD_LIBRARY_PATH'] = '/tmp/thread-wireshark'\n        if self._has_backbone_traffic():\n            self._prepare_backbone_network()\n            self._start_backbone_sniffer()\n        self._initial_topology = initial_topology = {}\n        for i, params in self.TOPOLOGY.items():\n            params = self._parse_params(params)\n            initial_topology[i] = params\n            backbone_network_name = self._construct_backbone_network_name(params.get('backbone_network_id')) if self._has_backbone_traffic() else None\n            logging.info('Creating node %d: %r', i, params)\n            logging.info('Backbone network: %s', backbone_network_name)\n            if params['is_otbr']:\n                nodeclass = OtbrNode\n            elif params['is_host']:\n                nodeclass = HostNode\n            else:\n                nodeclass = Node\n            node = nodeclass(i, is_mtd=params['is_mtd'], simulator=self.simulator, name=params.get('name'), version=params['version'], is_bbr=params['is_bbr'], backbone_network=backbone_network_name)\n            if 'boot_delay' in params:\n                self.simulator.go(params['boot_delay'])\n            self.nodes[i] = node\n            if node.is_host:\n                continue\n            self.nodes[i].set_mode(params['mode'])\n            if 'partition_id' in params:\n                self.nodes[i].set_preferred_partition_id(params['partition_id'])\n            if params['is_ftd']:\n                self.nodes[i].set_router_selection_jitter(params['router_selection_jitter'])\n            if 'router_upgrade_threshold' in params:\n                self.nodes[i].set_router_upgrade_threshold(params['router_upgrade_threshold'])\n            if 'router_downgrade_threshold' in params:\n                self.nodes[i].set_router_downgrade_threshold(params['router_downgrade_threshold'])\n            if 'router_eligible' in params:\n                self.nodes[i].set_router_eligible(params['router_eligible'])\n            if 'prefer_router_id' in params:\n                self.nodes[i].prefer_router_id(params['prefer_router_id'])\n            if 'timeout' in params:\n                self.nodes[i].set_timeout(params['timeout'])\n            self._set_up_active_dataset(self.nodes[i], params)\n            if 'pending_dataset' in params:\n                self.nodes[i].set_pending_dataset(params['pending_dataset']['pendingtimestamp'], params['pending_dataset']['activetimestamp'], panid=params['pending_dataset'].get('panid'), channel=params['pending_dataset'].get('channel'), delay=params['pending_dataset'].get('delay'))\n            if 'key_sequence_counter' in params:\n                self.nodes[i].set_key_sequence_counter(params['key_sequence_counter'])\n            if 'network_id_timeout' in params:\n                self.nodes[i].set_network_id_timeout(params['network_id_timeout'])\n            if 'context_reuse_delay' in params:\n                self.nodes[i].set_context_reuse_delay(params['context_reuse_delay'])\n            if 'max_children' in params:\n                self.nodes[i].set_max_children(params['max_children'])\n            if 'bbr_registration_jitter' in params:\n                self.nodes[i].set_bbr_registration_jitter(params['bbr_registration_jitter'])\n            if 'router_id_range' in params:\n                self.nodes[i].set_router_id_range(params['router_id_range'][0], params['router_id_range'][1])\n        for i, params in initial_topology.items():\n            allowlist = params['allowlist']\n            if allowlist is None:\n                continue\n            for j in allowlist:\n                rssi = None\n                if isinstance(j, tuple):\n                    j, rssi = j\n                self.nodes[i].add_allowlist(self.nodes[j].get_addr64(), rssi=rssi)\n            self.nodes[i].enable_allowlist()\n        self._inspector = debug.Inspector(self)\n        self._collect_test_info_after_setup()\n\n    def _set_up_active_dataset(self, node, params):\n        dataset = {'timestamp': 1, 'channel': config.CHANNEL, 'channel_mask': config.CHANNEL_MASK, 'extended_panid': config.EXTENDED_PANID, 'mesh_local_prefix': config.MESH_LOCAL_PREFIX.split('/')[0], 'network_key': config.DEFAULT_NETWORK_KEY, 'network_name': config.NETWORK_NAME, 'panid': config.PANID, 'pskc': config.PSKC, 'security_policy': config.SECURITY_POLICY}\n        if 'channel' in params:\n            dataset['channel'] = params['channel']\n        if 'network_key' in params:\n            dataset['network_key'] = params['network_key']\n        if 'network_name' in params:\n            dataset['network_name'] = params['network_name']\n        if 'panid' in params:\n            dataset['panid'] = params['panid']\n        if 'active_dataset' in params:\n            dataset.update(params['active_dataset'])\n        node.set_active_dataset(**dataset)\n\n    def inspect(self):\n        self._inspector.inspect()\n\n    def tearDown(self):\n        \"\"\"Destroy nodes and simulator.\n        \"\"\"\n        if self._do_packet_verification and os.uname().sysname != 'Linux':\n            raise NotImplementedError(f'{self.test_name}: Packet Verification not available on {os.uname().sysname} (Linux only).')\n        if self._do_packet_verification:\n            self.simulator.go(3)\n        if self._has_backbone_traffic():\n            self._stop_backbone_sniffer()\n        for node in list(self.nodes.values()):\n            try:\n                node.stop()\n            except:\n                traceback.print_exc()\n            finally:\n                node.destroy()\n        self.simulator.stop()\n        if self._has_backbone_traffic():\n            self._remove_backbone_network()\n        if self._do_packet_verification:\n            if self._has_backbone_traffic():\n                pcap_filename = self._merge_thread_backbone_pcaps()\n            else:\n                pcap_filename = self._get_thread_pcap_filename()\n            self._test_info['pcap'] = pcap_filename\n            test_info_path = self._output_test_info()\n            if not self._testSkipped:\n                self._verify_packets(test_info_path)\n\n    def flush_all(self):\n        \"\"\"Flush away all captured messages of all nodes.\n        \"\"\"\n        for i in list(self.nodes.keys()):\n            self.simulator.get_messages_sent_by(i)\n\n    def flush_nodes(self, nodes):\n        \"\"\"Flush away all captured messages of specified nodes.\n\n        Args:\n            nodes (list): nodes whose messages to flush.\n\n        \"\"\"\n        for i in nodes:\n            if i in list(self.nodes.keys()):\n                self.simulator.get_messages_sent_by(i)\n\n    def _clean_up_tmp(self):\n        \"\"\"\n        Clean up node files in tmp directory\n        \"\"\"\n        os.system(f'rm -f tmp/{PORT_OFFSET}_*.flash tmp/{PORT_OFFSET}_*.data tmp/{PORT_OFFSET}_*.swap')\n\n    def _verify_packets(self, test_info_path: str):\n        pv = PacketVerifier(test_info_path, self.CASE_WIRESHARK_PREFS)\n        pv.add_common_vars()\n        pv.pkts.filter_thread_unallowed_icmpv6().must_not_next()\n        self.verify(pv)\n        print('Packet verification passed: %s' % test_info_path, file=sys.stderr)\n\n    @property\n    def test_name(self):\n        return os.getenv('TEST_NAME', 'current')\n\n    def collect_ipaddrs(self):\n        if not self._do_packet_verification:\n            return\n        test_info = self._test_info\n        for i, node in self.nodes.items():\n            ipaddrs = node.get_addrs()\n            if hasattr(node, 'get_ether_addrs'):\n                ipaddrs += node.get_ether_addrs()\n            test_info['ipaddrs'][i] = ipaddrs\n            if not node.is_host:\n                mleid = node.get_mleid()\n                test_info['mleids'][i] = mleid\n\n    def collect_rloc16s(self):\n        if not self._do_packet_verification:\n            return\n        test_info = self._test_info\n        test_info['rloc16s'] = {}\n        for i, node in self.nodes.items():\n            if not node.is_host:\n                test_info['rloc16s'][i] = '0x%04x' % node.get_addr16()\n\n    def collect_rlocs(self):\n        if not self._do_packet_verification:\n            return\n        test_info = self._test_info\n        test_info['rlocs'] = {}\n        for i, node in self.nodes.items():\n            if node.is_host:\n                continue\n            test_info['rlocs'][i] = node.get_rloc()\n\n    def collect_omrs(self):\n        if not self._do_packet_verification:\n            return\n        test_info = self._test_info\n        test_info['omrs'] = {}\n        for i, node in self.nodes.items():\n            if node.is_host:\n                continue\n            test_info['omrs'][i] = node.get_ip6_address(config.ADDRESS_TYPE.OMR)\n\n    def collect_duas(self):\n        if not self._do_packet_verification:\n            return\n        test_info = self._test_info\n        test_info['duas'] = {}\n        for i, node in self.nodes.items():\n            if node.is_host:\n                continue\n            test_info['duas'][i] = node.get_ip6_address(config.ADDRESS_TYPE.DUA)\n\n    def collect_leader_aloc(self, node):\n        if not self._do_packet_verification:\n            return\n        test_info = self._test_info\n        test_info['leader_aloc'] = self.nodes[node].get_addr_leader_aloc()\n\n    def collect_extra_vars(self, **vars):\n        if not self._do_packet_verification:\n            return\n        for k in vars.keys():\n            assert isinstance(k, str), k\n        test_vars = self._test_info.setdefault('extra_vars', {})\n        test_vars.update(vars)\n\n    def _collect_test_info_after_setup(self):\n        \"\"\"\n        Collect test info after setUp\n        \"\"\"\n        if not self._do_packet_verification:\n            return\n        test_info = self._test_info = {'script': os.path.abspath(sys.argv[0]), 'testcase': self.test_name, 'start_time': time.ctime(self._start_time), 'pcap': '', 'extaddrs': {}, 'ethaddrs': {}, 'ipaddrs': {}, 'mleids': {}, 'topology': self._initial_topology, 'backbone': {'interface': config.BACKBONE_DOCKER_NETWORK_NAME, 'prefix': config.BACKBONE_PREFIX}, 'domain_prefix': config.DOMAIN_PREFIX, 'env': {'PORT_OFFSET': config.PORT_OFFSET}}\n        for i, node in self.nodes.items():\n            if not node.is_host:\n                extaddr = node.get_addr64()\n                test_info['extaddrs'][i] = ExtAddr(extaddr).format_octets()\n            if node.is_host or node.is_otbr:\n                ethaddr = node.get_ether_mac()\n                test_info['ethaddrs'][i] = EthAddr(ethaddr).format_octets()\n\n    def _construct_backbone_network_name(self, backbone_network_id) -> str:\n        \"\"\"\n        Construct the name of the backbone network based on the given backbone network id from TOPOLOGY. If the\n        backbone_network_id is not defined in TOPOLOGY, use the default backbone network id.\n        \"\"\"\n        id = backbone_network_id if backbone_network_id is not None else config.BACKBONE_DOCKER_NETWORK_DEFAULT_ID\n        backbone_name = f'{config.BACKBONE_DOCKER_NETWORK_NAME}.{id}'\n        assert backbone_name in self._backbone_network_names\n        return backbone_name\n\n    def _output_test_info(self):\n        \"\"\"\n        Output test info to json file after tearDown\n        \"\"\"\n        filename = f'{self.test_name}.json'\n        with open(filename, 'wt') as ofd:\n            ofd.write(json.dumps(self._test_info, indent=1, sort_keys=True))\n        return filename\n\n    def _get_thread_pcap_filename(self):\n        current_pcap = self.test_name + '.pcap'\n        return os.path.abspath(current_pcap)\n\n    def assure_run_ok(self, cmd, shell=False):\n        if not shell and isinstance(cmd, str):\n            cmd = cmd.split()\n        proc = subprocess.run(cmd, stdout=sys.stdout, stderr=sys.stderr, shell=shell)\n        print('>>> %s => %d' % (cmd, proc.returncode), file=sys.stderr)\n        proc.check_returncode()\n\n    def _parse_params(self, params: Optional[dict]) -> dict:\n        params = params or {}\n        if params.get('is_bbr') or params.get('is_otbr'):\n            version = params.get('version', '1.4')\n            assert version != '1.1', params\n            params['version'] = version\n            params.setdefault('bbr_registration_jitter', config.DEFAULT_BBR_REGISTRATION_JITTER)\n        elif params.get('is_host'):\n            assert params.get('version', '') == '', params\n            params['version'] = ''\n        if params.get('version') == '1.2':\n            params['version'] = '1.4'\n        is_ftd = not params.get('is_mtd') and (not params.get('is_host'))\n        effective_params = DEFAULT_PARAMS.copy()\n        if is_ftd:\n            effective_params.update(FTD_DEFAULT_PARAMS)\n        effective_params.update(params)\n        return effective_params\n\n    def _has_backbone_traffic(self):\n        for param in self.TOPOLOGY.values():\n            if param and (param.get('is_otbr') or param.get('is_host')):\n                return True\n        return False\n\n    def _prepare_backbone_network(self):\n        \"\"\"\n        Creates one or more backbone networks (Docker bridge networks) based on the TOPOLOGY definition.\n\n        * If `backbone_network_id` is defined in the TOPOLOGY:\n            * Network name:   `backbone{PORT_OFFSET}.{backbone_network_id}`      (e.g., \"backbone0.0\", \"backbone0.1\")\n            * Network prefix: `backbone{PORT_OFFSET}:{backbone_network_id}::/64` (e.g., \"9100:0::/64\", \"9100:1::/64\")\n\n        * If `backbone_network_id` is undefined:\n            * Network name:   `backbone{PORT_OFFSET}.0`    (e.g., \"backbone0.0\")\n            * Network prefix: `backbone{PORT_OFFSET}::/64` (e.g., \"9100::/64\")\n        \"\"\"\n        backbone_id_set = set()\n        for node in self.TOPOLOGY:\n            id = self.TOPOLOGY[node].get('backbone_network_id')\n            if id is not None:\n                backbone_id_set.add(id)\n        if not backbone_id_set:\n            backbone_id_set.add(config.BACKBONE_DOCKER_NETWORK_DEFAULT_ID)\n        for id in backbone_id_set:\n            backbone = f'{config.BACKBONE_DOCKER_NETWORK_NAME}.{id}'\n            backbone_prefix = f'{config.BACKBONE_IPV6_ADDR_START}:{id}::/64'\n            self._backbone_network_names.append(backbone)\n            self.assure_run_ok(f'docker network create --driver bridge --ipv6 --subnet {backbone_prefix} -o \"com.docker.network.bridge.name\"=\"{backbone}\" {backbone} || true', shell=True)\n\n    def _remove_backbone_network(self):\n        for network_name in self._backbone_network_names:\n            self.assure_run_ok(f'docker network rm {network_name}', shell=True)\n\n    def _start_backbone_sniffer(self):\n        assert self._backbone_network_names, 'Internal Error: self._backbone_network_names is empty'\n        sniffer_interface = self._backbone_network_names[0]\n        pcap_file = self._get_backbone_pcap_filename()\n        try:\n            os.remove(pcap_file)\n        except FileNotFoundError:\n            pass\n        dumpcap = pvutils.which_dumpcap()\n        self._dumpcap_proc = subprocess.Popen([dumpcap, '-i', sniffer_interface, '-w', pcap_file], stdout=sys.stdout, stderr=sys.stderr)\n        time.sleep(0.2)\n        assert self._dumpcap_proc.poll() is None, 'tshark terminated unexpectedly'\n        logging.info('Backbone sniffer launched successfully on interface %s, pid=%s', sniffer_interface, self._dumpcap_proc.pid)\n        os.chmod(pcap_file, stat.S_IWUSR | stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)\n\n    def _get_backbone_pcap_filename(self):\n        backbone_pcap = self.test_name + '_backbone.pcap'\n        return os.path.abspath(backbone_pcap)\n\n    def _get_merged_pcap_filename(self):\n        backbone_pcap = self.test_name + '_merged.pcap'\n        return os.path.abspath(backbone_pcap)\n\n    def _stop_backbone_sniffer(self):\n        self._dumpcap_proc.send_signal(signal.SIGTERM)\n        self._dumpcap_proc.__exit__(None, None, None)\n        logging.info('Backbone sniffer terminated successfully: pid=%s' % self._dumpcap_proc.pid)\n\n    def _merge_thread_backbone_pcaps(self):\n        thread_pcap = self._get_thread_pcap_filename()\n        backbone_pcap = self._get_backbone_pcap_filename()\n        merged_pcap = self._get_merged_pcap_filename()\n        mergecap = pvutils.which_mergecap()\n        self.assure_run_ok(f'{mergecap} -w {merged_pcap} {thread_pcap} {backbone_pcap}', shell=True)\n        return merged_pcap\n\n    def wait_until(self, cond: Callable[[], bool], timeout: int, go_interval: int=1):\n        while True:\n            self.simulator.go(go_interval)\n            if cond():\n                break\n            timeout -= go_interval\n            if timeout <= 0:\n                raise RuntimeError(f'wait failed after {timeout} seconds')\n\n    def wait_node_state(self, node: Union[int, Node], state: str, timeout: int):\n        node = self.nodes[node] if isinstance(node, int) else node\n        self.wait_until(lambda: node.get_state() == state, timeout)\n\n    def wait_route_established(self, node1: int, node2: int, timeout=10):\n        node2_addr = self.nodes[node2].get_ip6_address(config.ADDRESS_TYPE.RLOC)\n        while timeout > 0:\n            if self.nodes[node1].ping(node2_addr):\n                break\n            self.simulator.go(1)\n            timeout -= 1\n        else:\n            raise Exception('Route between node %d and %d is not established' % (node1, node2))\n\n    def assertDictIncludes(self, actual: Mapping[str, str], expected: Mapping[str, str]):\n        \"\"\" Asserts the `actual` dict includes the `expected` dict.\n\n        Args:\n            actual: A dict for checking.\n            expected: The expected items that the actual dict should contains.\n        \"\"\"\n        for k, v in expected.items():\n            if k not in actual:\n                raise AssertionError(f'key {k} is not found in first dict')\n            if v != actual[k]:\n                raise AssertionError(f'{repr(actual[k])} != {repr(v)} for key {k}')\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass LogCleanupManager:\n    '''Log file cleanup manager for automatic maintenance'''\n\n    def __init__(self, log_dir: str, max_age_days: int=30, cleanup_interval_hours: int=24):\n        '''\n        Initialize log cleanup manager.\n        Args:\n            log_dir: Directory containing log files\n            max_age_days: Maximum age of log files in days (default: 30 days)\n            cleanup_interval_hours: Cleanup interval in hours (default: 24 hours)\n        '''\n        pass\n\n    def start_cleanup_scheduler(self):\n        '''Start the cleanup scheduler in a background thread'''\n        pass\n\n    def stop_cleanup_scheduler(self):\n        '''Stop the cleanup scheduler'''\n        pass\n\n    def _cleanup_loop(self):\n        '''Background loop for periodic cleanup'''\n        pass\n\n    def cleanup_old_logs(self):\n        '''Clean up old log files based on age'''\n        pass\n\n    def get_cleanup_stats(self) -> dict:\n        '''Get statistics about log files and cleanup status'''\n        pass"
  }
]