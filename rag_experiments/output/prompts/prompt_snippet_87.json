[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Sample(CaseInsensitiveDict):\n    '''A single sample for a sample sheet.\n    This class is built with the keys and values in the ``\"[Data]\"`` section of\n    the sample sheet. As specified by Illumina, the only required keys are:\n        - ``\"Sample_ID\"``\n    Although this library recommends you define the following column names:\n        - ``\"Sample_ID\"``\n        - ``\"Sample_Name\"``\n        - ``\"index\"``\n    If the key ``\"Read_Structure\"`` is provided then its value is promoted to\n    the class :class:`ReadStructure` and additional functionality is enabled.\n    Args:\n        data: Mapping of key-value pairs describing this sample.\n        kwargs: Key-value pairs describing this sample.\n    Examples:\n        >>> mapping = {\"Sample_ID\": \"87\", \"Sample_Name\": \"3T\", \"index\": \"A\"}\n        >>> sample = Sample(mapping)\n        >>> sample\n        Sample({'Sample_ID': '87', 'Sample_Name': '3T', 'index': 'A'})\n        >>> sample = Sample({'Read_Structure': '151T'})\n        >>> sample.Read_Structure\n        ReadStructure(structure='151T')\n    '''\n\n    def __init__(self, data: Optional[Mapping]=None, **kwargs: Mapping) -> None:\n        pass\n\n    def to_json(self) -> Mapping:\n        '''Return the properties of this :class:`Sample` as JSON serializable.\n        '''\n        pass\n\n    def __eq__(self, other: object) -> bool:\n        '''Samples are equal if the following attributes are equal:\n            - ``\"Sample_ID\"``\n            - ``\"Library_ID\"``\n            - ``\"Lane\"``\n        '''\n        pass\n\n    def __getattr__(self, attr: Any) -> Optional[Any]:\n        '''Return ``None`` if an attribute is undefined.'''\n        pass\n\n    def __repr__(self) -> str:\n        '''Return an executeable ``__repr__()``.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Cast this object to string.'''\n        pass\nCorresponding class implementation:\n\nfrom typing import Any, Generator, Iterable, List, Mapping, Optional, Set, TextIO, Union\nimport re\nfrom requests.structures import CaseInsensitiveDict\n\nclass Sample(CaseInsensitiveDict):\n    \"\"\"A single sample for a sample sheet.\n\n    This class is built with the keys and values in the ``\"[Data]\"`` section of\n    the sample sheet. As specified by Illumina, the only required keys are:\n\n        - ``\"Sample_ID\"``\n\n    Although this library recommends you define the following column names:\n\n        - ``\"Sample_ID\"``\n        - ``\"Sample_Name\"``\n        - ``\"index\"``\n\n    If the key ``\"Read_Structure\"`` is provided then its value is promoted to\n    the class :class:`ReadStructure` and additional functionality is enabled.\n\n    Args:\n        data: Mapping of key-value pairs describing this sample.\n        kwargs: Key-value pairs describing this sample.\n\n    Examples:\n        >>> mapping = {\"Sample_ID\": \"87\", \"Sample_Name\": \"3T\", \"index\": \"A\"}\n        >>> sample = Sample(mapping)\n        >>> sample\n        Sample({'Sample_ID': '87', 'Sample_Name': '3T', 'index': 'A'})\n        >>> sample = Sample({'Read_Structure': '151T'})\n        >>> sample.Read_Structure\n        ReadStructure(structure='151T')\n\n    \"\"\"\n    _valid_index_key_pattern = re.compile('index\\\\d?')\n    _valid_index_value_pattern = re.compile('^[ACGTN]*$|^SI-[ACGTNS]{2}-[A-H]\\\\d+$')\n\n    def __init__(self, data: Optional[Mapping]=None, **kwargs: Mapping) -> None:\n        super().__init__()\n        data = {**data, **kwargs} if data is not None else kwargs\n        self._store: Mapping\n        self.sample_sheet: Optional[SampleSheet] = None\n        for key, value in data.items():\n            if key.lower().replace('_', '') == 'readstructure':\n                value = ReadStructure(str(value))\n            if self._valid_index_key_pattern.match(key) and (not bool(self._valid_index_value_pattern.match(str(value)))):\n                raise ValueError(f'Not a valid index: {value}')\n            self[key] = value\n        if self.Read_Structure is not None and self.Read_Structure.is_single_indexed and (self.index is None):\n            raise ValueError(f'If a single-indexed read structure is defined then a sample `index` must be defined also: {self}')\n        elif self.Read_Structure is not None and self.Read_Structure.is_dual_indexed and (self.index is None) and (self.index2 is None):\n            raise ValueError(f'If a dual-indexed read structure is defined then sample `index` and sample `index2` must be defined also: {self}')\n\n    def to_json(self) -> Mapping:\n        \"\"\"Return the properties of this :class:`Sample` as JSON serializable.\n\n        \"\"\"\n        return {str(x): str(y) for x, y in self.items()}\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Samples are equal if the following attributes are equal:\n\n            - ``\"Sample_ID\"``\n            - ``\"Library_ID\"``\n            - ``\"Lane\"``\n\n        \"\"\"\n        if not isinstance(other, Sample):\n            raise NotImplementedError\n        is_equal: bool = self.Sample_ID == other.Sample_ID and self.Library_ID == other.Library_ID and (self.Lane == other.Lane)\n        return is_equal\n\n    def __getattr__(self, attr: Any) -> Optional[Any]:\n        \"\"\"Return ``None`` if an attribute is undefined.\"\"\"\n        return super().get(attr)\n\n    def __repr__(self) -> str:\n        \"\"\"Return an executeable ``__repr__()``.\"\"\"\n        args = {key: getattr(self, key) for key in RECOMMENDED_KEYS}\n        args_str = args.__repr__()\n        return f'{self.__class__.__qualname__}({args_str})'\n\n    def __str__(self) -> str:\n        \"\"\"Cast this object to string.\"\"\"\n        return str(self.Sample_ID) if self.Sample_ID is not None else ''\n\nExample skeleton:\n\n\nclass TextCollection(Text):\n    '''Handle plotting a collection of text.\n    Text Collection plots text with a collection of similar properties: font, color,\n    and an offset relative to the x,y data location.\n    '''\n\n    def __init__(self, x, y, text, offset=(0, 0), **kwargs):\n        '''Initialize an instance of `TextCollection`.\n        This class encompasses drawing a collection of text values at a variety\n        of locations.\n        Parameters\n        ----------\n        x : array-like\n            The x locations, in data coordinates, for the text\n        y : array-like\n            The y locations, in data coordinates, for the text\n        text : array-like of str\n            The string values to draw\n        offset : (int, int), optional\n            The offset x and y, in normalized coordinates, to draw the text relative\n            to the data locations. Defaults to (0, 0), which has no offset.\n        kwargs : arbitrary keywords arguments\n        '''\n        pass\n\n    def __str__(self):\n        '''Make a string representation of `TextCollection`.'''\n        pass\n\n    def get_datalim(self, transData):\n        '''Return the limits of the data.\n        Parameters\n        ----------\n        transData : matplotlib.transforms.Transform\n        Returns\n        -------\n        matplotlib.transforms.Bbox\n            The bounding box of the data\n        '''\n        pass\n    @allow_rasterization\n    def draw(self, renderer):\n        '''Draw the :class:`TextCollection` object to the given *renderer*.'''\n        pass\n\n    def set_usetex(self, usetex):\n        '''\n        Set this `Text` object to render using TeX (or not).\n        If `None` is given, the option will be reset to use the value of\n        `rcParams['text.usetex']`\n        '''\n        pass\n\n    def get_usetex(self):\n        '''\n        Return whether this `Text` object will render using TeX.\n        If the user has not manually set this value, it will default to\n        the value of `rcParams['text.usetex']`\n        '''\n        pass\nCorresponding class implementation:\n\nfrom matplotlib.text import Text\nimport numpy as np\nfrom matplotlib.artist import allow_rasterization\nimport itertools\nfrom matplotlib import rcParams\nimport matplotlib.transforms as mtransforms\n\nclass TextCollection(Text):\n    \"\"\"Handle plotting a collection of text.\n\n    Text Collection plots text with a collection of similar properties: font, color,\n    and an offset relative to the x,y data location.\n    \"\"\"\n\n    def __init__(self, x, y, text, offset=(0, 0), **kwargs):\n        \"\"\"Initialize an instance of `TextCollection`.\n\n        This class encompasses drawing a collection of text values at a variety\n        of locations.\n\n        Parameters\n        ----------\n        x : array-like\n            The x locations, in data coordinates, for the text\n\n        y : array-like\n            The y locations, in data coordinates, for the text\n\n        text : array-like of str\n            The string values to draw\n\n        offset : (int, int), optional\n            The offset x and y, in normalized coordinates, to draw the text relative\n            to the data locations. Defaults to (0, 0), which has no offset.\n\n        kwargs : arbitrary keywords arguments\n\n        \"\"\"\n        Text.__init__(self, **kwargs)\n        self.x = x\n        self.y = y\n        self.text = text\n        self.offset = offset\n\n    def __str__(self):\n        \"\"\"Make a string representation of `TextCollection`.\"\"\"\n        return 'TextCollection'\n    __repr__ = __str__\n\n    def get_datalim(self, transData):\n        \"\"\"Return the limits of the data.\n\n        Parameters\n        ----------\n        transData : matplotlib.transforms.Transform\n\n        Returns\n        -------\n        matplotlib.transforms.Bbox\n            The bounding box of the data\n\n        \"\"\"\n        full_transform = self.get_transform() - transData\n        posx = self.convert_xunits(self.x)\n        posy = self.convert_yunits(self.y)\n        XY = full_transform.transform(np.vstack((posx, posy)).T)\n        bbox = mtransforms.Bbox.null()\n        bbox.update_from_data_xy(XY, ignore=True)\n        return bbox\n\n    @allow_rasterization\n    def draw(self, renderer):\n        \"\"\"Draw the :class:`TextCollection` object to the given *renderer*.\"\"\"\n        if renderer is not None:\n            self._renderer = renderer\n        if not self.get_visible():\n            return\n        if not any(self.text):\n            return\n        renderer.open_group('text', self.get_gid())\n        trans = self.get_transform()\n        if self.offset != (0, 0):\n            scale = self.axes.figure.dpi / 72\n            xoff, yoff = self.offset\n            trans += mtransforms.Affine2D().translate(scale * xoff, scale * yoff)\n        posx = self.convert_xunits(self.x)\n        posy = self.convert_yunits(self.y)\n        pts = np.vstack((posx, posy)).T\n        pts = trans.transform(pts)\n        _, canvash = renderer.get_canvas_width_height()\n        gc = renderer.new_gc()\n        gc.set_foreground(self.get_color())\n        gc.set_alpha(self.get_alpha())\n        gc.set_url(self._url)\n        self._set_gc_clip(gc)\n        angle = self.get_rotation()\n        for (posx, posy), t in zip(pts, itertools.cycle(self.text)):\n            if not t:\n                continue\n            self._text = t\n            _, info, _ = self._get_layout(renderer)\n            self._text = ''\n            for line, _, x, y in info:\n                mtext = self if len(info) == 1 else None\n                x = x + posx\n                y = y + posy\n                if renderer.flipy():\n                    y = canvash - y\n                clean_line, ismath = self._preprocess_math(line)\n                if self.get_path_effects():\n                    from matplotlib.patheffects import PathEffectRenderer\n                    textrenderer = PathEffectRenderer(self.get_path_effects(), renderer)\n                else:\n                    textrenderer = renderer\n                if self.get_usetex():\n                    textrenderer.draw_tex(gc, x, y, clean_line, self._fontproperties, angle, mtext=mtext)\n                else:\n                    textrenderer.draw_text(gc, x, y, clean_line, self._fontproperties, angle, ismath=ismath, mtext=mtext)\n        gc.restore()\n        renderer.close_group('text')\n\n    def set_usetex(self, usetex):\n        \"\"\"\n        Set this `Text` object to render using TeX (or not).\n\n        If `None` is given, the option will be reset to use the value of\n        `rcParams['text.usetex']`\n        \"\"\"\n        self._usetex = None if usetex is None else bool(usetex)\n        self.stale = True\n\n    def get_usetex(self):\n        \"\"\"\n        Return whether this `Text` object will render using TeX.\n\n        If the user has not manually set this value, it will default to\n        the value of `rcParams['text.usetex']`\n        \"\"\"\n        if self._usetex is None:\n            return rcParams['text.usetex']\n        else:\n            return self._usetex\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass RandomLoadText:\n    '''\n    Randomly samples positive and negative texts and updates class indices accordingly.\n    This class is responsible for sampling texts from a given set of class texts, including both positive\n    (present in the image) and negative (not present in the image) samples. It updates the class indices\n    to reflect the sampled texts and can optionally pad the text list to a fixed length.\n    Attributes:\n        prompt_format (str): Format string for text prompts.\n        neg_samples (Tuple[int, int]): Range for randomly sampling negative texts.\n        max_samples (int): Maximum number of different text samples in one image.\n        padding (bool): Whether to pad texts to max_samples.\n        padding_value (str): The text used for padding when padding is True.\n    Methods:\n        __call__: Processes the input labels and returns updated classes and texts.\n    Examples:\n        >>> loader = RandomLoadText(prompt_format=\"Object: {}\", neg_samples=(5, 10), max_samples=20)\n        >>> labels = {\"cls\": [0, 1, 2], \"texts\": [[\"cat\"], [\"dog\"], [\"bird\"]], \"instances\": [...]}\n        >>> updated_labels = loader(labels)\n        >>> print(updated_labels[\"texts\"])\n        ['Object: cat', 'Object: dog', 'Object: bird', 'Object: elephant', 'Object: car']\n    '''\n\n    def __init__(self, prompt_format: str='{}', neg_samples: Tuple[int, int]=(80, 80), max_samples:\n        '''\n        Initializes the RandomLoadText class for randomly sampling positive and negative texts.\n        This class is designed to randomly sample positive texts and negative texts, and update the class\n        indices accordingly to the number of samples. It can be used for text-based object detection tasks.\n        Args:\n            prompt_format (str): Format string for the prompt. Default is '{}'. The format string should\n                contain a single pair of curly braces {} where the text will be inserted.\n            neg_samples (Tuple[int, int]): A range to randomly sample negative texts. The first integer\n                specifies the minimum number of negative samples, and the second integer specifies the\n                maximum. Default is (80, 80).\n            max_samples (int): The maximum number of different text samples in one image. Default is 80.\n            padding (bool): Whether to pad texts to max_samples. If True, the number of texts will always\n                be equal to max_samples. Default is False.\n            padding_value (str): The padding text to use when padding is True. Default is an empty string.\n        Attributes:\n            prompt_format (str): The format string for the prompt.\n            neg_samples (Tuple[int, int]): The range for sampling negative texts.\n            max_samples (int): The maximum number of text samples.\n            padding (bool): Whether padding is enabled.\n            padding_value (str): The value used for padding.\n        Examples:\n            >>> random_load_text = RandomLoadText(prompt_format=\"Object: {}\", neg_samples=(50, 100), max_samples=120)\n            >>> random_load_text.prompt_format\n            'Object: {}'\n            >>> random_load_text.neg_samples\n            (50, 100)\n            >>> random_load_text.max_samples\n            120\n        '''\n        pass\n\n    def __call__(self, labels: dict) -> dict:\n        '''\n        Randomly samples positive and negative texts and updates class indices accordingly.\n        This method samples positive texts based on the existing class labels in the image, and randomly\n        selects negative texts from the remaining classes. It then updates the class indices to match the\n        new sampled text order.\n        Args:\n            labels (Dict): A dictionary containing image labels and metadata. Must include 'texts' and 'cls' keys.\n        Returns:\n            (Dict): Updated labels dictionary with new 'cls' and 'texts' entries.\n        Examples:\n            >>> loader = RandomLoadText(prompt_format=\"A photo of {}\", neg_samples=(5, 10), max_samples=20)\n            >>> labels = {\"cls\": np.array([[0], [1], [2]]), \"texts\": [[\"dog\"], [\"cat\"], [\"bird\"]]}\n            >>> updated_labels = loader(labels)\n        '''\n        pass"
  }
]