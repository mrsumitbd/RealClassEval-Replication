[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass EOWorkflowVisualization:\n    '''Class handling EOWorkflow visualization'''\n\n    def __init__(self, nodes: Sequence[EONode]):\n        '''\n        :param nodes: A sequence of topologically ordered workflow nodes\n        '''\n        pass\n\n    def dependency_graph(self, filename: str | None=None) -> Digraph:\n        '''Visualize the computational graph.\n        :param filename: Filename of the output image together with file extension. Supported formats: `png`, `jpg`,\n            `pdf`, ... . Check `graphviz` Python package for more options\n        :return: The DOT representation of the computational graph, with some more formatting\n        '''\n        pass\n\n    def get_dot(self) -> Digraph:\n        '''Generates the DOT description of the underlying computational graph.\n        :return: The DOT representation of the computational graph\n        '''\n        pass\n    @staticmethod\n    def _get_node_uid_to_dot_name_mapping(nodes: Sequence[EONode]) -> dict[str, str]:\n        '''Creates mapping between EONode classes and names used in DOT graph. To do that, it has to collect nodes with\n        the same name and assign them different indices.'''\n        pass\nCorresponding class implementation:\n\nfrom typing import Sequence\nfrom graphviz import Digraph\nfrom eolearn.core import EONode\n\nclass EOWorkflowVisualization:\n    \"\"\"Class handling EOWorkflow visualization\"\"\"\n\n    def __init__(self, nodes: Sequence[EONode]):\n        \"\"\"\n        :param nodes: A sequence of topologically ordered workflow nodes\n        \"\"\"\n        self.nodes = nodes\n\n    def dependency_graph(self, filename: str | None=None) -> Digraph:\n        \"\"\"Visualize the computational graph.\n\n        :param filename: Filename of the output image together with file extension. Supported formats: `png`, `jpg`,\n            `pdf`, ... . Check `graphviz` Python package for more options\n        :return: The DOT representation of the computational graph, with some more formatting\n        \"\"\"\n        dot = self.get_dot()\n        dot.attr(rankdir='LR')\n        if filename is not None:\n            file_name, file_format = filename.rsplit('.', 1)\n            dot.render(filename=file_name, format=file_format, cleanup=True)\n        return dot\n\n    def get_dot(self) -> Digraph:\n        \"\"\"Generates the DOT description of the underlying computational graph.\n\n        :return: The DOT representation of the computational graph\n        \"\"\"\n        dot = Digraph(format='png')\n        node_uid_to_dot_name = self._get_node_uid_to_dot_name_mapping(self.nodes)\n        for node in self.nodes:\n            for input_node in node.inputs:\n                dot.edge(node_uid_to_dot_name[input_node.uid], node_uid_to_dot_name[node.uid])\n        return dot\n\n    @staticmethod\n    def _get_node_uid_to_dot_name_mapping(nodes: Sequence[EONode]) -> dict[str, str]:\n        \"\"\"Creates mapping between EONode classes and names used in DOT graph. To do that, it has to collect nodes with\n        the same name and assign them different indices.\"\"\"\n        dot_name_to_nodes: dict[str, list[EONode]] = {}\n        for node in nodes:\n            dot_name_to_nodes[node.get_name()] = dot_name_to_nodes.get(node.get_name(), [])\n            dot_name_to_nodes[node.get_name()].append(node)\n        node_to_dot_name = {}\n        for same_name_nodes in dot_name_to_nodes.values():\n            if len(same_name_nodes) == 1:\n                node = same_name_nodes[0]\n                node_to_dot_name[node.uid] = node.get_name()\n            else:\n                for idx, node in enumerate(same_name_nodes):\n                    node_to_dot_name[node.uid] = node.get_name(idx + 1)\n        return node_to_dot_name\n\nExample skeleton:\n\n\nclass SearchSettingsConversationalSearch:\n    '''\n    Configuration settings for conversational search.\n    :param bool enabled: Whether to enable conversational search.\n    :param SearchSettingsConversationalSearchResponseLength response_length:\n          (optional)\n    :param SearchSettingsConversationalSearchSearchConfidence search_confidence:\n          (optional)\n    '''\n\n    def __init__(self, enabled: bool, *, response_length: Optional['SearchSettingsConversationalSearchResponseLength']=None, search_confidence: Optional['SearchSettingsConversationalSearchSearchConfidence']=None) -> None:\n        '''\n        Initialize a SearchSettingsConversationalSearch object.\n        :param bool enabled: Whether to enable conversational search.\n        :param SearchSettingsConversationalSearchResponseLength response_length:\n               (optional)\n        :param SearchSettingsConversationalSearchSearchConfidence\n               search_confidence: (optional)\n        '''\n        pass\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'SearchSettingsConversationalSearch':\n        '''Initialize a SearchSettingsConversationalSearch object from a json dictionary.'''\n        pass\n    @classmethod\n    def _from_dict(cls, _dict):\n        '''Initialize a SearchSettingsConversationalSearch object from a json dictionary.'''\n        pass\n\n    def to_dict(self) -> Dict:\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def _to_dict(self):\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Return a `str` version of this SearchSettingsConversationalSearch object.'''\n        pass\n\n    def __eq__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        '''Return `true` when self and other are equal, false otherwise.'''\n        pass\n\n    def __ne__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        '''Return `true` when self and other are not equal, false otherwise.'''\n        pass\nCorresponding class implementation:\n\nimport json\nfrom typing import BinaryIO, Dict, List, Optional\n\nclass SearchSettingsConversationalSearch:\n    \"\"\"\n    Configuration settings for conversational search.\n\n    :param bool enabled: Whether to enable conversational search.\n    :param SearchSettingsConversationalSearchResponseLength response_length:\n          (optional)\n    :param SearchSettingsConversationalSearchSearchConfidence search_confidence:\n          (optional)\n    \"\"\"\n\n    def __init__(self, enabled: bool, *, response_length: Optional['SearchSettingsConversationalSearchResponseLength']=None, search_confidence: Optional['SearchSettingsConversationalSearchSearchConfidence']=None) -> None:\n        \"\"\"\n        Initialize a SearchSettingsConversationalSearch object.\n\n        :param bool enabled: Whether to enable conversational search.\n        :param SearchSettingsConversationalSearchResponseLength response_length:\n               (optional)\n        :param SearchSettingsConversationalSearchSearchConfidence\n               search_confidence: (optional)\n        \"\"\"\n        self.enabled = enabled\n        self.response_length = response_length\n        self.search_confidence = search_confidence\n\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'SearchSettingsConversationalSearch':\n        \"\"\"Initialize a SearchSettingsConversationalSearch object from a json dictionary.\"\"\"\n        args = {}\n        if (enabled := _dict.get('enabled')) is not None:\n            args['enabled'] = enabled\n        else:\n            raise ValueError(\"Required property 'enabled' not present in SearchSettingsConversationalSearch JSON\")\n        if (response_length := _dict.get('response_length')) is not None:\n            args['response_length'] = SearchSettingsConversationalSearchResponseLength.from_dict(response_length)\n        if (search_confidence := _dict.get('search_confidence')) is not None:\n            args['search_confidence'] = SearchSettingsConversationalSearchSearchConfidence.from_dict(search_confidence)\n        return cls(**args)\n\n    @classmethod\n    def _from_dict(cls, _dict):\n        \"\"\"Initialize a SearchSettingsConversationalSearch object from a json dictionary.\"\"\"\n        return cls.from_dict(_dict)\n\n    def to_dict(self) -> Dict:\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        _dict = {}\n        if hasattr(self, 'enabled') and self.enabled is not None:\n            _dict['enabled'] = self.enabled\n        if hasattr(self, 'response_length') and self.response_length is not None:\n            if isinstance(self.response_length, dict):\n                _dict['response_length'] = self.response_length\n            else:\n                _dict['response_length'] = self.response_length.to_dict()\n        if hasattr(self, 'search_confidence') and self.search_confidence is not None:\n            if isinstance(self.search_confidence, dict):\n                _dict['search_confidence'] = self.search_confidence\n            else:\n                _dict['search_confidence'] = self.search_confidence.to_dict()\n        return _dict\n\n    def _to_dict(self):\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        return self.to_dict()\n\n    def __str__(self) -> str:\n        \"\"\"Return a `str` version of this SearchSettingsConversationalSearch object.\"\"\"\n        return json.dumps(self.to_dict(), indent=2)\n\n    def __eq__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        \"\"\"Return `true` when self and other are equal, false otherwise.\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        \"\"\"Return `true` when self and other are not equal, false otherwise.\"\"\"\n        return not self == other\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass LLMToolSupport:\n    '''Class to handle LLM tool support checking'''\n    @classmethod\n    def check_tool_support(cls, llm_config: dict[str, Any]) -> bool:\n        '''Check if the current LLM configuration supports tools.\n        Args:\n            llm_config: LLM configuration dictionary containing model and provider\n        Returns:\n            bool: True if the LLM supports tools, False otherwise\n        '''\n        pass\n    @classmethod\n    def get_supported_models(cls, provider: str) -> list[str] | None:\n        '''Get list of supported models for a provider.\n        Args:\n            provider: The provider name\n        Returns:\n            Optional[List[str]]: List of supported models or None if all models are supported\n        '''\n        pass"
  }
]