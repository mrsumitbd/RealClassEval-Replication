[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass FastRCNNLossComputation(object):\n    '''\n    Computes the loss for Faster R-CNN.\n    Also supports FPN\n    '''\n\n    def __init__(self, proposal_matcher, fg_bg_sampler, box_coder, cls_agnostic_bbox_reg=False):\n        '''\n        Arguments:\n            proposal_matcher (Matcher)\n            fg_bg_sampler (BalancedPositiveNegativeSampler)\n            box_coder (BoxCoder)\n        '''\n        pass\n\n    def match_targets_to_proposals(self, proposal, target):\n        pass\n\n    def prepare_targets(self, proposals, targets):\n        pass\n\n    def subsample(self, proposals, targets):\n        '''\n        This method performs the positive/negative sampling, and return\n        the sampled proposals.\n        Note: this function keeps a state.\n        Arguments:\n            proposals (list[BoxList])\n            targets (list[BoxList])\n        '''\n        pass\n\n    def __call__(self, class_logits, box_regression):\n        '''\n        Computes the loss for Faster R-CNN.\n        This requires that the subsample method has been called beforehand.\n        Arguments:\n            class_logits (list[Tensor])\n            box_regression (list[Tensor])\n        Returns:\n            classification_loss (Tensor)\n            box_loss (Tensor)\n                        '''\n                        pass\nCorresponding class implementation:\n\nfrom maskrcnn_benchmark.modeling.utils import cat\nfrom maskrcnn_benchmark.layers import smooth_l1_loss\nfrom torch.nn import functional as F\nfrom maskrcnn_benchmark.modeling.matcher import Matcher\nfrom maskrcnn_benchmark.structures.boxlist_ops import boxlist_iou\nimport torch\n\nclass FastRCNNLossComputation(object):\n    \"\"\"\n    Computes the loss for Faster R-CNN.\n    Also supports FPN\n    \"\"\"\n\n    def __init__(self, proposal_matcher, fg_bg_sampler, box_coder, cls_agnostic_bbox_reg=False):\n        \"\"\"\n        Arguments:\n            proposal_matcher (Matcher)\n            fg_bg_sampler (BalancedPositiveNegativeSampler)\n            box_coder (BoxCoder)\n        \"\"\"\n        self.proposal_matcher = proposal_matcher\n        self.fg_bg_sampler = fg_bg_sampler\n        self.box_coder = box_coder\n        self.cls_agnostic_bbox_reg = cls_agnostic_bbox_reg\n\n    def match_targets_to_proposals(self, proposal, target):\n        match_quality_matrix = boxlist_iou(target, proposal)\n        matched_idxs = self.proposal_matcher(match_quality_matrix)\n        target = target.copy_with_fields('labels')\n        matched_targets = target[matched_idxs.clamp(min=0)]\n        matched_targets.add_field('matched_idxs', matched_idxs)\n        return matched_targets\n\n    def prepare_targets(self, proposals, targets):\n        labels = []\n        regression_targets = []\n        for proposals_per_image, targets_per_image in zip(proposals, targets):\n            matched_targets = self.match_targets_to_proposals(proposals_per_image, targets_per_image)\n            matched_idxs = matched_targets.get_field('matched_idxs')\n            labels_per_image = matched_targets.get_field('labels')\n            labels_per_image = labels_per_image.to(dtype=torch.int64)\n            bg_inds = matched_idxs == Matcher.BELOW_LOW_THRESHOLD\n            labels_per_image[bg_inds] = 0\n            ignore_inds = matched_idxs == Matcher.BETWEEN_THRESHOLDS\n            labels_per_image[ignore_inds] = -1\n            regression_targets_per_image = self.box_coder.encode(matched_targets.bbox, proposals_per_image.bbox)\n            labels.append(labels_per_image)\n            regression_targets.append(regression_targets_per_image)\n        return (labels, regression_targets)\n\n    def subsample(self, proposals, targets):\n        \"\"\"\n        This method performs the positive/negative sampling, and return\n        the sampled proposals.\n        Note: this function keeps a state.\n\n        Arguments:\n            proposals (list[BoxList])\n            targets (list[BoxList])\n        \"\"\"\n        labels, regression_targets = self.prepare_targets(proposals, targets)\n        sampled_pos_inds, sampled_neg_inds = self.fg_bg_sampler(labels)\n        proposals = list(proposals)\n        for labels_per_image, regression_targets_per_image, proposals_per_image in zip(labels, regression_targets, proposals):\n            proposals_per_image.add_field('labels', labels_per_image)\n            proposals_per_image.add_field('regression_targets', regression_targets_per_image)\n        for img_idx, (pos_inds_img, neg_inds_img) in enumerate(zip(sampled_pos_inds, sampled_neg_inds)):\n            img_sampled_inds = torch.nonzero(pos_inds_img | neg_inds_img).squeeze(1)\n            proposals_per_image = proposals[img_idx][img_sampled_inds]\n            proposals[img_idx] = proposals_per_image\n        self._proposals = proposals\n        return proposals\n\n    def __call__(self, class_logits, box_regression):\n        \"\"\"\n        Computes the loss for Faster R-CNN.\n        This requires that the subsample method has been called beforehand.\n\n        Arguments:\n            class_logits (list[Tensor])\n            box_regression (list[Tensor])\n\n        Returns:\n            classification_loss (Tensor)\n            box_loss (Tensor)\n        \"\"\"\n        class_logits = cat(class_logits, dim=0)\n        box_regression = cat(box_regression, dim=0)\n        device = class_logits.device\n        if not hasattr(self, '_proposals'):\n            raise RuntimeError('subsample needs to be called before')\n        proposals = self._proposals\n        labels = cat([proposal.get_field('labels') for proposal in proposals], dim=0)\n        regression_targets = cat([proposal.get_field('regression_targets') for proposal in proposals], dim=0)\n        classification_loss = F.cross_entropy(class_logits, labels)\n        sampled_pos_inds_subset = torch.nonzero(labels > 0).squeeze(1)\n        labels_pos = labels[sampled_pos_inds_subset]\n        if self.cls_agnostic_bbox_reg:\n            map_inds = torch.tensor([4, 5, 6, 7], device=device)\n        else:\n            map_inds = 4 * labels_pos[:, None] + torch.tensor([0, 1, 2, 3], device=device)\n        box_loss = smooth_l1_loss(box_regression[sampled_pos_inds_subset[:, None], map_inds], regression_targets[sampled_pos_inds_subset], size_average=False, beta=1)\n        box_loss = box_loss / labels.numel()\n        return (classification_loss, box_loss)\n\nExample skeleton:\n\n\nclass SearchSettingsConversationalSearch:\n    '''\n    Configuration settings for conversational search.\n    :param bool enabled: Whether to enable conversational search.\n    :param SearchSettingsConversationalSearchResponseLength response_length:\n          (optional)\n    :param SearchSettingsConversationalSearchSearchConfidence search_confidence:\n          (optional)\n    '''\n\n    def __init__(self, enabled: bool, *, response_length: Optional['SearchSettingsConversationalSearchResponseLength']=None, search_confidence: Optional['SearchSettingsConversationalSearchSearchConfidence']=None) -> None:\n        '''\n        Initialize a SearchSettingsConversationalSearch object.\n        :param bool enabled: Whether to enable conversational search.\n        :param SearchSettingsConversationalSearchResponseLength response_length:\n               (optional)\n        :param SearchSettingsConversationalSearchSearchConfidence\n               search_confidence: (optional)\n        '''\n        pass\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'SearchSettingsConversationalSearch':\n        '''Initialize a SearchSettingsConversationalSearch object from a json dictionary.'''\n        pass\n    @classmethod\n    def _from_dict(cls, _dict):\n        '''Initialize a SearchSettingsConversationalSearch object from a json dictionary.'''\n        pass\n\n    def to_dict(self) -> Dict:\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def _to_dict(self):\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Return a `str` version of this SearchSettingsConversationalSearch object.'''\n        pass\n\n    def __eq__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        '''Return `true` when self and other are equal, false otherwise.'''\n        pass\n\n    def __ne__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        '''Return `true` when self and other are not equal, false otherwise.'''\n        pass\nCorresponding class implementation:\n\nimport json\nfrom typing import BinaryIO, Dict, List, Optional\n\nclass SearchSettingsConversationalSearch:\n    \"\"\"\n    Configuration settings for conversational search.\n\n    :param bool enabled: Whether to enable conversational search.\n    :param SearchSettingsConversationalSearchResponseLength response_length:\n          (optional)\n    :param SearchSettingsConversationalSearchSearchConfidence search_confidence:\n          (optional)\n    \"\"\"\n\n    def __init__(self, enabled: bool, *, response_length: Optional['SearchSettingsConversationalSearchResponseLength']=None, search_confidence: Optional['SearchSettingsConversationalSearchSearchConfidence']=None) -> None:\n        \"\"\"\n        Initialize a SearchSettingsConversationalSearch object.\n\n        :param bool enabled: Whether to enable conversational search.\n        :param SearchSettingsConversationalSearchResponseLength response_length:\n               (optional)\n        :param SearchSettingsConversationalSearchSearchConfidence\n               search_confidence: (optional)\n        \"\"\"\n        self.enabled = enabled\n        self.response_length = response_length\n        self.search_confidence = search_confidence\n\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'SearchSettingsConversationalSearch':\n        \"\"\"Initialize a SearchSettingsConversationalSearch object from a json dictionary.\"\"\"\n        args = {}\n        if (enabled := _dict.get('enabled')) is not None:\n            args['enabled'] = enabled\n        else:\n            raise ValueError(\"Required property 'enabled' not present in SearchSettingsConversationalSearch JSON\")\n        if (response_length := _dict.get('response_length')) is not None:\n            args['response_length'] = SearchSettingsConversationalSearchResponseLength.from_dict(response_length)\n        if (search_confidence := _dict.get('search_confidence')) is not None:\n            args['search_confidence'] = SearchSettingsConversationalSearchSearchConfidence.from_dict(search_confidence)\n        return cls(**args)\n\n    @classmethod\n    def _from_dict(cls, _dict):\n        \"\"\"Initialize a SearchSettingsConversationalSearch object from a json dictionary.\"\"\"\n        return cls.from_dict(_dict)\n\n    def to_dict(self) -> Dict:\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        _dict = {}\n        if hasattr(self, 'enabled') and self.enabled is not None:\n            _dict['enabled'] = self.enabled\n        if hasattr(self, 'response_length') and self.response_length is not None:\n            if isinstance(self.response_length, dict):\n                _dict['response_length'] = self.response_length\n            else:\n                _dict['response_length'] = self.response_length.to_dict()\n        if hasattr(self, 'search_confidence') and self.search_confidence is not None:\n            if isinstance(self.search_confidence, dict):\n                _dict['search_confidence'] = self.search_confidence\n            else:\n                _dict['search_confidence'] = self.search_confidence.to_dict()\n        return _dict\n\n    def _to_dict(self):\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        return self.to_dict()\n\n    def __str__(self) -> str:\n        \"\"\"Return a `str` version of this SearchSettingsConversationalSearch object.\"\"\"\n        return json.dumps(self.to_dict(), indent=2)\n\n    def __eq__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        \"\"\"Return `true` when self and other are equal, false otherwise.\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        \"\"\"Return `true` when self and other are not equal, false otherwise.\"\"\"\n        return not self == other\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass DreamSimScoreCalculator:\n    '''\n    A wrapper class for DreamSim model to calculate similarity scores between images.\n        '''\n\n    def __init__(self, pretrained=True, cache_dir='~/.cache', device=None):\n        '''\n        Initialize DreamSim model.\n        '''\n        pass\n\n    def calculate_similarity_score(self, gt_im, gen_im):\n        '''\n        Calculate similarity score between ground truth and generated images.\n        '''\n        pass\n\n    def calculate_batch_scores(self, gt_images: List[Any], gen_images: List[Any]) -> List[float]:\n        '''\n        Calculate similarity scores for multiple image pairs.\n        Since DreamSim doesn't natively support batch comparison, we process each pair individually.\n        '''\n        pass"
  }
]