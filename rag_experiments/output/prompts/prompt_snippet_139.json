[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass CustomTlsSigner(object):\n\n    def __init__(self, enterprise_cert_file_path):\n        '''\n        This class loads the offload and signer library, and calls APIs from\n        these libraries to obtain the cert and a signing callback, and attach\n        them to SSL context. The cert and the signing callback will be used\n        for client authentication in TLS handshake.\n        Args:\n            enterprise_cert_file_path (str): the path to a enterprise cert JSON\n                file. The file should contain the following field:\n                    {\n                        \"libs\": {\n                            \"ecp_client\": \"...\",\n                            \"tls_offload\": \"...\"\n                        }\n                    }\n        '''\n        pass\n\n    def load_libraries(self):\n        pass\n\n    def set_up_custom_key(self):\n        pass\n\n    def should_use_provider(self):\n        pass\n\n    def attach_to_ssl_context(self, ctx):\n        pass\nCorresponding class implementation:\n\nimport json\nimport ctypes\nfrom google.auth import exceptions\n\nclass CustomTlsSigner(object):\n\n    def __init__(self, enterprise_cert_file_path):\n        \"\"\"\n        This class loads the offload and signer library, and calls APIs from\n        these libraries to obtain the cert and a signing callback, and attach\n        them to SSL context. The cert and the signing callback will be used\n        for client authentication in TLS handshake.\n\n        Args:\n            enterprise_cert_file_path (str): the path to a enterprise cert JSON\n                file. The file should contain the following field:\n\n                    {\n                        \"libs\": {\n                            \"ecp_client\": \"...\",\n                            \"tls_offload\": \"...\"\n                        }\n                    }\n        \"\"\"\n        self._enterprise_cert_file_path = enterprise_cert_file_path\n        self._cert = None\n        self._sign_callback = None\n        self._provider_lib = None\n\n    def load_libraries(self):\n        with open(self._enterprise_cert_file_path, 'r') as f:\n            enterprise_cert_json = json.load(f)\n            libs = enterprise_cert_json.get('libs', {})\n            signer_library = libs.get('ecp_client', None)\n            offload_library = libs.get('tls_offload', None)\n            provider_library = libs.get('ecp_provider', None)\n        if provider_library:\n            self._provider_lib = load_provider_lib(provider_library)\n            return\n        if offload_library and signer_library:\n            self._offload_lib = load_offload_lib(offload_library)\n            self._signer_lib = load_signer_lib(signer_library)\n            self.set_up_custom_key()\n            return\n        raise exceptions.MutualTLSChannelError('enterprise cert file is invalid')\n\n    def set_up_custom_key(self):\n        self._cert = get_cert(self._signer_lib, self._enterprise_cert_file_path)\n        self._sign_callback = get_sign_callback(self._signer_lib, self._enterprise_cert_file_path)\n\n    def should_use_provider(self):\n        if self._provider_lib:\n            return True\n        return False\n\n    def attach_to_ssl_context(self, ctx):\n        if self.should_use_provider():\n            if not self._provider_lib.ECP_attach_to_ctx(_cast_ssl_ctx_to_void_p_stdlib(ctx), self._enterprise_cert_file_path.encode('ascii')):\n                raise exceptions.MutualTLSChannelError('failed to configure ECP Provider SSL context')\n        elif self._offload_lib and self._signer_lib:\n            if not self._offload_lib.ConfigureSslContext(self._sign_callback, ctypes.c_char_p(self._cert), _cast_ssl_ctx_to_void_p_pyopenssl(ctx._ctx._context)):\n                raise exceptions.MutualTLSChannelError('failed to configure ECP Offload SSL context')\n        else:\n            raise exceptions.MutualTLSChannelError('Invalid ECP configuration.')\n\nExample skeleton:\n\n\nclass ActivatedEvent(Event):\n    '''\n    This event indicates that the module channel has been switched to Active Channel by calling the Acquire Control API. Sent to the webhook URL server of the module channel.\n    '''\n\n    class Config:\n        '''Pydantic configuration'''\n\n    def to_str(self) -> str:\n        '''Returns the string representation of the model using alias'''\n        pass\n\n    def to_json(self) -> str:\n        '''Returns the JSON representation of the model using alias'''\n        pass\n    @classmethod\n    def from_json(cls, json_str: str) -> ActivatedEvent:\n        '''Create an instance of ActivatedEvent from a JSON string'''\n        pass\n\n    def to_dict(self):\n        '''Returns the dictionary representation of the model using alias'''\n        pass\n    @classmethod\n    def from_dict(cls, obj: dict) -> ActivatedEvent:\n        '''Create an instance of ActivatedEvent from a dict'''\n        pass\nCorresponding class implementation:\n\nfrom linebot.v3.webhooks.models.source import Source\nfrom linebot.v3.webhooks.models.chat_control import ChatControl\nfrom linebot.v3.webhooks.models.delivery_context import DeliveryContext\nimport pprint\nfrom linebot.v3.webhooks.models.event import Event\nfrom pydantic.v1 import Field\nimport json\n\nclass ActivatedEvent(Event):\n    \"\"\"\n    This event indicates that the module channel has been switched to Active Channel by calling the Acquire Control API. Sent to the webhook URL server of the module channel.\n    \"\"\"\n    chat_control: ChatControl = Field(..., alias='chatControl')\n    type: str = 'activated'\n    __properties = ['type', 'source', 'timestamp', 'mode', 'webhookEventId', 'deliveryContext', 'chatControl']\n\n    class Config:\n        \"\"\"Pydantic configuration\"\"\"\n        allow_population_by_field_name = True\n        validate_assignment = True\n\n    def to_str(self) -> str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.dict(by_alias=True))\n\n    def to_json(self) -> str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -> ActivatedEvent:\n        \"\"\"Create an instance of ActivatedEvent from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self):\n        \"\"\"Returns the dictionary representation of the model using alias\"\"\"\n        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)\n        if self.source:\n            _dict['source'] = self.source.to_dict()\n        if self.delivery_context:\n            _dict['deliveryContext'] = self.delivery_context.to_dict()\n        if self.chat_control:\n            _dict['chatControl'] = self.chat_control.to_dict()\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict) -> ActivatedEvent:\n        \"\"\"Create an instance of ActivatedEvent from a dict\"\"\"\n        if obj is None:\n            return None\n        if not isinstance(obj, dict):\n            return ActivatedEvent.parse_obj(obj)\n        _obj = ActivatedEvent.parse_obj({'type': obj.get('type'), 'source': Source.from_dict(obj.get('source')) if obj.get('source') is not None else None, 'timestamp': obj.get('timestamp'), 'mode': obj.get('mode'), 'webhook_event_id': obj.get('webhookEventId'), 'delivery_context': DeliveryContext.from_dict(obj.get('deliveryContext')) if obj.get('deliveryContext') is not None else None, 'chat_control': ChatControl.from_dict(obj.get('chatControl')) if obj.get('chatControl') is not None else None})\n        return _obj\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass ClientConfigManager:\n    '''Manages client-specific configuration'''\n\n    def __init__(self):\n        '''Initialize the client config manager'''\n        pass\n\n    def _refresh_config(self):\n        '''Refresh the local config cache from the config manager'''\n        pass\n\n    def get_supported_clients(self) -> List[str]:\n        '''Get a list of supported client names'''\n        pass\n\n    def get_client_manager(self, client_name: str):\n        '''Get the appropriate client manager for a client\n        Args:\n            client_name: Name of the client\n        Returns:\n            BaseClientManager or None if client not supported\n        '''\n        pass"
  }
]