[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass CfnginConfig(BaseConfig[CfnginConfigDefinitionModel]):\n    '''Python representation of a CFNgin config file.\n    This is used internally by CFNgin to parse and validate a YAML formatted\n    CFNgin configuration file, but can also be used in scripts to generate a\n    CFNgin config file before handing it off to CFNgin to deploy/destroy.\n    Example::\n        from runway.cfngin.config import dump, Config, Stack\n        vpc = Stack({\n            \"name\": \"vpc\",\n            \"class_path\": \"blueprints.VPC\"})\n        config = Config()\n        config.namespace = \"prod\"\n        config.stacks = [vpc]\n        print dump(config)\n    '''\n\n    def __init__(self, data: CfnginConfigDefinitionModel, *, path: Path | None=None, work_dir: Path | None=None) -> None:\n        '''Instantiate class.\n        Args:\n            data: The data model of the config file.\n            path: Path to the config file.\n            work_dir: Working directory.\n        '''\n        pass\n\n    def load(self) -> None:\n        '''Load config options into the current environment/session.'''\n        pass\n    @classmethod\n    def find_config_file(cls, path: Path | None=None, *, exclude: list[str] | None=None) -> list[Path]:\n        '''Find a config file in the provided path.\n        Args:\n            path: The path to search for a config file.\n            exclude: List of file names to exclude. This list is appended to\n                the global exclude list.\n        Raises:\n            ConfigNotFound: Could not find a config file in the provided path.\n            ValueError: More than one config file found in the provided path.\n        '''\n        pass\n    @classmethod\n    def parse_file(cls, *, path: Path | None=None, file_path: Path | None=None, parameters: MutableMapping[str, Any] | None=None, work_dir: Path | None=None, **kwargs: Any) -> CfnginConfig:\n        '''Parse a YAML file to create a config object.\n        Args:\n            path: The path to search for a config file.\n            file_path: Exact path to a file to parse.\n            parameters: Values to use when resolving a raw config.\n            work_dir: Explicit working directory.\n            **kwargs: Arbitrary keyword arguments.\n        Raises:\n            ConfigNotFound: Provided config file was not found.\n        '''\n        pass\n    @classmethod\n    def parse_obj(cls, obj: Any, *, path: Path | None=None, work_dir: Path | None=None) -> CfnginConfig:\n        '''Parse a python object.\n        Args:\n            obj: A python object to parse as a CFNgin config.\n            path: The path to the config file that was parsed into the object.\n            work_dir: Working directory.\n        '''\n        pass\n    @classmethod\n    def parse_raw(cls, data: str, *, parameters: MutableMapping[str, Any] | None=None, path: Path | None=None, skip_package_sources: bool=False, work_dir: Path | None=None) -> CfnginConfig:\n        '''Parse raw data.\n        Args:\n            data: The raw data to parse.\n            parameters: Values to use when resolving a raw config.\n            path: The path to search for a config file.\n            skip_package_sources: Skip processing package sources.\n            work_dir: Explicit working directory.\n        '''\n        pass\n    @classmethod\n    def process_package_sources(cls, raw_data: str, *, parameters: MutableMapping[str, Any] | None=None, work_dir: Path | None=None) -> str:\n        '''Process the package sources defined in a rendered config.\n        Args:\n            raw_data: Raw configuration data.\n            cache_dir: Directory to use when caching remote sources.\n            parameters: Values to use when resolving a raw config.\n            work_dir: Explicit working directory.\n        '''\n        pass\n    @staticmethod\n    def resolve_raw_data(raw_data: str, *, parameters: MutableMapping[str, Any] | None=None) -> str:\n        '''Resolve raw data.\n        Args:\n            raw_data: Raw configuration data.\n            parameters: Values to use when resolving a raw config.\n        Raises:\n            MissingEnvironment: A value required by the config was not provided\n                in parameters.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom string import Template\nfrom ..cfngin.utils import SourceProcessor\nimport re\nfrom ..utils import merge_dicts\nfrom ..exceptions import ConfigNotFound\nimport sys\nfrom typing import TYPE_CHECKING, Any, ClassVar, Generic, TypeVar, cast\nimport yaml\nfrom pathlib import Path\nfrom .models.cfngin import CfnginConfigDefinitionModel, CfnginHookDefinitionModel, CfnginPackageSourcesDefinitionModel, CfnginStackDefinitionModel\nfrom ..cfngin import exceptions\nfrom ..cfngin.lookups.registry import register_lookup_handler\n\nclass CfnginConfig(BaseConfig[CfnginConfigDefinitionModel]):\n    \"\"\"Python representation of a CFNgin config file.\n\n    This is used internally by CFNgin to parse and validate a YAML formatted\n    CFNgin configuration file, but can also be used in scripts to generate a\n    CFNgin config file before handing it off to CFNgin to deploy/destroy.\n\n    Example::\n\n        from runway.cfngin.config import dump, Config, Stack\n\n        vpc = Stack({\n            \"name\": \"vpc\",\n            \"class_path\": \"blueprints.VPC\"})\n\n        config = Config()\n        config.namespace = \"prod\"\n        config.stacks = [vpc]\n\n        print dump(config)\n\n    \"\"\"\n    EXCLUDE_REGEX: ClassVar[str] = '(?x)^(bitbucket-pipelines|buildspec|docker-compose|runway)(\\\\..*)?\\\\.(yml|yaml)'\n    'Regex for file names to exclude when looking for config files.'\n    EXCLUDE_LIST: ClassVar[list[str]] = []\n    'Explicit files names to ignore when looking for config files.'\n    cfngin_bucket: str | None\n    'Bucket to use for CFNgin resources. (e.g. CloudFormation templates).\\n    May be an empty string.\\n    '\n    cfngin_bucket_region: str | None\n    'Explicit region to use for :attr:`CfnginConfig.cfngin_bucket`'\n    cfngin_cache_dir: Path\n    'Local directory to use for caching.'\n    log_formats: dict[str, str]\n    'Custom formatting for log messages.'\n    lookups: dict[str, str]\n    'Register custom lookups.'\n    mappings: dict[str, dict[str, dict[str, Any]]]\n    'Mappings that will be added to all stacks.'\n    namespace: str\n    'Namespace to prepend to everything.'\n    namespace_delimiter: str\n    'Character used to separate :attr:`CfnginConfig.namespace` and anything it prepends.'\n    package_sources: CfnginPackageSourcesDefinitionModel\n    'Remote source locations.'\n    persistent_graph_key: str | None = None\n    'S3 object key were the persistent graph is stored.'\n    post_deploy: list[CfnginHookDefinitionModel]\n    'Hooks to run after a deploy action.'\n    post_destroy: list[CfnginHookDefinitionModel]\n    'Hooks to run after a destroy action.'\n    pre_deploy: list[CfnginHookDefinitionModel]\n    'Hooks to run before a deploy action.'\n    pre_destroy: list[CfnginHookDefinitionModel]\n    'Hooks to run before a destroy action.'\n    service_role: str | None\n    'IAM role for CloudFormation to use.'\n    stacks: list[CfnginStackDefinitionModel]\n    'Stacks to be processed.'\n    sys_path: Path | None\n    'Relative or absolute path to use as the work directory.'\n    tags: dict[str, str] | None\n    'Tags to apply to all resources.'\n    template_indent: int\n    'Spaces to use per-indent level when outputting a template to json.'\n\n    def __init__(self, data: CfnginConfigDefinitionModel, *, path: Path | None=None, work_dir: Path | None=None) -> None:\n        \"\"\"Instantiate class.\n\n        Args:\n            data: The data model of the config file.\n            path: Path to the config file.\n            work_dir: Working directory.\n\n        \"\"\"\n        super().__init__(data, path=path)\n        self.cfngin_bucket = self._data.cfngin_bucket\n        self.cfngin_bucket_region = self._data.cfngin_bucket_region\n        if self._data.cfngin_cache_dir:\n            self.cfngin_cache_dir = self._data.cfngin_cache_dir\n        elif work_dir:\n            self.cfngin_cache_dir = work_dir / 'cache'\n        elif path:\n            self.cfngin_cache_dir = path.parent / '.runway' / 'cache'\n        else:\n            self.cfngin_cache_dir = Path().cwd() / '.runway' / 'cache'\n        self.log_formats = self._data.log_formats\n        self.lookups = self._data.lookups\n        self.mappings = self._data.mappings\n        self.namespace = self._data.namespace\n        self.namespace_delimiter = self._data.namespace_delimiter\n        self.package_sources = self._data.package_sources\n        self.persistent_graph_key = self._data.persistent_graph_key\n        self.post_deploy = cast('list[CfnginHookDefinitionModel]', self._data.post_deploy)\n        self.post_destroy = cast('list[CfnginHookDefinitionModel]', self._data.post_destroy)\n        self.pre_deploy = cast('list[CfnginHookDefinitionModel]', self._data.pre_deploy)\n        self.pre_destroy = cast('list[CfnginHookDefinitionModel]', self._data.pre_destroy)\n        self.service_role = self._data.service_role\n        self.stacks = cast('list[CfnginStackDefinitionModel]', self._data.stacks)\n        self.sys_path = self._data.sys_path\n        self.tags = self._data.tags\n        self.template_indent = self._data.template_indent\n\n    def load(self) -> None:\n        \"\"\"Load config options into the current environment/session.\"\"\"\n        if self.sys_path:\n            LOGGER.debug('appending to sys.path: %s', self.sys_path)\n            sys.path.append(str(self.sys_path))\n            LOGGER.debug('sys.path: %s', sys.path)\n        if self.lookups:\n            for key, handler in self.lookups.items():\n                register_lookup_handler(key, handler)\n\n    @classmethod\n    def find_config_file(cls, path: Path | None=None, *, exclude: list[str] | None=None) -> list[Path]:\n        \"\"\"Find a config file in the provided path.\n\n        Args:\n            path: The path to search for a config file.\n            exclude: List of file names to exclude. This list is appended to\n                the global exclude list.\n\n        Raises:\n            ConfigNotFound: Could not find a config file in the provided path.\n            ValueError: More than one config file found in the provided path.\n\n        \"\"\"\n        if not path:\n            path = Path.cwd()\n        elif path.is_file():\n            return [path]\n        exclude = exclude or []\n        result: list[Path] = []\n        exclude.extend(cls.EXCLUDE_LIST)\n        yml_files = list(path.glob('*.yml'))\n        yml_files.extend(list(path.glob('*.yaml')))\n        for f in yml_files:\n            if re.match(cls.EXCLUDE_REGEX, f.name) or f.name in exclude or f.name.startswith('.'):\n                continue\n            result.append(f)\n        result.sort()\n        return result\n\n    @classmethod\n    def parse_file(cls, *, path: Path | None=None, file_path: Path | None=None, parameters: MutableMapping[str, Any] | None=None, work_dir: Path | None=None, **kwargs: Any) -> CfnginConfig:\n        \"\"\"Parse a YAML file to create a config object.\n\n        Args:\n            path: The path to search for a config file.\n            file_path: Exact path to a file to parse.\n            parameters: Values to use when resolving a raw config.\n            work_dir: Explicit working directory.\n            **kwargs: Arbitrary keyword arguments.\n\n        Raises:\n            ConfigNotFound: Provided config file was not found.\n\n        \"\"\"\n        if file_path:\n            if not file_path.is_file():\n                raise ConfigNotFound(path=file_path)\n            return cls.parse_raw(file_path.read_text(), path=file_path, parameters=parameters or {}, work_dir=work_dir, **kwargs)\n        if path:\n            found = cls.find_config_file(path)\n            if len(found) > 1:\n                raise ValueError(f'more than one config files found: {found}')\n            return cls.parse_file(file_path=found[0], parameters=parameters or {}, work_dir=work_dir, **kwargs)\n        raise ValueError('must provide path or file_path')\n\n    @classmethod\n    def parse_obj(cls, obj: Any, *, path: Path | None=None, work_dir: Path | None=None) -> CfnginConfig:\n        \"\"\"Parse a python object.\n\n        Args:\n            obj: A python object to parse as a CFNgin config.\n            path: The path to the config file that was parsed into the object.\n            work_dir: Working directory.\n\n        \"\"\"\n        return cls(CfnginConfigDefinitionModel.model_validate(obj), path=path, work_dir=work_dir)\n\n    @classmethod\n    def parse_raw(cls, data: str, *, parameters: MutableMapping[str, Any] | None=None, path: Path | None=None, skip_package_sources: bool=False, work_dir: Path | None=None) -> CfnginConfig:\n        \"\"\"Parse raw data.\n\n        Args:\n            data: The raw data to parse.\n            parameters: Values to use when resolving a raw config.\n            path: The path to search for a config file.\n            skip_package_sources: Skip processing package sources.\n            work_dir: Explicit working directory.\n\n        \"\"\"\n        if not parameters:\n            parameters = {}\n        pre_rendered = cls.resolve_raw_data(data, parameters=parameters)\n        if skip_package_sources:\n            return cls.parse_obj(yaml.safe_load(pre_rendered))\n        config_dict = yaml.safe_load(cls.process_package_sources(pre_rendered, parameters=parameters, work_dir=work_dir))\n        return cls.parse_obj(config_dict, path=path)\n\n    @classmethod\n    def process_package_sources(cls, raw_data: str, *, parameters: MutableMapping[str, Any] | None=None, work_dir: Path | None=None) -> str:\n        \"\"\"Process the package sources defined in a rendered config.\n\n        Args:\n            raw_data: Raw configuration data.\n            cache_dir: Directory to use when caching remote sources.\n            parameters: Values to use when resolving a raw config.\n            work_dir: Explicit working directory.\n\n        \"\"\"\n        config: dict[str, Any] = yaml.safe_load(raw_data) or {}\n        processor = SourceProcessor(sources=CfnginPackageSourcesDefinitionModel.model_validate(config.get('package_sources', {})), cache_dir=Path(config.get('cfngin_cache_dir', (work_dir or Path().cwd() / '.runway') / 'cache')))\n        processor.get_package_sources()\n        if processor.configs_to_merge:\n            for i in processor.configs_to_merge:\n                LOGGER.debug('merging in remote config: %s', i)\n                with i.open('rb') as opened_file:\n                    config = merge_dicts(yaml.safe_load(opened_file), config)\n            return cls.resolve_raw_data(yaml.dump(config), parameters=parameters or {})\n        return raw_data\n\n    @staticmethod\n    def resolve_raw_data(raw_data: str, *, parameters: MutableMapping[str, Any] | None=None) -> str:\n        \"\"\"Resolve raw data.\n\n        Args:\n            raw_data: Raw configuration data.\n            parameters: Values to use when resolving a raw config.\n\n        Raises:\n            MissingEnvironment: A value required by the config was not provided\n                in parameters.\n\n        \"\"\"\n        if not parameters:\n            parameters = {}\n        template = Template(raw_data)\n        try:\n            rendered = template.substitute(**parameters)\n        except KeyError as err:\n            raise exceptions.MissingEnvironment(err.args[0]) from None\n        except ValueError:\n            rendered = template.safe_substitute(**parameters)\n        return rendered\n\nExample skeleton:\n\nclass FakeHDF5FileHandler(HDF5FileHandler):\n    '''Swap  HDF5 File Handler for reader tests to use.'''\n\n    def __init__(self, filename, filename_info, filetype_info, **kwargs):\n        '''Get fake file content from 'get_test_content'.'''\n        pass\n\n    def get_test_content(self, filename, filename_info, filetype_info):\n        '''Mimic reader input file content.\n        Args:\n            filename (str): input filename\n            filename_info (dict): Dict of metadata pulled from filename\n            filetype_info (dict): Dict of metadata from the reader's yaml config for this file type\n        Returns: dict of file content with keys like:\n            - 'dataset'\n            - '/attr/global_attr'\n            - 'dataset/attr/global_attr'\n            - 'dataset/shape'\n        '''\n        pass\nCorresponding class implementation:\n\nclass FakeHDF5FileHandler(HDF5FileHandler):\n    \"\"\"Swap  HDF5 File Handler for reader tests to use.\"\"\"\n\n    def __init__(self, filename, filename_info, filetype_info, **kwargs):\n        \"\"\"Get fake file content from 'get_test_content'.\"\"\"\n        if HDF5FileHandler is object:\n            raise ImportError(\"Base 'HDF5FileHandler' could not be imported.\")\n        filename = str(filename)\n        super(HDF5FileHandler, self).__init__(filename, filename_info, filetype_info)\n        self.file_content = self.get_test_content(filename, filename_info, filetype_info)\n        self.file_content.update(kwargs)\n\n    def get_test_content(self, filename, filename_info, filetype_info):\n        \"\"\"Mimic reader input file content.\n\n        Args:\n            filename (str): input filename\n            filename_info (dict): Dict of metadata pulled from filename\n            filetype_info (dict): Dict of metadata from the reader's yaml config for this file type\n\n        Returns: dict of file content with keys like:\n\n            - 'dataset'\n            - '/attr/global_attr'\n            - 'dataset/attr/global_attr'\n            - 'dataset/shape'\n\n        \"\"\"\n        raise NotImplementedError(\"Fake File Handler subclass must implement 'get_test_content'\")\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass Config:\n    '''Configuration class for Gemini Scan.'''\n\n    def __init__(self, logger: logging.Logger, mcp_port: int=8765, model: str='gemini/gemini-2.5-flash', output_dir: str='', temperature: float=0, max_iterations: int=50, host: str='localhost', prompt: str | None=None, confidence: int=7, project_path: str=''):\n        '''\n        Initialize configuration.\n        Args:\n            logger: The logger instance to use under this config\n            model: Name of the model to use (e.g., \"gemini/gemini-2.5-flash\", \"openai/gpt-4\")\n            output_dir: Directory to store scan outputs\n            logger: Logger instance\n            max_iterations: Maximum number of tool calling iterations\n            project_path: Path to the project being scanned (set during scan)\n            temperature: Temperature for model generation\n            confidence: Minimum confidence threshold (1-10) for filtering findings\n        '''\n        pass\n\n    def _get_provider_from_model(self, model: str) -> str:\n        '''Extract the provider from the model name.'''\n        pass\n\n    def _get_env_var_for_provider(self, provider: str) -> str:\n        '''Get the expected environment variable name for a provider.'''\n        pass\n\n    def _get_api_key_for_model(self, model_name: str) -> str | None:\n        '''Get the API key for a given model from environment variables.'''\n        pass"
  }
]