[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass CommandFile:\n    '''A versioned and typed list of commands.\n    Args:\n        filetype (str): The name of the file type\n        version (str): An X.Y.Z version number\n        commands (list): A list of Command objects used to\n            initialize the command file.\n    '''\n\n    def __init__(self, filetype, version, commands=None):\n        pass\n\n    def add(self, command, *args):\n        '''Add a command to this command file.\n        Args:\n            command (str): The command to add\n            *args (str): The parameters to call the command with\n        '''\n        pass\n\n    def save(self, outpath):\n        '''Save this command file as an ascii file.\n        Agrs:\n            outpath (str): The output path to save.\n        '''\n        pass\n\n    def dump(self):\n        '''Dump all commands in this object to a string.\n        Returns:\n            str: An encoded list of commands separated by\n                \n characters suitable for saving to a file.\n        '''\n        pass\n    @classmethod\n    def FromString(cls, indata):\n        '''Load a CommandFile from a string.\n        The string should be produced from a previous call to\n        encode.\n        Args:\n            indata (str): The encoded input data.\n        Returns:\n            CommandFile: The decoded CommandFile object.\n        '''\n        pass\n    @classmethod\n    def FromFile(cls, inpath):\n        '''Load a CommandFile from a path.\n        Args:\n            inpath (str): The path to the file to load\n        Returns:\n            CommandFile: The decoded CommandFile object.\n        '''\n        pass\n    @classmethod\n    def encode(cls, command):\n        '''Encode a command as an unambiguous string.\n        Args:\n            command (Command): The command to encode.\n        Returns:\n            str: The encoded command\n        '''\n        pass\n    @classmethod\n    def decode(cls, command_str):\n        '''Decode a string encoded command back into a Command object.\n        Args:\n            command_str (str): The encoded command string output from a\n                previous call to encode.\n        Returns:\n            Command: The decoded Command object.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom iotile.core.exceptions import DataError\nfrom binascii import hexlify, unhexlify\n\nclass CommandFile:\n    \"\"\"A versioned and typed list of commands.\n\n    Args:\n        filetype (str): The name of the file type\n        version (str): An X.Y.Z version number\n        commands (list): A list of Command objects used to\n            initialize the command file.\n    \"\"\"\n\n    def __init__(self, filetype, version, commands=None):\n        if commands is None:\n            commands = []\n        self.commands = commands\n        self.validators = {}\n        self.filetype = filetype\n        self.version = version\n\n    def add(self, command, *args):\n        \"\"\"Add a command to this command file.\n\n        Args:\n            command (str): The command to add\n            *args (str): The parameters to call the command with\n        \"\"\"\n        cmd = Command(command, args)\n        self.commands.append(cmd)\n\n    def save(self, outpath):\n        \"\"\"Save this command file as an ascii file.\n\n        Agrs:\n            outpath (str): The output path to save.\n        \"\"\"\n        with open(outpath, 'w') as outfile:\n            outfile.write(self.dump())\n\n    def dump(self):\n        \"\"\"Dump all commands in this object to a string.\n\n        Returns:\n            str: An encoded list of commands separated by\n                \n characters suitable for saving to a file.\n        \"\"\"\n        out = []\n        out.append(self.filetype)\n        out.append('Format: {}'.format(self.version))\n        out.append('Type: ASCII')\n        out.append('')\n        for cmd in self.commands:\n            out.append(self.encode(cmd))\n        return '\\n'.join(out) + '\\n'\n\n    @classmethod\n    def FromString(cls, indata):\n        \"\"\"Load a CommandFile from a string.\n\n        The string should be produced from a previous call to\n        encode.\n\n        Args:\n            indata (str): The encoded input data.\n\n        Returns:\n            CommandFile: The decoded CommandFile object.\n        \"\"\"\n        lines = [x.strip() for x in indata.split('\\n') if not x.startswith('#') and (not x.strip() == '')]\n        if len(lines) < 3:\n            raise DataError('Invalid CommandFile string that did not contain 3 header lines', lines=lines)\n        fmt_line, version_line, ascii_line = lines[:3]\n        if not version_line.startswith('Format: '):\n            raise DataError(\"Invalid format version that did not start with 'Format: '\", line=version_line)\n        version = version_line[8:]\n        if ascii_line != 'Type: ASCII':\n            raise DataError('Unknown file type line (expected Type: ASCII)', line=ascii_line)\n        cmds = [cls.decode(x) for x in lines[3:]]\n        return CommandFile(fmt_line, version, cmds)\n\n    @classmethod\n    def FromFile(cls, inpath):\n        \"\"\"Load a CommandFile from a path.\n\n        Args:\n            inpath (str): The path to the file to load\n\n        Returns:\n            CommandFile: The decoded CommandFile object.\n        \"\"\"\n        with open(inpath, 'r') as infile:\n            indata = infile.read()\n        return cls.FromString(indata)\n\n    @classmethod\n    def encode(cls, command):\n        \"\"\"Encode a command as an unambiguous string.\n\n        Args:\n            command (Command): The command to encode.\n\n        Returns:\n            str: The encoded command\n        \"\"\"\n        args = []\n        for arg in command.args:\n            if not isinstance(arg, str):\n                arg = str(arg)\n            if ',' in arg or arg.startswith(' ') or arg.endswith(' ') or arg.startswith('hex:'):\n                arg = 'hex:{}'.format(hexlify(arg.encode('utf-8')).decode('utf-8'))\n            args.append(arg)\n        argstr = ''\n        if len(args) > 0:\n            argstr = ' {' + ','.join(args) + '}'\n        return command.name + argstr\n\n    @classmethod\n    def decode(cls, command_str):\n        \"\"\"Decode a string encoded command back into a Command object.\n\n        Args:\n            command_str (str): The encoded command string output from a\n                previous call to encode.\n\n        Returns:\n            Command: The decoded Command object.\n        \"\"\"\n        name, _, arg = command_str.partition(' ')\n        args = []\n        if len(arg) > 0:\n            if arg[0] != '{' or arg[-1] != '}':\n                raise DataError('Invalid command, argument is not contained in { and }', arg=arg, cmd=name)\n            arg = arg[1:-1]\n            args = arg.split(',')\n        proc = []\n        for arg in args:\n            if arg.startswith('hex:'):\n                arg = unhexlify(arg[4:]).decode('utf-8')\n            proc.append(arg)\n        return Command(name, proc)\n\nExample skeleton:\n\n\nclass Decrypter(object):\n    '''Decrypter interface.'''\n\n    def __init__(self, **kwargs):\n        '''Initializes a decrypter.\n        Args:\n          kwargs (dict): keyword arguments depending on the decrypter.\n        Raises:\n          ValueError: when there are unused keyword arguments.\n        '''\n        pass\n    @abc.abstractmethod\n    def Decrypt(self, encrypted_data, finalize=False):\n        '''Decrypts the encrypted data.\n        Args:\n          encrypted_data (bytes): encrypted data.\n          finalize (Optional[bool]): True if the end of data has been reached and\n              the cipher context should be finalized.\n        Returns:\n          tuple[bytes, bytes]: decrypted data and remaining encrypted data.\n        '''\n        pass\nCorresponding class implementation:\n\nimport abc\n\nclass Decrypter(object):\n    \"\"\"Decrypter interface.\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Initializes a decrypter.\n\n        Args:\n          kwargs (dict): keyword arguments depending on the decrypter.\n\n        Raises:\n          ValueError: when there are unused keyword arguments.\n        \"\"\"\n        if kwargs:\n            keyword_arguments = ', '.join(kwargs)\n            raise ValueError(f'Unused keyword arguments: {keyword_arguments:s}.')\n        super(Decrypter, self).__init__()\n\n    @abc.abstractmethod\n    def Decrypt(self, encrypted_data, finalize=False):\n        \"\"\"Decrypts the encrypted data.\n\n        Args:\n          encrypted_data (bytes): encrypted data.\n          finalize (Optional[bool]): True if the end of data has been reached and\n              the cipher context should be finalized.\n\n        Returns:\n          tuple[bytes, bytes]: decrypted data and remaining encrypted data.\n        \"\"\"\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass PromptCompiler:\n    '''Compiles .prompt.md files with parameter substitution.'''\n\n    def __init__(self):\n        '''Initialize compiler.'''\n        pass\n\n    def compile(self, prompt_file: str, params: Dict[str, str]) -> str:\n        '''Compile a .prompt.md file with parameter substitution.\n        Args:\n            prompt_file: Path to the .prompt.md file\n            params: Parameters to substitute\n        Returns:\n            Path to the compiled file\n        '''\n        pass\n\n    def _substitute_parameters(self, content: str, params: Dict[str, str]) -> str:\n        '''Substitute parameters in content.\n        Args:\n            content: Content to process\n            params: Parameters to substitute\n        Returns:\n            Content with parameters substituted\n        '''\n        pass"
  }
]