[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass ApproximateTokenSwapper:\n    '''A class for computing approximate solutions to the Token Swapping problem.\n    Internally caches the graph and associated datastructures for re-use.\n    '''\n\n    def __init__(self, graph: rx.PyGraph, seed: int | np.random.Generator | None=None) -> None:\n        '''Construct an ApproximateTokenSwapping object.\n        Args:\n            graph: Undirected graph represented a coupling map.\n            seed: Seed to use for random trials.\n        '''\n        pass\n\n    def distance(self, vertex0: int, vertex1: int) -> int:\n        '''Compute the distance between two nodes in `graph`.'''\n        pass\n\n    def permutation_circuit(self, permutation: Permutation, trials: int=4) -> PermutationCircuit:\n        '''Perform an approximately optimal Token Swapping algorithm to implement the permutation.\n        Args:\n          permutation: The partial mapping to implement in swaps.\n          trials: The number of trials to try to perform the mapping. Minimize over the trials.\n        Returns:\n          The circuit to implement the permutation\n        '''\n        pass\n\n    def map(self, mapping: Mapping[int, int], trials: int=4, parallel_threshold: int=50) -> list[Swap[int]]:\n        '''Perform an approximately optimal Token Swapping algorithm to implement the permutation.\n        Supports partial mappings (i.e. not-permutations) for graphs with missing tokens.\n        Based on the paper: Approximation and Hardness for Token Swapping by Miltzow et al. (2016)\n        ArXiV: https://arxiv.org/abs/1602.05150\n        and generalization based on our own work.\n        Args:\n          mapping: The partial mapping to implement in swaps.\n          trials: The number of trials to try to perform the mapping. Minimize over the trials.\n          parallel_threshold: The number of nodes in the graph beyond which the algorithm\n                will use parallel processing\n        Returns:\n          The swaps to implement the mapping\n        '''\n        pass\nCorresponding class implementation:\n\nimport numpy as np\nfrom .util import PermutationCircuit, permutation_circuit\nimport rustworkx as rx\nfrom .types import Swap, Permutation\nfrom collections.abc import Mapping\n\nclass ApproximateTokenSwapper:\n    \"\"\"A class for computing approximate solutions to the Token Swapping problem.\n\n    Internally caches the graph and associated datastructures for re-use.\n    \"\"\"\n\n    def __init__(self, graph: rx.PyGraph, seed: int | np.random.Generator | None=None) -> None:\n        \"\"\"Construct an ApproximateTokenSwapping object.\n\n        Args:\n            graph: Undirected graph represented a coupling map.\n            seed: Seed to use for random trials.\n        \"\"\"\n        self.graph = graph\n        self.shortest_paths = rx.graph_distance_matrix(graph)\n        if isinstance(seed, np.random.Generator):\n            self.seed = seed\n        else:\n            self.seed = np.random.default_rng(seed)\n\n    def distance(self, vertex0: int, vertex1: int) -> int:\n        \"\"\"Compute the distance between two nodes in `graph`.\"\"\"\n        return self.shortest_paths[vertex0, vertex1]\n\n    def permutation_circuit(self, permutation: Permutation, trials: int=4) -> PermutationCircuit:\n        \"\"\"Perform an approximately optimal Token Swapping algorithm to implement the permutation.\n\n        Args:\n          permutation: The partial mapping to implement in swaps.\n          trials: The number of trials to try to perform the mapping. Minimize over the trials.\n\n        Returns:\n          The circuit to implement the permutation\n        \"\"\"\n        sequential_swaps = self.map(permutation, trials=trials)\n        parallel_swaps = [[swap] for swap in sequential_swaps]\n        return permutation_circuit(parallel_swaps)\n\n    def map(self, mapping: Mapping[int, int], trials: int=4, parallel_threshold: int=50) -> list[Swap[int]]:\n        \"\"\"Perform an approximately optimal Token Swapping algorithm to implement the permutation.\n\n        Supports partial mappings (i.e. not-permutations) for graphs with missing tokens.\n\n        Based on the paper: Approximation and Hardness for Token Swapping by Miltzow et al. (2016)\n        ArXiV: https://arxiv.org/abs/1602.05150\n        and generalization based on our own work.\n\n        Args:\n          mapping: The partial mapping to implement in swaps.\n          trials: The number of trials to try to perform the mapping. Minimize over the trials.\n          parallel_threshold: The number of nodes in the graph beyond which the algorithm\n                will use parallel processing\n\n        Returns:\n          The swaps to implement the mapping\n        \"\"\"\n        seed = self.seed.integers(1, 10000)\n        return rx.graph_token_swapper(self.graph, mapping, trials, seed, parallel_threshold)\n\nExample skeleton:\n\n\nclass GroupedData:\n    '''Represents a grouped dataset created by calling ``Dataset.groupby()``.\n    The actual groupby is deferred until an aggregation is applied.\n        '''\n\n    def __init__(self, dataset: Dataset, key: Optional[Union[str, List[str]]], *, num_partitions: Optional[int]):\n        '''Construct a dataset grouped by key (internal API).\n        The constructor is not part of the GroupedData API.\n        Use the ``Dataset.groupby()`` method to construct one.\n        '''\n        pass\n\n    def __repr__(self) -> str:\n        pass\n    @PublicAPI(api_group=FA_API_GROUP)\n    def aggregate(self, *aggs: AggregateFn) -> Dataset:\n        '''Implements an accumulator-based aggregation.\n        Args:\n            aggs: Aggregations to do.\n        Returns:\n            The output is an dataset of ``n + 1`` columns where the first column\n            is the groupby key and the second through ``n + 1`` columns are the\n            results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n\n    def _aggregate_on(self, agg_cls: type, on: Union[str, List[str]], *args, **kwargs):\n        '''Helper for aggregating on a particular subset of the dataset.\n        This validates the `on` argument, and converts a list of column names\n        to a multi-aggregation. A null `on` results in a\n        multi-aggregation on all columns for an Arrow Dataset, and a single\n        aggregation on the entire row for a simple Dataset.\n        '''\n        pass\n    @PublicAPI(api_group=FA_API_GROUP)\n    def map_groups(self, fn: UserDefinedFunction[DataBatch, DataBatch], *, zero_copy_batch: bool=False, compute: Union[str, ComputeStrategy]=None, batch_format: Optional[str]='default', fn_args: Optional[Iterable[Any]]=None, fn_kwargs: Optional[Dict[str, Any]]=None, fn_constructor_args: Optional[Iterable[Any]]=None, fn_constructor_kwargs: Optional[Dict[str, Any]]=None, num_cpus: Optional[float]=None, num_gpus: Optional[float]=None, memory: Optional[float]=None, concurrency: Optional[Union[int, Tuple[int, int], Tuple[int, int, int]]]=None, ray_remote_args_fn: Optional[Callable[[], Dict[str, Any]]]=None, **ray_remote_args) -> 'Dataset':\n        '''Apply the given function to each group of records of this dataset.\n        While map_groups() is very flexible, note that it comes with downsides:\n        * It may be slower than using more specific methods such as min(), max().\n        * It requires that each group fits in memory on a single node.\n        In general, prefer to use `aggregate()` instead of `map_groups()`.\n        .. warning::\n            Specifying both ``num_cpus`` and ``num_gpus`` for map tasks is experimental,\n            and may result in scheduling or stability issues. Please\n            `report any issues <https://github.com/ray-project/ray/issues/new/choose>`_\n            to the Ray team.\n        Examples:\n            >>> # Return a single record per group (list of multiple records in,\n            >>> # list of a single record out).\n            >>> import ray\n            >>> import pandas as pd\n            >>> import numpy as np\n            >>> # Get first value per group.\n            >>> ds = ray.data.from_items([ # doctest: +SKIP\n            ...     {\"group\": 1, \"value\": 1},\n            ...     {\"group\": 1, \"value\": 2},\n            ...     {\"group\": 2, \"value\": 3},\n            ...     {\"group\": 2, \"value\": 4}])\n            >>> ds.groupby(\"group\").map_groups( # doctest: +SKIP\n            ...     lambda g: {\"result\": np.array([g[\"value\"][0]])})\n            >>> # Return multiple records per group (dataframe in, dataframe out).\n            >>> df = pd.DataFrame(\n            ...     {\"A\": [\"a\", \"a\", \"b\"], \"B\": [1, 1, 3], \"C\": [4, 6, 5]}\n            ... )\n            >>> ds = ray.data.from_pandas(df) # doctest: +SKIP\n            >>> grouped = ds.groupby(\"A\") # doctest: +SKIP\n            >>> grouped.map_groups( # doctest: +SKIP\n            ...     lambda g: g.apply(\n            ...         lambda c: c / g[c.name].sum() if c.name in [\"B\", \"C\"] else c\n            ...     )\n            ... ) # doctest: +SKIP\n        Args:\n            fn: The function to apply to each group of records, or a class type\n                that can be instantiated to create such a callable. It takes as\n                input a batch of all records from a single group, and returns a\n                batch of zero or more records, similar to map_batches().\n            zero_copy_batch: If True, each group of rows (batch) will be provided w/o\n                making an additional copy.\n            compute: This argument is deprecated. Use ``concurrency`` argument.\n            batch_format: Specify ``\"default\"`` to use the default block format\n                (NumPy), ``\"pandas\"`` to select ``pandas.DataFrame``, \"pyarrow\" to\n                select ``pyarrow.Table``, or ``\"numpy\"`` to select\n                ``Dict[str, numpy.ndarray]``, or None to return the underlying block\n                exactly as is with no additional formatting.\n            fn_args: Arguments to `fn`.\n            fn_kwargs: Keyword arguments to `fn`.\n            fn_constructor_args: Positional arguments to pass to ``fn``'s constructor.\n                You can only provide this if ``fn`` is a callable class. These arguments\n                are top-level arguments in the underlying Ray actor construction task.\n            fn_constructor_kwargs: Keyword arguments to pass to ``fn``'s constructor.\n                This can only be provided if ``fn`` is a callable class. These arguments\n                are top-level arguments in the underlying Ray actor construction task.\n            num_cpus: The number of CPUs to reserve for each parallel map worker.\n            num_gpus: The number of GPUs to reserve for each parallel map worker. For\n                example, specify `num_gpus=1` to request 1 GPU for each parallel map\n                worker.\n            memory: The heap memory in bytes to reserve for each parallel map worker.\n            ray_remote_args_fn: A function that returns a dictionary of remote args\n                passed to each map worker. The purpose of this argument is to generate\n                dynamic arguments for each actor or task, and will be called each time prior\n                to initializing the worker. Args returned from this dict will always\n                override the args in ``ray_remote_args``. Note: this is an advanced,\n                experimental feature.\n            concurrency: The semantics of this argument depend on the type of ``fn``:\n                * If ``fn`` is a function and ``concurrency`` isn't set (default), the\n                  actual concurrency is implicitly determined by the available\n                  resources and number of input blocks.\n                * If ``fn`` is a function and ``concurrency`` is an  int ``n``, Ray Data\n                  launches *at most* ``n`` concurrent tasks.\n                * If ``fn`` is a class and ``concurrency`` is an int ``n``, Ray Data\n                  uses an actor  pool with *exactly* ``n`` workers.\n                * If ``fn`` is a class and  ``concurrency`` is a tuple ``(m, n)``, Ray\n                  Data uses an autoscaling actor pool from ``m`` to ``n`` workers.\n                * If ``fn`` is a class and  ``concurrency`` is a tuple ``(m, n, initial)``, Ray\n                  Data uses an autoscaling actor pool from ``m`` to ``n`` workers, with an initial size of ``initial``.\n                * If ``fn`` is a class and ``concurrency`` isn't set (default), this\n                  method raises an error.\n            ray_remote_args: Additional resource requirements to request from\n                Ray (e.g., num_gpus=1 to request GPUs for the map tasks). See\n                :func:`ray.remote` for details.\n        Returns:\n            The return type is determined by the return type of ``fn``, and the return\n            value is combined from results of all groups.\n        .. seealso::\n            :meth:`GroupedData.aggregate`\n                Use this method for common aggregation use cases.\n        '''\n        pass\n\n            class wrapped_fn:\n\n    def __init__(self, dataset: Dataset, key: Optional[Union[str, List[str]]], *, num_partitions: Optional[int]):\n        pass\n\n                def __call__(self, batch, *args, **kwargs):\n                                pass\n\n            def wrapped_fn(batch, *args, **kwargs):\n                        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def count(self) -> Dataset:\n        '''Compute count aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": x % 3, \"B\": x} for x in range(100)]).groupby( # doctest: +SKIP\n            ...     \"A\").count() # doctest: +SKIP\n        Returns:\n            A dataset of ``[k, v]`` columns where ``k`` is the groupby key and\n            ``v`` is the number of rows with that key.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def sum(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        '''Compute grouped sum aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     (i % 3, i, i**2) # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(lambda x: x[0] % 3)  # doctest: +SKIP\n            ...     .sum(lambda x: x[2]) # doctest: +SKIP\n            >>> ray.data.range(100).groupby(\"id\").sum() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .sum([\"B\", \"C\"]) # doctest: +SKIP\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the sum; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n        Returns:\n            The sum result.\n            For different values of ``on``, the return varies:\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise sum column for each original column\n              in the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def min(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        '''Compute grouped min aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").min() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .min([\"B\", \"C\"]) # doctest: +SKIP\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the min; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n        Returns:\n            The min result.\n            For different values of ``on``, the return varies:\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise min column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def max(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        '''Compute grouped max aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").max() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .max([\"B\", \"C\"]) # doctest: +SKIP\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the max; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n        Returns:\n            The max result.\n            For different values of ``on``, the return varies:\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise max column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def mean(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        '''Compute grouped mean aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").mean() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .mean([\"B\", \"C\"]) # doctest: +SKIP\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the mean; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n        Returns:\n            The mean result.\n            For different values of ``on``, the return varies:\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise mean column for each original column\n              in the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def std(self, on: Union[str, List[str]]=None, ddof: int=1, ignore_nulls: bool=True) -> Dataset:\n        '''Compute grouped standard deviation aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.range(100).groupby(\"id\").std(ddof=0) # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .std([\"B\", \"C\"]) # doctest: +SKIP\n        NOTE: This uses Welford's online method for an accumulator-style\n        computation of the standard deviation. This method was chosen due to\n        it's numerical stability, and it being computable in a single pass.\n        This may give different (but more accurate) results than NumPy, Pandas,\n        and sklearn, which use a less numerically stable two-pass algorithm.\n        See\n        https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ddof: Delta Degrees of Freedom. The divisor used in calculations\n                is ``N - ddof``, where ``N`` represents the number of elements.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the std; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n        Returns:\n            The standard deviation result.\n            For different values of ``on``, the return varies:\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise std column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom ray.data._internal.compute import ComputeStrategy\nfrom ray.data.dataset import Dataset\nfrom ray.data.aggregate import AggregateFn, Count, Max, Mean, Min, Std, Sum\nfrom ray.data.context import ShuffleStrategy\nfrom ray.util.annotations import PublicAPI\nfrom ray.data.block import Block, BlockAccessor, CallableClass, DataBatch, UserDefinedFunction\nfrom typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Tuple, Union\nfrom ray.data._internal.logical.interfaces import LogicalPlan\nfrom functools import partial\nfrom ray.data._internal.logical.operators.all_to_all_operator import Aggregate\n\nclass GroupedData:\n    \"\"\"Represents a grouped dataset created by calling ``Dataset.groupby()``.\n\n    The actual groupby is deferred until an aggregation is applied.\n    \"\"\"\n\n    def __init__(self, dataset: Dataset, key: Optional[Union[str, List[str]]], *, num_partitions: Optional[int]):\n        \"\"\"Construct a dataset grouped by key (internal API).\n\n        The constructor is not part of the GroupedData API.\n        Use the ``Dataset.groupby()`` method to construct one.\n        \"\"\"\n        self._dataset: Dataset = dataset\n        self._key: Optional[Union[str, List[str]]] = key\n        self._num_partitions: Optional[int] = num_partitions\n\n    def __repr__(self) -> str:\n        return f'{self.__class__.__name__}(dataset={self._dataset}, key={self._key!r})'\n\n    @PublicAPI(api_group=FA_API_GROUP)\n    def aggregate(self, *aggs: AggregateFn) -> Dataset:\n        \"\"\"Implements an accumulator-based aggregation.\n\n        Args:\n            aggs: Aggregations to do.\n\n        Returns:\n            The output is an dataset of ``n + 1`` columns where the first column\n            is the groupby key and the second through ``n + 1`` columns are the\n            results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        plan = self._dataset._plan.copy()\n        op = Aggregate(self._dataset._logical_plan.dag, key=self._key, aggs=aggs, num_partitions=self._num_partitions)\n        logical_plan = LogicalPlan(op, self._dataset.context)\n        return Dataset(plan, logical_plan)\n\n    def _aggregate_on(self, agg_cls: type, on: Union[str, List[str]], *args, **kwargs):\n        \"\"\"Helper for aggregating on a particular subset of the dataset.\n\n        This validates the `on` argument, and converts a list of column names\n        to a multi-aggregation. A null `on` results in a\n        multi-aggregation on all columns for an Arrow Dataset, and a single\n        aggregation on the entire row for a simple Dataset.\n        \"\"\"\n        aggs = self._dataset._build_multicolumn_aggs(agg_cls, on, *args, skip_cols=self._key, **kwargs)\n        return self.aggregate(*aggs)\n\n    @PublicAPI(api_group=FA_API_GROUP)\n    def map_groups(self, fn: UserDefinedFunction[DataBatch, DataBatch], *, zero_copy_batch: bool=False, compute: Union[str, ComputeStrategy]=None, batch_format: Optional[str]='default', fn_args: Optional[Iterable[Any]]=None, fn_kwargs: Optional[Dict[str, Any]]=None, fn_constructor_args: Optional[Iterable[Any]]=None, fn_constructor_kwargs: Optional[Dict[str, Any]]=None, num_cpus: Optional[float]=None, num_gpus: Optional[float]=None, memory: Optional[float]=None, concurrency: Optional[Union[int, Tuple[int, int], Tuple[int, int, int]]]=None, ray_remote_args_fn: Optional[Callable[[], Dict[str, Any]]]=None, **ray_remote_args) -> 'Dataset':\n        \"\"\"Apply the given function to each group of records of this dataset.\n\n        While map_groups() is very flexible, note that it comes with downsides:\n\n        * It may be slower than using more specific methods such as min(), max().\n        * It requires that each group fits in memory on a single node.\n\n        In general, prefer to use `aggregate()` instead of `map_groups()`.\n\n        .. warning::\n            Specifying both ``num_cpus`` and ``num_gpus`` for map tasks is experimental,\n            and may result in scheduling or stability issues. Please\n            `report any issues <https://github.com/ray-project/ray/issues/new/choose>`_\n            to the Ray team.\n\n        Examples:\n            >>> # Return a single record per group (list of multiple records in,\n            >>> # list of a single record out).\n            >>> import ray\n            >>> import pandas as pd\n            >>> import numpy as np\n            >>> # Get first value per group.\n            >>> ds = ray.data.from_items([ # doctest: +SKIP\n            ...     {\"group\": 1, \"value\": 1},\n            ...     {\"group\": 1, \"value\": 2},\n            ...     {\"group\": 2, \"value\": 3},\n            ...     {\"group\": 2, \"value\": 4}])\n            >>> ds.groupby(\"group\").map_groups( # doctest: +SKIP\n            ...     lambda g: {\"result\": np.array([g[\"value\"][0]])})\n\n            >>> # Return multiple records per group (dataframe in, dataframe out).\n            >>> df = pd.DataFrame(\n            ...     {\"A\": [\"a\", \"a\", \"b\"], \"B\": [1, 1, 3], \"C\": [4, 6, 5]}\n            ... )\n            >>> ds = ray.data.from_pandas(df) # doctest: +SKIP\n            >>> grouped = ds.groupby(\"A\") # doctest: +SKIP\n            >>> grouped.map_groups( # doctest: +SKIP\n            ...     lambda g: g.apply(\n            ...         lambda c: c / g[c.name].sum() if c.name in [\"B\", \"C\"] else c\n            ...     )\n            ... ) # doctest: +SKIP\n\n        Args:\n            fn: The function to apply to each group of records, or a class type\n                that can be instantiated to create such a callable. It takes as\n                input a batch of all records from a single group, and returns a\n                batch of zero or more records, similar to map_batches().\n            zero_copy_batch: If True, each group of rows (batch) will be provided w/o\n                making an additional copy.\n            compute: This argument is deprecated. Use ``concurrency`` argument.\n            batch_format: Specify ``\"default\"`` to use the default block format\n                (NumPy), ``\"pandas\"`` to select ``pandas.DataFrame``, \"pyarrow\" to\n                select ``pyarrow.Table``, or ``\"numpy\"`` to select\n                ``Dict[str, numpy.ndarray]``, or None to return the underlying block\n                exactly as is with no additional formatting.\n            fn_args: Arguments to `fn`.\n            fn_kwargs: Keyword arguments to `fn`.\n            fn_constructor_args: Positional arguments to pass to ``fn``'s constructor.\n                You can only provide this if ``fn`` is a callable class. These arguments\n                are top-level arguments in the underlying Ray actor construction task.\n            fn_constructor_kwargs: Keyword arguments to pass to ``fn``'s constructor.\n                This can only be provided if ``fn`` is a callable class. These arguments\n                are top-level arguments in the underlying Ray actor construction task.\n            num_cpus: The number of CPUs to reserve for each parallel map worker.\n            num_gpus: The number of GPUs to reserve for each parallel map worker. For\n                example, specify `num_gpus=1` to request 1 GPU for each parallel map\n                worker.\n            memory: The heap memory in bytes to reserve for each parallel map worker.\n            ray_remote_args_fn: A function that returns a dictionary of remote args\n                passed to each map worker. The purpose of this argument is to generate\n                dynamic arguments for each actor or task, and will be called each time prior\n                to initializing the worker. Args returned from this dict will always\n                override the args in ``ray_remote_args``. Note: this is an advanced,\n                experimental feature.\n            concurrency: The semantics of this argument depend on the type of ``fn``:\n\n                * If ``fn`` is a function and ``concurrency`` isn't set (default), the\n                  actual concurrency is implicitly determined by the available\n                  resources and number of input blocks.\n\n                * If ``fn`` is a function and ``concurrency`` is an  int ``n``, Ray Data\n                  launches *at most* ``n`` concurrent tasks.\n\n                * If ``fn`` is a class and ``concurrency`` is an int ``n``, Ray Data\n                  uses an actor  pool with *exactly* ``n`` workers.\n\n                * If ``fn`` is a class and  ``concurrency`` is a tuple ``(m, n)``, Ray\n                  Data uses an autoscaling actor pool from ``m`` to ``n`` workers.\n\n                * If ``fn`` is a class and  ``concurrency`` is a tuple ``(m, n, initial)``, Ray\n                  Data uses an autoscaling actor pool from ``m`` to ``n`` workers, with an initial size of ``initial``.\n\n                * If ``fn`` is a class and ``concurrency`` isn't set (default), this\n                  method raises an error.\n\n            ray_remote_args: Additional resource requirements to request from\n                Ray (e.g., num_gpus=1 to request GPUs for the map tasks). See\n                :func:`ray.remote` for details.\n\n        Returns:\n            The return type is determined by the return type of ``fn``, and the return\n            value is combined from results of all groups.\n\n        .. seealso::\n\n            :meth:`GroupedData.aggregate`\n                Use this method for common aggregation use cases.\n        \"\"\"\n        if self._key is None:\n            shuffled_ds = self._dataset.repartition(1)\n        elif self._dataset.context.shuffle_strategy == ShuffleStrategy.HASH_SHUFFLE:\n            num_partitions = self._num_partitions or self._dataset.context.default_hash_shuffle_parallelism\n            shuffled_ds = self._dataset.repartition(num_partitions, keys=self._key, sort=True)\n        else:\n            shuffled_ds = self._dataset.sort(self._key)\n        if self._key is None:\n            keys = []\n        elif isinstance(self._key, str):\n            keys = [self._key]\n        elif isinstance(self._key, List):\n            keys = self._key\n        else:\n            raise ValueError(f\"Group-by keys are expected to either be a single column (str) or a list of columns (got '{self._key}')\")\n        if isinstance(fn, CallableClass):\n\n            class wrapped_fn:\n\n                def __init__(self, *args, **kwargs):\n                    self.fn = fn(*args, **kwargs)\n\n                def __call__(self, batch, *args, **kwargs):\n                    yield from _apply_udf_to_groups(self.fn, batch, keys, batch_format, *args, **kwargs)\n        else:\n\n            def wrapped_fn(batch, *args, **kwargs):\n                yield from _apply_udf_to_groups(fn, batch, keys, batch_format, *args, **kwargs)\n        if isinstance(fn, partial):\n            wrapped_fn.__name__ = fn.func.__name__\n        else:\n            wrapped_fn.__name__ = fn.__name__\n        return shuffled_ds._map_batches_without_batch_size_validation(wrapped_fn, batch_size=None, compute=compute, batch_format=None, zero_copy_batch=zero_copy_batch, fn_args=fn_args, fn_kwargs=fn_kwargs, fn_constructor_args=fn_constructor_args, fn_constructor_kwargs=fn_constructor_kwargs, num_cpus=num_cpus, num_gpus=num_gpus, memory=memory, concurrency=concurrency, ray_remote_args_fn=ray_remote_args_fn, **ray_remote_args)\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def count(self) -> Dataset:\n        \"\"\"Compute count aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": x % 3, \"B\": x} for x in range(100)]).groupby( # doctest: +SKIP\n            ...     \"A\").count() # doctest: +SKIP\n\n        Returns:\n            A dataset of ``[k, v]`` columns where ``k`` is the groupby key and\n            ``v`` is the number of rows with that key.\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self.aggregate(Count())\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def sum(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        \"\"\"Compute grouped sum aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     (i % 3, i, i**2) # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(lambda x: x[0] % 3)  # doctest: +SKIP\n            ...     .sum(lambda x: x[2]) # doctest: +SKIP\n            >>> ray.data.range(100).groupby(\"id\").sum() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .sum([\"B\", \"C\"]) # doctest: +SKIP\n\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the sum; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n\n        Returns:\n            The sum result.\n\n            For different values of ``on``, the return varies:\n\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise sum column for each original column\n              in the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self._aggregate_on(Sum, on, ignore_nulls=ignore_nulls)\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def min(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        \"\"\"Compute grouped min aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").min() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .min([\"B\", \"C\"]) # doctest: +SKIP\n\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the min; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n\n        Returns:\n            The min result.\n\n            For different values of ``on``, the return varies:\n\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise min column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self._aggregate_on(Min, on, ignore_nulls=ignore_nulls)\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def max(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        \"\"\"Compute grouped max aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").max() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .max([\"B\", \"C\"]) # doctest: +SKIP\n\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the max; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n\n        Returns:\n            The max result.\n\n            For different values of ``on``, the return varies:\n\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise max column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self._aggregate_on(Max, on, ignore_nulls=ignore_nulls)\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def mean(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        \"\"\"Compute grouped mean aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").mean() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .mean([\"B\", \"C\"]) # doctest: +SKIP\n\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the mean; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n\n        Returns:\n            The mean result.\n\n            For different values of ``on``, the return varies:\n\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise mean column for each original column\n              in the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self._aggregate_on(Mean, on, ignore_nulls=ignore_nulls)\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def std(self, on: Union[str, List[str]]=None, ddof: int=1, ignore_nulls: bool=True) -> Dataset:\n        \"\"\"Compute grouped standard deviation aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.range(100).groupby(\"id\").std(ddof=0) # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .std([\"B\", \"C\"]) # doctest: +SKIP\n\n        NOTE: This uses Welford's online method for an accumulator-style\n        computation of the standard deviation. This method was chosen due to\n        it's numerical stability, and it being computable in a single pass.\n        This may give different (but more accurate) results than NumPy, Pandas,\n        and sklearn, which use a less numerically stable two-pass algorithm.\n        See\n        https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm\n\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ddof: Delta Degrees of Freedom. The divisor used in calculations\n                is ``N - ddof``, where ``N`` represents the number of elements.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the std; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n\n        Returns:\n            The standard deviation result.\n\n            For different values of ``on``, the return varies:\n\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise std column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self._aggregate_on(Std, on, ignore_nulls=ignore_nulls, ddof=ddof)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass ParallelTopoMapperGroup:\n    '''\n    A class to represent a group of weight sharing topology maps used for weight synchronization.\n    This class manages multiple ParallelTopoMapper instances, each corresponding to a different parallelism strategy.\n    Different model parts may have different parallelism strategies in one whole model.\n    It is used to prepare local shard information for parameters based on the parallelism configuration.\n    It clusters parameters by model part and prepares local shard information for each part.\n    '''\n\n    def __init__(self, global_parallelism: ParallelDims, hf_config: Any, is_policy: bool, underlying_model: Any, backend: str='vllm', weight_mapper: Optional[WeightMapper]=None):\n        '''\n        Initialize the ParallelTopoMapperGroup with the given parallelism configurations.\n        :param global_parallelism: The parallelism config for the policy or rollout.\n        :param hf_config: The huggingface config.\n        :param is_policy: A boolean indicating if this is for policy parallelism.\n        :param underlying_model: The underlying model for which the parallelism map is created.\n        :param weight_mapper: An optional WeightMapper instance. If None, a default mapper is used based on the model type from hf_config.\n        '''\n        pass\n\n    def _cluster_params_by_model_part(self, params: List[Tuple[str, int]]) -> List[List[Tuple[str, int]]]:\n        '''\n        Resort the parameters based on the name mapper.\n        :param params: The parameters to resort.\n        :return: A list of tuples containing the resorted parameters separated by different model parts.\n        '''\n        pass\n\n    def prepare_local_shard_infos(self, hf_key_n_rank: List[Tuple[str, int]], global_rank: int) -> Dict[str, Any]:\n        '''\n        Prepare local shard information for the given parameters based on the parallelism configuration.\n        :param hf_key_n_rank: A list of tuples containing the parameter names and their shape ranks.\n        :param global_rank: The global rank to prepare local shard information for.\n        :return: A dictionary containing the local shard information for each parameter of that rank.\n        '''\n        pass"
  }
]