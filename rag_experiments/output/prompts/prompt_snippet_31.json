[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass GroupedData:\n    '''Represents a grouped dataset created by calling ``Dataset.groupby()``.\n    The actual groupby is deferred until an aggregation is applied.\n        '''\n\n    def __init__(self, dataset: Dataset, key: Optional[Union[str, List[str]]], *, num_partitions: Optional[int]):\n        '''Construct a dataset grouped by key (internal API).\n        The constructor is not part of the GroupedData API.\n        Use the ``Dataset.groupby()`` method to construct one.\n        '''\n        pass\n\n    def __repr__(self) -> str:\n        pass\n    @PublicAPI(api_group=FA_API_GROUP)\n    def aggregate(self, *aggs: AggregateFn) -> Dataset:\n        '''Implements an accumulator-based aggregation.\n        Args:\n            aggs: Aggregations to do.\n        Returns:\n            The output is an dataset of ``n + 1`` columns where the first column\n            is the groupby key and the second through ``n + 1`` columns are the\n            results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n\n    def _aggregate_on(self, agg_cls: type, on: Union[str, List[str]], *args, **kwargs):\n        '''Helper for aggregating on a particular subset of the dataset.\n        This validates the `on` argument, and converts a list of column names\n        to a multi-aggregation. A null `on` results in a\n        multi-aggregation on all columns for an Arrow Dataset, and a single\n        aggregation on the entire row for a simple Dataset.\n        '''\n        pass\n    @PublicAPI(api_group=FA_API_GROUP)\n    def map_groups(self, fn: UserDefinedFunction[DataBatch, DataBatch], *, zero_copy_batch: bool=False, compute: Union[str, ComputeStrategy]=None, batch_format: Optional[str]='default', fn_args: Optional[Iterable[Any]]=None, fn_kwargs: Optional[Dict[str, Any]]=None, fn_constructor_args: Optional[Iterable[Any]]=None, fn_constructor_kwargs: Optional[Dict[str, Any]]=None, num_cpus: Optional[float]=None, num_gpus: Optional[float]=None, memory: Optional[float]=None, concurrency: Optional[Union[int, Tuple[int, int], Tuple[int, int, int]]]=None, ray_remote_args_fn: Optional[Callable[[], Dict[str, Any]]]=None, **ray_remote_args) -> 'Dataset':\n        '''Apply the given function to each group of records of this dataset.\n        While map_groups() is very flexible, note that it comes with downsides:\n        * It may be slower than using more specific methods such as min(), max().\n        * It requires that each group fits in memory on a single node.\n        In general, prefer to use `aggregate()` instead of `map_groups()`.\n        .. warning::\n            Specifying both ``num_cpus`` and ``num_gpus`` for map tasks is experimental,\n            and may result in scheduling or stability issues. Please\n            `report any issues <https://github.com/ray-project/ray/issues/new/choose>`_\n            to the Ray team.\n        Examples:\n            >>> # Return a single record per group (list of multiple records in,\n            >>> # list of a single record out).\n            >>> import ray\n            >>> import pandas as pd\n            >>> import numpy as np\n            >>> # Get first value per group.\n            >>> ds = ray.data.from_items([ # doctest: +SKIP\n            ...     {\"group\": 1, \"value\": 1},\n            ...     {\"group\": 1, \"value\": 2},\n            ...     {\"group\": 2, \"value\": 3},\n            ...     {\"group\": 2, \"value\": 4}])\n            >>> ds.groupby(\"group\").map_groups( # doctest: +SKIP\n            ...     lambda g: {\"result\": np.array([g[\"value\"][0]])})\n            >>> # Return multiple records per group (dataframe in, dataframe out).\n            >>> df = pd.DataFrame(\n            ...     {\"A\": [\"a\", \"a\", \"b\"], \"B\": [1, 1, 3], \"C\": [4, 6, 5]}\n            ... )\n            >>> ds = ray.data.from_pandas(df) # doctest: +SKIP\n            >>> grouped = ds.groupby(\"A\") # doctest: +SKIP\n            >>> grouped.map_groups( # doctest: +SKIP\n            ...     lambda g: g.apply(\n            ...         lambda c: c / g[c.name].sum() if c.name in [\"B\", \"C\"] else c\n            ...     )\n            ... ) # doctest: +SKIP\n        Args:\n            fn: The function to apply to each group of records, or a class type\n                that can be instantiated to create such a callable. It takes as\n                input a batch of all records from a single group, and returns a\n                batch of zero or more records, similar to map_batches().\n            zero_copy_batch: If True, each group of rows (batch) will be provided w/o\n                making an additional copy.\n            compute: This argument is deprecated. Use ``concurrency`` argument.\n            batch_format: Specify ``\"default\"`` to use the default block format\n                (NumPy), ``\"pandas\"`` to select ``pandas.DataFrame``, \"pyarrow\" to\n                select ``pyarrow.Table``, or ``\"numpy\"`` to select\n                ``Dict[str, numpy.ndarray]``, or None to return the underlying block\n                exactly as is with no additional formatting.\n            fn_args: Arguments to `fn`.\n            fn_kwargs: Keyword arguments to `fn`.\n            fn_constructor_args: Positional arguments to pass to ``fn``'s constructor.\n                You can only provide this if ``fn`` is a callable class. These arguments\n                are top-level arguments in the underlying Ray actor construction task.\n            fn_constructor_kwargs: Keyword arguments to pass to ``fn``'s constructor.\n                This can only be provided if ``fn`` is a callable class. These arguments\n                are top-level arguments in the underlying Ray actor construction task.\n            num_cpus: The number of CPUs to reserve for each parallel map worker.\n            num_gpus: The number of GPUs to reserve for each parallel map worker. For\n                example, specify `num_gpus=1` to request 1 GPU for each parallel map\n                worker.\n            memory: The heap memory in bytes to reserve for each parallel map worker.\n            ray_remote_args_fn: A function that returns a dictionary of remote args\n                passed to each map worker. The purpose of this argument is to generate\n                dynamic arguments for each actor or task, and will be called each time prior\n                to initializing the worker. Args returned from this dict will always\n                override the args in ``ray_remote_args``. Note: this is an advanced,\n                experimental feature.\n            concurrency: The semantics of this argument depend on the type of ``fn``:\n                * If ``fn`` is a function and ``concurrency`` isn't set (default), the\n                  actual concurrency is implicitly determined by the available\n                  resources and number of input blocks.\n                * If ``fn`` is a function and ``concurrency`` is an  int ``n``, Ray Data\n                  launches *at most* ``n`` concurrent tasks.\n                * If ``fn`` is a class and ``concurrency`` is an int ``n``, Ray Data\n                  uses an actor  pool with *exactly* ``n`` workers.\n                * If ``fn`` is a class and  ``concurrency`` is a tuple ``(m, n)``, Ray\n                  Data uses an autoscaling actor pool from ``m`` to ``n`` workers.\n                * If ``fn`` is a class and  ``concurrency`` is a tuple ``(m, n, initial)``, Ray\n                  Data uses an autoscaling actor pool from ``m`` to ``n`` workers, with an initial size of ``initial``.\n                * If ``fn`` is a class and ``concurrency`` isn't set (default), this\n                  method raises an error.\n            ray_remote_args: Additional resource requirements to request from\n                Ray (e.g., num_gpus=1 to request GPUs for the map tasks). See\n                :func:`ray.remote` for details.\n        Returns:\n            The return type is determined by the return type of ``fn``, and the return\n            value is combined from results of all groups.\n        .. seealso::\n            :meth:`GroupedData.aggregate`\n                Use this method for common aggregation use cases.\n        '''\n        pass\n\n            class wrapped_fn:\n\n    def __init__(self, dataset: Dataset, key: Optional[Union[str, List[str]]], *, num_partitions: Optional[int]):\n        pass\n\n                def __call__(self, batch, *args, **kwargs):\n                                pass\n\n            def wrapped_fn(batch, *args, **kwargs):\n                        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def count(self) -> Dataset:\n        '''Compute count aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": x % 3, \"B\": x} for x in range(100)]).groupby( # doctest: +SKIP\n            ...     \"A\").count() # doctest: +SKIP\n        Returns:\n            A dataset of ``[k, v]`` columns where ``k`` is the groupby key and\n            ``v`` is the number of rows with that key.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def sum(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        '''Compute grouped sum aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     (i % 3, i, i**2) # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(lambda x: x[0] % 3)  # doctest: +SKIP\n            ...     .sum(lambda x: x[2]) # doctest: +SKIP\n            >>> ray.data.range(100).groupby(\"id\").sum() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .sum([\"B\", \"C\"]) # doctest: +SKIP\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the sum; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n        Returns:\n            The sum result.\n            For different values of ``on``, the return varies:\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise sum column for each original column\n              in the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def min(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        '''Compute grouped min aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").min() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .min([\"B\", \"C\"]) # doctest: +SKIP\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the min; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n        Returns:\n            The min result.\n            For different values of ``on``, the return varies:\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise min column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def max(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        '''Compute grouped max aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").max() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .max([\"B\", \"C\"]) # doctest: +SKIP\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the max; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n        Returns:\n            The max result.\n            For different values of ``on``, the return varies:\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise max column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def mean(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        '''Compute grouped mean aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").mean() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .mean([\"B\", \"C\"]) # doctest: +SKIP\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the mean; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n        Returns:\n            The mean result.\n            For different values of ``on``, the return varies:\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise mean column for each original column\n              in the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def std(self, on: Union[str, List[str]]=None, ddof: int=1, ignore_nulls: bool=True) -> Dataset:\n        '''Compute grouped standard deviation aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.range(100).groupby(\"id\").std(ddof=0) # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .std([\"B\", \"C\"]) # doctest: +SKIP\n        NOTE: This uses Welford's online method for an accumulator-style\n        computation of the standard deviation. This method was chosen due to\n        it's numerical stability, and it being computable in a single pass.\n        This may give different (but more accurate) results than NumPy, Pandas,\n        and sklearn, which use a less numerically stable two-pass algorithm.\n        See\n        https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ddof: Delta Degrees of Freedom. The divisor used in calculations\n                is ``N - ddof``, where ``N`` represents the number of elements.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the std; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n        Returns:\n            The standard deviation result.\n            For different values of ``on``, the return varies:\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise std column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom ray.data._internal.compute import ComputeStrategy\nfrom ray.data.dataset import Dataset\nfrom ray.data.aggregate import AggregateFn, Count, Max, Mean, Min, Std, Sum\nfrom ray.data.context import ShuffleStrategy\nfrom ray.util.annotations import PublicAPI\nfrom ray.data.block import Block, BlockAccessor, CallableClass, DataBatch, UserDefinedFunction\nfrom typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Tuple, Union\nfrom ray.data._internal.logical.interfaces import LogicalPlan\nfrom functools import partial\nfrom ray.data._internal.logical.operators.all_to_all_operator import Aggregate\n\nclass GroupedData:\n    \"\"\"Represents a grouped dataset created by calling ``Dataset.groupby()``.\n\n    The actual groupby is deferred until an aggregation is applied.\n    \"\"\"\n\n    def __init__(self, dataset: Dataset, key: Optional[Union[str, List[str]]], *, num_partitions: Optional[int]):\n        \"\"\"Construct a dataset grouped by key (internal API).\n\n        The constructor is not part of the GroupedData API.\n        Use the ``Dataset.groupby()`` method to construct one.\n        \"\"\"\n        self._dataset: Dataset = dataset\n        self._key: Optional[Union[str, List[str]]] = key\n        self._num_partitions: Optional[int] = num_partitions\n\n    def __repr__(self) -> str:\n        return f'{self.__class__.__name__}(dataset={self._dataset}, key={self._key!r})'\n\n    @PublicAPI(api_group=FA_API_GROUP)\n    def aggregate(self, *aggs: AggregateFn) -> Dataset:\n        \"\"\"Implements an accumulator-based aggregation.\n\n        Args:\n            aggs: Aggregations to do.\n\n        Returns:\n            The output is an dataset of ``n + 1`` columns where the first column\n            is the groupby key and the second through ``n + 1`` columns are the\n            results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        plan = self._dataset._plan.copy()\n        op = Aggregate(self._dataset._logical_plan.dag, key=self._key, aggs=aggs, num_partitions=self._num_partitions)\n        logical_plan = LogicalPlan(op, self._dataset.context)\n        return Dataset(plan, logical_plan)\n\n    def _aggregate_on(self, agg_cls: type, on: Union[str, List[str]], *args, **kwargs):\n        \"\"\"Helper for aggregating on a particular subset of the dataset.\n\n        This validates the `on` argument, and converts a list of column names\n        to a multi-aggregation. A null `on` results in a\n        multi-aggregation on all columns for an Arrow Dataset, and a single\n        aggregation on the entire row for a simple Dataset.\n        \"\"\"\n        aggs = self._dataset._build_multicolumn_aggs(agg_cls, on, *args, skip_cols=self._key, **kwargs)\n        return self.aggregate(*aggs)\n\n    @PublicAPI(api_group=FA_API_GROUP)\n    def map_groups(self, fn: UserDefinedFunction[DataBatch, DataBatch], *, zero_copy_batch: bool=False, compute: Union[str, ComputeStrategy]=None, batch_format: Optional[str]='default', fn_args: Optional[Iterable[Any]]=None, fn_kwargs: Optional[Dict[str, Any]]=None, fn_constructor_args: Optional[Iterable[Any]]=None, fn_constructor_kwargs: Optional[Dict[str, Any]]=None, num_cpus: Optional[float]=None, num_gpus: Optional[float]=None, memory: Optional[float]=None, concurrency: Optional[Union[int, Tuple[int, int], Tuple[int, int, int]]]=None, ray_remote_args_fn: Optional[Callable[[], Dict[str, Any]]]=None, **ray_remote_args) -> 'Dataset':\n        \"\"\"Apply the given function to each group of records of this dataset.\n\n        While map_groups() is very flexible, note that it comes with downsides:\n\n        * It may be slower than using more specific methods such as min(), max().\n        * It requires that each group fits in memory on a single node.\n\n        In general, prefer to use `aggregate()` instead of `map_groups()`.\n\n        .. warning::\n            Specifying both ``num_cpus`` and ``num_gpus`` for map tasks is experimental,\n            and may result in scheduling or stability issues. Please\n            `report any issues <https://github.com/ray-project/ray/issues/new/choose>`_\n            to the Ray team.\n\n        Examples:\n            >>> # Return a single record per group (list of multiple records in,\n            >>> # list of a single record out).\n            >>> import ray\n            >>> import pandas as pd\n            >>> import numpy as np\n            >>> # Get first value per group.\n            >>> ds = ray.data.from_items([ # doctest: +SKIP\n            ...     {\"group\": 1, \"value\": 1},\n            ...     {\"group\": 1, \"value\": 2},\n            ...     {\"group\": 2, \"value\": 3},\n            ...     {\"group\": 2, \"value\": 4}])\n            >>> ds.groupby(\"group\").map_groups( # doctest: +SKIP\n            ...     lambda g: {\"result\": np.array([g[\"value\"][0]])})\n\n            >>> # Return multiple records per group (dataframe in, dataframe out).\n            >>> df = pd.DataFrame(\n            ...     {\"A\": [\"a\", \"a\", \"b\"], \"B\": [1, 1, 3], \"C\": [4, 6, 5]}\n            ... )\n            >>> ds = ray.data.from_pandas(df) # doctest: +SKIP\n            >>> grouped = ds.groupby(\"A\") # doctest: +SKIP\n            >>> grouped.map_groups( # doctest: +SKIP\n            ...     lambda g: g.apply(\n            ...         lambda c: c / g[c.name].sum() if c.name in [\"B\", \"C\"] else c\n            ...     )\n            ... ) # doctest: +SKIP\n\n        Args:\n            fn: The function to apply to each group of records, or a class type\n                that can be instantiated to create such a callable. It takes as\n                input a batch of all records from a single group, and returns a\n                batch of zero or more records, similar to map_batches().\n            zero_copy_batch: If True, each group of rows (batch) will be provided w/o\n                making an additional copy.\n            compute: This argument is deprecated. Use ``concurrency`` argument.\n            batch_format: Specify ``\"default\"`` to use the default block format\n                (NumPy), ``\"pandas\"`` to select ``pandas.DataFrame``, \"pyarrow\" to\n                select ``pyarrow.Table``, or ``\"numpy\"`` to select\n                ``Dict[str, numpy.ndarray]``, or None to return the underlying block\n                exactly as is with no additional formatting.\n            fn_args: Arguments to `fn`.\n            fn_kwargs: Keyword arguments to `fn`.\n            fn_constructor_args: Positional arguments to pass to ``fn``'s constructor.\n                You can only provide this if ``fn`` is a callable class. These arguments\n                are top-level arguments in the underlying Ray actor construction task.\n            fn_constructor_kwargs: Keyword arguments to pass to ``fn``'s constructor.\n                This can only be provided if ``fn`` is a callable class. These arguments\n                are top-level arguments in the underlying Ray actor construction task.\n            num_cpus: The number of CPUs to reserve for each parallel map worker.\n            num_gpus: The number of GPUs to reserve for each parallel map worker. For\n                example, specify `num_gpus=1` to request 1 GPU for each parallel map\n                worker.\n            memory: The heap memory in bytes to reserve for each parallel map worker.\n            ray_remote_args_fn: A function that returns a dictionary of remote args\n                passed to each map worker. The purpose of this argument is to generate\n                dynamic arguments for each actor or task, and will be called each time prior\n                to initializing the worker. Args returned from this dict will always\n                override the args in ``ray_remote_args``. Note: this is an advanced,\n                experimental feature.\n            concurrency: The semantics of this argument depend on the type of ``fn``:\n\n                * If ``fn`` is a function and ``concurrency`` isn't set (default), the\n                  actual concurrency is implicitly determined by the available\n                  resources and number of input blocks.\n\n                * If ``fn`` is a function and ``concurrency`` is an  int ``n``, Ray Data\n                  launches *at most* ``n`` concurrent tasks.\n\n                * If ``fn`` is a class and ``concurrency`` is an int ``n``, Ray Data\n                  uses an actor  pool with *exactly* ``n`` workers.\n\n                * If ``fn`` is a class and  ``concurrency`` is a tuple ``(m, n)``, Ray\n                  Data uses an autoscaling actor pool from ``m`` to ``n`` workers.\n\n                * If ``fn`` is a class and  ``concurrency`` is a tuple ``(m, n, initial)``, Ray\n                  Data uses an autoscaling actor pool from ``m`` to ``n`` workers, with an initial size of ``initial``.\n\n                * If ``fn`` is a class and ``concurrency`` isn't set (default), this\n                  method raises an error.\n\n            ray_remote_args: Additional resource requirements to request from\n                Ray (e.g., num_gpus=1 to request GPUs for the map tasks). See\n                :func:`ray.remote` for details.\n\n        Returns:\n            The return type is determined by the return type of ``fn``, and the return\n            value is combined from results of all groups.\n\n        .. seealso::\n\n            :meth:`GroupedData.aggregate`\n                Use this method for common aggregation use cases.\n        \"\"\"\n        if self._key is None:\n            shuffled_ds = self._dataset.repartition(1)\n        elif self._dataset.context.shuffle_strategy == ShuffleStrategy.HASH_SHUFFLE:\n            num_partitions = self._num_partitions or self._dataset.context.default_hash_shuffle_parallelism\n            shuffled_ds = self._dataset.repartition(num_partitions, keys=self._key, sort=True)\n        else:\n            shuffled_ds = self._dataset.sort(self._key)\n        if self._key is None:\n            keys = []\n        elif isinstance(self._key, str):\n            keys = [self._key]\n        elif isinstance(self._key, List):\n            keys = self._key\n        else:\n            raise ValueError(f\"Group-by keys are expected to either be a single column (str) or a list of columns (got '{self._key}')\")\n        if isinstance(fn, CallableClass):\n\n            class wrapped_fn:\n\n                def __init__(self, *args, **kwargs):\n                    self.fn = fn(*args, **kwargs)\n\n                def __call__(self, batch, *args, **kwargs):\n                    yield from _apply_udf_to_groups(self.fn, batch, keys, batch_format, *args, **kwargs)\n        else:\n\n            def wrapped_fn(batch, *args, **kwargs):\n                yield from _apply_udf_to_groups(fn, batch, keys, batch_format, *args, **kwargs)\n        if isinstance(fn, partial):\n            wrapped_fn.__name__ = fn.func.__name__\n        else:\n            wrapped_fn.__name__ = fn.__name__\n        return shuffled_ds._map_batches_without_batch_size_validation(wrapped_fn, batch_size=None, compute=compute, batch_format=None, zero_copy_batch=zero_copy_batch, fn_args=fn_args, fn_kwargs=fn_kwargs, fn_constructor_args=fn_constructor_args, fn_constructor_kwargs=fn_constructor_kwargs, num_cpus=num_cpus, num_gpus=num_gpus, memory=memory, concurrency=concurrency, ray_remote_args_fn=ray_remote_args_fn, **ray_remote_args)\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def count(self) -> Dataset:\n        \"\"\"Compute count aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": x % 3, \"B\": x} for x in range(100)]).groupby( # doctest: +SKIP\n            ...     \"A\").count() # doctest: +SKIP\n\n        Returns:\n            A dataset of ``[k, v]`` columns where ``k`` is the groupby key and\n            ``v`` is the number of rows with that key.\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self.aggregate(Count())\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def sum(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        \"\"\"Compute grouped sum aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     (i % 3, i, i**2) # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(lambda x: x[0] % 3)  # doctest: +SKIP\n            ...     .sum(lambda x: x[2]) # doctest: +SKIP\n            >>> ray.data.range(100).groupby(\"id\").sum() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .sum([\"B\", \"C\"]) # doctest: +SKIP\n\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the sum; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n\n        Returns:\n            The sum result.\n\n            For different values of ``on``, the return varies:\n\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise sum column for each original column\n              in the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self._aggregate_on(Sum, on, ignore_nulls=ignore_nulls)\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def min(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        \"\"\"Compute grouped min aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").min() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .min([\"B\", \"C\"]) # doctest: +SKIP\n\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the min; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n\n        Returns:\n            The min result.\n\n            For different values of ``on``, the return varies:\n\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise min column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self._aggregate_on(Min, on, ignore_nulls=ignore_nulls)\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def max(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        \"\"\"Compute grouped max aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").max() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .max([\"B\", \"C\"]) # doctest: +SKIP\n\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the max; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n\n        Returns:\n            The max result.\n\n            For different values of ``on``, the return varies:\n\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise max column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self._aggregate_on(Max, on, ignore_nulls=ignore_nulls)\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def mean(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        \"\"\"Compute grouped mean aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").mean() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .mean([\"B\", \"C\"]) # doctest: +SKIP\n\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the mean; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n\n        Returns:\n            The mean result.\n\n            For different values of ``on``, the return varies:\n\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise mean column for each original column\n              in the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self._aggregate_on(Mean, on, ignore_nulls=ignore_nulls)\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def std(self, on: Union[str, List[str]]=None, ddof: int=1, ignore_nulls: bool=True) -> Dataset:\n        \"\"\"Compute grouped standard deviation aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.range(100).groupby(\"id\").std(ddof=0) # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .std([\"B\", \"C\"]) # doctest: +SKIP\n\n        NOTE: This uses Welford's online method for an accumulator-style\n        computation of the standard deviation. This method was chosen due to\n        it's numerical stability, and it being computable in a single pass.\n        This may give different (but more accurate) results than NumPy, Pandas,\n        and sklearn, which use a less numerically stable two-pass algorithm.\n        See\n        https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm\n\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ddof: Delta Degrees of Freedom. The divisor used in calculations\n                is ``N - ddof``, where ``N`` represents the number of elements.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the std; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n\n        Returns:\n            The standard deviation result.\n\n            For different values of ``on``, the return varies:\n\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise std column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self._aggregate_on(Std, on, ignore_nulls=ignore_nulls, ddof=ddof)\n\nExample skeleton:\n\n\nclass ScatterPlot(PluginInterface):\n    '''A Scatter Plot Plugin for Feature Sets.'''\n\n    def __init__(self, show_axes: bool=True):\n        '''Initialize the Scatter Plot Plugin\n        Args:\n            show_axes (bool): Whether to show the axes and grid. Default is True.\n        '''\n        pass\n\n    def create_component(self, component_id: str) -> html.Div:\n        '''Create a Dash Graph Component without any data.\n        Args:\n            component_id (str): The ID of the web component.\n        Returns:\n            html.Div: A Dash Div Component containing the graph and dropdowns.\n        '''\n        pass\n\n    def update_properties(self, input_data: pd.DataFrame, **kwargs) -> list:\n        '''Update the property values for the plugin component.\n        Args:\n            input_data (pd.DataFrame): The input data object.\n            **kwargs: Additional keyword arguments (plugins can define their own arguments).\n                      Note: The current kwargs processed are:\n                            - x: The default x-axis column\n                            - y: The default y-axis column\n                            - color: The default color column\n                            - dropdown_columns: The columns to use for the x and y options\n                            - hover_columns: The columns to show when hovering over a point\n                            - suppress_hover_display: Suppress hover display (default: False)\n                            - custom_data: Custom data that get passed to hoverData callbacks\n        Returns:\n            list: A list of updated property values (figure, x options, y options, color options,\n                                                    label options, x default, y default,\n                                                    color default).\n        '''\n        pass\n\n    def create_scatter_plot(self, df: pd.DataFrame, x_col: str, y_col: str, color_col: str, label_col: str, regression_line: bool=False, marker_size: int=15) -> go.Figure:\n        '''Create a Plotly Scatter Plot figure.\n        Args:\n            df (pd.DataFrame): The dataframe containing the data.\n            x_col (str): The column to use for the x-axis.\n            y_col (str): The column to use for the y-axis.\n            color_col (str): The column to use for the color scale.\n            label_col (str): The column to use for point labels.\n            regression_line (bool): Whether to include a regression line.\n            marker_size (int): Size of the markers. Default is 15.\n        Returns:\n            go.Figure: A Plotly Figure object.\n        '''\n        pass\n\n        def generate_hover_text(row):\n                pass\n\n    def register_internal_callbacks(self):\n        '''Register any internal callbacks for the plugin.'''\n        pass\n        @callback(Output(f'{self.component_id}-graph', 'figure', allow_duplicate=True), [Input(f'{self.component_id}-x-dropdown', 'value'), Input(f'{self.component_id}-y-dropdown', 'value'), Input(f'{self.component_id}-color-dropdown', 'value'), Input(f'{self.component_id}-label-dropdown', 'value'), Input(f'{self.component_id}-regression-line', 'value')], prevent_initial_call=True)\n        def _update_scatter_plot(x_value, y_value, color_value, label_value, regression_line):\n                '''Update the Scatter Plot Graph based on the dropdown values.'''\n                pass\n        @callback(Output(f'{self.component_id}-overlay', 'show'), Output(f'{self.component_id}-overlay', 'bbox'), Output(f'{self.component_id}-overlay', 'children'), Input(f'{self.component_id}-graph', 'hoverData'))\n        def _scatter_overlay(hover_data):\n                pass\nCorresponding class implementation:\n\nfrom workbench.utils.theme_manager import ThemeManager\nfrom dash import dcc, html, callback, Input, Output, no_update\nimport plotly.express as px\nimport base64\nimport pandas as pd\nfrom dash.exceptions import PreventUpdate\nfrom workbench.utils.plot_utils import prediction_intervals\nimport plotly.graph_objects as go\nfrom workbench.web_interface.components.plugin_interface import PluginInterface, PluginPage, PluginInputType\n\nclass ScatterPlot(PluginInterface):\n    \"\"\"A Scatter Plot Plugin for Feature Sets.\"\"\"\n    auto_load_page = PluginPage.NONE\n    plugin_input_type = PluginInputType.DATAFRAME\n\n    def __init__(self, show_axes: bool=True):\n        \"\"\"Initialize the Scatter Plot Plugin\n\n        Args:\n            show_axes (bool): Whether to show the axes and grid. Default is True.\n        \"\"\"\n        self.component_id = None\n        self.hover_columns = []\n        self.df = None\n        self.show_axes = show_axes\n        self.theme_manager = ThemeManager()\n        self.colorscale = self.theme_manager.colorscale()\n        super().__init__()\n\n    def create_component(self, component_id: str) -> html.Div:\n        \"\"\"Create a Dash Graph Component without any data.\n\n        Args:\n            component_id (str): The ID of the web component.\n\n        Returns:\n            html.Div: A Dash Div Component containing the graph and dropdowns.\n        \"\"\"\n        self.component_id = component_id\n        self.properties = [(f'{component_id}-graph', 'figure'), (f'{component_id}-x-dropdown', 'options'), (f'{component_id}-y-dropdown', 'options'), (f'{component_id}-color-dropdown', 'options'), (f'{component_id}-label-dropdown', 'options'), (f'{component_id}-x-dropdown', 'value'), (f'{component_id}-y-dropdown', 'value'), (f'{component_id}-color-dropdown', 'value')]\n        self.signals = [(f'{component_id}-graph', 'hoverData'), (f'{component_id}-graph', 'clickData')]\n        return html.Div(children=[dcc.Graph(id=f'{component_id}-graph', figure=self.display_text('Waiting for Data...'), config={'scrollZoom': True}, style={'height': '100%'}, clear_on_unhover=True), html.Div([html.Label('X', style={'marginLeft': '40px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-x-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, clearable=False), html.Label('Y', style={'marginLeft': '30px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-y-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, clearable=False), html.Label('Color', style={'marginLeft': '30px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-color-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, clearable=False), html.Label('Label', style={'marginLeft': '30px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-label-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, options=[{'label': 'None', 'value': 'none'}], value='none', clearable=False), dcc.Checklist(id=f'{component_id}-regression-line', options=[{'label': ' Diagonal', 'value': 'show'}], value=[], style={'margin': '10px'})], style={'padding': '0px 0px 10px 0px', 'display': 'flex', 'gap': '10px'}), dcc.Tooltip(id=f'{component_id}-overlay', background_color='rgba(0,0,0,0)', border_color='rgba(0,0,0,0)', direction='bottom', loading_text='')], style={'height': '100%', 'display': 'flex', 'flexDirection': 'column'})\n\n    def update_properties(self, input_data: pd.DataFrame, **kwargs) -> list:\n        \"\"\"Update the property values for the plugin component.\n\n        Args:\n            input_data (pd.DataFrame): The input data object.\n            **kwargs: Additional keyword arguments (plugins can define their own arguments).\n                      Note: The current kwargs processed are:\n                            - x: The default x-axis column\n                            - y: The default y-axis column\n                            - color: The default color column\n                            - dropdown_columns: The columns to use for the x and y options\n                            - hover_columns: The columns to show when hovering over a point\n                            - suppress_hover_display: Suppress hover display (default: False)\n                            - custom_data: Custom data that get passed to hoverData callbacks\n\n        Returns:\n            list: A list of updated property values (figure, x options, y options, color options,\n                                                    label options, x default, y default,\n                                                    color default).\n        \"\"\"\n        limit = kwargs.get('limit', 20000)\n        if isinstance(input_data, pd.DataFrame):\n            self.df = input_data.sample(n=limit) if len(input_data) > limit else input_data\n        else:\n            raise ValueError('The input data must be a Pandas DataFrame.')\n        aws_cols = ['write_time', 'api_invocation_time', 'is_deleted', 'event_time']\n        self.df = self.df.drop(columns=aws_cols, errors='ignore')\n        self.hover_columns = kwargs.get('hover_columns', self.df.columns.tolist()[:10])\n        self.suppress_hover_display = kwargs.get('suppress_hover_display', False)\n        self.custom_data = kwargs.get('custom_data', [])\n        numeric_columns = self.df.select_dtypes(include='number').columns.tolist()\n        if len(numeric_columns) < 3:\n            raise ValueError('At least three numeric columns are required for x, y, and color.')\n        x_default = kwargs.get('x', numeric_columns[0])\n        y_default = kwargs.get('y', numeric_columns[1])\n        color_default = kwargs.get('color', numeric_columns[2])\n        regression_line = kwargs.get('regression_line', False)\n        figure = self.create_scatter_plot(self.df, x_default, y_default, color_default, 'none', regression_line)\n        dropdown_columns = kwargs.get('dropdown_columns', numeric_columns)\n        x_options = [{'label': col, 'value': col} for col in dropdown_columns]\n        y_options = x_options.copy()\n        cat_columns = self.df.select_dtypes(include=['object', 'string', 'category']).columns.tolist()\n        cat_columns = [col for col in cat_columns if self.df[col].astype(str).nunique() < 20]\n        color_columns = numeric_columns + cat_columns\n        color_options = [{'label': col, 'value': col} for col in color_columns]\n        label_options = [{'label': 'None', 'value': 'none'}]\n        label_options.extend([{'label': col, 'value': col} for col in self.df.columns])\n        return [figure, x_options, y_options, color_options, label_options, x_default, y_default, color_default]\n\n    def create_scatter_plot(self, df: pd.DataFrame, x_col: str, y_col: str, color_col: str, label_col: str, regression_line: bool=False, marker_size: int=15) -> go.Figure:\n        \"\"\"Create a Plotly Scatter Plot figure.\n\n        Args:\n            df (pd.DataFrame): The dataframe containing the data.\n            x_col (str): The column to use for the x-axis.\n            y_col (str): The column to use for the y-axis.\n            color_col (str): The column to use for the color scale.\n            label_col (str): The column to use for point labels.\n            regression_line (bool): Whether to include a regression line.\n            marker_size (int): Size of the markers. Default is 15.\n\n        Returns:\n            go.Figure: A Plotly Figure object.\n        \"\"\"\n        show_labels = label_col != 'none' and len(df) < 1000\n\n        def generate_hover_text(row):\n            return '<br>'.join([f'{col}: {row[col]}' for col in self.hover_columns])\n        hovertext = df.apply(generate_hover_text, axis=1)\n        hovertemplate = '%{hovertext}<extra></extra>'\n        hoverinfo = 'none' if self.suppress_hover_display else None\n        if pd.api.types.is_numeric_dtype(df[color_col]):\n            marker_color = df[color_col]\n            colorbar = dict(title=color_col, thickness=10)\n            data = [go.Scattergl(x=df[x_col], y=df[y_col], mode='markers', text=df[label_col].astype(str) if show_labels else None, textposition='top center', hoverinfo=hoverinfo, hovertext=hovertext, hovertemplate=hovertemplate, customdata=df[self.custom_data], marker=dict(size=marker_size, color=marker_color, colorscale=self.colorscale, colorbar=colorbar, opacity=0.8, line=dict(color='rgba(0,0,0,0.25)', width=1)))]\n            showlegend = False\n        else:\n            categories = sorted(df[color_col].astype(str).unique())\n            discrete_colors = px.colors.qualitative.Plotly\n            data = []\n            for i, cat in enumerate(categories):\n                sub_df = df[df[color_col] == cat]\n                sub_hovertext = hovertext.loc[sub_df.index]\n                trace = go.Scattergl(x=sub_df[x_col], y=sub_df[y_col], mode='markers', text=sub_df[label_col] if show_labels else None, textposition='top center', name=cat, hoverinfo=hoverinfo, hovertext=sub_hovertext, hovertemplate=hovertemplate, customdata=sub_df[self.custom_data], marker=dict(size=marker_size, color=discrete_colors[i % len(discrete_colors)], opacity=0.8, line=dict(color='rgba(0,0,0,0.25)', width=1)))\n                data.append(trace)\n            showlegend = True\n        figure = go.Figure()\n        if y_col == 'prediction' or x_col == 'prediction':\n            figure = prediction_intervals(df, figure, x_col)\n        if regression_line:\n            axis_min = min(df[x_col].min(), df[y_col].min())\n            axis_max = max(df[x_col].max(), df[y_col].max())\n            figure.add_shape(type='line', line=dict(width=4, color='rgba(128, 128, 128, 1.0)'), x0=axis_min, x1=axis_max, y0=axis_min, y1=axis_max)\n        figure.add_traces(data)\n        if self.show_axes:\n            xaxis = dict(title=dict(text=x_col, font=dict(size=16), standoff=15), tickformat='.2f', tickfont=dict(size=10))\n            yaxis = dict(title=dict(text=y_col, font=dict(size=16), standoff=25), tickformat='.2f', tickfont=dict(size=10))\n        else:\n            xaxis = dict(visible=False)\n            yaxis = dict(visible=False)\n        figure.update_layout(margin={'t': 20, 'b': 55, 'r': 0, 'l': 35, 'pad': 0}, xaxis=xaxis, yaxis=yaxis, showlegend=showlegend, dragmode='pan', modebar={'bgcolor': 'rgba(0, 0, 0, 0)'}, uirevision='constant')\n        return figure\n\n    def register_internal_callbacks(self):\n        \"\"\"Register any internal callbacks for the plugin.\"\"\"\n\n        @callback(Output(f'{self.component_id}-graph', 'figure', allow_duplicate=True), [Input(f'{self.component_id}-x-dropdown', 'value'), Input(f'{self.component_id}-y-dropdown', 'value'), Input(f'{self.component_id}-color-dropdown', 'value'), Input(f'{self.component_id}-label-dropdown', 'value'), Input(f'{self.component_id}-regression-line', 'value')], prevent_initial_call=True)\n        def _update_scatter_plot(x_value, y_value, color_value, label_value, regression_line):\n            \"\"\"Update the Scatter Plot Graph based on the dropdown values.\"\"\"\n            if not self.df.empty and x_value and y_value and color_value:\n                figure = self.create_scatter_plot(self.df, x_value, y_value, color_value, label_value, regression_line)\n                return figure\n            raise PreventUpdate\n\n        @callback(Output(f'{self.component_id}-overlay', 'show'), Output(f'{self.component_id}-overlay', 'bbox'), Output(f'{self.component_id}-overlay', 'children'), Input(f'{self.component_id}-graph', 'hoverData'))\n        def _scatter_overlay(hover_data):\n            if hover_data is None:\n                return (False, no_update, no_update)\n            bbox = hover_data['points'][0]['bbox']\n            svg = '\\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\" style=\"overflow: visible;\">\\n                <!-- Circle for the node -->\\n                <circle cx=\"50\" cy=\"50\" r=\"10\" stroke=\"rgba(255, 255, 255, 1)\" stroke-width=\"3\" fill=\"none\" />\\n            </svg>\\n            '\n            encoded_svg = base64.b64encode(svg.encode('utf-8')).decode('utf-8')\n            data_uri = f'data:image/svg+xml;base64,{encoded_svg}'\n            svg_image = html.Img(src=data_uri, style={'width': '100px', 'height': '100px'})\n            center_x = (bbox['x0'] + bbox['x1']) / 2\n            center_y = (bbox['y0'] + bbox['y1']) / 2\n            adjusted_bbox = {'x0': center_x - 50, 'x1': center_x + 50, 'y0': center_y - 162, 'y1': center_y - 62}\n            return (True, adjusted_bbox, [svg_image])\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass UsageAggregator:\n    '''Aggregates usage data for daily and monthly reports.'''\n\n    def __init__(self, data_path: str, aggregation_mode: str='daily', timezone: str='UTC'):\n        '''Initialize the aggregator.\n        Args:\n            data_path: Path to the data directory\n            aggregation_mode: Mode of aggregation ('daily' or 'monthly')\n            timezone: Timezone string for date formatting\n        '''\n        pass\n\n    def _aggregate_by_period(self, entries: List[UsageEntry], period_key_func: Callable[[datetime], str], period_type: str, start_date: Optional[datetime]=None, end_date: Optional[datetime]=None) -> List[Dict[str, Any]]:\n        '''Generic aggregation by time period.\n        Args:\n            entries: List of usage entries\n            period_key_func: Function to extract period key from timestamp\n            period_type: Type of period ('date' or 'month')\n            start_date: Optional start date filter\n            end_date: Optional end date filter\n        Returns:\n            List of aggregated data dictionaries\n        '''\n        pass\n\n    def aggregate_daily(self, entries: List[UsageEntry], start_date: Optional[datetime]=None, end_date: Optional[datetime]=None) -> List[Dict[str, Any]]:\n        '''Aggregate usage data by day.\n        Args:\n            entries: List of usage entries\n            start_date: Optional start date filter\n            end_date: Optional end date filter\n        Returns:\n            List of daily aggregated data\n        '''\n        pass\n\n    def aggregate_monthly(self, entries: List[UsageEntry], start_date: Optional[datetime]=None, end_date: Optional[datetime]=None) -> List[Dict[str, Any]]:\n        '''Aggregate usage data by month.\n        Args:\n            entries: List of usage entries\n            start_date: Optional start date filter\n            end_date: Optional end date filter\n        Returns:\n            List of monthly aggregated data\n        '''\n        pass\n\n    def aggregate_from_blocks(self, blocks: List[SessionBlock], view_type: str='daily') -> List[Dict[str, Any]]:\n        '''Aggregate data from session blocks.\n        Args:\n            blocks: List of session blocks\n            view_type: Type of aggregation ('daily' or 'monthly')\n        Returns:\n            List of aggregated data\n        '''\n        pass\n\n    def calculate_totals(self, aggregated_data: List[Dict[str, Any]]) -> Dict[str, Any]:\n        '''Calculate totals from aggregated data.\n        Args:\n            aggregated_data: List of aggregated daily or monthly data\n        Returns:\n            Dictionary with total statistics\n        '''\n        pass\n\n    def aggregate_daily(self, entries: List[UsageEntry], start_date: Optional[datetime]=None, end_date: Optional[datetime]=None) -> List[Dict[str, Any]]:\n        '''Main aggregation method that reads data and returns aggregated results.\n        Returns:\n            List of aggregated data based on aggregation_mode\n        '''\n        pass"
  }
]