[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass AliasManager(object):\n\n    def __init__(self, **kwargs):\n        pass\n\n    def load_alias_table(self):\n        '''\n        Load (create, if not exist) the alias config file.\n        '''\n        pass\n\n    def load_alias_hash(self):\n        '''\n        Load (create, if not exist) the alias hash file.\n        '''\n        pass\n\n    def load_collided_alias(self):\n        '''\n        Load (create, if not exist) the collided alias file.\n        '''\n        pass\n\n    def detect_alias_config_change(self):\n        '''\n        Change if the alias configuration has changed since the last run.\n        Returns:\n            False if the alias configuration file has not been changed since the last run.\n            Otherwise, return True.\n        '''\n        pass\n\n    def transform(self, args):\n        '''\n        Transform any aliases in args to their respective commands.\n        Args:\n            args: A list of space-delimited command input extracted directly from the console.\n        Returns:\n            A list of transformed commands according to the alias configuration file.\n        '''\n        pass\n\n    def get_full_alias(self, query):\n        '''\n        Get the full alias given a search query.\n        Args:\n            query: The query this function performs searching on.\n        Returns:\n            The full alias (with the placeholders, if any).\n        '''\n        pass\n\n    def load_full_command_table(self):\n        '''\n        Perform a full load of the command table to get all the reserved command words.\n        '''\n        pass\n\n    def post_transform(self, args):\n        '''\n        Inject environment variables, and write hash to alias hash file after transforming alias to commands.\n        Args:\n            args: A list of args to post-transform.\n        '''\n        pass\n\n    def parse_error(self):\n        '''\n        Check if there is a configuration parsing error.\n        A parsing error has occurred if there are strings inside the alias config file\n        but there is no alias loaded in self.alias_table.\n        Returns:\n            True if there is an error parsing the alias configuration file. Otherwises, false.\n        '''\n        pass\n    @staticmethod\n    def build_collision_table(aliases, levels=COLLISION_CHECK_LEVEL_DEPTH):\n        '''\n        Build the collision table according to the alias configuration file against the entire command table.\n        self.collided_alias is structured as:\n        {\n            'collided_alias': [the command level at which collision happens]\n        }\n        For example:\n        {\n            'account': [1, 2]\n        }\n        This means that 'account' is a reserved command in level 1 and level 2 of the command tree because\n        (az account ...) and (az storage account ...)\n             lvl 1                        lvl 2\n        Args:\n            levels: the amount of levels we tranverse through the command table tree.\n        '''\n        pass\n    @staticmethod\n    def write_alias_config_hash(alias_config_hash='', empty_hash=False):\n        '''\n        Write self.alias_config_hash to the alias hash file.\n        Args:\n            empty_hash: True if we want to write an empty string into the file. Empty string in the alias hash file\n                means that we have to perform a full load of the command table in the next run.\n        '''\n        pass\n    @staticmethod\n    def write_collided_alias(collided_alias_dict):\n        '''\n        Write the collided aliases string into the collided alias file.\n        '''\n        pass\n    @staticmethod\n    def process_exception_message(exception):\n        '''\n        Process an exception message.\n        Args:\n            exception: The exception to process.\n        Returns:\n            A filtered string summarizing the exception.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom azext_alias._const import GLOBAL_CONFIG_DIR, ALIAS_FILE_NAME, ALIAS_HASH_FILE_NAME, COLLIDED_ALIAS_FILE_NAME, CONFIG_PARSING_ERROR, DEBUG_MSG, COLLISION_CHECK_LEVEL_DEPTH, POS_ARG_DEBUG_MSG\nfrom collections import defaultdict\nimport azext_alias\nimport hashlib\nimport shlex\nfrom azext_alias.util import is_alias_command, cache_reserved_commands, get_config_parser, build_tab_completion_table\nimport os\nimport json\nfrom azext_alias.argument import build_pos_args_table, render_template\nimport re\nfrom azext_alias import telemetry\n\nclass AliasManager(object):\n\n    def __init__(self, **kwargs):\n        self.alias_table = get_config_parser()\n        self.kwargs = kwargs\n        self.collided_alias = defaultdict(list)\n        self.alias_config_str = ''\n        self.alias_config_hash = ''\n        self.load_alias_table()\n        self.load_alias_hash()\n\n    def load_alias_table(self):\n        \"\"\"\n        Load (create, if not exist) the alias config file.\n        \"\"\"\n        try:\n            open_mode = 'r+' if os.path.exists(GLOBAL_ALIAS_PATH) else 'w+'\n            with open(GLOBAL_ALIAS_PATH, open_mode) as alias_config_file:\n                self.alias_config_str = alias_config_file.read()\n            self.alias_table.read(GLOBAL_ALIAS_PATH)\n            telemetry.set_number_of_aliases_registered(len(self.alias_table.sections()))\n        except Exception as exception:\n            logger.warning(CONFIG_PARSING_ERROR, AliasManager.process_exception_message(exception))\n            self.alias_table = get_config_parser()\n            telemetry.set_exception(exception)\n\n    def load_alias_hash(self):\n        \"\"\"\n        Load (create, if not exist) the alias hash file.\n        \"\"\"\n        open_mode = 'r+' if os.path.exists(GLOBAL_ALIAS_HASH_PATH) else 'w+'\n        with open(GLOBAL_ALIAS_HASH_PATH, open_mode) as alias_config_hash_file:\n            self.alias_config_hash = alias_config_hash_file.read()\n\n    def load_collided_alias(self):\n        \"\"\"\n        Load (create, if not exist) the collided alias file.\n        \"\"\"\n        open_mode = 'r+' if os.path.exists(GLOBAL_COLLIDED_ALIAS_PATH) else 'w+'\n        with open(GLOBAL_COLLIDED_ALIAS_PATH, open_mode) as collided_alias_file:\n            collided_alias_str = collided_alias_file.read()\n            try:\n                self.collided_alias = json.loads(collided_alias_str if collided_alias_str else '{}')\n            except Exception:\n                self.collided_alias = {}\n\n    def detect_alias_config_change(self):\n        \"\"\"\n        Change if the alias configuration has changed since the last run.\n\n        Returns:\n            False if the alias configuration file has not been changed since the last run.\n            Otherwise, return True.\n        \"\"\"\n        if self.parse_error():\n            return False\n        alias_config_sha1 = hashlib.sha1(self.alias_config_str.encode('utf-8')).hexdigest()\n        if alias_config_sha1 != self.alias_config_hash:\n            self.alias_config_hash = alias_config_sha1\n            return True\n        return False\n\n    def transform(self, args):\n        \"\"\"\n        Transform any aliases in args to their respective commands.\n\n        Args:\n            args: A list of space-delimited command input extracted directly from the console.\n\n        Returns:\n            A list of transformed commands according to the alias configuration file.\n        \"\"\"\n        if self.parse_error():\n            AliasManager.write_alias_config_hash(empty_hash=True)\n            return args\n        if self.detect_alias_config_change():\n            self.load_full_command_table()\n            self.collided_alias = AliasManager.build_collision_table(self.alias_table.sections())\n            build_tab_completion_table(self.alias_table)\n        else:\n            self.load_collided_alias()\n        transformed_commands = []\n        alias_iter = enumerate(args, 1)\n        for alias_index, alias in alias_iter:\n            is_collided_alias = alias in self.collided_alias and alias_index in self.collided_alias[alias]\n            is_named_arg = alias_index > 1 and args[alias_index - 2].startswith('-')\n            is_named_arg_flag = alias.startswith('-')\n            excluded_commands = is_alias_command(['remove', 'export'], transformed_commands)\n            if not alias or is_collided_alias or is_named_arg or is_named_arg_flag or excluded_commands:\n                transformed_commands.append(alias)\n                continue\n            full_alias = self.get_full_alias(alias)\n            if self.alias_table.has_option(full_alias, 'command'):\n                cmd_derived_from_alias = self.alias_table.get(full_alias, 'command')\n                telemetry.set_alias_hit(full_alias)\n            else:\n                transformed_commands.append(alias)\n                continue\n            pos_args_table = build_pos_args_table(full_alias, args, alias_index)\n            if pos_args_table:\n                logger.debug(POS_ARG_DEBUG_MSG, full_alias, cmd_derived_from_alias, pos_args_table)\n                transformed_commands += render_template(cmd_derived_from_alias, pos_args_table)\n                for pos_arg in pos_args_table:\n                    next(alias_iter)\n            else:\n                logger.debug(DEBUG_MSG, full_alias, cmd_derived_from_alias)\n                transformed_commands += shlex.split(cmd_derived_from_alias)\n        return self.post_transform(transformed_commands)\n\n    def get_full_alias(self, query):\n        \"\"\"\n        Get the full alias given a search query.\n\n        Args:\n            query: The query this function performs searching on.\n\n        Returns:\n            The full alias (with the placeholders, if any).\n        \"\"\"\n        if query in self.alias_table.sections():\n            return query\n        return next((section for section in self.alias_table.sections() if section.split()[0] == query), '')\n\n    def load_full_command_table(self):\n        \"\"\"\n        Perform a full load of the command table to get all the reserved command words.\n        \"\"\"\n        load_cmd_tbl_func = self.kwargs.get('load_cmd_tbl_func', lambda _: {})\n        cache_reserved_commands(load_cmd_tbl_func)\n        telemetry.set_full_command_table_loaded()\n\n    def post_transform(self, args):\n        \"\"\"\n        Inject environment variables, and write hash to alias hash file after transforming alias to commands.\n\n        Args:\n            args: A list of args to post-transform.\n        \"\"\"\n        args = args[1:] if args and args[0] == 'az' else args\n        post_transform_commands = []\n        for i, arg in enumerate(args):\n            if is_alias_command(['create'], args) and i > 0 and (args[i - 1] in ['-c', '--command']):\n                post_transform_commands.append(arg)\n            else:\n                post_transform_commands.append(os.path.expandvars(arg))\n        AliasManager.write_alias_config_hash(self.alias_config_hash)\n        AliasManager.write_collided_alias(self.collided_alias)\n        return post_transform_commands\n\n    def parse_error(self):\n        \"\"\"\n        Check if there is a configuration parsing error.\n\n        A parsing error has occurred if there are strings inside the alias config file\n        but there is no alias loaded in self.alias_table.\n\n        Returns:\n            True if there is an error parsing the alias configuration file. Otherwises, false.\n        \"\"\"\n        return not self.alias_table.sections() and self.alias_config_str\n\n    @staticmethod\n    def build_collision_table(aliases, levels=COLLISION_CHECK_LEVEL_DEPTH):\n        \"\"\"\n        Build the collision table according to the alias configuration file against the entire command table.\n\n        self.collided_alias is structured as:\n        {\n            'collided_alias': [the command level at which collision happens]\n        }\n        For example:\n        {\n            'account': [1, 2]\n        }\n        This means that 'account' is a reserved command in level 1 and level 2 of the command tree because\n        (az account ...) and (az storage account ...)\n             lvl 1                        lvl 2\n\n        Args:\n            levels: the amount of levels we tranverse through the command table tree.\n        \"\"\"\n        collided_alias = defaultdict(list)\n        for alias in aliases:\n            word = alias.split()[0]\n            for level in range(1, levels + 1):\n                collision_regex = '^{}{}($|\\\\s)'.format('([a-z\\\\-]*\\\\s)' * (level - 1), word.lower())\n                if list(filter(re.compile(collision_regex).match, azext_alias.cached_reserved_commands)) and level not in collided_alias[word]:\n                    collided_alias[word].append(level)\n        telemetry.set_collided_aliases(list(collided_alias.keys()))\n        return collided_alias\n\n    @staticmethod\n    def write_alias_config_hash(alias_config_hash='', empty_hash=False):\n        \"\"\"\n        Write self.alias_config_hash to the alias hash file.\n\n        Args:\n            empty_hash: True if we want to write an empty string into the file. Empty string in the alias hash file\n                means that we have to perform a full load of the command table in the next run.\n        \"\"\"\n        with open(GLOBAL_ALIAS_HASH_PATH, 'w') as alias_config_hash_file:\n            alias_config_hash_file.write('' if empty_hash else alias_config_hash)\n\n    @staticmethod\n    def write_collided_alias(collided_alias_dict):\n        \"\"\"\n        Write the collided aliases string into the collided alias file.\n        \"\"\"\n        open_mode = 'r+' if os.path.exists(GLOBAL_COLLIDED_ALIAS_PATH) else 'w+'\n        with open(GLOBAL_COLLIDED_ALIAS_PATH, open_mode) as collided_alias_file:\n            collided_alias_file.truncate()\n            collided_alias_file.write(json.dumps(collided_alias_dict))\n\n    @staticmethod\n    def process_exception_message(exception):\n        \"\"\"\n        Process an exception message.\n\n        Args:\n            exception: The exception to process.\n\n        Returns:\n            A filtered string summarizing the exception.\n        \"\"\"\n        exception_message = str(exception)\n        for replace_char in ['\\t', '\\n', '\\\\n']:\n            exception_message = exception_message.replace(replace_char, '' if replace_char != '\\t' else ' ')\n        return exception_message.replace('section', 'alias')\n\nExample skeleton:\n\n\nclass InitTask(BaseTask):\n\n    def copy_starter_repo(self, project_name: str) -> None:\n        pass\n\n    def create_profiles_dir(self, profiles_dir: str) -> bool:\n        '''Create the user's profiles directory if it doesn't already exist.'''\n        pass\n\n    def create_profile_from_sample(self, adapter: str, profile_name: str):\n        '''Create a profile entry using the adapter's sample_profiles.yml\n        Renames the profile in sample_profiles.yml to match that of the project.'''\n        pass\n\n    def generate_target_from_input(self, profile_template: dict, target: dict={}) -> dict:\n        '''Generate a target configuration from profile_template and user input.'''\n        pass\n\n    def get_profile_name_from_current_project(self) -> str:\n        '''Reads dbt_project.yml in the current directory to retrieve the\n        profile name.\n        '''\n        pass\n\n    def write_profile(self, profile: dict, profile_name: str):\n        '''Given a profile, write it to the current project's profiles.yml.\n        This will overwrite any profile with a matching name.'''\n        pass\n\n    def create_profile_from_profile_template(self, profile_template: dict, profile_name: str):\n        '''Create and write a profile using the supplied profile_template.'''\n        pass\n\n    def create_profile_from_target(self, adapter: str, profile_name: str):\n        '''Create a profile without defaults using target's profile_template.yml if available, or\n        sample_profiles.yml as a fallback.'''\n        pass\n\n    def check_if_profile_exists(self, profile_name: str) -> bool:\n        '''\n        Validate that the specified profile exists. Can't use the regular profile validation\n        routine because it assumes the project file exists\n        '''\n        pass\n\n    def check_if_can_write_profile(self, profile_name: Optional[str]=None) -> bool:\n        '''Using either a provided profile name or that specified in dbt_project.yml,\n        check if the profile already exists in profiles.yml, and if so ask the\n        user whether to proceed and overwrite it.'''\n        pass\n\n    def create_profile_using_project_profile_template(self, profile_name):\n        '''Create a profile using the project's profile_template.yml'''\n        pass\n\n    def ask_for_adapter_choice(self) -> str:\n        '''Ask the user which adapter (database) they'd like to use.'''\n        pass\n\n    def setup_profile(self, profile_name: str) -> None:\n        '''Set up a new profile for a project'''\n        pass\n\n    def get_valid_project_name(self) -> str:\n        '''Returns a valid project name, either from CLI arg or user prompt.'''\n        pass\n\n    def create_new_project(self, project_name: str, profile_name: str):\n        pass\n\n    def run(self):\n        '''Entry point for the init task.'''\n        pass\nCorresponding class implementation:\n\nfrom dbt_common.events.functions import fire_event\nfrom dbt.flags import get_flags\nfrom dbt_common.exceptions import DbtRuntimeError\nimport copy\nfrom typing import Optional\nimport os\nimport shutil\nimport yaml\nfrom dbt.task.base import BaseTask, move_to_nearest_project_dir\nimport click\nfrom dbt.events.types import ConfigFolderDirectory, InvalidProfileTemplateYAML, NoSampleProfileFound, ProfileWrittenWithProjectTemplateYAML, ProfileWrittenWithSample, ProfileWrittenWithTargetTemplateYAML, ProjectCreated, ProjectNameAlreadyExists, SettingUpProfile, StarterProjectPath\nimport re\nimport dbt_common.clients.system\nfrom dbt.config.profile import read_profile\nfrom pathlib import Path\nfrom dbt.contracts.util import Identifier as ProjectName\nimport dbt.config\nfrom dbt.adapters.factory import get_include_paths, load_plugin\nfrom dbt.version import _get_adapter_plugin_names\n\nclass InitTask(BaseTask):\n\n    def copy_starter_repo(self, project_name: str) -> None:\n        from dbt.include.starter_project import PACKAGE_PATH as starter_project_directory\n        fire_event(StarterProjectPath(dir=starter_project_directory))\n        shutil.copytree(starter_project_directory, project_name, ignore=shutil.ignore_patterns(*IGNORE_FILES))\n\n    def create_profiles_dir(self, profiles_dir: str) -> bool:\n        \"\"\"Create the user's profiles directory if it doesn't already exist.\"\"\"\n        profiles_path = Path(profiles_dir)\n        if not profiles_path.exists():\n            fire_event(ConfigFolderDirectory(dir=str(profiles_dir)))\n            dbt_common.clients.system.make_directory(profiles_dir)\n            return True\n        return False\n\n    def create_profile_from_sample(self, adapter: str, profile_name: str):\n        \"\"\"Create a profile entry using the adapter's sample_profiles.yml\n\n        Renames the profile in sample_profiles.yml to match that of the project.\"\"\"\n        load_plugin(adapter)\n        adapter_path = get_include_paths(adapter)[0]\n        sample_profiles_path = adapter_path / 'sample_profiles.yml'\n        if not sample_profiles_path.exists():\n            fire_event(NoSampleProfileFound(adapter=adapter))\n        else:\n            with open(sample_profiles_path, 'r') as f:\n                sample_profile = f.read()\n            sample_profile_name = list(yaml.safe_load(sample_profile).keys())[0]\n            sample_profile = re.sub(f'^{sample_profile_name}:', f'{profile_name}:', sample_profile)\n            profiles_filepath = Path(get_flags().PROFILES_DIR) / Path('profiles.yml')\n            if profiles_filepath.exists():\n                with open(profiles_filepath, 'a') as f:\n                    f.write('\\n' + sample_profile)\n            else:\n                with open(profiles_filepath, 'w') as f:\n                    f.write(sample_profile)\n                fire_event(ProfileWrittenWithSample(name=profile_name, path=str(profiles_filepath)))\n\n    def generate_target_from_input(self, profile_template: dict, target: dict={}) -> dict:\n        \"\"\"Generate a target configuration from profile_template and user input.\"\"\"\n        profile_template_local = copy.deepcopy(profile_template)\n        for key, value in profile_template_local.items():\n            if key.startswith('_choose'):\n                choice_type = key[8:].replace('_', ' ')\n                option_list = list(value.keys())\n                prompt_msg = '\\n'.join([f'[{n + 1}] {v}' for n, v in enumerate(option_list)]) + f'\\nDesired {choice_type} option (enter a number)'\n                numeric_choice = click.prompt(prompt_msg, type=click.INT)\n                choice = option_list[numeric_choice - 1]\n                target = self.generate_target_from_input(profile_template_local[key][choice], target)\n            elif key.startswith('_fixed'):\n                target[key[7:]] = value\n            else:\n                hide_input = value.get('hide_input', False)\n                default = value.get('default', None)\n                hint = value.get('hint', None)\n                type = click_type_mapping[value.get('type', None)]\n                text = key + (f' ({hint})' if hint else '')\n                target[key] = click.prompt(text, default=default, hide_input=hide_input, type=type)\n        return target\n\n    def get_profile_name_from_current_project(self) -> str:\n        \"\"\"Reads dbt_project.yml in the current directory to retrieve the\n        profile name.\n        \"\"\"\n        with open('dbt_project.yml') as f:\n            dbt_project = yaml.safe_load(f)\n        return dbt_project['profile']\n\n    def write_profile(self, profile: dict, profile_name: str):\n        \"\"\"Given a profile, write it to the current project's profiles.yml.\n        This will overwrite any profile with a matching name.\"\"\"\n        profiles_filepath = Path(get_flags().PROFILES_DIR) / Path('profiles.yml')\n        profiles = {profile_name: profile}\n        if profiles_filepath.exists():\n            with open(profiles_filepath, 'r') as f:\n                profiles = yaml.safe_load(f) or {}\n                profiles[profile_name] = profile\n        with open(profiles_filepath, 'w') as f:\n            yaml.dump(profiles, f)\n\n    def create_profile_from_profile_template(self, profile_template: dict, profile_name: str):\n        \"\"\"Create and write a profile using the supplied profile_template.\"\"\"\n        initial_target = profile_template.get('fixed', {})\n        prompts = profile_template.get('prompts', {})\n        target = self.generate_target_from_input(prompts, initial_target)\n        target_name = target.pop('target', 'dev')\n        profile = {'outputs': {target_name: target}, 'target': target_name}\n        self.write_profile(profile, profile_name)\n\n    def create_profile_from_target(self, adapter: str, profile_name: str):\n        \"\"\"Create a profile without defaults using target's profile_template.yml if available, or\n        sample_profiles.yml as a fallback.\"\"\"\n        load_plugin(adapter)\n        adapter_path = get_include_paths(adapter)[0]\n        profile_template_path = adapter_path / 'profile_template.yml'\n        if profile_template_path.exists():\n            with open(profile_template_path) as f:\n                profile_template = yaml.safe_load(f)\n            self.create_profile_from_profile_template(profile_template, profile_name)\n            profiles_filepath = Path(get_flags().PROFILES_DIR) / Path('profiles.yml')\n            fire_event(ProfileWrittenWithTargetTemplateYAML(name=profile_name, path=str(profiles_filepath)))\n        else:\n            self.create_profile_from_sample(adapter, profile_name)\n\n    def check_if_profile_exists(self, profile_name: str) -> bool:\n        \"\"\"\n        Validate that the specified profile exists. Can't use the regular profile validation\n        routine because it assumes the project file exists\n        \"\"\"\n        profiles_dir = get_flags().PROFILES_DIR\n        raw_profiles = read_profile(profiles_dir)\n        return profile_name in raw_profiles\n\n    def check_if_can_write_profile(self, profile_name: Optional[str]=None) -> bool:\n        \"\"\"Using either a provided profile name or that specified in dbt_project.yml,\n        check if the profile already exists in profiles.yml, and if so ask the\n        user whether to proceed and overwrite it.\"\"\"\n        profiles_file = Path(get_flags().PROFILES_DIR) / Path('profiles.yml')\n        if not profiles_file.exists():\n            return True\n        profile_name = profile_name or self.get_profile_name_from_current_project()\n        with open(profiles_file, 'r') as f:\n            profiles = yaml.safe_load(f) or {}\n        if profile_name in profiles.keys():\n            response = click.confirm(f'The profile {profile_name} already exists in {profiles_file}. Continue and overwrite it?')\n            return response\n        else:\n            return True\n\n    def create_profile_using_project_profile_template(self, profile_name):\n        \"\"\"Create a profile using the project's profile_template.yml\"\"\"\n        with open('profile_template.yml') as f:\n            profile_template = yaml.safe_load(f)\n        self.create_profile_from_profile_template(profile_template, profile_name)\n        profiles_filepath = Path(get_flags().PROFILES_DIR) / Path('profiles.yml')\n        fire_event(ProfileWrittenWithProjectTemplateYAML(name=profile_name, path=str(profiles_filepath)))\n\n    def ask_for_adapter_choice(self) -> str:\n        \"\"\"Ask the user which adapter (database) they'd like to use.\"\"\"\n        available_adapters = list(_get_adapter_plugin_names())\n        if not available_adapters:\n            raise dbt.exceptions.NoAdaptersAvailableError()\n        prompt_msg = 'Which database would you like to use?\\n' + '\\n'.join([f'[{n + 1}] {v}' for n, v in enumerate(available_adapters)]) + \"\\n\\n(Don't see the one you want? https://docs.getdbt.com/docs/available-adapters)\" + '\\n\\nEnter a number'\n        numeric_choice = click.prompt(prompt_msg, type=click.INT)\n        return available_adapters[numeric_choice - 1]\n\n    def setup_profile(self, profile_name: str) -> None:\n        \"\"\"Set up a new profile for a project\"\"\"\n        fire_event(SettingUpProfile())\n        if not self.check_if_can_write_profile(profile_name=profile_name):\n            return\n        profile_template_path = Path('profile_template.yml')\n        if profile_template_path.exists():\n            try:\n                self.create_profile_using_project_profile_template(profile_name)\n                return\n            except Exception:\n                fire_event(InvalidProfileTemplateYAML())\n        adapter = self.ask_for_adapter_choice()\n        self.create_profile_from_target(adapter, profile_name=profile_name)\n\n    def get_valid_project_name(self) -> str:\n        \"\"\"Returns a valid project name, either from CLI arg or user prompt.\"\"\"\n        from dbt.include.global_project import PROJECT_NAME as GLOBAL_PROJECT_NAME\n        name = self.args.project_name\n        internal_package_names = {GLOBAL_PROJECT_NAME}\n        available_adapters = list(_get_adapter_plugin_names())\n        for adapter_name in available_adapters:\n            internal_package_names.update(f'dbt_{adapter_name}')\n        while not ProjectName.is_valid(name) or name in internal_package_names:\n            if name:\n                click.echo(name + ' is not a valid project name.')\n            name = click.prompt('Enter a name for your project (letters, digits, underscore)')\n        return name\n\n    def create_new_project(self, project_name: str, profile_name: str):\n        self.copy_starter_repo(project_name)\n        os.chdir(project_name)\n        with open('dbt_project.yml', 'r') as f:\n            content = f'{f.read()}'.format(project_name=project_name, profile_name=profile_name)\n        with open('dbt_project.yml', 'w') as f:\n            f.write(content)\n        fire_event(ProjectCreated(project_name=project_name, docs_url=DOCS_URL, slack_url=SLACK_URL))\n\n    def run(self):\n        \"\"\"Entry point for the init task.\"\"\"\n        profiles_dir = get_flags().PROFILES_DIR\n        self.create_profiles_dir(profiles_dir)\n        try:\n            move_to_nearest_project_dir(self.args.project_dir)\n            in_project = True\n        except dbt_common.exceptions.DbtRuntimeError:\n            in_project = False\n        if in_project:\n            if self.args.profile:\n                raise DbtRuntimeError(msg='Can not init existing project with specified profile, edit dbt_project.yml instead')\n            if not self.args.skip_profile_setup:\n                profile_name = self.get_profile_name_from_current_project()\n                self.setup_profile(profile_name)\n        else:\n            project_name = self.get_valid_project_name()\n            project_path = Path(project_name)\n            if project_path.exists():\n                fire_event(ProjectNameAlreadyExists(name=project_name))\n                return\n            user_profile_name = self.args.profile\n            if user_profile_name:\n                if not self.check_if_profile_exists(user_profile_name):\n                    raise DbtRuntimeError(msg=\"Could not find profile named '{}'\".format(user_profile_name))\n                self.create_new_project(project_name, user_profile_name)\n            else:\n                profile_name = project_name\n                self.create_new_project(project_name, profile_name)\n                if not self.args.skip_profile_setup:\n                    self.setup_profile(profile_name)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass ScriptRunner:\n    '''Executes APM scripts with auto-compilation of .prompt.md files.'''\n\n    def __init__(self, compiler=None):\n        '''Initialize script runner with optional compiler.'''\n        pass\n\n    def run_script(self, script_name: str, params: Dict[str, str]) -> bool:\n        '''Run a script from apm.yml with parameter substitution.\n        Args:\n            script_name: Name of the script to run\n            params: Parameters for compilation and script execution\n        Returns:\n            bool: True if script executed successfully\n        '''\n        pass\n\n    def list_scripts(self) -> Dict[str, str]:\n        '''List all available scripts from apm.yml.\n        Returns:\n            Dict mapping script names to their commands\n        '''\n        pass\n\n    def _load_config(self) -> Optional[Dict]:\n        '''Load apm.yml from current directory.'''\n        pass\n\n    def _auto_compile_prompts(self, command: str, params: Dict[str, str]) -> tuple[str, list[str]]:\n        '''Auto-compile .prompt.md files and transform runtime commands.\n        Args:\n            command: Original script command\n            params: Parameters for compilation\n        Returns:\n            Tuple of (compiled_command, list_of_compiled_prompt_files)\n        '''\n        pass\n\n    def _transform_runtime_command(self, command: str, prompt_file: str, compiled_content: str, compiled_path: str) -> str:\n        '''Transform runtime commands to their proper execution format.\n        Args:\n            command: Original command\n            prompt_file: Original .prompt.md file path\n            compiled_content: Compiled prompt content as string\n            compiled_path: Path to compiled .txt file\n        Returns:\n            Transformed command for proper runtime execution\n        '''\n        pass"
  }
]