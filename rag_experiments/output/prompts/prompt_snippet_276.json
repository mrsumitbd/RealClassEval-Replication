[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass DatatableJSONResponseMixin(object):\n\n    def dispatch(self, request, *args, **kwargs):\n        pass\n\n    def get_json_response_object(self, datatable):\n        '''\n        Returns the JSON-compatible dictionary that will be serialized for an AJAX response.\n        The value names are in the form \"s~\" for strings, \"i~\" for integers, and \"a~\" for arrays,\n        if you're unfamiliar with the old C-style jargon used in dataTables.js.  \"aa~\" means\n        \"array of arrays\".  In some instances, the author uses \"ao~\" for \"array of objects\", an\n        object being a javascript dictionary.\n        '''\n        pass\n\n    def serialize_to_json(self, response_data):\n        '''Returns the JSON string for the compiled data object.'''\n        pass\nCorresponding class implementation:\n\nimport json\nfrom django.conf import settings\nfrom django.core.serializers.json import DjangoJSONEncoder\nfrom django.utils.encoding import escape_uri_path\n\nclass DatatableJSONResponseMixin(object):\n\n    def dispatch(self, request, *args, **kwargs):\n        try:\n            is_ajax = request.headers.get('x-requested-with') == 'XMLHttpRequest'\n        except AttributeError:\n            is_ajax = request.is_ajax()\n        if is_ajax or getattr(request, request.method).get('ajax') == 'true':\n            datatable = self.get_datatable()\n            datatable.configure()\n            if request.method == datatable.config['request_method']:\n                return self.get_ajax(request, *args, **kwargs)\n        return super(DatatableJSONResponseMixin, self).dispatch(request, *args, **kwargs)\n\n    def get_json_response_object(self, datatable):\n        \"\"\"\n        Returns the JSON-compatible dictionary that will be serialized for an AJAX response.\n\n        The value names are in the form \"s~\" for strings, \"i~\" for integers, and \"a~\" for arrays,\n        if you're unfamiliar with the old C-style jargon used in dataTables.js.  \"aa~\" means\n        \"array of arrays\".  In some instances, the author uses \"ao~\" for \"array of objects\", an\n        object being a javascript dictionary.\n        \"\"\"\n        datatable.populate_records()\n        draw = getattr(self.request, self.request.method).get('draw', None)\n        if draw is not None:\n            draw = escape_uri_path(draw)\n        response_data = {'draw': draw, 'recordsFiltered': datatable.unpaged_record_count, 'recordsTotal': datatable.total_initial_record_count, 'data': [dict(record, **{'DT_RowId': record.pop('pk'), 'DT_RowData': record.pop('_extra_data')}) for record in datatable.get_records()]}\n        return response_data\n\n    def serialize_to_json(self, response_data):\n        \"\"\"Returns the JSON string for the compiled data object.\"\"\"\n        indent = None\n        if settings.DEBUG:\n            indent = 4\n        return json.dumps(response_data, indent=indent, cls=DjangoJSONEncoder)\n\nExample skeleton:\n\n\nclass CatalogueFunctionRegistry(dict):\n    '''\n    A collection of methods/functions working on catalogues.\n    The registry also holds information about the type of the input arguments\n    '''\n\n    def check_config(self, config, fields_spec):\n        '''\n        Check that `config` has each field in `fields_spec` if a default\n        has not been provided.\n        '''\n        pass\n\n    def set_defaults(self, config, fields_spec):\n        '''\n        Set default values got from `fields_spec` into the `config`\n        dictionary\n        '''\n        pass\n\n    def add(self, method_name, completeness=False, **fields):\n        '''\n        Class decorator.\n        Decorate `method_name` by adding a call to `set_defaults` and\n        `check_config`. Then, save into the registry a callable\n        function with the same signature of the original method.\n        :param str method_name:\n            the method to decorate\n        :param bool completeness:\n            True if the method accepts in input an optional parameter\n            for the completeness table\n        :param fields:\n            a dictionary of field spec corresponding to the\n            keys expected to be present in the config dictionary\n            for the decorated method, e.g.\n            time_bin=float,\n            b_value=1E-6\n        '''\n        pass\n\n        def class_decorator(class_obj):\n                pass\n\n            def caller(fn, obj, catalogue, config=None, *args, **kwargs):\n                        pass\n\n    def add_function(self, completeness=False, **fields):\n        '''\n        Function decorator.\n        Decorate a function by adding a call to `set_defaults` and\n        `check_config`. Then, save into the registry a callable\n        function with the same signature of the original method\n        :param fields:\n            a dictionary of field spec, e.g.\n            time_bin=float,\n            b_value=1E-6\n        '''\n        pass\n\n        def dec(fn):\n                pass\n\n                def fn_with_config_and_c(catalogue, config, completeness_table=None):\n                                pass\n\n                def fn_with_config_without_c(catalogue, config):\n                                pass\nCorresponding class implementation:\n\nimport sys\nfrom decorator import decorator\nimport functools\n\nclass CatalogueFunctionRegistry(dict):\n    \"\"\"\n    A collection of methods/functions working on catalogues.\n\n    The registry also holds information about the type of the input arguments\n    \"\"\"\n\n    def check_config(self, config, fields_spec):\n        \"\"\"\n        Check that `config` has each field in `fields_spec` if a default\n        has not been provided.\n        \"\"\"\n        for field, type_info in fields_spec.items():\n            has_default = not isinstance(type_info, type)\n            if field not in config and (not has_default):\n                raise RuntimeError('Configuration not complete. %s missing' % field)\n\n    def set_defaults(self, config, fields_spec):\n        \"\"\"\n        Set default values got from `fields_spec` into the `config`\n        dictionary\n        \"\"\"\n        defaults = dict([(f, d) for f, d in fields_spec.items() if not isinstance(d, type)])\n        for field, default_value in defaults.items():\n            if field not in config:\n                config[field] = default_value\n\n    def add(self, method_name, completeness=False, **fields):\n        \"\"\"\n        Class decorator.\n\n        Decorate `method_name` by adding a call to `set_defaults` and\n        `check_config`. Then, save into the registry a callable\n        function with the same signature of the original method.\n\n        :param str method_name:\n            the method to decorate\n        :param bool completeness:\n            True if the method accepts in input an optional parameter\n            for the completeness table\n        :param fields:\n            a dictionary of field spec corresponding to the\n            keys expected to be present in the config dictionary\n            for the decorated method, e.g.\n            time_bin=float,\n            b_value=1E-6\n        \"\"\"\n\n        def class_decorator(class_obj):\n            original_method = getattr(class_obj, method_name)\n            if sys.version[0] == '2':\n                original_method = original_method.im_func\n\n            def caller(fn, obj, catalogue, config=None, *args, **kwargs):\n                config = config or {}\n                self.set_defaults(config, fields)\n                self.check_config(config, fields)\n                return fn(obj, catalogue, config, *args, **kwargs)\n            new_method = decorator(caller, original_method)\n            setattr(class_obj, method_name, new_method)\n            instance = class_obj()\n            func = functools.partial(new_method, instance)\n            func.fields = fields\n            func.model = instance\n            func.completeness = completeness\n            functools.update_wrapper(func, new_method)\n            self[class_obj.__name__] = func\n            return class_obj\n        return class_decorator\n\n    def add_function(self, completeness=False, **fields):\n        \"\"\"\n        Function decorator.\n\n        Decorate a function by adding a call to `set_defaults` and\n        `check_config`. Then, save into the registry a callable\n        function with the same signature of the original method\n\n        :param fields:\n            a dictionary of field spec, e.g.\n            time_bin=float,\n            b_value=1E-6\n        \"\"\"\n\n        def dec(fn):\n            if completeness:\n\n                def fn_with_config_and_c(catalogue, config, completeness_table=None):\n                    return fn(catalogue, completeness_table, **config)\n                fn_with_config = fn_with_config_and_c\n            else:\n\n                def fn_with_config_without_c(catalogue, config):\n                    return fn(catalogue, **config)\n                fn_with_config = fn_with_config_without_c\n            fn_with_config.fields = fields\n            fn_with_config.completeness = completeness\n            fn.fields = fields\n            self[fn.__name__] = fn_with_config\n            return fn\n        return dec\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass NoDefaultsMixin:\n    '''\n    Mixin so that we don't need to copy and paste the code to avoid filling JSON values\n    with a full catalog of the default values of rarely-used fields.\n        '''\n    @pydantic.model_serializer(mode='wrap')\n    def _workaround_for_design_flaw_in_pydantic(self, nxt):\n        '''\n        Workaround for a design flaw in Pydantic that forces users to accept\n        unnecessary garbage in their serialized JSON data or to override\n        poorly-documented serialization hooks repeatedly.  Automates overriding said\n        poorly-documented serialization hooks for a single dataclass.\n        See https://github.com/pydantic/pydantic/issues/4554 for the relevant dismissive\n        comment from the devs. This comment suggests overriding :func:`dict()`, but that\n        method was disabled a year later. Now you need to add a custom serializer method\n        with a ``@model_serializer`` decorator.\n        See the docs at\n        https://docs.pydantic.dev/latest/api/functional_serializers/\n        for some dubious information on how this API works.\n        See comments below for important gotchas that aren't in the documentation.\n        '''\n        pass\n\n    def _keep_these_fields(self) -> tuple[str]:\n        '''\n        Dataclasses that include this mixin can override this method to add specific\n        default values to serialized JSON.\n        This is necessary for round-tripping to JSON when there are fields that\n        determine which dataclass to use for deserialization.\n                '''\n                pass"
  }
]