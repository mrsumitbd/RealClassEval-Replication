[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass WinLnkParser(interface.FileObjectParser):\n    '''Windows Shortcut (LNK) file parser.'''\n\n    def __init__(self):\n        '''Initializes a Windows Shortcut (LNK) file parser.'''\n        pass\n\n    def _GetDateTime(self, filetime):\n        '''Retrieves the date and time from a FILETIME timestamp.\n        Args:\n          filetime (int): FILETIME timestamp.\n        Returns:\n          dfdatetime.DateTimeValues: date and time or None if not set.\n        '''\n        pass\n\n    def _GetSanitizedPathString(self, path):\n        '''Retrieves a sanitize path string.\n        Args:\n          path (str): path.\n        Returns:\n          str: sanitized path string.\n        '''\n        pass\n    @classmethod\n    def GetFormatSpecification(cls):\n        '''Retrieves the format specification.\n        Returns:\n          FormatSpecification: format specification.\n        '''\n        pass\n\n    def _ParseDistributedTrackingIdentifier(self, parser_mediator, uuid_string, origin):\n        '''Extracts data from a Distributed Tracking identifier.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          uuid_string (str): UUID string of the Distributed Tracking identifier.\n          origin (str): origin of the event (event source).\n        '''\n        pass\n\n    def ParseFileObject(self, parser_mediator, file_object):\n        '''Parses a Windows Shortcut (LNK) file-like object.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): file-like object.\n        '''\n        pass\n\n    def ParseFileLNKFile(self, parser_mediator, file_object, display_name):\n        '''Parses a Windows Shortcut (LNK) file-like object.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): file-like object.\n          display_name (str): display name.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom plaso.lib import specification\nfrom dfdatetime import filetime as dfdatetime_filetime\nfrom plaso.containers import windows_events\nimport uuid\nfrom plaso.parsers.shared import shell_items\nfrom plaso.parsers import interface\nfrom plaso.lib import definitions\nimport pylnk\n\nclass WinLnkParser(interface.FileObjectParser):\n    \"\"\"Windows Shortcut (LNK) file parser.\"\"\"\n    _INITIAL_FILE_OFFSET = None\n    _PATH_ESCAPE_CHARACTERS = {'\\\\': '\\\\\\\\'}\n    _PATH_ESCAPE_CHARACTERS.update(definitions.NON_PRINTABLE_CHARACTERS)\n    NAME = 'lnk'\n    DATA_FORMAT = 'Windows Shortcut (LNK) file'\n\n    def __init__(self):\n        \"\"\"Initializes a Windows Shortcut (LNK) file parser.\"\"\"\n        super(WinLnkParser, self).__init__()\n        self._path_escape_characters = str.maketrans(self._PATH_ESCAPE_CHARACTERS)\n\n    def _GetDateTime(self, filetime):\n        \"\"\"Retrieves the date and time from a FILETIME timestamp.\n\n        Args:\n          filetime (int): FILETIME timestamp.\n\n        Returns:\n          dfdatetime.DateTimeValues: date and time or None if not set.\n        \"\"\"\n        if not filetime:\n            return None\n        return dfdatetime_filetime.Filetime(timestamp=filetime)\n\n    def _GetSanitizedPathString(self, path):\n        \"\"\"Retrieves a sanitize path string.\n\n        Args:\n          path (str): path.\n\n        Returns:\n          str: sanitized path string.\n        \"\"\"\n        if not path:\n            return None\n        return path.translate(self._path_escape_characters)\n\n    @classmethod\n    def GetFormatSpecification(cls):\n        \"\"\"Retrieves the format specification.\n\n        Returns:\n          FormatSpecification: format specification.\n        \"\"\"\n        format_specification = specification.FormatSpecification(cls.NAME)\n        format_specification.AddNewSignature(b'\\x01\\x14\\x02\\x00\\x00\\x00\\x00\\x00\\xc0\\x00\\x00\\x00\\x00\\x00\\x00F', offset=4)\n        return format_specification\n\n    def _ParseDistributedTrackingIdentifier(self, parser_mediator, uuid_string, origin):\n        \"\"\"Extracts data from a Distributed Tracking identifier.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          uuid_string (str): UUID string of the Distributed Tracking identifier.\n          origin (str): origin of the event (event source).\n        \"\"\"\n        uuid_object = uuid.UUID(uuid_string)\n        if uuid_object.version == 1:\n            event_data = windows_events.WindowsDistributedLinkTrackingEventData(uuid_object, origin)\n            parser_mediator.ProduceEventData(event_data)\n\n    def ParseFileObject(self, parser_mediator, file_object):\n        \"\"\"Parses a Windows Shortcut (LNK) file-like object.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): file-like object.\n        \"\"\"\n        display_name = parser_mediator.GetDisplayName()\n        self.ParseFileLNKFile(parser_mediator, file_object, display_name)\n\n    def ParseFileLNKFile(self, parser_mediator, file_object, display_name):\n        \"\"\"Parses a Windows Shortcut (LNK) file-like object.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): file-like object.\n          display_name (str): display name.\n        \"\"\"\n        code_page = parser_mediator.GetCodePage()\n        lnk_file = pylnk.file()\n        lnk_file.set_ascii_codepage(code_page)\n        try:\n            lnk_file.open_file_object(file_object)\n        except IOError as exception:\n            parser_mediator.ProduceExtractionWarning('unable to open file with error: {0!s}'.format(exception))\n            return\n        link_target = None\n        if lnk_file.link_target_identifier_data:\n            display_name = parser_mediator.GetFilename()\n            shell_items_parser = shell_items.ShellItemsParser(display_name)\n            shell_items_parser.ParseByteStream(parser_mediator, lnk_file.link_target_identifier_data, codepage=code_page)\n            link_target = shell_items_parser.CopyToPath()\n        access_time = lnk_file.get_file_access_time_as_integer()\n        creation_time = lnk_file.get_file_creation_time_as_integer()\n        modification_time = lnk_file.get_file_modification_time_as_integer()\n        event_data = WinLnkLinkEventData()\n        event_data.access_time = self._GetDateTime(access_time)\n        event_data.birth_droid_file_identifier = lnk_file.birth_droid_file_identifier\n        event_data.birth_droid_volume_identifier = lnk_file.birth_droid_volume_identifier\n        event_data.command_line_arguments = self._GetSanitizedPathString(lnk_file.command_line_arguments)\n        event_data.creation_time = self._GetDateTime(creation_time)\n        event_data.description = self._GetSanitizedPathString(lnk_file.description)\n        event_data.drive_serial_number = lnk_file.drive_serial_number\n        event_data.drive_type = lnk_file.drive_type\n        event_data.droid_file_identifier = lnk_file.droid_file_identifier\n        event_data.droid_volume_identifier = lnk_file.droid_volume_identifier\n        event_data.env_var_location = self._GetSanitizedPathString(lnk_file.environment_variables_location)\n        event_data.file_attribute_flags = lnk_file.file_attribute_flags\n        event_data.file_size = lnk_file.file_size\n        event_data.icon_location = self._GetSanitizedPathString(lnk_file.icon_location)\n        event_data.link_target = link_target\n        event_data.local_path = self._GetSanitizedPathString(lnk_file.local_path)\n        event_data.modification_time = self._GetDateTime(modification_time)\n        event_data.network_path = self._GetSanitizedPathString(lnk_file.network_path)\n        event_data.relative_path = self._GetSanitizedPathString(lnk_file.relative_path)\n        event_data.volume_label = lnk_file.volume_label\n        event_data.working_directory = self._GetSanitizedPathString(lnk_file.working_directory)\n        parser_mediator.ProduceEventData(event_data)\n        if lnk_file.droid_file_identifier:\n            try:\n                self._ParseDistributedTrackingIdentifier(parser_mediator, lnk_file.droid_file_identifier, display_name)\n            except (TypeError, ValueError) as exception:\n                parser_mediator.ProduceExtractionWarning('unable to read droid file identifier with error: {0!s}.'.format(exception))\n        if lnk_file.birth_droid_file_identifier and lnk_file.birth_droid_file_identifier != lnk_file.droid_file_identifier:\n            try:\n                self._ParseDistributedTrackingIdentifier(parser_mediator, lnk_file.birth_droid_file_identifier, display_name)\n            except (TypeError, ValueError) as exception:\n                parser_mediator.ProduceExtractionWarning('unable to read birth droid file identifier with error: {0!s}.'.format(exception))\n        lnk_file.close()\n\nExample skeleton:\n\n\nclass RefLog(List[RefLogEntry], Serializable):\n    '''A reflog contains :class:`RefLogEntry`\\s, each of which defines a certain state\n    of the head in question. Custom query methods allow to retrieve log entries by date\n    or by other criteria.\n    Reflog entries are ordered. The first added entry is first in the list. The last\n    entry, i.e. the last change of the head or reference, is last in the list.\n    '''\n\n    def __new__(cls, filepath: Union[PathLike, None]=None) -> 'RefLog':\n        pass\n\n    def __init__(self, filepath: Union[PathLike, None]=None) -> None:\n        '''Initialize this instance with an optional filepath, from which we will\n        initialize our data. The path is also used to write changes back using the\n        :meth:`write` method.'''\n        pass\n\n    def _read_from_file(self) -> None:\n        pass\n    @classmethod\n    def from_file(cls, filepath: PathLike) -> 'RefLog':\n        '''\n        :return:\n            A new :class:`RefLog` instance containing all entries from the reflog at the\n            given `filepath`.\n        :param filepath:\n            Path to reflog.\n        :raise ValueError:\n            If the file could not be read or was corrupted in some way.\n        '''\n        pass\n    @classmethod\n    def path(cls, ref: 'SymbolicReference') -> str:\n        '''\n        :return:\n            String to absolute path at which the reflog of the given ref instance would\n            be found. The path is not guaranteed to point to a valid file though.\n        :param ref:\n            :class:`~git.refs.symbolic.SymbolicReference` instance\n        '''\n        pass\n    @classmethod\n    def iter_entries(cls, stream: Union[str, 'BytesIO', mmap]) -> Iterator[RefLogEntry]:\n        '''\n        :return:\n            Iterator yielding :class:`RefLogEntry` instances, one for each line read\n            from the given stream.\n        :param stream:\n            File-like object containing the revlog in its native format or string\n            instance pointing to a file to read.\n        '''\n        pass\n    @classmethod\n    def entry_at(cls, filepath: PathLike, index: int) -> 'RefLogEntry':\n        '''\n        :return:\n            :class:`RefLogEntry` at the given index.\n        :param filepath:\n            Full path to the index file from which to read the entry.\n        :param index:\n            Python list compatible index, i.e. it may be negative to specify an entry\n            counted from the end of the list.\n        :raise IndexError:\n            If the entry didn't exist.\n        :note:\n            This method is faster as it only parses the entry at index, skipping all\n            other lines. Nonetheless, the whole file has to be read if the index is\n            negative.\n        '''\n        pass\n\n    def to_file(self, filepath: PathLike) -> None:\n        '''Write the contents of the reflog instance to a file at the given filepath.\n        :param filepath:\n            Path to file. Parent directories are assumed to exist.\n        '''\n        pass\n    @classmethod\n    def append_entry(cls, config_reader: Union[Actor, 'GitConfigParser', 'SectionConstraint', None], filepath: PathLike, oldbinsha: bytes, newbinsha: bytes, message: str, write: bool=True) -> 'RefLogEntry':\n        '''Append a new log entry to the revlog at filepath.\n        :param config_reader:\n            Configuration reader of the repository - used to obtain user information.\n            May also be an :class:`~git.util.Actor` instance identifying the committer\n            directly or ``None``.\n        :param filepath:\n            Full path to the log file.\n        :param oldbinsha:\n            Binary sha of the previous commit.\n        :param newbinsha:\n            Binary sha of the current commit.\n        :param message:\n            Message describing the change to the reference.\n        :param write:\n            If ``True``, the changes will be written right away.\n            Otherwise the change will not be written.\n        :return:\n            :class:`RefLogEntry` objects which was appended to the log.\n        :note:\n            As we are append-only, concurrent access is not a problem as we do not\n            interfere with readers.\n        '''\n        pass\n\n    def write(self) -> 'RefLog':\n        '''Write this instance's data to the file we are originating from.\n        :return:\n            self\n        '''\n        pass\n\n    def _serialize(self, stream: 'BytesIO') -> 'RefLog':\n        pass\n\n    def _deserialize(self, stream: 'BytesIO') -> 'RefLog':\n        pass\nCorresponding class implementation:\n\nfrom git.types import PathLike\nfrom mmap import mmap\nfrom typing import Iterator, List, Tuple, TYPE_CHECKING, Union\nfrom git.compat import defenc\nfrom git.util import Actor, LockedFD, LockFile, assure_directory_exists, bin_to_hex, file_contents_ro_filepath, to_native_path\nimport time as _time\nimport os.path as osp\nfrom git.objects.util import Serializable, altz_to_utctz_str, parse_date\n\nclass RefLog(List[RefLogEntry], Serializable):\n    \"\"\"A reflog contains :class:`RefLogEntry`\\\\s, each of which defines a certain state\n    of the head in question. Custom query methods allow to retrieve log entries by date\n    or by other criteria.\n\n    Reflog entries are ordered. The first added entry is first in the list. The last\n    entry, i.e. the last change of the head or reference, is last in the list.\n    \"\"\"\n    __slots__ = ('_path',)\n\n    def __new__(cls, filepath: Union[PathLike, None]=None) -> 'RefLog':\n        inst = super().__new__(cls)\n        return inst\n\n    def __init__(self, filepath: Union[PathLike, None]=None) -> None:\n        \"\"\"Initialize this instance with an optional filepath, from which we will\n        initialize our data. The path is also used to write changes back using the\n        :meth:`write` method.\"\"\"\n        self._path = filepath\n        if filepath is not None:\n            self._read_from_file()\n\n    def _read_from_file(self) -> None:\n        try:\n            fmap = file_contents_ro_filepath(self._path, stream=True, allow_mmap=True)\n        except OSError:\n            return\n        try:\n            self._deserialize(fmap)\n        finally:\n            fmap.close()\n\n    @classmethod\n    def from_file(cls, filepath: PathLike) -> 'RefLog':\n        \"\"\"\n        :return:\n            A new :class:`RefLog` instance containing all entries from the reflog at the\n            given `filepath`.\n\n        :param filepath:\n            Path to reflog.\n\n        :raise ValueError:\n            If the file could not be read or was corrupted in some way.\n        \"\"\"\n        return cls(filepath)\n\n    @classmethod\n    def path(cls, ref: 'SymbolicReference') -> str:\n        \"\"\"\n        :return:\n            String to absolute path at which the reflog of the given ref instance would\n            be found. The path is not guaranteed to point to a valid file though.\n\n        :param ref:\n            :class:`~git.refs.symbolic.SymbolicReference` instance\n        \"\"\"\n        return osp.join(ref.repo.git_dir, 'logs', to_native_path(ref.path))\n\n    @classmethod\n    def iter_entries(cls, stream: Union[str, 'BytesIO', mmap]) -> Iterator[RefLogEntry]:\n        \"\"\"\n        :return:\n            Iterator yielding :class:`RefLogEntry` instances, one for each line read\n            from the given stream.\n\n        :param stream:\n            File-like object containing the revlog in its native format or string\n            instance pointing to a file to read.\n        \"\"\"\n        new_entry = RefLogEntry.from_line\n        if isinstance(stream, str):\n            _stream = file_contents_ro_filepath(stream)\n            assert isinstance(_stream, mmap)\n        else:\n            _stream = stream\n        while True:\n            line = _stream.readline()\n            if not line:\n                return\n            yield new_entry(line.strip())\n\n    @classmethod\n    def entry_at(cls, filepath: PathLike, index: int) -> 'RefLogEntry':\n        \"\"\"\n        :return:\n            :class:`RefLogEntry` at the given index.\n\n        :param filepath:\n            Full path to the index file from which to read the entry.\n\n        :param index:\n            Python list compatible index, i.e. it may be negative to specify an entry\n            counted from the end of the list.\n\n        :raise IndexError:\n            If the entry didn't exist.\n\n        :note:\n            This method is faster as it only parses the entry at index, skipping all\n            other lines. Nonetheless, the whole file has to be read if the index is\n            negative.\n        \"\"\"\n        with open(filepath, 'rb') as fp:\n            if index < 0:\n                return RefLogEntry.from_line(fp.readlines()[index].strip())\n            for i in range(index + 1):\n                line = fp.readline()\n                if not line:\n                    raise IndexError(f'Index file ended at line {i + 1}, before given index was reached')\n            return RefLogEntry.from_line(line.strip())\n\n    def to_file(self, filepath: PathLike) -> None:\n        \"\"\"Write the contents of the reflog instance to a file at the given filepath.\n\n        :param filepath:\n            Path to file. Parent directories are assumed to exist.\n        \"\"\"\n        lfd = LockedFD(filepath)\n        assure_directory_exists(filepath, is_file=True)\n        fp = lfd.open(write=True, stream=True)\n        try:\n            self._serialize(fp)\n            lfd.commit()\n        except BaseException:\n            lfd.rollback()\n            raise\n\n    @classmethod\n    def append_entry(cls, config_reader: Union[Actor, 'GitConfigParser', 'SectionConstraint', None], filepath: PathLike, oldbinsha: bytes, newbinsha: bytes, message: str, write: bool=True) -> 'RefLogEntry':\n        \"\"\"Append a new log entry to the revlog at filepath.\n\n        :param config_reader:\n            Configuration reader of the repository - used to obtain user information.\n            May also be an :class:`~git.util.Actor` instance identifying the committer\n            directly or ``None``.\n\n        :param filepath:\n            Full path to the log file.\n\n        :param oldbinsha:\n            Binary sha of the previous commit.\n\n        :param newbinsha:\n            Binary sha of the current commit.\n\n        :param message:\n            Message describing the change to the reference.\n\n        :param write:\n            If ``True``, the changes will be written right away.\n            Otherwise the change will not be written.\n\n        :return:\n            :class:`RefLogEntry` objects which was appended to the log.\n\n        :note:\n            As we are append-only, concurrent access is not a problem as we do not\n            interfere with readers.\n        \"\"\"\n        if len(oldbinsha) != 20 or len(newbinsha) != 20:\n            raise ValueError('Shas need to be given in binary format')\n        assure_directory_exists(filepath, is_file=True)\n        first_line = message.split('\\n')[0]\n        if isinstance(config_reader, Actor):\n            committer = config_reader\n        else:\n            committer = Actor.committer(config_reader)\n        entry = RefLogEntry((bin_to_hex(oldbinsha).decode('ascii'), bin_to_hex(newbinsha).decode('ascii'), committer, (int(_time.time()), _time.altzone), first_line))\n        if write:\n            lf = LockFile(filepath)\n            lf._obtain_lock_or_raise()\n            fd = open(filepath, 'ab')\n            try:\n                fd.write(entry.format().encode(defenc))\n            finally:\n                fd.close()\n                lf._release_lock()\n        return entry\n\n    def write(self) -> 'RefLog':\n        \"\"\"Write this instance's data to the file we are originating from.\n\n        :return:\n            self\n        \"\"\"\n        if self._path is None:\n            raise ValueError('Instance was not initialized with a path, use to_file(...) instead')\n        self.to_file(self._path)\n        return self\n\n    def _serialize(self, stream: 'BytesIO') -> 'RefLog':\n        write = stream.write\n        for e in self:\n            write(e.format().encode(defenc))\n        return self\n\n    def _deserialize(self, stream: 'BytesIO') -> 'RefLog':\n        self.extend(self.iter_entries(stream))\n        return self\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass TimestampProcessor:\n    '''Unified timestamp parsing and processing utilities.'''\n\n    def __init__(self, timezone_handler: Optional[TimezoneHandler]=None) -> None:\n        '''Initialize with optional timezone handler.'''\n        pass\n\n    def parse_timestamp(self, timestamp_value: Union[str, int, float, datetime, None]) -> Optional[datetime]:\n        '''Parse timestamp from various formats to UTC datetime.\n        Args:\n            timestamp_value: Timestamp in various formats (str, int, float, datetime)\n        Returns:\n            Parsed UTC datetime or None if parsing fails\n        '''\n        pass"
  }
]