[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass LogFile(File):\n    '''\n    A log file to configure with Python's logging module.\n    '''\n\n    def __init__(self, path=None, logger=None, loggers=[], formatter={}, format=None, *args, **kwargs):\n        pass\n\n    def prepare(self):\n        '''\n        Configure the log file.\n        '''\n        pass\n\n    def configure(self):\n        '''\n        Configure the Python logging module for this file.\n        '''\n        pass\nCorresponding class implementation:\n\nimport logging.config\nimport logging\nfrom six import string_types\n\nclass LogFile(File):\n    \"\"\"\n    A log file to configure with Python's logging module.\n    \"\"\"\n\n    def __init__(self, path=None, logger=None, loggers=[], formatter={}, format=None, *args, **kwargs):\n        super(LogFile, self).__init__(*args, path=path, **kwargs)\n        self._create = True\n        self._cleanup = True\n        self._formatter = formatter\n        self._format = format\n        if logger:\n            self._loggers = [logger]\n        else:\n            self._loggers = loggers\n\n    def prepare(self):\n        \"\"\"\n        Configure the log file.\n        \"\"\"\n        self.configure()\n\n    def configure(self):\n        \"\"\"\n        Configure the Python logging module for this file.\n        \"\"\"\n        handler = logging.FileHandler(self.path, delay=True)\n        if self._format:\n            handler.setFormatter(logging.Formatter(self._format))\n        if isinstance(self._format, string_types):\n            if self._env and self._env.config.logging.dict_config.formatters[self._formatter]:\n                d = self._env.config.logging.dict_config.formatters[self._formatter].to_dict()\n                handler.setFormatter(logging.Formatter(**d))\n        elif type(self._formatter) == dict:\n            handler.setFormatter(logging.Formatter(**self._formatter))\n        if len(self._loggers):\n            for name in self._loggers:\n                logging.getLogger(name).addHandler(handler)\n        else:\n            logging.getLogger().addHandler(handler)\n\nExample skeleton:\n\n\nclass Logging:\n    '''\n    Logging Configuration\n    '''\n\n    def __init__(self, name='fmf'):\n        pass\n\n    class ColoredFormatter(logging.Formatter):\n        '''\n        Custom color formatter for logging\n        '''\n\n        def format(self, record):\n                pass\n    @staticmethod\n    def _create_logger(name='fmf', level=None):\n        '''\n        Create fmf logger\n        '''\n        pass\n\n    def set(self, level=None):\n        '''\n        Set the default log level\n        If the level is not specified environment variable DEBUG is used\n        with the following meaning::\n            DEBUG=0 ... LOG_WARN (default)\n            DEBUG=1 ... LOG_INFO\n            DEBUG=2 ... LOG_DEBUG\n            DEBUG=3 ... LOG_CACHE\n            DEBUG=4 ... LOG_DATA\n            DEBUG=5 ... LOG_ALL (log all messages)\n        '''\n        pass\n\n    def get(self):\n        '''\n        Get the current log level\n        '''\n        pass\nCorresponding class implementation:\n\nimport os\nimport logging\n\nclass Logging:\n    \"\"\"\n    Logging Configuration\n    \"\"\"\n    COLORS = {LOG_ERROR: 'red', LOG_WARN: 'yellow', LOG_INFO: 'blue', LOG_DEBUG: 'green', LOG_CACHE: 'cyan', LOG_DATA: 'magenta'}\n    MAPPING = {0: LOG_WARN, 1: LOG_INFO, 2: LOG_DEBUG, 3: LOG_CACHE, 4: LOG_DATA, 5: LOG_ALL}\n    LEVELS = 'CRITICAL DEBUG ERROR FATAL INFO NOTSET WARN WARNING'.split()\n    _level = LOG_WARN\n    _loggers: dict[str, logging.Logger] = dict()\n\n    def __init__(self, name='fmf'):\n        try:\n            self.logger = Logging._loggers[name]\n        except KeyError:\n            self.logger = self._create_logger(name=name)\n            Logging._loggers[name] = self.logger\n            self.set()\n\n    class ColoredFormatter(logging.Formatter):\n        \"\"\"\n        Custom color formatter for logging\n        \"\"\"\n\n        def format(self, record):\n            if record.levelno == LOG_ALL:\n                levelname = 'ALL'\n            elif record.levelno == LOG_DATA:\n                levelname = 'DATA'\n            elif record.levelno == LOG_CACHE:\n                levelname = 'CACHE'\n            else:\n                levelname = record.levelname\n            try:\n                colour = Logging.COLORS[record.levelno]\n            except KeyError:\n                colour = 'black'\n            if Coloring().enabled():\n                level = color(' ' + levelname + ' ', 'lightwhite', colour)\n            else:\n                level = '[{0}]'.format(levelname)\n            return u'{0} {1}'.format(level, record.getMessage())\n\n    @staticmethod\n    def _create_logger(name='fmf', level=None):\n        \"\"\"\n        Create fmf logger\n        \"\"\"\n        logger = logging.getLogger(name)\n        handler = logging.StreamHandler()\n        handler.setFormatter(Logging.ColoredFormatter())\n        logger.addHandler(handler)\n        for level in Logging.LEVELS:\n            setattr(logger, level, getattr(logging, level))\n        logger.DATA = LOG_DATA\n        logger.CACHE = LOG_CACHE\n        logger.ALL = LOG_ALL\n        logger.cache = lambda message: logger.log(LOG_CACHE, message)\n        logger.data = lambda message: logger.log(LOG_DATA, message)\n        logger.all = lambda message: logger.log(LOG_ALL, message)\n        return logger\n\n    def set(self, level=None):\n        \"\"\"\n        Set the default log level\n\n        If the level is not specified environment variable DEBUG is used\n        with the following meaning::\n\n            DEBUG=0 ... LOG_WARN (default)\n            DEBUG=1 ... LOG_INFO\n            DEBUG=2 ... LOG_DEBUG\n            DEBUG=3 ... LOG_CACHE\n            DEBUG=4 ... LOG_DATA\n            DEBUG=5 ... LOG_ALL (log all messages)\n        \"\"\"\n        if level is not None:\n            Logging._level = level\n        else:\n            try:\n                Logging._level = Logging.MAPPING[int(os.environ['DEBUG'])]\n            except Exception:\n                Logging._level = logging.WARN\n        self.logger.setLevel(Logging._level)\n\n    def get(self):\n        \"\"\"\n        Get the current log level\n        \"\"\"\n        return self.logger.level\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass Logger:\n    '''Centralized logger for mcp_use.\n    This class provides logging functionality with configurable levels,\n    formatters, and handlers.\n    '''\n    @classmethod\n    def get_logger(cls, name: str='mcp_use') -> logging.Logger:\n        '''Get a logger instance for the specified name.\n        Args:\n            name: Logger name, usually the module name (defaults to 'mcp_use')\n        Returns:\n            Configured logger instance\n        '''\n        pass\n    @classmethod\n    def configure(cls, level: int | str=None, format_str: str | None=None, log_to_console: bool=True, log_to_file: str | None=None) -> None:\n        '''Configure the root mcp_use logger.\n        Args:\n            level: Log level (default: DEBUG if MCP_USE_DEBUG is 2,\n            INFO if MCP_USE_DEBUG is 1,\n            otherwise WARNING)\n            format_str: Log format string (default: DEFAULT_FORMAT)\n            log_to_console: Whether to log to console (default: True)\n            log_to_file: Path to log file (default: None)\n        '''\n        pass\n    @classmethod\n    def set_debug(cls, debug_level: int=2) -> None:\n        '''Set the debug flag and update the log level accordingly.\n        Args:\n            debug_level: Debug level (0=off, 1=info, 2=debug)\n        '''\n        pass"
  }
]