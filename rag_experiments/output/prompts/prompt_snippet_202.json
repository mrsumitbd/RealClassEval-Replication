[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Metadata(UNTLElement):\n\n    def __init__(self, **kwargs):\n        pass\n\n    def create_xml_string(self):\n        '''Create a UNTL document in a string from a UNTL metadata\n        root object.\n        untl_xml_string = metadata_root_object.create_xml_string()\n        '''\n        pass\n\n    def create_xml_string(self):\n        '''Create an ElementTree representation of the object.'''\n        pass\n\n    def create_element_dict(self):\n        '''Convert a UNTL Python object into a UNTL Python dictionary.'''\n        pass\n\n    def create_xml_file(self, untl_filename):\n        '''Create a UNTL file.\n        Writes file to supplied file path.\n        '''\n        pass\n\n    def sort_untl(self, sort_structure):\n        '''Sort the UNTL Python object by the index\n        of a sort structure pre-ordered list.\n        '''\n        pass\n\n    def validate(self):\n        ''' Validate all of the UNTL elements.'''\n        pass\n\n    def generate_form_data(self, **kwargs):\n        '''Create a form dictionary with the key being the element name\n        and the value being a list of form element objects.\n        '''\n        pass\n\n    def make_hidden(self):\n        '''Make an unhidden record hidden.'''\n        pass\n\n    def make_unhidden(self):\n        '''Make a hidden record unhidden.'''\n        pass\n    @property\n    def is_hidden(self):\n        '''Return True if a UNTL element is hidden.'''\n        pass\nCorresponding class implementation:\n\nfrom lxml.etree import Element, SubElement, tostring\nimport sys\nfrom pyuntl import UNTL_XML_ORDER, VOCABULARIES_URL\n\nclass Metadata(UNTLElement):\n\n    def __init__(self, **kwargs):\n        self.tag = 'metadata'\n        self.allows_content = False\n        self.allows_qualifier = False\n        self.contained_children = ['title', 'identifier', 'note', 'institution', 'collection', 'subject', 'creator', 'primarySource', 'description', 'date', 'publisher', 'contributor', 'source', 'language', 'coverage', 'resourceType', 'relation', 'format', 'rights', 'degree', 'meta', 'citation']\n        super(Metadata, self).__init__(**kwargs)\n\n    def create_xml_string(self):\n        \"\"\"Create a UNTL document in a string from a UNTL metadata\n        root object.\n\n        untl_xml_string = metadata_root_object.create_xml_string()\n        \"\"\"\n        root = self.create_xml()\n        return b'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' + tostring(root, encoding='UTF-8', xml_declaration=False, pretty_print=True)\n\n    def create_xml(self, useNamespace=False):\n        \"\"\"Create an ElementTree representation of the object.\"\"\"\n        UNTL_NAMESPACE = 'http://digital2.library.unt.edu/untl/'\n        UNTL = '{%s}' % UNTL_NAMESPACE\n        NSMAP = {'untl': UNTL_NAMESPACE}\n        if useNamespace:\n            root = Element(UNTL + self.tag, nsmap=NSMAP)\n        else:\n            root = Element(self.tag)\n        self.sort_untl(UNTL_XML_ORDER)\n        for element in self.children:\n            if useNamespace:\n                create_untl_xml_subelement(root, element, UNTL)\n            else:\n                create_untl_xml_subelement(root, element)\n        return root\n\n    def create_element_dict(self):\n        \"\"\"Convert a UNTL Python object into a UNTL Python dictionary.\"\"\"\n        untl_dict = {}\n        for element in self.children:\n            if element.tag not in untl_dict:\n                untl_dict[element.tag] = []\n            element_dict = {}\n            if element.qualifier is not None:\n                element_dict['qualifier'] = element.qualifier\n            if len(element.contained_children) > 0:\n                child_dict = {}\n                for child in element.children:\n                    if child.content is not None:\n                        child_dict[child.tag] = child.content\n                element_dict['content'] = child_dict\n            elif element.content is not None:\n                element_dict['content'] = element.content\n            untl_dict[element.tag].append(element_dict)\n        return untl_dict\n\n    def create_xml_file(self, untl_filename):\n        \"\"\"Create a UNTL file.\n\n        Writes file to supplied file path.\n        \"\"\"\n        try:\n            f = open(untl_filename, 'wb')\n            f.write(self.create_xml_string())\n            f.close()\n        except:\n            raise UNTLStructureException('Failed to create UNTL XML file. File: %s' % untl_filename)\n\n    def sort_untl(self, sort_structure):\n        \"\"\"Sort the UNTL Python object by the index\n        of a sort structure pre-ordered list.\n        \"\"\"\n        self.children.sort(key=lambda obj: sort_structure.index(obj.tag))\n\n    def validate(self):\n        \"\"\" Validate all of the UNTL elements.\"\"\"\n        pass\n\n    def generate_form_data(self, **kwargs):\n        \"\"\"Create a form dictionary with the key being the element name\n        and the value being a list of form element objects.\n        \"\"\"\n        self.children = add_missing_children(self.contained_children, self.children)\n        kwargs['children'] = self.children\n        return FormGenerator(**kwargs)\n\n    def make_hidden(self):\n        \"\"\"Make an unhidden record hidden.\"\"\"\n        for element in self.children:\n            if element.tag == 'meta' and element.qualifier == 'hidden':\n                if element.content == 'False':\n                    element.content = 'True'\n                return None\n        hidden_element = PYUNTL_DISPATCH['meta'](qualifier='hidden', content='True')\n        self.children.append(hidden_element)\n\n    def make_unhidden(self):\n        \"\"\"Make a hidden record unhidden.\"\"\"\n        for element in self.children:\n            if element.tag == 'meta' and element.qualifier == 'hidden':\n                if element.content == 'True':\n                    element.content = 'False'\n                return None\n        hidden_element = PYUNTL_DISPATCH['meta'](qualifier='hidden', content='False')\n        self.children.append(hidden_element)\n\n    @property\n    def is_hidden(self):\n        \"\"\"Return True if a UNTL element is hidden.\"\"\"\n        for element in self.children:\n            if element.tag == 'meta' and element.qualifier == 'hidden':\n                if element.content == 'True':\n                    return True\n                else:\n                    return False\n        sys.stderr.write('A hidden meta element does not exist.')\n        return False\n\nExample skeleton:\n\n\nclass StateTransitionWrapper(Generic[_P, _R, _T]):\n    '''\n    Wraps :class:`StateTransition` with the context of the object it is accessed from.\n    Automatically constructed by :class:`StateTransition`.\n        '''\n\n    def __init__(self, statetransition: StateTransition[_P, _R], obj: _T) -> None:\n        pass\n    @property\n    def data(self) -> dict[str, Any]:\n        '''Return data as provided to the :meth:`~StateManager.transition` decorator.'''\n        pass\n\n    def _validate_available(self) -> Optional[tuple[StateManager, Any, Any]]:\n        '''\n        If the state is invalid for the transition, return details on what didn't match.\n        :return: Tuple of (state manager, current state, label for current state)\n        '''\n        pass\n    @property\n    def is_available(self) -> bool:\n        '''Property that indicates whether this transition is currently available.'''\n        pass\n\n    def __getattr__(self, name: str) -> Any:\n        pass\n\n    def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -> _R:\n        '''Perform the state transition.'''\n        pass\nCorresponding class implementation:\n\nfrom typing import TYPE_CHECKING, Any, Callable, Generic, NoReturn, Optional, Union, cast, overload\nfrom ..utils import LabeledEnum, NameTitle, is_collection\n\nclass StateTransitionWrapper(Generic[_P, _R, _T]):\n    \"\"\"\n    Wraps :class:`StateTransition` with the context of the object it is accessed from.\n\n    Automatically constructed by :class:`StateTransition`.\n    \"\"\"\n\n    def __init__(self, statetransition: StateTransition[_P, _R], obj: _T) -> None:\n        self.statetransition = statetransition\n        self.obj = obj\n\n    @property\n    def data(self) -> dict[str, Any]:\n        \"\"\"Return data as provided to the :meth:`~StateManager.transition` decorator.\"\"\"\n        return self.statetransition.data\n\n    def _validate_available(self) -> Optional[tuple[StateManager, Any, Any]]:\n        \"\"\"\n        If the state is invalid for the transition, return details on what didn't match.\n\n        :return: Tuple of (state manager, current state, label for current state)\n        \"\"\"\n        for statemanager, conditions in self.statetransition.transitions.items():\n            current_state_value = statemanager._get_state_value(self.obj)\n            if conditions.from_ is None:\n                state_valid = True\n            else:\n                mstate = conditions.from_.get(current_state_value)\n                state_valid = mstate is not None and mstate.is_current_in(self.obj)\n            if not state_valid:\n                return (statemanager, current_state_value, statemanager.lenum.get(current_state_value))\n        return None\n\n    @property\n    def is_available(self) -> bool:\n        \"\"\"Property that indicates whether this transition is currently available.\"\"\"\n        return not self._validate_available()\n\n    def __getattr__(self, name: str) -> Any:\n        return getattr(self.statetransition, name)\n\n    def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -> _R:\n        \"\"\"Perform the state transition.\"\"\"\n        state_invalid = self._validate_available()\n        if state_invalid:\n            transition_error.send(self.obj, transition=self.statetransition, statemanager=state_invalid[0])\n            label = state_invalid[2]\n            if isinstance(label, NameTitle):\n                label = label.title\n            raise StateTransitionError(f'Invalid state for transition {self.statetransition.name}: {state_invalid[0]!r} = {label}')\n        transition_before.send(self.obj, transition=self.statetransition)\n        try:\n            result = self.statetransition.func(self.obj, *args, **kwargs)\n        except AbortTransition as e:\n            transition_exception.send(self.obj, transition=self.statetransition, exception=e)\n            return e.result\n        except Exception as e:\n            transition_exception.send(self.obj, transition=self.statetransition, exception=e)\n            raise\n        for statemanager, conditions in self.statetransition.transitions.items():\n            if conditions.to is not None:\n                statemanager._set_state_value(self.obj, conditions.to.value)\n        transition_after.send(self.obj, transition=self.statetransition)\n        return result\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass BestCandidateResult:\n    '''A collection of candidates, returned by `PackageFinder.find_best_candidate`.\n    This class is only intended to be instantiated by CandidateEvaluator's\n    `compute_best_candidate()` method.\n    '''\n\n    def __init__(self, candidates: List[InstallationCandidate], applicable_candidates: List[InstallationCandidate], best_candidate: Optional[InstallationCandidate]) -> None:\n        '''\n        :param candidates: A sequence of all available candidates found.\n        :param applicable_candidates: The applicable candidates.\n        :param best_candidate: The most preferred candidate found, or None\n            if no applicable candidates were found.\n        '''\n        pass\n\n    def iter_all(self) -> Iterable[InstallationCandidate]:\n        '''Iterate through all candidates.'''\n        pass\n\n    def iter_applicable(self) -> Iterable[InstallationCandidate]:\n        '''Iterate through the applicable candidates.'''\n        pass"
  }
]