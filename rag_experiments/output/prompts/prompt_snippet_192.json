[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass GroupedData:\n    '''Represents a grouped dataset created by calling ``Dataset.groupby()``.\n    The actual groupby is deferred until an aggregation is applied.\n        '''\n\n    def __init__(self, dataset: Dataset, key: Optional[Union[str, List[str]]], *, num_partitions: Optional[int]):\n        '''Construct a dataset grouped by key (internal API).\n        The constructor is not part of the GroupedData API.\n        Use the ``Dataset.groupby()`` method to construct one.\n        '''\n        pass\n\n    def __repr__(self) -> str:\n        pass\n    @PublicAPI(api_group=FA_API_GROUP)\n    def aggregate(self, *aggs: AggregateFn) -> Dataset:\n        '''Implements an accumulator-based aggregation.\n        Args:\n            aggs: Aggregations to do.\n        Returns:\n            The output is an dataset of ``n + 1`` columns where the first column\n            is the groupby key and the second through ``n + 1`` columns are the\n            results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n\n    def _aggregate_on(self, agg_cls: type, on: Union[str, List[str]], *args, **kwargs):\n        '''Helper for aggregating on a particular subset of the dataset.\n        This validates the `on` argument, and converts a list of column names\n        to a multi-aggregation. A null `on` results in a\n        multi-aggregation on all columns for an Arrow Dataset, and a single\n        aggregation on the entire row for a simple Dataset.\n        '''\n        pass\n    @PublicAPI(api_group=FA_API_GROUP)\n    def map_groups(self, fn: UserDefinedFunction[DataBatch, DataBatch], *, zero_copy_batch: bool=False, compute: Union[str, ComputeStrategy]=None, batch_format: Optional[str]='default', fn_args: Optional[Iterable[Any]]=None, fn_kwargs: Optional[Dict[str, Any]]=None, fn_constructor_args: Optional[Iterable[Any]]=None, fn_constructor_kwargs: Optional[Dict[str, Any]]=None, num_cpus: Optional[float]=None, num_gpus: Optional[float]=None, memory: Optional[float]=None, concurrency: Optional[Union[int, Tuple[int, int], Tuple[int, int, int]]]=None, ray_remote_args_fn: Optional[Callable[[], Dict[str, Any]]]=None, **ray_remote_args) -> 'Dataset':\n        '''Apply the given function to each group of records of this dataset.\n        While map_groups() is very flexible, note that it comes with downsides:\n        * It may be slower than using more specific methods such as min(), max().\n        * It requires that each group fits in memory on a single node.\n        In general, prefer to use `aggregate()` instead of `map_groups()`.\n        .. warning::\n            Specifying both ``num_cpus`` and ``num_gpus`` for map tasks is experimental,\n            and may result in scheduling or stability issues. Please\n            `report any issues <https://github.com/ray-project/ray/issues/new/choose>`_\n            to the Ray team.\n        Examples:\n            >>> # Return a single record per group (list of multiple records in,\n            >>> # list of a single record out).\n            >>> import ray\n            >>> import pandas as pd\n            >>> import numpy as np\n            >>> # Get first value per group.\n            >>> ds = ray.data.from_items([ # doctest: +SKIP\n            ...     {\"group\": 1, \"value\": 1},\n            ...     {\"group\": 1, \"value\": 2},\n            ...     {\"group\": 2, \"value\": 3},\n            ...     {\"group\": 2, \"value\": 4}])\n            >>> ds.groupby(\"group\").map_groups( # doctest: +SKIP\n            ...     lambda g: {\"result\": np.array([g[\"value\"][0]])})\n            >>> # Return multiple records per group (dataframe in, dataframe out).\n            >>> df = pd.DataFrame(\n            ...     {\"A\": [\"a\", \"a\", \"b\"], \"B\": [1, 1, 3], \"C\": [4, 6, 5]}\n            ... )\n            >>> ds = ray.data.from_pandas(df) # doctest: +SKIP\n            >>> grouped = ds.groupby(\"A\") # doctest: +SKIP\n            >>> grouped.map_groups( # doctest: +SKIP\n            ...     lambda g: g.apply(\n            ...         lambda c: c / g[c.name].sum() if c.name in [\"B\", \"C\"] else c\n            ...     )\n            ... ) # doctest: +SKIP\n        Args:\n            fn: The function to apply to each group of records, or a class type\n                that can be instantiated to create such a callable. It takes as\n                input a batch of all records from a single group, and returns a\n                batch of zero or more records, similar to map_batches().\n            zero_copy_batch: If True, each group of rows (batch) will be provided w/o\n                making an additional copy.\n            compute: This argument is deprecated. Use ``concurrency`` argument.\n            batch_format: Specify ``\"default\"`` to use the default block format\n                (NumPy), ``\"pandas\"`` to select ``pandas.DataFrame``, \"pyarrow\" to\n                select ``pyarrow.Table``, or ``\"numpy\"`` to select\n                ``Dict[str, numpy.ndarray]``, or None to return the underlying block\n                exactly as is with no additional formatting.\n            fn_args: Arguments to `fn`.\n            fn_kwargs: Keyword arguments to `fn`.\n            fn_constructor_args: Positional arguments to pass to ``fn``'s constructor.\n                You can only provide this if ``fn`` is a callable class. These arguments\n                are top-level arguments in the underlying Ray actor construction task.\n            fn_constructor_kwargs: Keyword arguments to pass to ``fn``'s constructor.\n                This can only be provided if ``fn`` is a callable class. These arguments\n                are top-level arguments in the underlying Ray actor construction task.\n            num_cpus: The number of CPUs to reserve for each parallel map worker.\n            num_gpus: The number of GPUs to reserve for each parallel map worker. For\n                example, specify `num_gpus=1` to request 1 GPU for each parallel map\n                worker.\n            memory: The heap memory in bytes to reserve for each parallel map worker.\n            ray_remote_args_fn: A function that returns a dictionary of remote args\n                passed to each map worker. The purpose of this argument is to generate\n                dynamic arguments for each actor or task, and will be called each time prior\n                to initializing the worker. Args returned from this dict will always\n                override the args in ``ray_remote_args``. Note: this is an advanced,\n                experimental feature.\n            concurrency: The semantics of this argument depend on the type of ``fn``:\n                * If ``fn`` is a function and ``concurrency`` isn't set (default), the\n                  actual concurrency is implicitly determined by the available\n                  resources and number of input blocks.\n                * If ``fn`` is a function and ``concurrency`` is an  int ``n``, Ray Data\n                  launches *at most* ``n`` concurrent tasks.\n                * If ``fn`` is a class and ``concurrency`` is an int ``n``, Ray Data\n                  uses an actor  pool with *exactly* ``n`` workers.\n                * If ``fn`` is a class and  ``concurrency`` is a tuple ``(m, n)``, Ray\n                  Data uses an autoscaling actor pool from ``m`` to ``n`` workers.\n                * If ``fn`` is a class and  ``concurrency`` is a tuple ``(m, n, initial)``, Ray\n                  Data uses an autoscaling actor pool from ``m`` to ``n`` workers, with an initial size of ``initial``.\n                * If ``fn`` is a class and ``concurrency`` isn't set (default), this\n                  method raises an error.\n            ray_remote_args: Additional resource requirements to request from\n                Ray (e.g., num_gpus=1 to request GPUs for the map tasks). See\n                :func:`ray.remote` for details.\n        Returns:\n            The return type is determined by the return type of ``fn``, and the return\n            value is combined from results of all groups.\n        .. seealso::\n            :meth:`GroupedData.aggregate`\n                Use this method for common aggregation use cases.\n        '''\n        pass\n\n            class wrapped_fn:\n\n    def __init__(self, dataset: Dataset, key: Optional[Union[str, List[str]]], *, num_partitions: Optional[int]):\n        pass\n\n                def __call__(self, batch, *args, **kwargs):\n                                pass\n\n            def wrapped_fn(batch, *args, **kwargs):\n                        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def count(self) -> Dataset:\n        '''Compute count aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": x % 3, \"B\": x} for x in range(100)]).groupby( # doctest: +SKIP\n            ...     \"A\").count() # doctest: +SKIP\n        Returns:\n            A dataset of ``[k, v]`` columns where ``k`` is the groupby key and\n            ``v`` is the number of rows with that key.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def sum(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        '''Compute grouped sum aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     (i % 3, i, i**2) # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(lambda x: x[0] % 3)  # doctest: +SKIP\n            ...     .sum(lambda x: x[2]) # doctest: +SKIP\n            >>> ray.data.range(100).groupby(\"id\").sum() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .sum([\"B\", \"C\"]) # doctest: +SKIP\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the sum; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n        Returns:\n            The sum result.\n            For different values of ``on``, the return varies:\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise sum column for each original column\n              in the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def min(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        '''Compute grouped min aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").min() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .min([\"B\", \"C\"]) # doctest: +SKIP\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the min; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n        Returns:\n            The min result.\n            For different values of ``on``, the return varies:\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise min column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def max(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        '''Compute grouped max aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").max() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .max([\"B\", \"C\"]) # doctest: +SKIP\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the max; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n        Returns:\n            The max result.\n            For different values of ``on``, the return varies:\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise max column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def mean(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        '''Compute grouped mean aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").mean() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .mean([\"B\", \"C\"]) # doctest: +SKIP\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the mean; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n        Returns:\n            The mean result.\n            For different values of ``on``, the return varies:\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise mean column for each original column\n              in the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def std(self, on: Union[str, List[str]]=None, ddof: int=1, ignore_nulls: bool=True) -> Dataset:\n        '''Compute grouped standard deviation aggregation.\n        Examples:\n            >>> import ray\n            >>> ray.data.range(100).groupby(\"id\").std(ddof=0) # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .std([\"B\", \"C\"]) # doctest: +SKIP\n        NOTE: This uses Welford's online method for an accumulator-style\n        computation of the standard deviation. This method was chosen due to\n        it's numerical stability, and it being computable in a single pass.\n        This may give different (but more accurate) results than NumPy, Pandas,\n        and sklearn, which use a less numerically stable two-pass algorithm.\n        See\n        https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ddof: Delta Degrees of Freedom. The divisor used in calculations\n                is ``N - ddof``, where ``N`` represents the number of elements.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the std; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n        Returns:\n            The standard deviation result.\n            For different values of ``on``, the return varies:\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise std column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom ray.data._internal.compute import ComputeStrategy\nfrom ray.data.dataset import Dataset\nfrom ray.data.aggregate import AggregateFn, Count, Max, Mean, Min, Std, Sum\nfrom ray.data.context import ShuffleStrategy\nfrom ray.util.annotations import PublicAPI\nfrom ray.data.block import Block, BlockAccessor, CallableClass, DataBatch, UserDefinedFunction\nfrom typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Tuple, Union\nfrom ray.data._internal.logical.interfaces import LogicalPlan\nfrom functools import partial\nfrom ray.data._internal.logical.operators.all_to_all_operator import Aggregate\n\nclass GroupedData:\n    \"\"\"Represents a grouped dataset created by calling ``Dataset.groupby()``.\n\n    The actual groupby is deferred until an aggregation is applied.\n    \"\"\"\n\n    def __init__(self, dataset: Dataset, key: Optional[Union[str, List[str]]], *, num_partitions: Optional[int]):\n        \"\"\"Construct a dataset grouped by key (internal API).\n\n        The constructor is not part of the GroupedData API.\n        Use the ``Dataset.groupby()`` method to construct one.\n        \"\"\"\n        self._dataset: Dataset = dataset\n        self._key: Optional[Union[str, List[str]]] = key\n        self._num_partitions: Optional[int] = num_partitions\n\n    def __repr__(self) -> str:\n        return f'{self.__class__.__name__}(dataset={self._dataset}, key={self._key!r})'\n\n    @PublicAPI(api_group=FA_API_GROUP)\n    def aggregate(self, *aggs: AggregateFn) -> Dataset:\n        \"\"\"Implements an accumulator-based aggregation.\n\n        Args:\n            aggs: Aggregations to do.\n\n        Returns:\n            The output is an dataset of ``n + 1`` columns where the first column\n            is the groupby key and the second through ``n + 1`` columns are the\n            results of the aggregations.\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        plan = self._dataset._plan.copy()\n        op = Aggregate(self._dataset._logical_plan.dag, key=self._key, aggs=aggs, num_partitions=self._num_partitions)\n        logical_plan = LogicalPlan(op, self._dataset.context)\n        return Dataset(plan, logical_plan)\n\n    def _aggregate_on(self, agg_cls: type, on: Union[str, List[str]], *args, **kwargs):\n        \"\"\"Helper for aggregating on a particular subset of the dataset.\n\n        This validates the `on` argument, and converts a list of column names\n        to a multi-aggregation. A null `on` results in a\n        multi-aggregation on all columns for an Arrow Dataset, and a single\n        aggregation on the entire row for a simple Dataset.\n        \"\"\"\n        aggs = self._dataset._build_multicolumn_aggs(agg_cls, on, *args, skip_cols=self._key, **kwargs)\n        return self.aggregate(*aggs)\n\n    @PublicAPI(api_group=FA_API_GROUP)\n    def map_groups(self, fn: UserDefinedFunction[DataBatch, DataBatch], *, zero_copy_batch: bool=False, compute: Union[str, ComputeStrategy]=None, batch_format: Optional[str]='default', fn_args: Optional[Iterable[Any]]=None, fn_kwargs: Optional[Dict[str, Any]]=None, fn_constructor_args: Optional[Iterable[Any]]=None, fn_constructor_kwargs: Optional[Dict[str, Any]]=None, num_cpus: Optional[float]=None, num_gpus: Optional[float]=None, memory: Optional[float]=None, concurrency: Optional[Union[int, Tuple[int, int], Tuple[int, int, int]]]=None, ray_remote_args_fn: Optional[Callable[[], Dict[str, Any]]]=None, **ray_remote_args) -> 'Dataset':\n        \"\"\"Apply the given function to each group of records of this dataset.\n\n        While map_groups() is very flexible, note that it comes with downsides:\n\n        * It may be slower than using more specific methods such as min(), max().\n        * It requires that each group fits in memory on a single node.\n\n        In general, prefer to use `aggregate()` instead of `map_groups()`.\n\n        .. warning::\n            Specifying both ``num_cpus`` and ``num_gpus`` for map tasks is experimental,\n            and may result in scheduling or stability issues. Please\n            `report any issues <https://github.com/ray-project/ray/issues/new/choose>`_\n            to the Ray team.\n\n        Examples:\n            >>> # Return a single record per group (list of multiple records in,\n            >>> # list of a single record out).\n            >>> import ray\n            >>> import pandas as pd\n            >>> import numpy as np\n            >>> # Get first value per group.\n            >>> ds = ray.data.from_items([ # doctest: +SKIP\n            ...     {\"group\": 1, \"value\": 1},\n            ...     {\"group\": 1, \"value\": 2},\n            ...     {\"group\": 2, \"value\": 3},\n            ...     {\"group\": 2, \"value\": 4}])\n            >>> ds.groupby(\"group\").map_groups( # doctest: +SKIP\n            ...     lambda g: {\"result\": np.array([g[\"value\"][0]])})\n\n            >>> # Return multiple records per group (dataframe in, dataframe out).\n            >>> df = pd.DataFrame(\n            ...     {\"A\": [\"a\", \"a\", \"b\"], \"B\": [1, 1, 3], \"C\": [4, 6, 5]}\n            ... )\n            >>> ds = ray.data.from_pandas(df) # doctest: +SKIP\n            >>> grouped = ds.groupby(\"A\") # doctest: +SKIP\n            >>> grouped.map_groups( # doctest: +SKIP\n            ...     lambda g: g.apply(\n            ...         lambda c: c / g[c.name].sum() if c.name in [\"B\", \"C\"] else c\n            ...     )\n            ... ) # doctest: +SKIP\n\n        Args:\n            fn: The function to apply to each group of records, or a class type\n                that can be instantiated to create such a callable. It takes as\n                input a batch of all records from a single group, and returns a\n                batch of zero or more records, similar to map_batches().\n            zero_copy_batch: If True, each group of rows (batch) will be provided w/o\n                making an additional copy.\n            compute: This argument is deprecated. Use ``concurrency`` argument.\n            batch_format: Specify ``\"default\"`` to use the default block format\n                (NumPy), ``\"pandas\"`` to select ``pandas.DataFrame``, \"pyarrow\" to\n                select ``pyarrow.Table``, or ``\"numpy\"`` to select\n                ``Dict[str, numpy.ndarray]``, or None to return the underlying block\n                exactly as is with no additional formatting.\n            fn_args: Arguments to `fn`.\n            fn_kwargs: Keyword arguments to `fn`.\n            fn_constructor_args: Positional arguments to pass to ``fn``'s constructor.\n                You can only provide this if ``fn`` is a callable class. These arguments\n                are top-level arguments in the underlying Ray actor construction task.\n            fn_constructor_kwargs: Keyword arguments to pass to ``fn``'s constructor.\n                This can only be provided if ``fn`` is a callable class. These arguments\n                are top-level arguments in the underlying Ray actor construction task.\n            num_cpus: The number of CPUs to reserve for each parallel map worker.\n            num_gpus: The number of GPUs to reserve for each parallel map worker. For\n                example, specify `num_gpus=1` to request 1 GPU for each parallel map\n                worker.\n            memory: The heap memory in bytes to reserve for each parallel map worker.\n            ray_remote_args_fn: A function that returns a dictionary of remote args\n                passed to each map worker. The purpose of this argument is to generate\n                dynamic arguments for each actor or task, and will be called each time prior\n                to initializing the worker. Args returned from this dict will always\n                override the args in ``ray_remote_args``. Note: this is an advanced,\n                experimental feature.\n            concurrency: The semantics of this argument depend on the type of ``fn``:\n\n                * If ``fn`` is a function and ``concurrency`` isn't set (default), the\n                  actual concurrency is implicitly determined by the available\n                  resources and number of input blocks.\n\n                * If ``fn`` is a function and ``concurrency`` is an  int ``n``, Ray Data\n                  launches *at most* ``n`` concurrent tasks.\n\n                * If ``fn`` is a class and ``concurrency`` is an int ``n``, Ray Data\n                  uses an actor  pool with *exactly* ``n`` workers.\n\n                * If ``fn`` is a class and  ``concurrency`` is a tuple ``(m, n)``, Ray\n                  Data uses an autoscaling actor pool from ``m`` to ``n`` workers.\n\n                * If ``fn`` is a class and  ``concurrency`` is a tuple ``(m, n, initial)``, Ray\n                  Data uses an autoscaling actor pool from ``m`` to ``n`` workers, with an initial size of ``initial``.\n\n                * If ``fn`` is a class and ``concurrency`` isn't set (default), this\n                  method raises an error.\n\n            ray_remote_args: Additional resource requirements to request from\n                Ray (e.g., num_gpus=1 to request GPUs for the map tasks). See\n                :func:`ray.remote` for details.\n\n        Returns:\n            The return type is determined by the return type of ``fn``, and the return\n            value is combined from results of all groups.\n\n        .. seealso::\n\n            :meth:`GroupedData.aggregate`\n                Use this method for common aggregation use cases.\n        \"\"\"\n        if self._key is None:\n            shuffled_ds = self._dataset.repartition(1)\n        elif self._dataset.context.shuffle_strategy == ShuffleStrategy.HASH_SHUFFLE:\n            num_partitions = self._num_partitions or self._dataset.context.default_hash_shuffle_parallelism\n            shuffled_ds = self._dataset.repartition(num_partitions, keys=self._key, sort=True)\n        else:\n            shuffled_ds = self._dataset.sort(self._key)\n        if self._key is None:\n            keys = []\n        elif isinstance(self._key, str):\n            keys = [self._key]\n        elif isinstance(self._key, List):\n            keys = self._key\n        else:\n            raise ValueError(f\"Group-by keys are expected to either be a single column (str) or a list of columns (got '{self._key}')\")\n        if isinstance(fn, CallableClass):\n\n            class wrapped_fn:\n\n                def __init__(self, *args, **kwargs):\n                    self.fn = fn(*args, **kwargs)\n\n                def __call__(self, batch, *args, **kwargs):\n                    yield from _apply_udf_to_groups(self.fn, batch, keys, batch_format, *args, **kwargs)\n        else:\n\n            def wrapped_fn(batch, *args, **kwargs):\n                yield from _apply_udf_to_groups(fn, batch, keys, batch_format, *args, **kwargs)\n        if isinstance(fn, partial):\n            wrapped_fn.__name__ = fn.func.__name__\n        else:\n            wrapped_fn.__name__ = fn.__name__\n        return shuffled_ds._map_batches_without_batch_size_validation(wrapped_fn, batch_size=None, compute=compute, batch_format=None, zero_copy_batch=zero_copy_batch, fn_args=fn_args, fn_kwargs=fn_kwargs, fn_constructor_args=fn_constructor_args, fn_constructor_kwargs=fn_constructor_kwargs, num_cpus=num_cpus, num_gpus=num_gpus, memory=memory, concurrency=concurrency, ray_remote_args_fn=ray_remote_args_fn, **ray_remote_args)\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def count(self) -> Dataset:\n        \"\"\"Compute count aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": x % 3, \"B\": x} for x in range(100)]).groupby( # doctest: +SKIP\n            ...     \"A\").count() # doctest: +SKIP\n\n        Returns:\n            A dataset of ``[k, v]`` columns where ``k`` is the groupby key and\n            ``v`` is the number of rows with that key.\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self.aggregate(Count())\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def sum(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        \"\"\"Compute grouped sum aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     (i % 3, i, i**2) # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(lambda x: x[0] % 3)  # doctest: +SKIP\n            ...     .sum(lambda x: x[2]) # doctest: +SKIP\n            >>> ray.data.range(100).groupby(\"id\").sum() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .sum([\"B\", \"C\"]) # doctest: +SKIP\n\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the sum; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n\n        Returns:\n            The sum result.\n\n            For different values of ``on``, the return varies:\n\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise sum column for each original column\n              in the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self._aggregate_on(Sum, on, ignore_nulls=ignore_nulls)\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def min(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        \"\"\"Compute grouped min aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").min() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .min([\"B\", \"C\"]) # doctest: +SKIP\n\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the min; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n\n        Returns:\n            The min result.\n\n            For different values of ``on``, the return varies:\n\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise min column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self._aggregate_on(Min, on, ignore_nulls=ignore_nulls)\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def max(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        \"\"\"Compute grouped max aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").max() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .max([\"B\", \"C\"]) # doctest: +SKIP\n\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the max; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n\n        Returns:\n            The max result.\n\n            For different values of ``on``, the return varies:\n\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise max column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self._aggregate_on(Max, on, ignore_nulls=ignore_nulls)\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def mean(self, on: Union[str, List[str]]=None, ignore_nulls: bool=True) -> Dataset:\n        \"\"\"Compute grouped mean aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.le(100).groupby(\"value\").mean() # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .mean([\"B\", \"C\"]) # doctest: +SKIP\n\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the mean; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n\n        Returns:\n            The mean result.\n\n            For different values of ``on``, the return varies:\n\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise mean column for each original column\n              in the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self._aggregate_on(Mean, on, ignore_nulls=ignore_nulls)\n\n    @PublicAPI(api_group=CDS_API_GROUP)\n    def std(self, on: Union[str, List[str]]=None, ddof: int=1, ignore_nulls: bool=True) -> Dataset:\n        \"\"\"Compute grouped standard deviation aggregation.\n\n        Examples:\n            >>> import ray\n            >>> ray.data.range(100).groupby(\"id\").std(ddof=0) # doctest: +SKIP\n            >>> ray.data.from_items([ # doctest: +SKIP\n            ...     {\"A\": i % 3, \"B\": i, \"C\": i**2} # doctest: +SKIP\n            ...     for i in range(100)])  # doctest: +SKIP\n            ...     .groupby(\"A\")  # doctest: +SKIP\n            ...     .std([\"B\", \"C\"]) # doctest: +SKIP\n\n        NOTE: This uses Welford's online method for an accumulator-style\n        computation of the standard deviation. This method was chosen due to\n        it's numerical stability, and it being computable in a single pass.\n        This may give different (but more accurate) results than NumPy, Pandas,\n        and sklearn, which use a less numerically stable two-pass algorithm.\n        See\n        https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm\n\n        Args:\n            on: a column name or a list of column names to aggregate.\n            ddof: Delta Degrees of Freedom. The divisor used in calculations\n                is ``N - ddof``, where ``N`` represents the number of elements.\n            ignore_nulls: Whether to ignore null values. If ``True``, null\n                values will be ignored when computing the std; if ``False``,\n                if a null value is encountered, the output will be null.\n                We consider np.nan, None, and pd.NaT to be null values.\n                Default is ``True``.\n\n        Returns:\n            The standard deviation result.\n\n            For different values of ``on``, the return varies:\n\n            - ``on=None``: a dataset containing a groupby key column,\n              ``\"k\"``, and a column-wise std column for each original column in\n              the dataset.\n            - ``on=[\"col_1\", ..., \"col_n\"]``: a dataset of ``n + 1``\n              columns where the first column is the groupby key and the second\n              through ``n + 1`` columns are the results of the aggregations.\n\n            If groupby key is ``None`` then the key part of return is omitted.\n        \"\"\"\n        return self._aggregate_on(Std, on, ignore_nulls=ignore_nulls, ddof=ddof)\n\nExample skeleton:\n\n\nclass RawMetricsOperator(BaseOperator):\n    '''Raw Metrics Operator.'''\n\n    def __init__(self, config: WilyConfig, targets: Iterable[str]):\n        '''\n        Instantiate a new raw operator.\n        :param config: The wily configuration.\n        :param targets: An iterable of paths from which to harvest metrics.\n        '''\n        pass\n\n    def run(self, module: str, options: Dict[str, Any]) -> Dict[Any, Any]:\n        '''\n        Run the operator.\n        :param module: The target module path.\n        :param options: Any runtime options.\n        :return: The operator results.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom wily.lang import _\nfrom wily.operators import BaseOperator, Metric, MetricType\nfrom typing import Any, Dict, Iterable\nfrom wily.config.types import WilyConfig\nfrom radon.cli import Config\nfrom wily import logger\nimport radon.cli.harvest as harvesters\n\nclass RawMetricsOperator(BaseOperator):\n    \"\"\"Raw Metrics Operator.\"\"\"\n    name = 'raw'\n    defaults = {'exclude': None, 'ignore': None, 'summary': False, 'include_ipynb': True, 'ipynb_cells': True}\n    metrics = (Metric('loc', _('Lines of Code'), int, MetricType.Informational, sum), Metric('lloc', _('L Lines of Code'), int, MetricType.AimLow, sum), Metric('sloc', _('S Lines of Code'), int, MetricType.AimLow, sum), Metric('comments', _('Multi-line comments'), int, MetricType.AimHigh, sum), Metric('multi', _('Multi lines'), int, MetricType.Informational, sum), Metric('blank', _('blank lines'), int, MetricType.Informational, sum), Metric('single_comments', _('Single comment lines'), int, MetricType.Informational, sum))\n    default_metric_index = 0\n\n    def __init__(self, config: WilyConfig, targets: Iterable[str]):\n        \"\"\"\n        Instantiate a new raw operator.\n\n        :param config: The wily configuration.\n        :param targets: An iterable of paths from which to harvest metrics.\n        \"\"\"\n        logger.debug('Using %s with %s for Raw metrics', targets, self.defaults)\n        self.harvester = harvesters.RawHarvester(targets, config=Config(**self.defaults))\n\n    def run(self, module: str, options: Dict[str, Any]) -> Dict[Any, Any]:\n        \"\"\"\n        Run the operator.\n\n        :param module: The target module path.\n        :param options: Any runtime options.\n        :return: The operator results.\n        \"\"\"\n        logger.debug('Running raw harvester')\n        results = {}\n        for filename, metrics in dict(self.harvester.results).items():\n            results[filename] = {'total': metrics}\n        return results\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass DistributedMetricAggregator:\n    '''\n    A helper class to encapsulate the logic for aggregating metrics\n    in a distributed environment.\n    '''\n\n    def __init__(self, local_metrics: Dict[str, Union[float, List[float], torch.Tensor]], group: Optional[dist.ProcessGroup]):\n        '''\n        Initializes the aggregator and prepares metrics for reduction.\n        Args:\n            local_metrics: The dictionary of metrics on the local rank.\n            group: The process group for distributed communication.\n        '''\n        pass\n\n    def _bucket_local_metrics(self, metrics: Dict) -> defaultdict:\n        '''\n        Parses local metrics and groups them by the required reduction operation.\n        This step also performs local pre-aggregation on lists and tensors.\n        This version correctly handles multi-element tensors as input.\n        Returns:\n            A defaultdict containing keys and pre-aggregated values,\n            grouped by reduction operation type (_ReduceOp).\n        '''\n        pass\n\n    def aggregate_and_get_results(self) -> Dict[str, float]:\n        '''\n        Performs the distributed all_reduce operations and composes the final\n        metrics dictionary.\n        Returns:\n            A dictionary with the globally aggregated metrics.\n        '''\n        pass"
  }
]