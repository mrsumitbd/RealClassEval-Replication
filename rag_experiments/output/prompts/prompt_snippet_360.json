[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n@dataclasses.dataclass()\nclass DatasetDocumentation:\n    '''Functionality to generate documentation for a community dataset.'''\n    @property\n    def tfds_id(self) -> str:\n        '''Returns the ID to use when loading this dataset in TFDS.'''\n        pass\n    @property\n    def name(self) -> str:\n        pass\n    @property\n    def namespace(self) -> str:\n        pass\n\n    def code_url(self, title: str='Code') -> str:\n        pass\n\n    def to_namespace_overview(self) -> str:\n        '''Returns the entry to be shown in the overview for a single namespace.'''\n        pass\n\n    def to_details_markdown(self) -> str:\n        '''Markdown to be shown on the details page for the namespace.'''\n        pass\n\n    def dataset_info_per_config(self) -> Mapping[str, dataset_info_pb2.DatasetInfo]:\n        pass\n\n    def documentation(self, keep_short: bool=False) -> str:\n        '''Returns detailed documentation for all configs of this dataset.'''\n        pass\n\n        def format_splits(split_infos: Sequence[dataset_info_pb2.SplitInfo]) -> str:\n                pass\n\n        def format_feature(feature: feature_pb2.Feature) -> str:\n                pass\n\n        def format_template(config_name: str, info: dataset_info_pb2.DatasetInfo) -> str:\n                pass\n\n    def extra_links(self) -> Sequence[str]:\n        '''List of extra links (formatted in Markdown) relevant for this dataset.'''\n        pass\n\n    def format_extra_links(self, prefix: str, infix: str) -> str:\n        pass\n\n    def to_toc_markdown(self) -> str:\n        '''Markdown to be shown in the TOC in the overview page.'''\n        pass\nCorresponding class implementation:\n\nfrom tensorflow_datasets.core.proto import feature_pb2\nfrom tensorflow_datasets.core.utils import conversion_utils\nfrom typing import Any, Iterator, List, Mapping, MutableMapping, Optional, Sequence, Tuple\nfrom tensorflow_datasets.core.proto import dataset_info_pb2\nfrom tensorflow_datasets.core.utils import py_utils\nimport textwrap\nimport dataclasses\n\n@dataclasses.dataclass()\nclass DatasetDocumentation:\n    \"\"\"Functionality to generate documentation for a community dataset.\"\"\"\n    dataset: DatasetPackage\n    templates: DocumentationTemplates\n    options: _Options\n\n    @property\n    def tfds_id(self) -> str:\n        \"\"\"Returns the ID to use when loading this dataset in TFDS.\"\"\"\n        return str(self.dataset.name)\n\n    @property\n    def name(self) -> str:\n        return self.dataset.name.name\n\n    @property\n    def namespace(self) -> str:\n        return self.dataset.name.namespace\n\n    def code_url(self, title: str='Code') -> str:\n        return f'[{title}]({self.dataset.source.root_path})'\n\n    def to_namespace_overview(self) -> str:\n        \"\"\"Returns the entry to be shown in the overview for a single namespace.\"\"\"\n        template = textwrap.dedent('*  [{dataset}]({namespace}/{dataset}.md)')\n        return template.format(dataset=self.name, namespace=self.namespace)\n\n    def to_details_markdown(self) -> str:\n        \"\"\"Markdown to be shown on the details page for the namespace.\"\"\"\n        extra_links = self.format_extra_links(prefix='*   ', infix='\\n')\n        details = self.templates.dataset_details_template.format(name=self.name, description=self.documentation(), namespace=self.namespace, tfds_id=self.tfds_id, references_bulleted_list=extra_links)\n        if len(details) < 2 * 1024 * 1024:\n            return details\n        return self.templates.dataset_details_template.format(name=self.name, description=self.documentation(keep_short=True), namespace=self.namespace, tfds_id=self.tfds_id, references_bulleted_list=extra_links)\n\n    def dataset_info_per_config(self) -> Mapping[str, dataset_info_pb2.DatasetInfo]:\n        return {}\n\n    def documentation(self, keep_short: bool=False) -> str:\n        \"\"\"Returns detailed documentation for all configs of this dataset.\"\"\"\n        header_template = '## {config_name}'\n        template = textwrap.dedent(\"\\n      Use the following command to load this dataset in TFDS:\\n\\n      ```python\\n      ds = tfds.load('{tfds_id}')\\n      ```\\n\\n      *   **Description**:\\n\\n      {description}\\n\\n      *   **License**: {license}\\n      *   **Version**: {version}\\n      *   **Splits**:\\n      {splits}\\n      *   **Features**:\\n      {features}\\n    \")\n\n        def format_splits(split_infos: Sequence[dataset_info_pb2.SplitInfo]) -> str:\n            splits_str = '\\n'.join(sorted([f\"`'{split.name}'` | {sum(split.shard_lengths)}\" for split in split_infos]))\n            return textwrap.dedent(f\"\\n            Split  | Examples\\n            :----- | -------:\\n            {py_utils.indent(splits_str, '            ')}\\n            \")\n\n        def format_feature(feature: feature_pb2.Feature) -> str:\n            if feature.HasField('json_feature'):\n                return textwrap.dedent(f'\\n```json\\n{feature.json_feature.json}\\n```\\n                               ')\n            if feature.HasField('features_dict'):\n                descriptions = [f'    *   `{name}`' for name, _ in feature.features_dict.features.items()]\n                return '\\n'.join(descriptions)\n            return ''\n\n        def format_template(config_name: str, info: dataset_info_pb2.DatasetInfo) -> str:\n            if self.namespace and self.namespace == 'huggingface':\n                tfds_id = conversion_utils.to_tfds_name(self.tfds_id)\n            else:\n                tfds_id = self.tfds_id\n            if config_name != 'default':\n                config_name = conversion_utils.to_tfds_name(config_name)\n                tfds_id = f'{tfds_id}/{config_name}'\n            if keep_short:\n                features = ''\n            else:\n                features = format_feature(info.features)\n            content = template.format(description=_clean_up_text(info.description), tfds_id=tfds_id, license=info.redistribution_info.license or 'No known license', version=info.version, splits=format_splits(info.splits), features=features, citation=info.citation)\n            if config_name == 'default':\n                return content\n            return '{header}\\n\\n{content}'.format(header=header_template.format(config_name=config_name), content=content)\n        config_descriptions = [format_template(config_name, info) for config_name, info in self.dataset_info_per_config().items()]\n        return '\\n\\n'.join(config_descriptions)\n\n    def extra_links(self) -> Sequence[str]:\n        \"\"\"List of extra links (formatted in Markdown) relevant for this dataset.\"\"\"\n        return [self.code_url()]\n\n    def format_extra_links(self, prefix: str, infix: str) -> str:\n        return infix.join([f'{prefix}{link}' for link in self.extra_links()])\n\n    def to_toc_markdown(self) -> str:\n        \"\"\"Markdown to be shown in the TOC in the overview page.\"\"\"\n        extra_links = self.format_extra_links(prefix='', infix=' / ')\n        return f'{self.name} ({extra_links})'\n\nExample skeleton:\n\n\nclass ProjectContext(threading.local):\n    '''A configuration class to hold global configuration.'''\n\n    def __init__(self) -> None:\n        pass\n\n    def __del__(self):\n        pass\n    @property\n    def database(self) -> 'Database':\n        '''Current database.'''\n        pass\n    @property\n    def database_path(self) -> Path:\n        '''Path to the metadata storage directory.'''\n        pass\n    @property\n    def datadir(self) -> str:\n        '''Define a name of the folder for storing datasets.'''\n        pass\n    @datadir.setter\n    def datadir(self) -> str:\n        '''Set the current datadir.'''\n        pass\n    @property\n    def dataset_images_path(self) -> Path:\n        '''Return a ``Path`` instance of Renku dataset metadata folder.'''\n        pass\n    @property\n    def project_image_pathname(self) -> Path:\n        '''Return the path to the project's image file.'''\n        pass\n    @property\n    def dockerfile_path(self) -> Path:\n        '''Path to the Dockerfile.'''\n        pass\n    @property\n    def ssh_authorized_keys_path(self) -> Path:\n        '''Path to SSH authorized keys.'''\n        pass\n    @property\n    def global_config_dir(self) -> str:\n        '''Return user's config directory.'''\n        pass\n    @property\n    def global_config_path(self) -> Path:\n        '''Renku global (user's) config path.'''\n        pass\n    @property\n    def latest_agent(self) -> Optional[str]:\n        '''Returns latest agent version used in the repository.'''\n        pass\n    @property\n    def local_config_path(self) -> Path:\n        '''Renku local (project) config path.'''\n        pass\n    @property\n    def lock(self):\n        '''Create a Renku config lock.'''\n        pass\n    @property\n    def metadata_path(self) -> Path:\n        '''Current project's metadata (RENKU_HOME) path.'''\n        pass\n    @property\n    def path(self) -> Path:\n        '''Current project path.'''\n        pass\n    @property\n    def pointers_path(self) -> Path:\n        '''Return a ``Path`` instance of Renku pointer files folder.'''\n        pass\n    @property\n    def project_image_pathname(self) -> Path:\n        '''Return the Project instance.'''\n        pass\n    @property\n    def remote(self) -> 'ProjectRemote':\n        '''Return host, owner and name of the remote if it exists.'''\n        pass\n    @property\n    def repository(self) -> 'Repository':\n        '''Return current context's repository.'''\n        pass\n    @repository.setter\n    def repository(self) -> 'Repository':\n        '''Set the current repository.'''\n        pass\n    @property\n    def template_checksums_path(self):\n        '''Return a ``Path`` instance to the template checksums file.'''\n        pass\n    @property\n    def transaction_id(self) -> str:\n        '''Get a transaction id for the current context to be used for grouping git commits.'''\n        pass\n    @property\n    def _top(self) -> 'ProjectProperties':\n        '''Return current context.'''\n        pass\n\n    def has_context(self, path: Optional[Union[Path, str]]=None) -> bool:\n        '''Return if at least one context which is equal to path (if not None) is pushed.'''\n        pass\n\n    def clear(self) -> None:\n        '''Remove all contexts and reset the state without committing intermediate changes.\n        NOTE: This method should be used only in tests.\n        '''\n        pass\n\n    def pop_context(self) -> 'ProjectProperties':\n        '''Pop current project context from stack.\n        Returns:\n            Path: the popped project path.\n        '''\n        pass\n\n    def push_path(self, path: Union[Path, str], save_changes: bool=False) -> None:\n        '''Push a new project path to the stack.\n        Arguments:\n            path(Union[Path, str]): The path to push.\n            save_changes(bool): Whether to save changes to the database or not.\n        '''\n        pass\n\n    def replace_path(self, path: Union[Path, str]):\n        '''Replace the current project path with a new one if they are different.\n        Arguments:\n            path(Union[Path, str]): The path to replace with.\n        '''\n        pass\n    @contextlib.contextmanager\n    def with_path(self, path: Union[Path, str], save_changes: bool=False) -> Generator['ProjectProperties', None, None]:\n        '''Temporarily push a new project path to the stack.\n        Arguments:\n            path(Union[Path, str]): The path to push.\n            save_changes(bool): Whether to save changes to the database or not.\n        '''\n        pass\n    @contextlib.contextmanager\n    def with_rollback(self) -> Generator[None, None, None]:\n        '''Rollback to the current state.\n        NOTE: This won't work correctly if the current context is popped or swapped.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom typing import TYPE_CHECKING, Generator, List, NamedTuple, Optional, Union\nfrom pathlib import Path\nimport threading\nfrom renku.core.constant import APP_NAME, CONFIG_NAME, DATA_DIR_CONFIG_KEY, DATABASE_PATH, DATASET_IMAGES, DEFAULT_DATA_DIR, DOCKERFILE, IMAGES, LOCK_SUFFIX, POINTERS, RENKU_HOME, TEMPLATE_CHECKSUMS\nfrom renku.core import errors\nimport uuid\nimport contextlib\n\nclass ProjectContext(threading.local):\n    \"\"\"A configuration class to hold global configuration.\"\"\"\n    external_storage_requested = True\n    'External storage (e.g. LFS) requested for Renku command.'\n\n    def __init__(self) -> None:\n        self._context_stack: List[ProjectProperties] = []\n\n    def __del__(self):\n        self.clear()\n\n    @property\n    def database(self) -> 'Database':\n        \"\"\"Current database.\"\"\"\n        if not self._top.database:\n            from renku.infrastructure.database import Database\n            self._top.database = Database.from_path(self.database_path)\n        return self._top.database\n\n    @property\n    def database_path(self) -> Path:\n        \"\"\"Path to the metadata storage directory.\"\"\"\n        return self.metadata_path / DATABASE_PATH\n\n    @property\n    def datadir(self) -> str:\n        \"\"\"Define a name of the folder for storing datasets.\"\"\"\n        from renku.core.config import get_value\n        from renku.domain_model.enums import ConfigFilter\n        if not self._top.datadir:\n            datadir = get_value('renku', DATA_DIR_CONFIG_KEY, config_filter=ConfigFilter.LOCAL_ONLY)\n            self._top.datadir = datadir or DEFAULT_DATA_DIR\n        return self._top.datadir\n\n    @datadir.setter\n    def datadir(self, value: str):\n        \"\"\"Set the current datadir.\"\"\"\n        self._top.datadir = value\n\n    @property\n    def dataset_images_path(self) -> Path:\n        \"\"\"Return a ``Path`` instance of Renku dataset metadata folder.\"\"\"\n        return self.path / RENKU_HOME / DATASET_IMAGES\n\n    @property\n    def project_image_pathname(self) -> Path:\n        \"\"\"Return the path to the project's image file.\"\"\"\n        return self.path / RENKU_HOME / IMAGES / 'project' / '0.png'\n\n    @property\n    def dockerfile_path(self) -> Path:\n        \"\"\"Path to the Dockerfile.\"\"\"\n        return self.path / DOCKERFILE\n\n    @property\n    def ssh_authorized_keys_path(self) -> Path:\n        \"\"\"Path to SSH authorized keys.\"\"\"\n        return self.path / '.ssh' / 'authorized_keys'\n\n    @property\n    def global_config_dir(self) -> str:\n        \"\"\"Return user's config directory.\"\"\"\n        import click\n        return click.get_app_dir(APP_NAME, force_posix=True)\n\n    @property\n    def global_config_path(self) -> Path:\n        \"\"\"Renku global (user's) config path.\"\"\"\n        config = Path(self.global_config_dir)\n        if not config.exists():\n            config.mkdir(parents=True)\n        return config / CONFIG_NAME\n\n    @property\n    def latest_agent(self) -> Optional[str]:\n        \"\"\"Returns latest agent version used in the repository.\"\"\"\n        try:\n            return self.project.agent_version\n        except ValueError as e:\n            if 'Project name not set' in str(e):\n                return None\n            raise\n\n    @property\n    def local_config_path(self) -> Path:\n        \"\"\"Renku local (project) config path.\"\"\"\n        return self.metadata_path / CONFIG_NAME\n\n    @property\n    def lock(self):\n        \"\"\"Create a Renku config lock.\"\"\"\n        from renku.core.util.contexts import Lock\n        return Lock(filename=self.metadata_path.with_suffix(LOCK_SUFFIX), mode='exclusive')\n\n    @property\n    def metadata_path(self) -> Path:\n        \"\"\"Current project's metadata (RENKU_HOME) path.\"\"\"\n        return self.path / RENKU_HOME\n\n    @property\n    def path(self) -> Path:\n        \"\"\"Current project path.\"\"\"\n        return self._top.path\n\n    @property\n    def pointers_path(self) -> Path:\n        \"\"\"Return a ``Path`` instance of Renku pointer files folder.\"\"\"\n        path = self.path / RENKU_HOME / POINTERS\n        path.mkdir(exist_ok=True)\n        return path\n\n    @property\n    def project(self) -> 'Project':\n        \"\"\"Return the Project instance.\"\"\"\n        from renku.command.command_builder.command import inject\n        from renku.core.interface.project_gateway import IProjectGateway\n        project_gateway = inject.instance(IProjectGateway)\n        return project_gateway.get_project()\n\n    @property\n    def remote(self) -> 'ProjectRemote':\n        \"\"\"Return host, owner and name of the remote if it exists.\"\"\"\n        from renku.core.util.git import get_remote\n        repository = self.repository\n        remote = get_remote(repository=repository)\n        if not remote and len(repository.remotes) > 1:\n            remote = repository.remotes.get('origin')\n        return ProjectRemote.from_remote(remote=remote)\n\n    @property\n    def repository(self) -> 'Repository':\n        \"\"\"Return current context's repository.\"\"\"\n        if not self._top.repository:\n            from renku.infrastructure.repository import Repository\n            try:\n                self._top.repository = Repository(project_context.path)\n            except errors.GitError as e:\n                raise ValueError from e\n        return self._top.repository\n\n    @repository.setter\n    def repository(self, value: Optional['Repository']):\n        \"\"\"Set the current repository.\"\"\"\n        self._top.repository = value\n\n    @property\n    def template_checksums_path(self):\n        \"\"\"Return a ``Path`` instance to the template checksums file.\"\"\"\n        return self.metadata_path / TEMPLATE_CHECKSUMS\n\n    @property\n    def transaction_id(self) -> str:\n        \"\"\"Get a transaction id for the current context to be used for grouping git commits.\"\"\"\n        if not self._top.transaction_id:\n            self._top.transaction_id = uuid.uuid4().hex\n        return f'\\n\\nrenku-transaction: {self._top.transaction_id}'\n\n    @property\n    def _top(self) -> 'ProjectProperties':\n        \"\"\"Return current context.\"\"\"\n        if self._context_stack:\n            return self._context_stack[-1]\n        raise errors.ProjectContextError('No project context was pushed')\n\n    def has_context(self, path: Optional[Union[Path, str]]=None) -> bool:\n        \"\"\"Return if at least one context which is equal to path (if not None) is pushed.\"\"\"\n        return True if self._context_stack and (path is None or self.path == Path(path).resolve()) else False\n\n    def clear(self) -> None:\n        \"\"\"Remove all contexts and reset the state without committing intermediate changes.\n\n        NOTE: This method should be used only in tests.\n        \"\"\"\n        while self._context_stack:\n            if self._top.repository:\n                self._top.repository.close()\n            self._context_stack.pop()\n        self.external_storage_requested = True\n\n    def pop_context(self) -> 'ProjectProperties':\n        \"\"\"Pop current project context from stack.\n\n        Returns:\n            Path: the popped project path.\n        \"\"\"\n        if self._context_stack:\n            if self._top.save_changes and self._top.database:\n                self._top.database.commit()\n            if self._top.repository:\n                self._top.repository.close()\n            return self._context_stack.pop()\n        else:\n            raise IndexError('No more context to pop.')\n\n    def push_path(self, path: Union[Path, str], save_changes: bool=False) -> None:\n        \"\"\"Push a new project path to the stack.\n\n        Arguments:\n            path(Union[Path, str]): The path to push.\n            save_changes(bool): Whether to save changes to the database or not.\n        \"\"\"\n        path = Path(path).resolve()\n        self._context_stack.append(ProjectProperties(path=path, save_changes=save_changes))\n\n    def replace_path(self, path: Union[Path, str]):\n        \"\"\"Replace the current project path with a new one if they are different.\n\n        Arguments:\n            path(Union[Path, str]): The path to replace with.\n        \"\"\"\n        path = Path(path).resolve()\n        if not self._context_stack:\n            self.push_path(path)\n        elif self._top.path != path:\n            self._context_stack[-1] = ProjectProperties(path=path)\n\n    @contextlib.contextmanager\n    def with_path(self, path: Union[Path, str], save_changes: bool=False) -> Generator['ProjectProperties', None, None]:\n        \"\"\"Temporarily push a new project path to the stack.\n\n        Arguments:\n            path(Union[Path, str]): The path to push.\n            save_changes(bool): Whether to save changes to the database or not.\n        \"\"\"\n        with self.with_rollback():\n            self.push_path(path=path, save_changes=save_changes)\n            yield self._top\n\n    @contextlib.contextmanager\n    def with_rollback(self) -> Generator[None, None, None]:\n        \"\"\"Rollback to the current state.\n\n        NOTE: This won't work correctly if the current context is popped or swapped.\n        \"\"\"\n        before_top = self._top if self._context_stack else None\n        try:\n            yield\n        finally:\n            could_rollback = False\n            while self._context_stack:\n                if self._top == before_top:\n                    could_rollback = True\n                    break\n                self.pop_context()\n            if not could_rollback and before_top is not None:\n                raise errors.ProjectContextError(f'Cannot rollback to {before_top.path}.')\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n@dataclass\nclass SearchResult:\n    '''Dataclass to hold search results.'''\n    @staticmethod\n    def to_relative_path(file_path: str, project_root: str) -> str:\n        '''Convert an absolute path to a path relative to the project root.\n        Args:\n            - file_path (str): The absolute path.\n            - project_root (str): Absolute path of the project root dir.\n        Returns:\n            The relative path.\n        '''\n        pass\n\n    def to_tagged_upto_file(self, project_root: str):\n        '''Convert the search result to a tagged string, upto file path.'''\n        pass\n\n    def to_tagged_upto_class(self, project_root: str):\n        '''Convert the search result to a tagged string, upto class.'''\n        pass\n\n    def to_tagged_upto_func(self, project_root: str):\n        '''Convert the search result to a tagged string, upto function.'''\n        pass\n\n    def to_tagged_str(self, project_root: str):\n        '''Convert the search result to a tagged string.'''\n        pass\n    @staticmethod\n    def collapse_to_file_level(lst, project_root: str) -> str:\n        '''Collapse search results to file level.'''\n        pass\n    @staticmethod\n    def collapse_to_method_level(lst, project_root: str) -> str:\n        '''Collapse search results to method level.'''\n        pass"
  }
]