[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Compiler(object):\n    '''A Sass compiler.  Stores settings and knows how to fire off a\n    compilation.  Main entry point into compiling Sass.\n    '''\n\n    def __init__(self, root=Path(), search_path=(), namespace=None, extensions=(CoreExtension,), import_static_css=False, output_style='nested', generate_source_map=False, live_errors=False, warn_unused_imports=False, ignore_parse_errors=False, loops_have_own_scopes=True, undefined_variables_fatal=True, super_selector=''):\n        '''Configure a compiler.\n        :param root: Directory to treat as the \"project root\".  Search paths\n            and some custom extensions (e.g. Compass) are relative to this\n            directory.  Defaults to the current directory.\n        :type root: :class:`pathlib.Path`\n        :param search_path: List of paths to search for ``@import``s, relative\n            to ``root``.  Absolute and parent paths are allowed here, but\n            ``@import`` will refuse to load files that aren't in one of the\n            directories here.  Defaults to only the root.\n        :type search_path: list of strings, :class:`pathlib.Path` objects, or\n            something that implements a similar interface (useful for custom\n            pseudo filesystems)\n        '''\n        pass\n\n    def normalize_path(self, path):\n        pass\n\n    def make_compilation(self):\n        pass\n\n    def call_and_catch_errors(self, f, *args, **kwargs):\n        '''Call the given function with the given arguments.  If it succeeds,\n        return its return value.  If it raises a :class:`scss.errors.SassError`\n        and `live_errors` is turned on, return CSS containing a traceback and\n        error message.\n        '''\n        pass\n\n    def compile(self, *filenames):\n        pass\n\n    def compile_sources(self, *sources):\n        pass\n\n    def compile_string(self, string):\n        pass\nCorresponding class implementation:\n\nfrom scss.source import SourceFile\nimport six\nfrom scss.extension import Extension\nfrom scss.rule import Namespace\nfrom pathlib import Path\nfrom scss.extension import NamespaceAdapterExtension\nfrom scss.errors import SassError\nfrom scss.extension.core import CoreExtension\n\nclass Compiler(object):\n    \"\"\"A Sass compiler.  Stores settings and knows how to fire off a\n    compilation.  Main entry point into compiling Sass.\n    \"\"\"\n\n    def __init__(self, root=Path(), search_path=(), namespace=None, extensions=(CoreExtension,), import_static_css=False, output_style='nested', generate_source_map=False, live_errors=False, warn_unused_imports=False, ignore_parse_errors=False, loops_have_own_scopes=True, undefined_variables_fatal=True, super_selector=''):\n        \"\"\"Configure a compiler.\n\n        :param root: Directory to treat as the \"project root\".  Search paths\n            and some custom extensions (e.g. Compass) are relative to this\n            directory.  Defaults to the current directory.\n        :type root: :class:`pathlib.Path`\n        :param search_path: List of paths to search for ``@import``s, relative\n            to ``root``.  Absolute and parent paths are allowed here, but\n            ``@import`` will refuse to load files that aren't in one of the\n            directories here.  Defaults to only the root.\n        :type search_path: list of strings, :class:`pathlib.Path` objects, or\n            something that implements a similar interface (useful for custom\n            pseudo filesystems)\n        \"\"\"\n        if root is None:\n            self.root = None\n        else:\n            self.root = root.resolve()\n        self.search_path = tuple((self.normalize_path(path) for path in search_path))\n        self.extensions = []\n        if namespace is not None:\n            self.extensions.append(NamespaceAdapterExtension(namespace))\n        for extension in extensions:\n            if isinstance(extension, Extension):\n                self.extensions.append(extension)\n            elif isinstance(extension, type) and issubclass(extension, Extension):\n                self.extensions.append(extension())\n            elif isinstance(extension, Namespace):\n                self.extensions.append(NamespaceAdapterExtension(extension))\n            else:\n                raise TypeError('Expected an Extension or Namespace, got: {0!r}'.format(extension))\n        if import_static_css:\n            self.dynamic_extensions = ('.scss', '.sass', '.css')\n            self.static_extensions = ()\n        else:\n            self.dynamic_extensions = ('.scss', '.sass')\n            self.static_extensions = ('.css',)\n        self.output_style = output_style\n        self.generate_source_map = generate_source_map\n        self.live_errors = live_errors\n        self.warn_unused_imports = warn_unused_imports\n        self.ignore_parse_errors = ignore_parse_errors\n        self.loops_have_own_scopes = loops_have_own_scopes\n        self.undefined_variables_fatal = undefined_variables_fatal\n        self.super_selector = super_selector\n\n    def normalize_path(self, path):\n        if isinstance(path, six.string_types):\n            path = Path(path)\n        if path.is_absolute():\n            return path\n        if self.root is None:\n            raise IOError(\"Can't make absolute path when root is None\")\n        return self.root / path\n\n    def make_compilation(self):\n        return Compilation(self)\n\n    def call_and_catch_errors(self, f, *args, **kwargs):\n        \"\"\"Call the given function with the given arguments.  If it succeeds,\n        return its return value.  If it raises a :class:`scss.errors.SassError`\n        and `live_errors` is turned on, return CSS containing a traceback and\n        error message.\n        \"\"\"\n        try:\n            return f(*args, **kwargs)\n        except SassError as e:\n            if self.live_errors:\n                return e.to_css()\n            else:\n                raise\n\n    def compile(self, *filenames):\n        compilation = self.make_compilation()\n        for filename in filenames:\n            source = SourceFile.from_filename(self.normalize_path(filename))\n            compilation.add_source(source)\n        return self.call_and_catch_errors(compilation.run)\n\n    def compile_sources(self, *sources):\n        compilation = self.make_compilation()\n        for source in sources:\n            compilation.add_source(source)\n        return self.call_and_catch_errors(compilation.run)\n\n    def compile_string(self, string):\n        source = SourceFile.from_string(string)\n        compilation = self.make_compilation()\n        compilation.add_source(source)\n        return self.call_and_catch_errors(compilation.run)\n\nExample skeleton:\n\nclass MetadataEndpoint(NamespacedDriver):\n    '''Exposes functionality of the ``'/metadata'`` endpoint.\n    Attributes:\n        path (str): The path of the endpoint.\n    '''\n\n    def get(self, *, search, limit=0, headers=None):\n        '''Retrieves the metadata that match a given text search string.\n        Args:\n            search (str): Text search string.\n            limit (int): Limit the number of returned documents. Defaults to\n                zero meaning that it returns all the matching metadata.\n            headers (dict): Optional headers to pass to the request.\n        Returns:\n            :obj:`list` of :obj:`dict`: List of metadata that match the query.\n        '''\n        pass\nCorresponding class implementation:\n\nclass MetadataEndpoint(NamespacedDriver):\n    \"\"\"Exposes functionality of the ``'/metadata'`` endpoint.\n\n    Attributes:\n        path (str): The path of the endpoint.\n\n    \"\"\"\n    PATH = '/metadata/'\n\n    def get(self, *, search, limit=0, headers=None):\n        \"\"\"Retrieves the metadata that match a given text search string.\n\n        Args:\n            search (str): Text search string.\n            limit (int): Limit the number of returned documents. Defaults to\n                zero meaning that it returns all the matching metadata.\n            headers (dict): Optional headers to pass to the request.\n\n        Returns:\n            :obj:`list` of :obj:`dict`: List of metadata that match the query.\n\n        \"\"\"\n        return self.transport.forward_request(method='GET', path=self.path, params={'search': search, 'limit': limit}, headers=headers)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass ContentMixin:\n    '''\n    Mixin class for BedrockServerManager that handles global content management.\n        '''\n\n    def _list_content_files(self, sub_folder: str, extensions: List[str]) -> List[str]:\n        '''\n        Internal helper to list files with specified extensions from a sub-folder\n        within the global content directory.\n        This method constructs a path to ``<content_dir>/<sub_folder>``, then\n        scans this directory for files matching any of the provided ``extensions``.\n        The global content directory is defined by ``settings['paths.content']``\n        and cached in :attr:`._content_dir`.\n        Args:\n            sub_folder (str): The name of the sub-folder within the global content\n                directory to scan (e.g., \"worlds\", \"addons\").\n            extensions (List[str]): A list of file extensions to search for.\n                Extensions should include the leading dot (e.g., ``[\".mcworld\"]``,\n                ``[\".mcpack\", \".mcaddon\"]``).\n        Returns:\n            List[str]: A sorted list of absolute paths to the files found.\n            Returns an empty list if the target directory does not exist or no\n            matching files are found.\n        Raises:\n            AppFileNotFoundError: If the main content directory (:attr:`._content_dir`)\n                is not configured or does not exist as a directory.\n            FileOperationError: If an OS-level error occurs while scanning the\n                directory (e.g., permission issues).\n        '''\n        pass\n\n    def list_available_worlds(self) -> List[str]:\n        '''Lists available ``.mcworld`` template files from the global content directory.\n        This method scans the ``worlds`` sub-folder within the application's\n        global content directory (see :attr:`._content_dir` and\n        ``settings['paths.content']``) for files with the ``.mcworld`` extension.\n        It relies on :meth:`._list_content_files` for the actual scanning.\n        These ``.mcworld`` files typically represent world templates that can be\n        imported to create new server worlds or overwrite existing ones.\n        Returns:\n            List[str]: A sorted list of absolute paths to all found ``.mcworld`` files.\n            Returns an empty list if the directory doesn't exist or no ``.mcworld``\n            files are present.\n        Raises:\n            AppFileNotFoundError: If the main content directory is not configured\n                or found (from :meth:`._list_content_files`).\n            FileOperationError: If an OS error occurs during directory scanning\n                (from :meth:`._list_content_files`).\n        '''\n        pass\n\n    def list_available_addons(self) -> List[str]:\n        '''Lists available addon files (``.mcpack``, ``.mcaddon``) from the global content directory.\n        This method scans the ``addons`` sub-folder within the application's\n        global content directory (see :attr:`._content_dir` and\n        ``settings['paths.content']``) for files with ``.mcpack`` or\n        ``.mcaddon`` extensions. It uses :meth:`._list_content_files` for scanning.\n        These files represent behavior packs, resource packs, or bundled addons\n        that can be installed onto server instances.\n        Returns:\n            List[str]: A sorted list of absolute paths to all found ``.mcpack``\n            and ``.mcaddon`` files. Returns an empty list if the directory\n            doesn't exist or no such files are present.\n        Raises:\n            AppFileNotFoundError: If the main content directory is not configured\n                or found (from :meth:`._list_content_files`).\n            FileOperationError: If an OS error occurs during directory scanning\n                (from :meth:`._list_content_files`).\n        '''\n        pass"
  }
]