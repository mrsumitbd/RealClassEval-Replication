[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass RandomGrayscale(torch.nn.Module):\n    '''Randomly convert image to grayscale with a probability of p (default 0.1).\n    If the image is torch Tensor, it is expected\n    to have [..., 3, H, W] shape, where ... means an arbitrary number of leading dimensions\n    Args:\n        p (float): probability that image should be converted to grayscale.\n    Returns:\n        PIL Image or Tensor: Grayscale version of the input image with probability p and unchanged\n        with probability (1-p).\n        - If input image is 1 channel: grayscale version is 1 channel\n        - If input image is 3 channel: grayscale version is 3 channel with r == g == b\n    '''\n\n    def __init__(self, p=0.1):\n        pass\n\n    def forward(self, img):\n        '''\n        Args:\n            img (PIL Image or Tensor): Image to be converted to grayscale.\n        Returns:\n            PIL Image or Tensor: Randomly grayscaled image.\n        '''\n        pass\n\n    def __repr__(self) -> str:\n        pass\nCorresponding class implementation:\n\nfrom ..utils import _log_api_usage_once\nfrom . import functional as F\nimport torch\n\nclass RandomGrayscale(torch.nn.Module):\n    \"\"\"Randomly convert image to grayscale with a probability of p (default 0.1).\n    If the image is torch Tensor, it is expected\n    to have [..., 3, H, W] shape, where ... means an arbitrary number of leading dimensions\n\n    Args:\n        p (float): probability that image should be converted to grayscale.\n\n    Returns:\n        PIL Image or Tensor: Grayscale version of the input image with probability p and unchanged\n        with probability (1-p).\n        - If input image is 1 channel: grayscale version is 1 channel\n        - If input image is 3 channel: grayscale version is 3 channel with r == g == b\n\n    \"\"\"\n\n    def __init__(self, p=0.1):\n        super().__init__()\n        _log_api_usage_once(self)\n        self.p = p\n\n    def forward(self, img):\n        \"\"\"\n        Args:\n            img (PIL Image or Tensor): Image to be converted to grayscale.\n\n        Returns:\n            PIL Image or Tensor: Randomly grayscaled image.\n        \"\"\"\n        num_output_channels, _, _ = F.get_dimensions(img)\n        if torch.rand(1) < self.p:\n            return F.rgb_to_grayscale(img, num_output_channels=num_output_channels)\n        return img\n\n    def __repr__(self) -> str:\n        return f'{self.__class__.__name__}(p={self.p})'\n\nExample skeleton:\n\n\nclass VAO:\n    '''\n    Represents a vertex array object.\n    This is a wrapper class over ``moderngl.VertexArray`` to provide helper method.\n    The main purpose is to provide render methods taking a program as parameter.\n    The class will auto detect the programs attributes and add padding when needed\n    to match the vertex object.\n    A new vertexbuffer object is created and stored internally for each unique\n    shader program used.\n    A secondary purpose is to provide an alternate way to build vertexbuffers\n    This can be practical when loading or creating various geometry.\n    There is no requirements to use this class, but most methods in the\n    system creating vertexbuffers will return this type. You can obtain\n    a single vertexbuffer instance by calling :py:meth:`VAO.instance`\n    method if you prefer to work directly on moderngl instances.\n    '''\n\n    def __init__(self, name='', mode=moderngl.TRIANGLES):\n        '''\n        Create and empty VAO\n        Keyword Args:\n            name (str): The name for debug purposes\n            mode (int): Default draw mode\n        '''\n        pass\n\n    def render(self, program: moderngl.Program, mode=None, vertices=-1, first=0, instances=1):\n        '''\n        Render the VAO.\n        Args:\n            program: The ``moderngl.Program``\n        Keyword Args:\n            mode: Override the draw mode (``TRIANGLES`` etc)\n            vertices (int): The number of vertices to transform\n            first (int): The index of the first vertex to start with\n            instances (int): The number of instances\n        '''\n        pass\n\n    def render_indirect(self, program: moderngl.Program, buffer, mode=None, count=-1, *, first=0):\n        '''\n        The render primitive (mode) must be the same as the input primitive of the GeometryShader.\n        The draw commands are 5 integers: (count, instanceCount, firstIndex, baseVertex, baseInstance).\n        Args:\n            program: The ``moderngl.Program``\n            buffer: The ``moderngl.Buffer`` containing indirect draw commands\n        Keyword Args:\n            mode (int): By default :py:data:`TRIANGLES` will be used.\n            count (int): The number of draws.\n            first (int): The index of the first indirect draw command.\n        '''\n        pass\n\n    def transform(self, program: moderngl.Program, buffer: moderngl.Buffer, mode=None, vertices=-1, first=0, instances=1):\n        '''\n        Transform vertices. Stores the output in a single buffer.\n        Args:\n            program: The ``moderngl.Program``\n            buffer: The ``moderngl.buffer`` to store the output\n        Keyword Args:\n            mode: Draw mode (for example ``moderngl.POINTS``)\n            vertices (int): The number of vertices to transform\n            first (int): The index of the first vertex to start with\n            instances (int): The number of instances\n        '''\n        pass\n\n    def buffer(self, buffer, buffer_format: str, attribute_names, per_instance=False):\n        '''\n        Register a buffer/vbo for the VAO. This can be called multiple times.\n        adding multiple buffers (interleaved or not)\n        Args:\n            buffer: The buffer data. Can be ``numpy.array``, ``moderngl.Buffer`` or ``bytes``.\n            buffer_format (str): The format of the buffer. (eg. ``3f 3f`` for interleaved positions and normals).\n            attribute_names: A list of attribute names this buffer should map to.\n        Keyword Args:\n            per_instance (bool): Is this buffer per instance data for instanced rendering?\n        Returns:\n            The ``moderngl.Buffer`` instance object. This is handy when providing ``bytes`` and ``numpy.array``.\n        '''\n        pass\n\n    def index_buffer(self, buffer, index_element_size=4):\n        '''\n        Set the index buffer for this VAO\n        Args:\n            buffer: ``moderngl.Buffer``, ``numpy.array`` or ``bytes``\n        Keyword Args:\n            index_element_size (int): Byte size of each element. 1, 2 or 4\n        '''\n        pass\n\n    def instance(self, program: moderngl.Program) -> moderngl.VertexArray:\n        '''\n        Obtain the ``moderngl.VertexArray`` instance for the program.\n        The instance is only created once and cached internally.\n        Returns: ``moderngl.VertexArray`` instance\n        '''\n        pass\n\n    def release(self, buffer=True):\n        '''\n        Destroy the vao object\n        Keyword Args:\n            buffers (bool): also release buffers\n        '''\n        pass\nCorresponding class implementation:\n\nimport numpy\nimport moderngl\nfrom demosys import context\n\nclass VAO:\n    \"\"\"\n    Represents a vertex array object.\n    This is a wrapper class over ``moderngl.VertexArray`` to provide helper method.\n\n    The main purpose is to provide render methods taking a program as parameter.\n    The class will auto detect the programs attributes and add padding when needed\n    to match the vertex object.\n    A new vertexbuffer object is created and stored internally for each unique\n    shader program used.\n\n    A secondary purpose is to provide an alternate way to build vertexbuffers\n    This can be practical when loading or creating various geometry.\n\n    There is no requirements to use this class, but most methods in the\n    system creating vertexbuffers will return this type. You can obtain\n    a single vertexbuffer instance by calling :py:meth:`VAO.instance`\n    method if you prefer to work directly on moderngl instances.\n    \"\"\"\n\n    def __init__(self, name='', mode=moderngl.TRIANGLES):\n        \"\"\"\n        Create and empty VAO\n\n        Keyword Args:\n            name (str): The name for debug purposes\n            mode (int): Default draw mode\n        \"\"\"\n        self.ctx = context.ctx()\n        self.name = name\n        self.mode = mode\n        try:\n            DRAW_MODES[self.mode]\n        except KeyError:\n            raise VAOError('Invalid draw mode. Options are {}'.format(DRAW_MODES.values()))\n        self.buffers = []\n        self._index_buffer = None\n        self._index_element_size = None\n        self.vertex_count = 0\n        self.vaos = {}\n\n    def render(self, program: moderngl.Program, mode=None, vertices=-1, first=0, instances=1):\n        \"\"\"\n        Render the VAO.\n\n        Args:\n            program: The ``moderngl.Program``\n\n        Keyword Args:\n            mode: Override the draw mode (``TRIANGLES`` etc)\n            vertices (int): The number of vertices to transform\n            first (int): The index of the first vertex to start with\n            instances (int): The number of instances\n        \"\"\"\n        vao = self.instance(program)\n        if mode is None:\n            mode = self.mode\n        vao.render(mode, vertices=vertices, first=first, instances=instances)\n\n    def render_indirect(self, program: moderngl.Program, buffer, mode=None, count=-1, *, first=0):\n        \"\"\"\n        The render primitive (mode) must be the same as the input primitive of the GeometryShader.\n        The draw commands are 5 integers: (count, instanceCount, firstIndex, baseVertex, baseInstance).\n\n        Args:\n            program: The ``moderngl.Program``\n            buffer: The ``moderngl.Buffer`` containing indirect draw commands\n\n        Keyword Args:\n            mode (int): By default :py:data:`TRIANGLES` will be used.\n            count (int): The number of draws.\n            first (int): The index of the first indirect draw command.\n        \"\"\"\n        vao = self.instance(program)\n        if mode is None:\n            mode = self.mode\n        vao.render_indirect(buffer, mode=mode, count=count, first=first)\n\n    def transform(self, program: moderngl.Program, buffer: moderngl.Buffer, mode=None, vertices=-1, first=0, instances=1):\n        \"\"\"\n        Transform vertices. Stores the output in a single buffer.\n\n        Args:\n            program: The ``moderngl.Program``\n            buffer: The ``moderngl.buffer`` to store the output\n\n        Keyword Args:\n            mode: Draw mode (for example ``moderngl.POINTS``)\n            vertices (int): The number of vertices to transform\n            first (int): The index of the first vertex to start with\n            instances (int): The number of instances\n        \"\"\"\n        vao = self.instance(program)\n        if mode is None:\n            mode = self.mode\n        vao.transform(buffer, mode=mode, vertices=vertices, first=first, instances=instances)\n\n    def buffer(self, buffer, buffer_format: str, attribute_names, per_instance=False):\n        \"\"\"\n        Register a buffer/vbo for the VAO. This can be called multiple times.\n        adding multiple buffers (interleaved or not)\n\n        Args:\n            buffer: The buffer data. Can be ``numpy.array``, ``moderngl.Buffer`` or ``bytes``.\n            buffer_format (str): The format of the buffer. (eg. ``3f 3f`` for interleaved positions and normals).\n            attribute_names: A list of attribute names this buffer should map to.\n\n        Keyword Args:\n            per_instance (bool): Is this buffer per instance data for instanced rendering?\n\n        Returns:\n            The ``moderngl.Buffer`` instance object. This is handy when providing ``bytes`` and ``numpy.array``.\n        \"\"\"\n        if not isinstance(attribute_names, list):\n            attribute_names = [attribute_names]\n        if not type(buffer) in [moderngl.Buffer, numpy.ndarray, bytes]:\n            raise VAOError('buffer parameter must be a moderngl.Buffer, numpy.ndarray or bytes instance(not {})'.format(type(buffer)))\n        if isinstance(buffer, numpy.ndarray):\n            buffer = self.ctx.buffer(buffer.tobytes())\n        if isinstance(buffer, bytes):\n            buffer = self.ctx.buffer(data=buffer)\n        formats = buffer_format.split()\n        if len(formats) != len(attribute_names):\n            raise VAOError(\"Format '{}' does not describe attributes {}\".format(buffer_format, attribute_names))\n        self.buffers.append(BufferInfo(buffer, buffer_format, attribute_names, per_instance=per_instance))\n        self.vertex_count = self.buffers[-1].vertices\n        return buffer\n\n    def index_buffer(self, buffer, index_element_size=4):\n        \"\"\"\n        Set the index buffer for this VAO\n\n        Args:\n            buffer: ``moderngl.Buffer``, ``numpy.array`` or ``bytes``\n\n        Keyword Args:\n            index_element_size (int): Byte size of each element. 1, 2 or 4\n        \"\"\"\n        if not type(buffer) in [moderngl.Buffer, numpy.ndarray, bytes]:\n            raise VAOError('buffer parameter must be a moderngl.Buffer, numpy.ndarray or bytes instance')\n        if isinstance(buffer, numpy.ndarray):\n            buffer = self.ctx.buffer(buffer.tobytes())\n        if isinstance(buffer, bytes):\n            buffer = self.ctx.buffer(data=buffer)\n        self._index_buffer = buffer\n        self._index_element_size = index_element_size\n\n    def instance(self, program: moderngl.Program) -> moderngl.VertexArray:\n        \"\"\"\n        Obtain the ``moderngl.VertexArray`` instance for the program.\n        The instance is only created once and cached internally.\n\n        Returns: ``moderngl.VertexArray`` instance\n        \"\"\"\n        vao = self.vaos.get(program.glo)\n        if vao:\n            return vao\n        program_attributes = [name for name, attr in program._members.items() if isinstance(attr, moderngl.Attribute)]\n        for attrib_name in program_attributes:\n            if attrib_name.startswith('gl_'):\n                continue\n            if not sum((buffer.has_attribute(attrib_name) for buffer in self.buffers)):\n                raise VAOError(\"VAO {} doesn't have attribute {} for program {}\".format(self.name, attrib_name, program.name))\n        vao_content = []\n        for buffer in self.buffers:\n            content = buffer.content(program_attributes)\n            if content:\n                vao_content.append(content)\n        if program_attributes:\n            for attrib_name in program_attributes:\n                if attrib_name.startswith('gl_'):\n                    continue\n                raise VAOError('Did not find a buffer mapping for {}'.format([n for n in program_attributes]))\n        if self._index_buffer:\n            vao = context.ctx().vertex_array(program, vao_content, self._index_buffer, self._index_element_size)\n        else:\n            vao = context.ctx().vertex_array(program, vao_content)\n        self.vaos[program.glo] = vao\n        return vao\n\n    def release(self, buffer=True):\n        \"\"\"\n        Destroy the vao object\n\n        Keyword Args:\n            buffers (bool): also release buffers\n        \"\"\"\n        for key, vao in self.vaos:\n            vao.release()\n        if buffer:\n            for buff in self.buffers:\n                buff.buffer.release()\n            if self._index_buffer:\n                self._index_buffer.release()\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass ClassifyLetterBox:\n    '''\n    A class for resizing and padding images for classification tasks.\n    This class is designed to be part of a transformation pipeline, e.g., T.Compose([LetterBox(size), ToTensor()]).\n    It resizes and pads images to a specified size while maintaining the original aspect ratio.\n    Attributes:\n        h (int): Target height of the image.\n        w (int): Target width of the image.\n        auto (bool): If True, automatically calculates the short side using stride.\n        stride (int): The stride value, used when 'auto' is True.\n    Methods:\n        __call__: Applies the letterbox transformation to an input image.\n    Examples:\n        >>> transform = ClassifyLetterBox(size=(640, 640), auto=False, stride=32)\n        >>> img = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)\n        >>> result = transform(img)\n        >>> print(result.shape)\n        (640, 640, 3)\n    '''\n\n    def __init__(self, size=(640, 640), auto=False, stride=32):\n        '''\n        Initializes the ClassifyLetterBox object for image preprocessing.\n        This class is designed to be part of a transformation pipeline for image classification tasks. It resizes and\n        pads images to a specified size while maintaining the original aspect ratio.\n        Args:\n            size (int | Tuple[int, int]): Target size for the letterboxed image. If an int, a square image of\n                (size, size) is created. If a tuple, it should be (height, width).\n            auto (bool): If True, automatically calculates the short side based on stride. Default is False.\n            stride (int): The stride value, used when 'auto' is True. Default is 32.\n        Attributes:\n            h (int): Target height of the letterboxed image.\n            w (int): Target width of the letterboxed image.\n            auto (bool): Flag indicating whether to automatically calculate short side.\n            stride (int): Stride value for automatic short side calculation.\n        Examples:\n            >>> transform = ClassifyLetterBox(size=224)\n            >>> img = np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)\n            >>> result = transform(img)\n            >>> print(result.shape)\n            (224, 224, 3)\n        '''\n        pass\n\n    def __call__(self, im):\n        '''\n        Resizes and pads an image using the letterbox method.\n        This method resizes the input image to fit within the specified dimensions while maintaining its aspect ratio,\n        then pads the resized image to match the target size.\n        Args:\n            im (numpy.ndarray): Input image as a numpy array with shape (H, W, C).\n        Returns:\n            (numpy.ndarray): Resized and padded image as a numpy array with shape (hs, ws, 3), where hs and ws are\n                the target height and width respectively.\n        Examples:\n            >>> letterbox = ClassifyLetterBox(size=(640, 640))\n            >>> image = np.random.randint(0, 255, (720, 1280, 3), dtype=np.uint8)\n            >>> resized_image = letterbox(image)\n            >>> print(resized_image.shape)\n            (640, 640, 3)\n        '''\n        pass"
  }
]