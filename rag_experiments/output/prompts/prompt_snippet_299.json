[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\nclass PostgresqlProvider(SAProvider):\n\n    def _get_database_specific_engine_args(self) -> dict:\n        '''Supplies additional database-specific arguments to SQLAlchemy Engine.\n        Return: a dictionary with database-specific SQLAlchemy Engine arguments.\n        '''\n        pass\n\n    def _get_database_specific_session_args(self) -> dict:\n        '''Set Database specific session parameters.\n        Depending on the database in use, this method supplies\n        additional arguments while constructing sessions.\n        Return: a dictionary with additional arguments and values.\n        '''\n        pass\n\n    def _execute_database_specific_connection_statements(self, conn):\n        '''Execute connection statements depending on the database in use.\n        Overridden implementation for PostgreSQL.\n        Arguments:\n        * conn: An active connection object to the database\n        Return: Updated connection object\n        '''\n        pass\nCorresponding class implementation:\n\nclass PostgresqlProvider(SAProvider):\n    __database__ = SAProvider.databases.postgresql.value\n\n    def _get_database_specific_engine_args(self) -> dict:\n        \"\"\"Supplies additional database-specific arguments to SQLAlchemy Engine.\n\n        Return: a dictionary with database-specific SQLAlchemy Engine arguments.\n        \"\"\"\n        return {'isolation_level': 'AUTOCOMMIT'}\n\n    def _get_database_specific_session_args(self) -> dict:\n        \"\"\"Set Database specific session parameters.\n\n        Depending on the database in use, this method supplies\n        additional arguments while constructing sessions.\n\n        Return: a dictionary with additional arguments and values.\n        \"\"\"\n        return {'autoflush': False}\n\n    def _execute_database_specific_connection_statements(self, conn):\n        \"\"\"Execute connection statements depending on the database in use.\n        Overridden implementation for PostgreSQL.\n        Arguments:\n        * conn: An active connection object to the database\n\n        Return: Updated connection object\n        \"\"\"\n        return conn\n\nExample skeleton:\n\nclass AnalyzersManager(object):\n    '''Class that implements the analyzers manager.'''\n    @classmethod\n    def DeregisterAnalyzer(cls, analyzer_class):\n        '''Deregisters a analyzer class.\n        The analyzer classes are identified based on their lower case name.\n        Args:\n          analyzer_class (type): class object of the analyzer.\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzersInformation(cls):\n        '''Retrieves the analyzers information.\n        Returns:\n          list[tuple]: containing:\n            str: analyzer name.\n            str: analyzer description.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzerInstance(cls, analyzer_name):\n        '''Retrieves an instance of a specific analyzer.\n        Args:\n          analyzer_name (str): name of the analyzer to retrieve.\n        Returns:\n          BaseAnalyzer: analyzer instance.\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzerInstances(cls, analyzer_names):\n        '''Retrieves instances for all the specified analyzers.\n        Args:\n          analyzer_names (list[str]): names of the analyzers to retrieve.\n        Returns:\n          list[BaseAnalyzer]: analyzer instances.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzerNames(cls):\n        '''Retrieves the names of all loaded analyzers.\n        Returns:\n          list[str]: of analyzer names.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzersInformation(cls):\n        '''Retrieves the registered analyzers.\n        Yields:\n          tuple: containing:\n            str: the uniquely identifying name of the analyzer\n            type: the analyzer class.\n        '''\n        pass\n    @classmethod\n    def RegisterAnalyzer(cls, analyzer_class):\n        '''Registers a analyzer class.\n        The analyzer classes are identified by their lower case name.\n        Args:\n          analyzer_class (type): the analyzer class to register.\n        Raises:\n          KeyError: if analyzer class is already set for the corresponding name.\n        '''\n        pass\nCorresponding class implementation:\n\nclass AnalyzersManager(object):\n    \"\"\"Class that implements the analyzers manager.\"\"\"\n    _analyzer_classes = {}\n\n    @classmethod\n    def DeregisterAnalyzer(cls, analyzer_class):\n        \"\"\"Deregisters a analyzer class.\n\n        The analyzer classes are identified based on their lower case name.\n\n        Args:\n          analyzer_class (type): class object of the analyzer.\n\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        \"\"\"\n        analyzer_name = analyzer_class.NAME.lower()\n        if analyzer_name not in cls._analyzer_classes:\n            raise KeyError(f'analyzer class not set for name: {analyzer_class.NAME:s}')\n        del cls._analyzer_classes[analyzer_name]\n\n    @classmethod\n    def GetAnalyzersInformation(cls):\n        \"\"\"Retrieves the analyzers information.\n\n        Returns:\n          list[tuple]: containing:\n\n            str: analyzer name.\n            str: analyzer description.\n        \"\"\"\n        analyzer_information = []\n        for _, analyzer_class in cls.GetAnalyzers():\n            description = getattr(analyzer_class, 'DESCRIPTION', '')\n            analyzer_information.append((analyzer_class.NAME, description))\n        return analyzer_information\n\n    @classmethod\n    def GetAnalyzerInstance(cls, analyzer_name):\n        \"\"\"Retrieves an instance of a specific analyzer.\n\n        Args:\n          analyzer_name (str): name of the analyzer to retrieve.\n\n        Returns:\n          BaseAnalyzer: analyzer instance.\n\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        \"\"\"\n        analyzer_name = analyzer_name.lower()\n        if analyzer_name not in cls._analyzer_classes:\n            raise KeyError(f'analyzer class not set for name: {analyzer_name:s}.')\n        analyzer_class = cls._analyzer_classes[analyzer_name]\n        return analyzer_class()\n\n    @classmethod\n    def GetAnalyzerInstances(cls, analyzer_names):\n        \"\"\"Retrieves instances for all the specified analyzers.\n\n        Args:\n          analyzer_names (list[str]): names of the analyzers to retrieve.\n\n        Returns:\n          list[BaseAnalyzer]: analyzer instances.\n        \"\"\"\n        analyzer_instances = []\n        for analyzer_name, analyzer_class in cls.GetAnalyzers():\n            if analyzer_name in analyzer_names:\n                analyzer_instances.append(analyzer_class())\n        return analyzer_instances\n\n    @classmethod\n    def GetAnalyzerNames(cls):\n        \"\"\"Retrieves the names of all loaded analyzers.\n\n        Returns:\n          list[str]: of analyzer names.\n        \"\"\"\n        return cls._analyzer_classes.keys()\n\n    @classmethod\n    def GetAnalyzers(cls):\n        \"\"\"Retrieves the registered analyzers.\n\n        Yields:\n          tuple: containing:\n\n            str: the uniquely identifying name of the analyzer\n            type: the analyzer class.\n        \"\"\"\n        for analyzer_name, analyzer_class in cls._analyzer_classes.items():\n            yield (analyzer_name, analyzer_class)\n\n    @classmethod\n    def RegisterAnalyzer(cls, analyzer_class):\n        \"\"\"Registers a analyzer class.\n\n        The analyzer classes are identified by their lower case name.\n\n        Args:\n          analyzer_class (type): the analyzer class to register.\n\n        Raises:\n          KeyError: if analyzer class is already set for the corresponding name.\n        \"\"\"\n        analyzer_name = analyzer_class.NAME.lower()\n        if analyzer_name in cls._analyzer_classes:\n            raise KeyError(f'analyzer class already set for name: {analyzer_class.NAME:s}.')\n        cls._analyzer_classes[analyzer_name] = analyzer_class\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass SessionManagerRegistry:\n    '''Registry for SQLAlchemy session managers.\n    This registry provides a centralized access point for both synchronous and\n    asynchronous session managers, implementing the Service Locator pattern.\n    Subclasses should override get_sync_manager and get_async_manager to provide\n    concrete session managers, or use set_sync_manager and set_async_manager to\n    register managers manually.\n    Examples:\n        >>> from archipy.adapters.postgres.sqlalchemy.session_manager_registry import PostgresSessionManagerRegistry\n        >>> sync_manager = PostgresSessionManagerRegistry.get_sync_manager()\n        >>> session = sync_manager.get_session()\n    '''\n    @classmethod\n    def get_sync_manager(cls) -> 'SessionManagerPort':\n        '''Get the synchronous session manager instance.\n        Returns:\n            SessionManagerPort: The registered synchronous session manager\n        Raises:\n            InternalError: If no synchronous session manager is set\n            DatabaseConnectionError: If there's an error initializing the session manager\n        '''\n        pass\n    @classmethod\n    def set_sync_manager(cls, manager: 'SessionManagerPort') -> None:\n        '''Set a custom synchronous session manager.\n        Args:\n            manager: An instance implementing SessionManagerPort\n        Raises:\n            InvalidArgumentError: If the manager is None or doesn't implement SessionManagerPort\n        '''\n        pass\n    @classmethod\n    def get_async_manager(cls) -> 'AsyncSessionManagerPort':\n        '''Get the asynchronous session manager instance.\n        Returns:\n            AsyncSessionManagerPort: The registered asynchronous session manager\n        Raises:\n            InternalError: If no asynchronous session manager is set\n            DatabaseConnectionError: If there's an error initializing the session manager\n        '''\n        pass\n    @classmethod\n    def set_async_manager(cls, manager: 'AsyncSessionManagerPort') -> None:\n        '''Set a custom asynchronous session manager.\n        Args:\n            manager: An instance implementing AsyncSessionManagerPort\n        Raises:\n            InvalidArgumentError: If the manager is None or doesn't implement AsyncSessionManagerPort\n        '''\n        pass\n    @classmethod\n    def reset(cls) -> None:\n        '''Reset the registry to its initial state.\n        This method clears both registered managers, useful for testing.\n        '''\n        pass"
  }
]