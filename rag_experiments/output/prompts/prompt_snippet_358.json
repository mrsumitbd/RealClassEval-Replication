[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass SparseConvFunction(Function):\n    '''Sparse Convolution.\n    Please refer to `SECOND <https://www.mdpi.com/1424-8220/18/10/3337>`_ for\n    more details.\n    '''\n    @staticmethod\n    def forward(ctx: Any, features: torch.Tensor, filters: torch.nn.Parameter, indice_pairs: torch.Tensor, indice_pair_num: torch.Tensor, num_activate_out: torch.Tensor) -> torch.Tensor:\n        '''\n        Args:\n            features (torch.Tensor): Features that needs to convolute.\n            filters (torch.nn.parameter.Parameter): Convolution filters.\n            indice_pairs (torch.Tensor): Indice pairs between inputs locations\n                and outputs locations.\n            indice_pair_num (torch.Tensor): Indice pairs num.\n            num_activate_out (torch.Tensor): Output channels num.\n        Returns:\n            torch.Tensor: Output features from gather-gemm-scatter.\n        '''\n        pass\n    @staticmethod\n    def backward(ctx: Any, grad_output: torch.Tensor) -> tuple:\n        pass\nCorresponding class implementation:\n\nfrom typing import Any\nimport torch\nfrom . import sparse_ops as ops\nfrom torch.autograd import Function\n\nclass SparseConvFunction(Function):\n    \"\"\"Sparse Convolution.\n\n    Please refer to `SECOND <https://www.mdpi.com/1424-8220/18/10/3337>`_ for\n    more details.\n    \"\"\"\n\n    @staticmethod\n    def forward(ctx: Any, features: torch.Tensor, filters: torch.nn.Parameter, indice_pairs: torch.Tensor, indice_pair_num: torch.Tensor, num_activate_out: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Args:\n            features (torch.Tensor): Features that needs to convolute.\n            filters (torch.nn.parameter.Parameter): Convolution filters.\n            indice_pairs (torch.Tensor): Indice pairs between inputs locations\n                and outputs locations.\n            indice_pair_num (torch.Tensor): Indice pairs num.\n            num_activate_out (torch.Tensor): Output channels num.\n\n        Returns:\n            torch.Tensor: Output features from gather-gemm-scatter.\n        \"\"\"\n        ctx.save_for_backward(indice_pairs, indice_pair_num, features, filters)\n        return ops.indice_conv(features, filters, indice_pairs, indice_pair_num, num_activate_out, False)\n\n    @staticmethod\n    def backward(ctx: Any, grad_output: torch.Tensor) -> tuple:\n        indice_pairs, indice_pair_num, features, filters = ctx.saved_tensors\n        input_bp, filters_bp = ops.indice_conv_backward(features, filters, grad_output, indice_pairs, indice_pair_num, False)\n        return (input_bp, filters_bp, None, None, None)\n\nExample skeleton:\n\n\nclass RandomGrayscale(torch.nn.Module):\n    '''Randomly convert image to grayscale with a probability of p (default 0.1).\n    If the image is torch Tensor, it is expected\n    to have [..., 3, H, W] shape, where ... means an arbitrary number of leading dimensions\n    Args:\n        p (float): probability that image should be converted to grayscale.\n    Returns:\n        PIL Image or Tensor: Grayscale version of the input image with probability p and unchanged\n        with probability (1-p).\n        - If input image is 1 channel: grayscale version is 1 channel\n        - If input image is 3 channel: grayscale version is 3 channel with r == g == b\n    '''\n\n    def __init__(self, p=0.1):\n        pass\n\n    def forward(self, img):\n        '''\n        Args:\n            img (PIL Image or Tensor): Image to be converted to grayscale.\n        Returns:\n            PIL Image or Tensor: Randomly grayscaled image.\n        '''\n        pass\n\n    def __repr__(self) -> str:\n        pass\nCorresponding class implementation:\n\nfrom ..utils import _log_api_usage_once\nfrom . import functional as F\nimport torch\n\nclass RandomGrayscale(torch.nn.Module):\n    \"\"\"Randomly convert image to grayscale with a probability of p (default 0.1).\n    If the image is torch Tensor, it is expected\n    to have [..., 3, H, W] shape, where ... means an arbitrary number of leading dimensions\n\n    Args:\n        p (float): probability that image should be converted to grayscale.\n\n    Returns:\n        PIL Image or Tensor: Grayscale version of the input image with probability p and unchanged\n        with probability (1-p).\n        - If input image is 1 channel: grayscale version is 1 channel\n        - If input image is 3 channel: grayscale version is 3 channel with r == g == b\n\n    \"\"\"\n\n    def __init__(self, p=0.1):\n        super().__init__()\n        _log_api_usage_once(self)\n        self.p = p\n\n    def forward(self, img):\n        \"\"\"\n        Args:\n            img (PIL Image or Tensor): Image to be converted to grayscale.\n\n        Returns:\n            PIL Image or Tensor: Randomly grayscaled image.\n        \"\"\"\n        num_output_channels, _, _ = F.get_dimensions(img)\n        if torch.rand(1) < self.p:\n            return F.rgb_to_grayscale(img, num_output_channels=num_output_channels)\n        return img\n\n    def __repr__(self) -> str:\n        return f'{self.__class__.__name__}(p={self.p})'\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass ResidualConnection:\n    '''\n    A utility class for applying residual connections in neural networks.\n        '''\n\n    def __init__(self, use_residual: bool=False):\n        '''\n        Initialize the ResidualConnection.\n        Args:\n            use_residual (bool): If True, apply residual connection.\n        '''\n        pass\n\n    def register(self, x: torch.Tensor):\n        '''\n        Register the input tensor for residual connection.\n        Args:\n            x (torch.Tensor): The input tensor to be registered.\n        '''\n        pass\n\n    def apply(self, y: torch.Tensor) -> torch.Tensor:\n        '''\n        Apply the residual connection.\n        The residual connection is only applied if it was instantiated with `use_residual=True`.\n        Args:\n            y (torch.Tensor): The output tensor to which the residual connection is applied.\n        Returns:\n            torch.Tensor: The output tensor after applying the residual connection.\n        '''\n        pass"
  }
]