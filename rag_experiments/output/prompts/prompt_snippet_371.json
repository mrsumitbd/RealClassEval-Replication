[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass JumpStartMetadataBaseFields(JumpStartDataHolderType):\n    '''Data class JumpStart metadata base fields that can be overridden.'''\n\n    def __init__(self, fields: Dict[str, Any], is_hub_content: Optional[bool]=False):\n        '''Initializes a JumpStartMetadataFields object.\n        Args:\n            fields (Dict[str, Any]): Dictionary representation of metadata fields.\n        '''\n        pass\n\n    def from_json(self, json_obj: Dict[str, Any]) -> None:\n        '''Sets fields in object based on json of header.\n        Args:\n            json_obj (Dict[str, Any]): Dictionary representation of spec.\n        '''\n        pass\n\n    def to_json(self) -> Dict[str, Any]:\n        '''Returns json representation of JumpStartMetadataBaseFields object.'''\n        pass\n\n    def set_hub_content_type(self, hub_content_type: HubContentType) -> None:\n        '''Sets the hub content type.'''\n        pass\nCorresponding class implementation:\n\nfrom typing import Any, Callable, Dict, List, Optional, Set, Union\nfrom copy import deepcopy\nfrom sagemaker.jumpstart.hub.parser_utils import camel_to_snake, walk_and_apply_json\n\nclass JumpStartMetadataBaseFields(JumpStartDataHolderType):\n    \"\"\"Data class JumpStart metadata base fields that can be overridden.\"\"\"\n    __slots__ = ['model_id', 'url', 'version', 'min_sdk_version', 'model_types', 'capabilities', 'incremental_training_supported', 'hosting_ecr_specs', 'hosting_ecr_uri', 'hosting_artifact_uri', 'hosting_artifact_key', 'hosting_script_key', 'training_supported', 'training_ecr_specs', 'training_ecr_uri', 'training_artifact_key', 'training_script_key', 'hyperparameters', 'inference_environment_variables', 'inference_vulnerable', 'inference_dependencies', 'inference_vulnerabilities', 'training_vulnerable', 'training_dependencies', 'training_vulnerabilities', 'deprecated', 'usage_info_message', 'deprecated_message', 'deprecate_warn_message', 'default_inference_instance_type', 'supported_inference_instance_types', 'dynamic_container_deployment_supported', 'hosting_resource_requirements', 'default_training_instance_type', 'supported_training_instance_types', 'metrics', 'training_prepacked_script_key', 'training_prepacked_script_version', 'hosting_prepacked_artifact_key', 'hosting_prepacked_artifact_version', 'model_kwargs', 'deploy_kwargs', 'estimator_kwargs', 'fit_kwargs', 'predictor_specs', 'inference_volume_size', 'training_volume_size', 'inference_enable_network_isolation', 'training_enable_network_isolation', 'resource_name_base', 'hosting_eula_key', 'hosting_model_package_arns', 'training_model_package_artifact_uris', 'hosting_use_script_uri', 'hosting_instance_type_variants', 'training_instance_type_variants', 'default_payloads', 'gated_bucket', 'model_subscription_link', 'hosting_additional_data_sources', 'hosting_neuron_model_id', 'hosting_neuron_model_version', 'hub_content_type', '_is_hub_content', 'default_training_dataset_key', 'default_training_dataset_uri']\n    _non_serializable_slots = ['_is_hub_content']\n\n    def __init__(self, fields: Dict[str, Any], is_hub_content: Optional[bool]=False):\n        \"\"\"Initializes a JumpStartMetadataFields object.\n\n        Args:\n            fields (Dict[str, Any]): Dictionary representation of metadata fields.\n        \"\"\"\n        self._is_hub_content = is_hub_content\n        self.from_json(fields)\n\n    def from_json(self, json_obj: Dict[str, Any]) -> None:\n        \"\"\"Sets fields in object based on json of header.\n\n        Args:\n            json_obj (Dict[str, Any]): Dictionary representation of spec.\n        \"\"\"\n        if self._is_hub_content:\n            json_obj = walk_and_apply_json(json_obj, camel_to_snake)\n        self.model_id: str = json_obj.get('model_id')\n        self.url: str = json_obj.get('url')\n        self.version: str = json_obj.get('version')\n        self.min_sdk_version: str = json_obj.get('min_sdk_version')\n        self.incremental_training_supported: bool = bool(json_obj.get('incremental_training_supported', False))\n        if self._is_hub_content:\n            self.capabilities: Optional[List[str]] = json_obj.get('capabilities')\n            self.model_types: Optional[List[str]] = json_obj.get('model_types')\n            self.hosting_ecr_uri: Optional[str] = json_obj.get('hosting_ecr_uri')\n            self._non_serializable_slots.append('hosting_ecr_specs')\n        else:\n            self.hosting_ecr_specs: Optional[JumpStartECRSpecs] = JumpStartECRSpecs(json_obj['hosting_ecr_specs'], is_hub_content=self._is_hub_content) if 'hosting_ecr_specs' in json_obj else None\n            self._non_serializable_slots.append('hosting_ecr_uri')\n        self.hosting_artifact_key: Optional[str] = json_obj.get('hosting_artifact_key')\n        self.hosting_artifact_uri: Optional[str] = json_obj.get('hosting_artifact_uri')\n        self.hosting_script_key: Optional[str] = json_obj.get('hosting_script_key')\n        self.training_supported: Optional[bool] = bool(json_obj.get('training_supported', False))\n        self.inference_environment_variables = [JumpStartEnvironmentVariable(env_variable, is_hub_content=self._is_hub_content) for env_variable in json_obj.get('inference_environment_variables', [])]\n        self.inference_vulnerable: bool = bool(json_obj.get('inference_vulnerable', False))\n        self.inference_dependencies: List[str] = json_obj.get('inference_dependencies', [])\n        self.inference_vulnerabilities: List[str] = json_obj.get('inference_vulnerabilities', [])\n        self.training_vulnerable: bool = bool(json_obj.get('training_vulnerable', False))\n        self.training_dependencies: List[str] = json_obj.get('training_dependencies', [])\n        self.training_vulnerabilities: List[str] = json_obj.get('training_vulnerabilities', [])\n        self.deprecated: bool = bool(json_obj.get('deprecated', False))\n        self.deprecated_message: Optional[str] = json_obj.get('deprecated_message')\n        self.deprecate_warn_message: Optional[str] = json_obj.get('deprecate_warn_message')\n        self.usage_info_message: Optional[str] = json_obj.get('usage_info_message')\n        self.default_inference_instance_type: Optional[str] = json_obj.get('default_inference_instance_type')\n        self.default_training_instance_type: Optional[str] = json_obj.get('default_training_instance_type')\n        self.supported_inference_instance_types: Optional[List[str]] = json_obj.get('supported_inference_instance_types')\n        self.supported_training_instance_types: Optional[List[str]] = json_obj.get('supported_training_instance_types')\n        self.dynamic_container_deployment_supported: Optional[bool] = bool(json_obj.get('dynamic_container_deployment_supported'))\n        self.hosting_resource_requirements: Optional[Dict[str, int]] = json_obj.get('hosting_resource_requirements', None)\n        self.metrics: Optional[List[Dict[str, str]]] = json_obj.get('metrics', None)\n        self.training_prepacked_script_key: Optional[str] = json_obj.get('training_prepacked_script_key', None)\n        self.hosting_prepacked_artifact_key: Optional[str] = json_obj.get('hosting_prepacked_artifact_key', None)\n        if self._is_hub_content:\n            self.training_prepacked_script_version: Optional[str] = json_obj.get('training_prepacked_script_version')\n            self.hosting_prepacked_artifact_version: Optional[str] = json_obj.get('hosting_prepacked_artifact_version')\n        self.model_kwargs = deepcopy(json_obj.get('model_kwargs', {}))\n        self.deploy_kwargs = deepcopy(json_obj.get('deploy_kwargs', {}))\n        self.predictor_specs: Optional[JumpStartPredictorSpecs] = JumpStartPredictorSpecs(json_obj.get('predictor_specs'), is_hub_content=self._is_hub_content) if json_obj.get('predictor_specs') else None\n        self.default_payloads: Optional[Dict[str, JumpStartSerializablePayload]] = {alias: JumpStartSerializablePayload(payload, is_hub_content=self._is_hub_content) for alias, payload in json_obj['default_payloads'].items()} if json_obj.get('default_payloads') else None\n        self.gated_bucket = json_obj.get('gated_bucket', False)\n        self.inference_volume_size: Optional[int] = json_obj.get('inference_volume_size')\n        self.inference_enable_network_isolation: bool = json_obj.get('inference_enable_network_isolation', False)\n        self.resource_name_base: bool = json_obj.get('resource_name_base')\n        self.hosting_eula_key: Optional[str] = json_obj.get('hosting_eula_key')\n        model_package_arns = json_obj.get('hosting_model_package_arns')\n        self.hosting_model_package_arns: Optional[Dict] = model_package_arns if model_package_arns is not None else {}\n        self.hosting_use_script_uri: bool = json_obj.get('hosting_use_script_uri', True)\n        self.hosting_instance_type_variants: Optional[JumpStartInstanceTypeVariants] = JumpStartInstanceTypeVariants(json_obj['hosting_instance_type_variants'], self._is_hub_content) if json_obj.get('hosting_instance_type_variants') else None\n        self.hosting_additional_data_sources: Optional[JumpStartAdditionalDataSources] = JumpStartAdditionalDataSources(json_obj['hosting_additional_data_sources']) if json_obj.get('hosting_additional_data_sources') else None\n        self.hosting_neuron_model_id: Optional[str] = json_obj.get('hosting_neuron_model_id')\n        self.hosting_neuron_model_version: Optional[str] = json_obj.get('hosting_neuron_model_version')\n        if self.training_supported:\n            if self._is_hub_content:\n                self.training_ecr_uri: Optional[str] = json_obj.get('training_ecr_uri')\n                self._non_serializable_slots.append('training_ecr_specs')\n            else:\n                self.training_ecr_specs: Optional[JumpStartECRSpecs] = JumpStartECRSpecs(json_obj['training_ecr_specs']) if 'training_ecr_specs' in json_obj else None\n                self._non_serializable_slots.append('training_ecr_uri')\n            self.training_artifact_key: str = json_obj['training_artifact_key']\n            self.training_script_key: str = json_obj['training_script_key']\n            hyperparameters: Any = json_obj.get('hyperparameters')\n            self.hyperparameters: List[JumpStartHyperparameter] = []\n            if hyperparameters is not None:\n                self.hyperparameters.extend([JumpStartHyperparameter(hyperparameter, is_hub_content=self._is_hub_content) for hyperparameter in hyperparameters])\n            self.estimator_kwargs = deepcopy(json_obj.get('estimator_kwargs', {}))\n            self.fit_kwargs = deepcopy(json_obj.get('fit_kwargs', {}))\n            self.training_volume_size: Optional[int] = json_obj.get('training_volume_size')\n            self.training_enable_network_isolation: bool = json_obj.get('training_enable_network_isolation', False)\n            self.training_model_package_artifact_uris: Optional[Dict] = json_obj.get('training_model_package_artifact_uris')\n            self.training_instance_type_variants: Optional[JumpStartInstanceTypeVariants] = JumpStartInstanceTypeVariants(json_obj['training_instance_type_variants'], is_hub_content=self._is_hub_content) if json_obj.get('training_instance_type_variants') else None\n        self.model_subscription_link = json_obj.get('model_subscription_link')\n        self.default_training_dataset_key: Optional[str] = json_obj.get('default_training_dataset_key')\n        self.default_training_dataset_uri: Optional[str] = json_obj.get('default_training_dataset_uri')\n\n    def to_json(self) -> Dict[str, Any]:\n        \"\"\"Returns json representation of JumpStartMetadataBaseFields object.\"\"\"\n        json_obj = {}\n        for att in self.__slots__:\n            if hasattr(self, att) and att not in getattr(self, '_non_serializable_slots', []):\n                cur_val = getattr(self, att)\n                if issubclass(type(cur_val), JumpStartDataHolderType):\n                    json_obj[att] = cur_val.to_json()\n                elif isinstance(cur_val, list):\n                    json_obj[att] = []\n                    for obj in cur_val:\n                        if issubclass(type(obj), JumpStartDataHolderType):\n                            json_obj[att].append(obj.to_json())\n                        else:\n                            json_obj[att].append(obj)\n                elif isinstance(cur_val, dict):\n                    json_obj[att] = {}\n                    for key, val in cur_val.items():\n                        if issubclass(type(val), JumpStartDataHolderType):\n                            json_obj[att][key] = val.to_json()\n                        else:\n                            json_obj[att][key] = val\n                else:\n                    json_obj[att] = cur_val\n        return json_obj\n\n    def set_hub_content_type(self, hub_content_type: HubContentType) -> None:\n        \"\"\"Sets the hub content type.\"\"\"\n        if self._is_hub_content:\n            self.hub_content_type = hub_content_type\n\nExample skeleton:\n\n\nclass ScatterPlot(PluginInterface):\n    '''A Scatter Plot Plugin for Feature Sets.'''\n\n    def __init__(self, show_axes: bool=True):\n        '''Initialize the Scatter Plot Plugin\n        Args:\n            show_axes (bool): Whether to show the axes and grid. Default is True.\n        '''\n        pass\n\n    def create_component(self, component_id: str) -> html.Div:\n        '''Create a Dash Graph Component without any data.\n        Args:\n            component_id (str): The ID of the web component.\n        Returns:\n            html.Div: A Dash Div Component containing the graph and dropdowns.\n        '''\n        pass\n\n    def update_properties(self, input_data: pd.DataFrame, **kwargs) -> list:\n        '''Update the property values for the plugin component.\n        Args:\n            input_data (pd.DataFrame): The input data object.\n            **kwargs: Additional keyword arguments (plugins can define their own arguments).\n                      Note: The current kwargs processed are:\n                            - x: The default x-axis column\n                            - y: The default y-axis column\n                            - color: The default color column\n                            - dropdown_columns: The columns to use for the x and y options\n                            - hover_columns: The columns to show when hovering over a point\n                            - suppress_hover_display: Suppress hover display (default: False)\n                            - custom_data: Custom data that get passed to hoverData callbacks\n        Returns:\n            list: A list of updated property values (figure, x options, y options, color options,\n                                                    label options, x default, y default,\n                                                    color default).\n        '''\n        pass\n\n    def create_scatter_plot(self, df: pd.DataFrame, x_col: str, y_col: str, color_col: str, label_col: str, regression_line: bool=False, marker_size: int=15) -> go.Figure:\n        '''Create a Plotly Scatter Plot figure.\n        Args:\n            df (pd.DataFrame): The dataframe containing the data.\n            x_col (str): The column to use for the x-axis.\n            y_col (str): The column to use for the y-axis.\n            color_col (str): The column to use for the color scale.\n            label_col (str): The column to use for point labels.\n            regression_line (bool): Whether to include a regression line.\n            marker_size (int): Size of the markers. Default is 15.\n        Returns:\n            go.Figure: A Plotly Figure object.\n        '''\n        pass\n\n        def generate_hover_text(row):\n                pass\n\n    def register_internal_callbacks(self):\n        '''Register any internal callbacks for the plugin.'''\n        pass\n        @callback(Output(f'{self.component_id}-graph', 'figure', allow_duplicate=True), [Input(f'{self.component_id}-x-dropdown', 'value'), Input(f'{self.component_id}-y-dropdown', 'value'), Input(f'{self.component_id}-color-dropdown', 'value'), Input(f'{self.component_id}-label-dropdown', 'value'), Input(f'{self.component_id}-regression-line', 'value')], prevent_initial_call=True)\n        def _update_scatter_plot(x_value, y_value, color_value, label_value, regression_line):\n                '''Update the Scatter Plot Graph based on the dropdown values.'''\n                pass\n        @callback(Output(f'{self.component_id}-overlay', 'show'), Output(f'{self.component_id}-overlay', 'bbox'), Output(f'{self.component_id}-overlay', 'children'), Input(f'{self.component_id}-graph', 'hoverData'))\n        def _scatter_overlay(hover_data):\n                pass\nCorresponding class implementation:\n\nfrom workbench.utils.theme_manager import ThemeManager\nfrom dash import dcc, html, callback, Input, Output, no_update\nimport plotly.express as px\nimport base64\nimport pandas as pd\nfrom dash.exceptions import PreventUpdate\nfrom workbench.utils.plot_utils import prediction_intervals\nimport plotly.graph_objects as go\nfrom workbench.web_interface.components.plugin_interface import PluginInterface, PluginPage, PluginInputType\n\nclass ScatterPlot(PluginInterface):\n    \"\"\"A Scatter Plot Plugin for Feature Sets.\"\"\"\n    auto_load_page = PluginPage.NONE\n    plugin_input_type = PluginInputType.DATAFRAME\n\n    def __init__(self, show_axes: bool=True):\n        \"\"\"Initialize the Scatter Plot Plugin\n\n        Args:\n            show_axes (bool): Whether to show the axes and grid. Default is True.\n        \"\"\"\n        self.component_id = None\n        self.hover_columns = []\n        self.df = None\n        self.show_axes = show_axes\n        self.theme_manager = ThemeManager()\n        self.colorscale = self.theme_manager.colorscale()\n        super().__init__()\n\n    def create_component(self, component_id: str) -> html.Div:\n        \"\"\"Create a Dash Graph Component without any data.\n\n        Args:\n            component_id (str): The ID of the web component.\n\n        Returns:\n            html.Div: A Dash Div Component containing the graph and dropdowns.\n        \"\"\"\n        self.component_id = component_id\n        self.properties = [(f'{component_id}-graph', 'figure'), (f'{component_id}-x-dropdown', 'options'), (f'{component_id}-y-dropdown', 'options'), (f'{component_id}-color-dropdown', 'options'), (f'{component_id}-label-dropdown', 'options'), (f'{component_id}-x-dropdown', 'value'), (f'{component_id}-y-dropdown', 'value'), (f'{component_id}-color-dropdown', 'value')]\n        self.signals = [(f'{component_id}-graph', 'hoverData'), (f'{component_id}-graph', 'clickData')]\n        return html.Div(children=[dcc.Graph(id=f'{component_id}-graph', figure=self.display_text('Waiting for Data...'), config={'scrollZoom': True}, style={'height': '100%'}, clear_on_unhover=True), html.Div([html.Label('X', style={'marginLeft': '40px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-x-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, clearable=False), html.Label('Y', style={'marginLeft': '30px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-y-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, clearable=False), html.Label('Color', style={'marginLeft': '30px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-color-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, clearable=False), html.Label('Label', style={'marginLeft': '30px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-label-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, options=[{'label': 'None', 'value': 'none'}], value='none', clearable=False), dcc.Checklist(id=f'{component_id}-regression-line', options=[{'label': ' Diagonal', 'value': 'show'}], value=[], style={'margin': '10px'})], style={'padding': '0px 0px 10px 0px', 'display': 'flex', 'gap': '10px'}), dcc.Tooltip(id=f'{component_id}-overlay', background_color='rgba(0,0,0,0)', border_color='rgba(0,0,0,0)', direction='bottom', loading_text='')], style={'height': '100%', 'display': 'flex', 'flexDirection': 'column'})\n\n    def update_properties(self, input_data: pd.DataFrame, **kwargs) -> list:\n        \"\"\"Update the property values for the plugin component.\n\n        Args:\n            input_data (pd.DataFrame): The input data object.\n            **kwargs: Additional keyword arguments (plugins can define their own arguments).\n                      Note: The current kwargs processed are:\n                            - x: The default x-axis column\n                            - y: The default y-axis column\n                            - color: The default color column\n                            - dropdown_columns: The columns to use for the x and y options\n                            - hover_columns: The columns to show when hovering over a point\n                            - suppress_hover_display: Suppress hover display (default: False)\n                            - custom_data: Custom data that get passed to hoverData callbacks\n\n        Returns:\n            list: A list of updated property values (figure, x options, y options, color options,\n                                                    label options, x default, y default,\n                                                    color default).\n        \"\"\"\n        limit = kwargs.get('limit', 20000)\n        if isinstance(input_data, pd.DataFrame):\n            self.df = input_data.sample(n=limit) if len(input_data) > limit else input_data\n        else:\n            raise ValueError('The input data must be a Pandas DataFrame.')\n        aws_cols = ['write_time', 'api_invocation_time', 'is_deleted', 'event_time']\n        self.df = self.df.drop(columns=aws_cols, errors='ignore')\n        self.hover_columns = kwargs.get('hover_columns', self.df.columns.tolist()[:10])\n        self.suppress_hover_display = kwargs.get('suppress_hover_display', False)\n        self.custom_data = kwargs.get('custom_data', [])\n        numeric_columns = self.df.select_dtypes(include='number').columns.tolist()\n        if len(numeric_columns) < 3:\n            raise ValueError('At least three numeric columns are required for x, y, and color.')\n        x_default = kwargs.get('x', numeric_columns[0])\n        y_default = kwargs.get('y', numeric_columns[1])\n        color_default = kwargs.get('color', numeric_columns[2])\n        regression_line = kwargs.get('regression_line', False)\n        figure = self.create_scatter_plot(self.df, x_default, y_default, color_default, 'none', regression_line)\n        dropdown_columns = kwargs.get('dropdown_columns', numeric_columns)\n        x_options = [{'label': col, 'value': col} for col in dropdown_columns]\n        y_options = x_options.copy()\n        cat_columns = self.df.select_dtypes(include=['object', 'string', 'category']).columns.tolist()\n        cat_columns = [col for col in cat_columns if self.df[col].astype(str).nunique() < 20]\n        color_columns = numeric_columns + cat_columns\n        color_options = [{'label': col, 'value': col} for col in color_columns]\n        label_options = [{'label': 'None', 'value': 'none'}]\n        label_options.extend([{'label': col, 'value': col} for col in self.df.columns])\n        return [figure, x_options, y_options, color_options, label_options, x_default, y_default, color_default]\n\n    def create_scatter_plot(self, df: pd.DataFrame, x_col: str, y_col: str, color_col: str, label_col: str, regression_line: bool=False, marker_size: int=15) -> go.Figure:\n        \"\"\"Create a Plotly Scatter Plot figure.\n\n        Args:\n            df (pd.DataFrame): The dataframe containing the data.\n            x_col (str): The column to use for the x-axis.\n            y_col (str): The column to use for the y-axis.\n            color_col (str): The column to use for the color scale.\n            label_col (str): The column to use for point labels.\n            regression_line (bool): Whether to include a regression line.\n            marker_size (int): Size of the markers. Default is 15.\n\n        Returns:\n            go.Figure: A Plotly Figure object.\n        \"\"\"\n        show_labels = label_col != 'none' and len(df) < 1000\n\n        def generate_hover_text(row):\n            return '<br>'.join([f'{col}: {row[col]}' for col in self.hover_columns])\n        hovertext = df.apply(generate_hover_text, axis=1)\n        hovertemplate = '%{hovertext}<extra></extra>'\n        hoverinfo = 'none' if self.suppress_hover_display else None\n        if pd.api.types.is_numeric_dtype(df[color_col]):\n            marker_color = df[color_col]\n            colorbar = dict(title=color_col, thickness=10)\n            data = [go.Scattergl(x=df[x_col], y=df[y_col], mode='markers', text=df[label_col].astype(str) if show_labels else None, textposition='top center', hoverinfo=hoverinfo, hovertext=hovertext, hovertemplate=hovertemplate, customdata=df[self.custom_data], marker=dict(size=marker_size, color=marker_color, colorscale=self.colorscale, colorbar=colorbar, opacity=0.8, line=dict(color='rgba(0,0,0,0.25)', width=1)))]\n            showlegend = False\n        else:\n            categories = sorted(df[color_col].astype(str).unique())\n            discrete_colors = px.colors.qualitative.Plotly\n            data = []\n            for i, cat in enumerate(categories):\n                sub_df = df[df[color_col] == cat]\n                sub_hovertext = hovertext.loc[sub_df.index]\n                trace = go.Scattergl(x=sub_df[x_col], y=sub_df[y_col], mode='markers', text=sub_df[label_col] if show_labels else None, textposition='top center', name=cat, hoverinfo=hoverinfo, hovertext=sub_hovertext, hovertemplate=hovertemplate, customdata=sub_df[self.custom_data], marker=dict(size=marker_size, color=discrete_colors[i % len(discrete_colors)], opacity=0.8, line=dict(color='rgba(0,0,0,0.25)', width=1)))\n                data.append(trace)\n            showlegend = True\n        figure = go.Figure()\n        if y_col == 'prediction' or x_col == 'prediction':\n            figure = prediction_intervals(df, figure, x_col)\n        if regression_line:\n            axis_min = min(df[x_col].min(), df[y_col].min())\n            axis_max = max(df[x_col].max(), df[y_col].max())\n            figure.add_shape(type='line', line=dict(width=4, color='rgba(128, 128, 128, 1.0)'), x0=axis_min, x1=axis_max, y0=axis_min, y1=axis_max)\n        figure.add_traces(data)\n        if self.show_axes:\n            xaxis = dict(title=dict(text=x_col, font=dict(size=16), standoff=15), tickformat='.2f', tickfont=dict(size=10))\n            yaxis = dict(title=dict(text=y_col, font=dict(size=16), standoff=25), tickformat='.2f', tickfont=dict(size=10))\n        else:\n            xaxis = dict(visible=False)\n            yaxis = dict(visible=False)\n        figure.update_layout(margin={'t': 20, 'b': 55, 'r': 0, 'l': 35, 'pad': 0}, xaxis=xaxis, yaxis=yaxis, showlegend=showlegend, dragmode='pan', modebar={'bgcolor': 'rgba(0, 0, 0, 0)'}, uirevision='constant')\n        return figure\n\n    def register_internal_callbacks(self):\n        \"\"\"Register any internal callbacks for the plugin.\"\"\"\n\n        @callback(Output(f'{self.component_id}-graph', 'figure', allow_duplicate=True), [Input(f'{self.component_id}-x-dropdown', 'value'), Input(f'{self.component_id}-y-dropdown', 'value'), Input(f'{self.component_id}-color-dropdown', 'value'), Input(f'{self.component_id}-label-dropdown', 'value'), Input(f'{self.component_id}-regression-line', 'value')], prevent_initial_call=True)\n        def _update_scatter_plot(x_value, y_value, color_value, label_value, regression_line):\n            \"\"\"Update the Scatter Plot Graph based on the dropdown values.\"\"\"\n            if not self.df.empty and x_value and y_value and color_value:\n                figure = self.create_scatter_plot(self.df, x_value, y_value, color_value, label_value, regression_line)\n                return figure\n            raise PreventUpdate\n\n        @callback(Output(f'{self.component_id}-overlay', 'show'), Output(f'{self.component_id}-overlay', 'bbox'), Output(f'{self.component_id}-overlay', 'children'), Input(f'{self.component_id}-graph', 'hoverData'))\n        def _scatter_overlay(hover_data):\n            if hover_data is None:\n                return (False, no_update, no_update)\n            bbox = hover_data['points'][0]['bbox']\n            svg = '\\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\" style=\"overflow: visible;\">\\n                <!-- Circle for the node -->\\n                <circle cx=\"50\" cy=\"50\" r=\"10\" stroke=\"rgba(255, 255, 255, 1)\" stroke-width=\"3\" fill=\"none\" />\\n            </svg>\\n            '\n            encoded_svg = base64.b64encode(svg.encode('utf-8')).decode('utf-8')\n            data_uri = f'data:image/svg+xml;base64,{encoded_svg}'\n            svg_image = html.Img(src=data_uri, style={'width': '100px', 'height': '100px'})\n            center_x = (bbox['x0'] + bbox['x1']) / 2\n            center_y = (bbox['y0'] + bbox['y1']) / 2\n            adjusted_bbox = {'x0': center_x - 50, 'x1': center_x + 50, 'y0': center_y - 162, 'y1': center_y - 62}\n            return (True, adjusted_bbox, [svg_image])\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\nclass WorkflowDefinition:\n    '''Simple container for workflow data.'''\n\n    def __init__(self, name, file_path, metadata, content):\n        '''Initialize a workflow definition.\n        Args:\n            name (str): Name of the workflow.\n            file_path (str): Path to the workflow file.\n            metadata (dict): Metadata from the frontmatter.\n            content (str): Content of the workflow file.\n        '''\n        pass\n\n    def validate(self):\n        '''Basic validation of required fields.\n        Returns:\n            list: List of validation errors.\n        '''\n        pass"
  }
]