[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass VAO:\n    '''\n    Represents a vertex array object.\n    This is a wrapper class over ``moderngl.VertexArray`` to provide helper method.\n    The main purpose is to provide render methods taking a program as parameter.\n    The class will auto detect the programs attributes and add padding when needed\n    to match the vertex object.\n    A new vertexbuffer object is created and stored internally for each unique\n    shader program used.\n    A secondary purpose is to provide an alternate way to build vertexbuffers\n    This can be practical when loading or creating various geometry.\n    There is no requirements to use this class, but most methods in the\n    system creating vertexbuffers will return this type. You can obtain\n    a single vertexbuffer instance by calling :py:meth:`VAO.instance`\n    method if you prefer to work directly on moderngl instances.\n    '''\n\n    def __init__(self, name='', mode=moderngl.TRIANGLES):\n        '''\n        Create and empty VAO\n        Keyword Args:\n            name (str): The name for debug purposes\n            mode (int): Default draw mode\n        '''\n        pass\n\n    def render(self, program: moderngl.Program, mode=None, vertices=-1, first=0, instances=1):\n        '''\n        Render the VAO.\n        Args:\n            program: The ``moderngl.Program``\n        Keyword Args:\n            mode: Override the draw mode (``TRIANGLES`` etc)\n            vertices (int): The number of vertices to transform\n            first (int): The index of the first vertex to start with\n            instances (int): The number of instances\n        '''\n        pass\n\n    def render_indirect(self, program: moderngl.Program, buffer, mode=None, count=-1, *, first=0):\n        '''\n        The render primitive (mode) must be the same as the input primitive of the GeometryShader.\n        The draw commands are 5 integers: (count, instanceCount, firstIndex, baseVertex, baseInstance).\n        Args:\n            program: The ``moderngl.Program``\n            buffer: The ``moderngl.Buffer`` containing indirect draw commands\n        Keyword Args:\n            mode (int): By default :py:data:`TRIANGLES` will be used.\n            count (int): The number of draws.\n            first (int): The index of the first indirect draw command.\n        '''\n        pass\n\n    def transform(self, program: moderngl.Program, buffer: moderngl.Buffer, mode=None, vertices=-1, first=0, instances=1):\n        '''\n        Transform vertices. Stores the output in a single buffer.\n        Args:\n            program: The ``moderngl.Program``\n            buffer: The ``moderngl.buffer`` to store the output\n        Keyword Args:\n            mode: Draw mode (for example ``moderngl.POINTS``)\n            vertices (int): The number of vertices to transform\n            first (int): The index of the first vertex to start with\n            instances (int): The number of instances\n        '''\n        pass\n\n    def buffer(self, buffer, buffer_format: str, attribute_names, per_instance=False):\n        '''\n        Register a buffer/vbo for the VAO. This can be called multiple times.\n        adding multiple buffers (interleaved or not)\n        Args:\n            buffer: The buffer data. Can be ``numpy.array``, ``moderngl.Buffer`` or ``bytes``.\n            buffer_format (str): The format of the buffer. (eg. ``3f 3f`` for interleaved positions and normals).\n            attribute_names: A list of attribute names this buffer should map to.\n        Keyword Args:\n            per_instance (bool): Is this buffer per instance data for instanced rendering?\n        Returns:\n            The ``moderngl.Buffer`` instance object. This is handy when providing ``bytes`` and ``numpy.array``.\n        '''\n        pass\n\n    def index_buffer(self, buffer, index_element_size=4):\n        '''\n        Set the index buffer for this VAO\n        Args:\n            buffer: ``moderngl.Buffer``, ``numpy.array`` or ``bytes``\n        Keyword Args:\n            index_element_size (int): Byte size of each element. 1, 2 or 4\n        '''\n        pass\n\n    def instance(self, program: moderngl.Program) -> moderngl.VertexArray:\n        '''\n        Obtain the ``moderngl.VertexArray`` instance for the program.\n        The instance is only created once and cached internally.\n        Returns: ``moderngl.VertexArray`` instance\n        '''\n        pass\n\n    def release(self, buffer=True):\n        '''\n        Destroy the vao object\n        Keyword Args:\n            buffers (bool): also release buffers\n        '''\n        pass\nCorresponding class implementation:\n\nimport numpy\nimport moderngl\nfrom demosys import context\n\nclass VAO:\n    \"\"\"\n    Represents a vertex array object.\n    This is a wrapper class over ``moderngl.VertexArray`` to provide helper method.\n\n    The main purpose is to provide render methods taking a program as parameter.\n    The class will auto detect the programs attributes and add padding when needed\n    to match the vertex object.\n    A new vertexbuffer object is created and stored internally for each unique\n    shader program used.\n\n    A secondary purpose is to provide an alternate way to build vertexbuffers\n    This can be practical when loading or creating various geometry.\n\n    There is no requirements to use this class, but most methods in the\n    system creating vertexbuffers will return this type. You can obtain\n    a single vertexbuffer instance by calling :py:meth:`VAO.instance`\n    method if you prefer to work directly on moderngl instances.\n    \"\"\"\n\n    def __init__(self, name='', mode=moderngl.TRIANGLES):\n        \"\"\"\n        Create and empty VAO\n\n        Keyword Args:\n            name (str): The name for debug purposes\n            mode (int): Default draw mode\n        \"\"\"\n        self.ctx = context.ctx()\n        self.name = name\n        self.mode = mode\n        try:\n            DRAW_MODES[self.mode]\n        except KeyError:\n            raise VAOError('Invalid draw mode. Options are {}'.format(DRAW_MODES.values()))\n        self.buffers = []\n        self._index_buffer = None\n        self._index_element_size = None\n        self.vertex_count = 0\n        self.vaos = {}\n\n    def render(self, program: moderngl.Program, mode=None, vertices=-1, first=0, instances=1):\n        \"\"\"\n        Render the VAO.\n\n        Args:\n            program: The ``moderngl.Program``\n\n        Keyword Args:\n            mode: Override the draw mode (``TRIANGLES`` etc)\n            vertices (int): The number of vertices to transform\n            first (int): The index of the first vertex to start with\n            instances (int): The number of instances\n        \"\"\"\n        vao = self.instance(program)\n        if mode is None:\n            mode = self.mode\n        vao.render(mode, vertices=vertices, first=first, instances=instances)\n\n    def render_indirect(self, program: moderngl.Program, buffer, mode=None, count=-1, *, first=0):\n        \"\"\"\n        The render primitive (mode) must be the same as the input primitive of the GeometryShader.\n        The draw commands are 5 integers: (count, instanceCount, firstIndex, baseVertex, baseInstance).\n\n        Args:\n            program: The ``moderngl.Program``\n            buffer: The ``moderngl.Buffer`` containing indirect draw commands\n\n        Keyword Args:\n            mode (int): By default :py:data:`TRIANGLES` will be used.\n            count (int): The number of draws.\n            first (int): The index of the first indirect draw command.\n        \"\"\"\n        vao = self.instance(program)\n        if mode is None:\n            mode = self.mode\n        vao.render_indirect(buffer, mode=mode, count=count, first=first)\n\n    def transform(self, program: moderngl.Program, buffer: moderngl.Buffer, mode=None, vertices=-1, first=0, instances=1):\n        \"\"\"\n        Transform vertices. Stores the output in a single buffer.\n\n        Args:\n            program: The ``moderngl.Program``\n            buffer: The ``moderngl.buffer`` to store the output\n\n        Keyword Args:\n            mode: Draw mode (for example ``moderngl.POINTS``)\n            vertices (int): The number of vertices to transform\n            first (int): The index of the first vertex to start with\n            instances (int): The number of instances\n        \"\"\"\n        vao = self.instance(program)\n        if mode is None:\n            mode = self.mode\n        vao.transform(buffer, mode=mode, vertices=vertices, first=first, instances=instances)\n\n    def buffer(self, buffer, buffer_format: str, attribute_names, per_instance=False):\n        \"\"\"\n        Register a buffer/vbo for the VAO. This can be called multiple times.\n        adding multiple buffers (interleaved or not)\n\n        Args:\n            buffer: The buffer data. Can be ``numpy.array``, ``moderngl.Buffer`` or ``bytes``.\n            buffer_format (str): The format of the buffer. (eg. ``3f 3f`` for interleaved positions and normals).\n            attribute_names: A list of attribute names this buffer should map to.\n\n        Keyword Args:\n            per_instance (bool): Is this buffer per instance data for instanced rendering?\n\n        Returns:\n            The ``moderngl.Buffer`` instance object. This is handy when providing ``bytes`` and ``numpy.array``.\n        \"\"\"\n        if not isinstance(attribute_names, list):\n            attribute_names = [attribute_names]\n        if not type(buffer) in [moderngl.Buffer, numpy.ndarray, bytes]:\n            raise VAOError('buffer parameter must be a moderngl.Buffer, numpy.ndarray or bytes instance(not {})'.format(type(buffer)))\n        if isinstance(buffer, numpy.ndarray):\n            buffer = self.ctx.buffer(buffer.tobytes())\n        if isinstance(buffer, bytes):\n            buffer = self.ctx.buffer(data=buffer)\n        formats = buffer_format.split()\n        if len(formats) != len(attribute_names):\n            raise VAOError(\"Format '{}' does not describe attributes {}\".format(buffer_format, attribute_names))\n        self.buffers.append(BufferInfo(buffer, buffer_format, attribute_names, per_instance=per_instance))\n        self.vertex_count = self.buffers[-1].vertices\n        return buffer\n\n    def index_buffer(self, buffer, index_element_size=4):\n        \"\"\"\n        Set the index buffer for this VAO\n\n        Args:\n            buffer: ``moderngl.Buffer``, ``numpy.array`` or ``bytes``\n\n        Keyword Args:\n            index_element_size (int): Byte size of each element. 1, 2 or 4\n        \"\"\"\n        if not type(buffer) in [moderngl.Buffer, numpy.ndarray, bytes]:\n            raise VAOError('buffer parameter must be a moderngl.Buffer, numpy.ndarray or bytes instance')\n        if isinstance(buffer, numpy.ndarray):\n            buffer = self.ctx.buffer(buffer.tobytes())\n        if isinstance(buffer, bytes):\n            buffer = self.ctx.buffer(data=buffer)\n        self._index_buffer = buffer\n        self._index_element_size = index_element_size\n\n    def instance(self, program: moderngl.Program) -> moderngl.VertexArray:\n        \"\"\"\n        Obtain the ``moderngl.VertexArray`` instance for the program.\n        The instance is only created once and cached internally.\n\n        Returns: ``moderngl.VertexArray`` instance\n        \"\"\"\n        vao = self.vaos.get(program.glo)\n        if vao:\n            return vao\n        program_attributes = [name for name, attr in program._members.items() if isinstance(attr, moderngl.Attribute)]\n        for attrib_name in program_attributes:\n            if attrib_name.startswith('gl_'):\n                continue\n            if not sum((buffer.has_attribute(attrib_name) for buffer in self.buffers)):\n                raise VAOError(\"VAO {} doesn't have attribute {} for program {}\".format(self.name, attrib_name, program.name))\n        vao_content = []\n        for buffer in self.buffers:\n            content = buffer.content(program_attributes)\n            if content:\n                vao_content.append(content)\n        if program_attributes:\n            for attrib_name in program_attributes:\n                if attrib_name.startswith('gl_'):\n                    continue\n                raise VAOError('Did not find a buffer mapping for {}'.format([n for n in program_attributes]))\n        if self._index_buffer:\n            vao = context.ctx().vertex_array(program, vao_content, self._index_buffer, self._index_element_size)\n        else:\n            vao = context.ctx().vertex_array(program, vao_content)\n        self.vaos[program.glo] = vao\n        return vao\n\n    def release(self, buffer=True):\n        \"\"\"\n        Destroy the vao object\n\n        Keyword Args:\n            buffers (bool): also release buffers\n        \"\"\"\n        for key, vao in self.vaos:\n            vao.release()\n        if buffer:\n            for buff in self.buffers:\n                buff.buffer.release()\n            if self._index_buffer:\n                self._index_buffer.release()\n\nExample skeleton:\n\n\nclass ScatterPlot(PluginInterface):\n    '''A Scatter Plot Plugin for Feature Sets.'''\n\n    def __init__(self, show_axes: bool=True):\n        '''Initialize the Scatter Plot Plugin\n        Args:\n            show_axes (bool): Whether to show the axes and grid. Default is True.\n        '''\n        pass\n\n    def create_component(self, component_id: str) -> html.Div:\n        '''Create a Dash Graph Component without any data.\n        Args:\n            component_id (str): The ID of the web component.\n        Returns:\n            html.Div: A Dash Div Component containing the graph and dropdowns.\n        '''\n        pass\n\n    def update_properties(self, input_data: pd.DataFrame, **kwargs) -> list:\n        '''Update the property values for the plugin component.\n        Args:\n            input_data (pd.DataFrame): The input data object.\n            **kwargs: Additional keyword arguments (plugins can define their own arguments).\n                      Note: The current kwargs processed are:\n                            - x: The default x-axis column\n                            - y: The default y-axis column\n                            - color: The default color column\n                            - dropdown_columns: The columns to use for the x and y options\n                            - hover_columns: The columns to show when hovering over a point\n                            - suppress_hover_display: Suppress hover display (default: False)\n                            - custom_data: Custom data that get passed to hoverData callbacks\n        Returns:\n            list: A list of updated property values (figure, x options, y options, color options,\n                                                    label options, x default, y default,\n                                                    color default).\n        '''\n        pass\n\n    def create_scatter_plot(self, df: pd.DataFrame, x_col: str, y_col: str, color_col: str, label_col: str, regression_line: bool=False, marker_size: int=15) -> go.Figure:\n        '''Create a Plotly Scatter Plot figure.\n        Args:\n            df (pd.DataFrame): The dataframe containing the data.\n            x_col (str): The column to use for the x-axis.\n            y_col (str): The column to use for the y-axis.\n            color_col (str): The column to use for the color scale.\n            label_col (str): The column to use for point labels.\n            regression_line (bool): Whether to include a regression line.\n            marker_size (int): Size of the markers. Default is 15.\n        Returns:\n            go.Figure: A Plotly Figure object.\n        '''\n        pass\n\n        def generate_hover_text(row):\n                pass\n\n    def register_internal_callbacks(self):\n        '''Register any internal callbacks for the plugin.'''\n        pass\n        @callback(Output(f'{self.component_id}-graph', 'figure', allow_duplicate=True), [Input(f'{self.component_id}-x-dropdown', 'value'), Input(f'{self.component_id}-y-dropdown', 'value'), Input(f'{self.component_id}-color-dropdown', 'value'), Input(f'{self.component_id}-label-dropdown', 'value'), Input(f'{self.component_id}-regression-line', 'value')], prevent_initial_call=True)\n        def _update_scatter_plot(x_value, y_value, color_value, label_value, regression_line):\n                '''Update the Scatter Plot Graph based on the dropdown values.'''\n                pass\n        @callback(Output(f'{self.component_id}-overlay', 'show'), Output(f'{self.component_id}-overlay', 'bbox'), Output(f'{self.component_id}-overlay', 'children'), Input(f'{self.component_id}-graph', 'hoverData'))\n        def _scatter_overlay(hover_data):\n                pass\nCorresponding class implementation:\n\nfrom workbench.utils.theme_manager import ThemeManager\nfrom dash import dcc, html, callback, Input, Output, no_update\nimport plotly.express as px\nimport base64\nimport pandas as pd\nfrom dash.exceptions import PreventUpdate\nfrom workbench.utils.plot_utils import prediction_intervals\nimport plotly.graph_objects as go\nfrom workbench.web_interface.components.plugin_interface import PluginInterface, PluginPage, PluginInputType\n\nclass ScatterPlot(PluginInterface):\n    \"\"\"A Scatter Plot Plugin for Feature Sets.\"\"\"\n    auto_load_page = PluginPage.NONE\n    plugin_input_type = PluginInputType.DATAFRAME\n\n    def __init__(self, show_axes: bool=True):\n        \"\"\"Initialize the Scatter Plot Plugin\n\n        Args:\n            show_axes (bool): Whether to show the axes and grid. Default is True.\n        \"\"\"\n        self.component_id = None\n        self.hover_columns = []\n        self.df = None\n        self.show_axes = show_axes\n        self.theme_manager = ThemeManager()\n        self.colorscale = self.theme_manager.colorscale()\n        super().__init__()\n\n    def create_component(self, component_id: str) -> html.Div:\n        \"\"\"Create a Dash Graph Component without any data.\n\n        Args:\n            component_id (str): The ID of the web component.\n\n        Returns:\n            html.Div: A Dash Div Component containing the graph and dropdowns.\n        \"\"\"\n        self.component_id = component_id\n        self.properties = [(f'{component_id}-graph', 'figure'), (f'{component_id}-x-dropdown', 'options'), (f'{component_id}-y-dropdown', 'options'), (f'{component_id}-color-dropdown', 'options'), (f'{component_id}-label-dropdown', 'options'), (f'{component_id}-x-dropdown', 'value'), (f'{component_id}-y-dropdown', 'value'), (f'{component_id}-color-dropdown', 'value')]\n        self.signals = [(f'{component_id}-graph', 'hoverData'), (f'{component_id}-graph', 'clickData')]\n        return html.Div(children=[dcc.Graph(id=f'{component_id}-graph', figure=self.display_text('Waiting for Data...'), config={'scrollZoom': True}, style={'height': '100%'}, clear_on_unhover=True), html.Div([html.Label('X', style={'marginLeft': '40px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-x-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, clearable=False), html.Label('Y', style={'marginLeft': '30px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-y-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, clearable=False), html.Label('Color', style={'marginLeft': '30px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-color-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, clearable=False), html.Label('Label', style={'marginLeft': '30px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-label-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, options=[{'label': 'None', 'value': 'none'}], value='none', clearable=False), dcc.Checklist(id=f'{component_id}-regression-line', options=[{'label': ' Diagonal', 'value': 'show'}], value=[], style={'margin': '10px'})], style={'padding': '0px 0px 10px 0px', 'display': 'flex', 'gap': '10px'}), dcc.Tooltip(id=f'{component_id}-overlay', background_color='rgba(0,0,0,0)', border_color='rgba(0,0,0,0)', direction='bottom', loading_text='')], style={'height': '100%', 'display': 'flex', 'flexDirection': 'column'})\n\n    def update_properties(self, input_data: pd.DataFrame, **kwargs) -> list:\n        \"\"\"Update the property values for the plugin component.\n\n        Args:\n            input_data (pd.DataFrame): The input data object.\n            **kwargs: Additional keyword arguments (plugins can define their own arguments).\n                      Note: The current kwargs processed are:\n                            - x: The default x-axis column\n                            - y: The default y-axis column\n                            - color: The default color column\n                            - dropdown_columns: The columns to use for the x and y options\n                            - hover_columns: The columns to show when hovering over a point\n                            - suppress_hover_display: Suppress hover display (default: False)\n                            - custom_data: Custom data that get passed to hoverData callbacks\n\n        Returns:\n            list: A list of updated property values (figure, x options, y options, color options,\n                                                    label options, x default, y default,\n                                                    color default).\n        \"\"\"\n        limit = kwargs.get('limit', 20000)\n        if isinstance(input_data, pd.DataFrame):\n            self.df = input_data.sample(n=limit) if len(input_data) > limit else input_data\n        else:\n            raise ValueError('The input data must be a Pandas DataFrame.')\n        aws_cols = ['write_time', 'api_invocation_time', 'is_deleted', 'event_time']\n        self.df = self.df.drop(columns=aws_cols, errors='ignore')\n        self.hover_columns = kwargs.get('hover_columns', self.df.columns.tolist()[:10])\n        self.suppress_hover_display = kwargs.get('suppress_hover_display', False)\n        self.custom_data = kwargs.get('custom_data', [])\n        numeric_columns = self.df.select_dtypes(include='number').columns.tolist()\n        if len(numeric_columns) < 3:\n            raise ValueError('At least three numeric columns are required for x, y, and color.')\n        x_default = kwargs.get('x', numeric_columns[0])\n        y_default = kwargs.get('y', numeric_columns[1])\n        color_default = kwargs.get('color', numeric_columns[2])\n        regression_line = kwargs.get('regression_line', False)\n        figure = self.create_scatter_plot(self.df, x_default, y_default, color_default, 'none', regression_line)\n        dropdown_columns = kwargs.get('dropdown_columns', numeric_columns)\n        x_options = [{'label': col, 'value': col} for col in dropdown_columns]\n        y_options = x_options.copy()\n        cat_columns = self.df.select_dtypes(include=['object', 'string', 'category']).columns.tolist()\n        cat_columns = [col for col in cat_columns if self.df[col].astype(str).nunique() < 20]\n        color_columns = numeric_columns + cat_columns\n        color_options = [{'label': col, 'value': col} for col in color_columns]\n        label_options = [{'label': 'None', 'value': 'none'}]\n        label_options.extend([{'label': col, 'value': col} for col in self.df.columns])\n        return [figure, x_options, y_options, color_options, label_options, x_default, y_default, color_default]\n\n    def create_scatter_plot(self, df: pd.DataFrame, x_col: str, y_col: str, color_col: str, label_col: str, regression_line: bool=False, marker_size: int=15) -> go.Figure:\n        \"\"\"Create a Plotly Scatter Plot figure.\n\n        Args:\n            df (pd.DataFrame): The dataframe containing the data.\n            x_col (str): The column to use for the x-axis.\n            y_col (str): The column to use for the y-axis.\n            color_col (str): The column to use for the color scale.\n            label_col (str): The column to use for point labels.\n            regression_line (bool): Whether to include a regression line.\n            marker_size (int): Size of the markers. Default is 15.\n\n        Returns:\n            go.Figure: A Plotly Figure object.\n        \"\"\"\n        show_labels = label_col != 'none' and len(df) < 1000\n\n        def generate_hover_text(row):\n            return '<br>'.join([f'{col}: {row[col]}' for col in self.hover_columns])\n        hovertext = df.apply(generate_hover_text, axis=1)\n        hovertemplate = '%{hovertext}<extra></extra>'\n        hoverinfo = 'none' if self.suppress_hover_display else None\n        if pd.api.types.is_numeric_dtype(df[color_col]):\n            marker_color = df[color_col]\n            colorbar = dict(title=color_col, thickness=10)\n            data = [go.Scattergl(x=df[x_col], y=df[y_col], mode='markers', text=df[label_col].astype(str) if show_labels else None, textposition='top center', hoverinfo=hoverinfo, hovertext=hovertext, hovertemplate=hovertemplate, customdata=df[self.custom_data], marker=dict(size=marker_size, color=marker_color, colorscale=self.colorscale, colorbar=colorbar, opacity=0.8, line=dict(color='rgba(0,0,0,0.25)', width=1)))]\n            showlegend = False\n        else:\n            categories = sorted(df[color_col].astype(str).unique())\n            discrete_colors = px.colors.qualitative.Plotly\n            data = []\n            for i, cat in enumerate(categories):\n                sub_df = df[df[color_col] == cat]\n                sub_hovertext = hovertext.loc[sub_df.index]\n                trace = go.Scattergl(x=sub_df[x_col], y=sub_df[y_col], mode='markers', text=sub_df[label_col] if show_labels else None, textposition='top center', name=cat, hoverinfo=hoverinfo, hovertext=sub_hovertext, hovertemplate=hovertemplate, customdata=sub_df[self.custom_data], marker=dict(size=marker_size, color=discrete_colors[i % len(discrete_colors)], opacity=0.8, line=dict(color='rgba(0,0,0,0.25)', width=1)))\n                data.append(trace)\n            showlegend = True\n        figure = go.Figure()\n        if y_col == 'prediction' or x_col == 'prediction':\n            figure = prediction_intervals(df, figure, x_col)\n        if regression_line:\n            axis_min = min(df[x_col].min(), df[y_col].min())\n            axis_max = max(df[x_col].max(), df[y_col].max())\n            figure.add_shape(type='line', line=dict(width=4, color='rgba(128, 128, 128, 1.0)'), x0=axis_min, x1=axis_max, y0=axis_min, y1=axis_max)\n        figure.add_traces(data)\n        if self.show_axes:\n            xaxis = dict(title=dict(text=x_col, font=dict(size=16), standoff=15), tickformat='.2f', tickfont=dict(size=10))\n            yaxis = dict(title=dict(text=y_col, font=dict(size=16), standoff=25), tickformat='.2f', tickfont=dict(size=10))\n        else:\n            xaxis = dict(visible=False)\n            yaxis = dict(visible=False)\n        figure.update_layout(margin={'t': 20, 'b': 55, 'r': 0, 'l': 35, 'pad': 0}, xaxis=xaxis, yaxis=yaxis, showlegend=showlegend, dragmode='pan', modebar={'bgcolor': 'rgba(0, 0, 0, 0)'}, uirevision='constant')\n        return figure\n\n    def register_internal_callbacks(self):\n        \"\"\"Register any internal callbacks for the plugin.\"\"\"\n\n        @callback(Output(f'{self.component_id}-graph', 'figure', allow_duplicate=True), [Input(f'{self.component_id}-x-dropdown', 'value'), Input(f'{self.component_id}-y-dropdown', 'value'), Input(f'{self.component_id}-color-dropdown', 'value'), Input(f'{self.component_id}-label-dropdown', 'value'), Input(f'{self.component_id}-regression-line', 'value')], prevent_initial_call=True)\n        def _update_scatter_plot(x_value, y_value, color_value, label_value, regression_line):\n            \"\"\"Update the Scatter Plot Graph based on the dropdown values.\"\"\"\n            if not self.df.empty and x_value and y_value and color_value:\n                figure = self.create_scatter_plot(self.df, x_value, y_value, color_value, label_value, regression_line)\n                return figure\n            raise PreventUpdate\n\n        @callback(Output(f'{self.component_id}-overlay', 'show'), Output(f'{self.component_id}-overlay', 'bbox'), Output(f'{self.component_id}-overlay', 'children'), Input(f'{self.component_id}-graph', 'hoverData'))\n        def _scatter_overlay(hover_data):\n            if hover_data is None:\n                return (False, no_update, no_update)\n            bbox = hover_data['points'][0]['bbox']\n            svg = '\\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\" style=\"overflow: visible;\">\\n                <!-- Circle for the node -->\\n                <circle cx=\"50\" cy=\"50\" r=\"10\" stroke=\"rgba(255, 255, 255, 1)\" stroke-width=\"3\" fill=\"none\" />\\n            </svg>\\n            '\n            encoded_svg = base64.b64encode(svg.encode('utf-8')).decode('utf-8')\n            data_uri = f'data:image/svg+xml;base64,{encoded_svg}'\n            svg_image = html.Img(src=data_uri, style={'width': '100px', 'height': '100px'})\n            center_x = (bbox['x0'] + bbox['x1']) / 2\n            center_y = (bbox['y0'] + bbox['y1']) / 2\n            adjusted_bbox = {'x0': center_x - 50, 'x1': center_x + 50, 'y0': center_y - 162, 'y1': center_y - 62}\n            return (True, adjusted_bbox, [svg_image])\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass LetterBox:\n    '''\n    Resize image and padding for detection, instance segmentation, pose.\n    This class resizes and pads images to a specified shape while preserving aspect ratio. It also updates\n    corresponding labels and bounding boxes.\n    Attributes:\n        new_shape (tuple): Target shape (height, width) for resizing.\n        auto (bool): Whether to use minimum rectangle.\n        scaleFill (bool): Whether to stretch the image to new_shape.\n        scaleup (bool): Whether to allow scaling up. If False, only scale down.\n        stride (int): Stride for rounding padding.\n        center (bool): Whether to center the image or align to top-left.\n    Methods:\n        __call__: Resize and pad image, update labels and bounding boxes.\n    Examples:\n        >>> transform = LetterBox(new_shape=(640, 640))\n        >>> result = transform(labels)\n        >>> resized_img = result[\"img\"]\n        >>> updated_instances = result[\"instances\"]\n    '''\n\n    def __init__(self, new_shape=(640, 640), auto=False, scaleFill=False, scaleup=True, center=True, stride=32):\n        '''\n        Initialize LetterBox object for resizing and padding images.\n        This class is designed to resize and pad images for object detection, instance segmentation, and pose estimation\n        tasks. It supports various resizing modes including auto-sizing, scale-fill, and letterboxing.\n        Args:\n            new_shape (Tuple[int, int]): Target size (height, width) for the resized image.\n            auto (bool): If True, use minimum rectangle to resize. If False, use new_shape directly.\n            scaleFill (bool): If True, stretch the image to new_shape without padding.\n            scaleup (bool): If True, allow scaling up. If False, only scale down.\n            center (bool): If True, center the placed image. If False, place image in top-left corner.\n            stride (int): Stride of the model (e.g., 32 for YOLOv5).\n        Attributes:\n            new_shape (Tuple[int, int]): Target size for the resized image.\n            auto (bool): Flag for using minimum rectangle resizing.\n            scaleFill (bool): Flag for stretching image without padding.\n            scaleup (bool): Flag for allowing upscaling.\n            stride (int): Stride value for ensuring image size is divisible by stride.\n        Examples:\n            >>> letterbox = LetterBox(new_shape=(640, 640), auto=False, scaleFill=False, scaleup=True, stride=32)\n            >>> resized_img = letterbox(original_img)\n        '''\n        pass\n\n    def __call__(self, labels=None, image=None):\n        '''\n        Resizes and pads an image for object detection, instance segmentation, or pose estimation tasks.\n        This method applies letterboxing to the input image, which involves resizing the image while maintaining its\n        aspect ratio and adding padding to fit the new shape. It also updates any associated labels accordingly.\n        Args:\n            labels (Dict | None): A dictionary containing image data and associated labels, or empty dict if None.\n            image (np.ndarray | None): The input image as a numpy array. If None, the image is taken from 'labels'.\n        Returns:\n            (Dict | Tuple): If 'labels' is provided, returns an updated dictionary with the resized and padded image,\n                updated labels, and additional metadata. If 'labels' is empty, returns a tuple containing the resized\n                and padded image, and a tuple of (ratio, (left_pad, top_pad)).\n        Examples:\n            >>> letterbox = LetterBox(new_shape=(640, 640))\n            >>> result = letterbox(labels={\"img\": np.zeros((480, 640, 3)), \"instances\": Instances(...)})\n            >>> resized_img = result[\"img\"]\n            >>> updated_instances = result[\"instances\"]\n        '''\n        pass\n    @staticmethod\n    def _update_labels(labels, ratio, padw, padh):\n        '''\n        Updates labels after applying letterboxing to an image.\n        This method modifies the bounding box coordinates of instances in the labels\n        to account for resizing and padding applied during letterboxing.\n        Args:\n            labels (Dict): A dictionary containing image labels and instances.\n            ratio (Tuple[float, float]): Scaling ratios (width, height) applied to the image.\n            padw (float): Padding width added to the image.\n            padh (float): Padding height added to the image.\n        Returns:\n            (Dict): Updated labels dictionary with modified instance coordinates.\n        Examples:\n            >>> letterbox = LetterBox(new_shape=(640, 640))\n            >>> labels = {\"instances\": Instances(...)}\n            >>> ratio = (0.5, 0.5)\n            >>> padw, padh = 10, 20\n            >>> updated_labels = letterbox._update_labels(labels, ratio, padw, padh)\n        '''\n        pass"
  }
]