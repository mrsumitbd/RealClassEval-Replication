[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass TrafficRule(ApiItem):\n    '''Represent a traffic rule configuration.'''\n    @property\n    def id(self) -> str:\n        '''ID of traffic rule.'''\n        pass\n    @property\n    def description(self) -> str:\n        '''Description given by user to traffic rule.'''\n        pass\n    @property\n    def enabled(self) -> bool:\n        '''Is traffic rule enabled.'''\n        pass\n    @property\n    def action(self) -> str:\n        '''What action is defined by this traffic rule.'''\n        pass\n    @property\n    def matching_target(self) -> str:\n        '''What target is matched by this traffic rule.'''\n        pass\n    @property\n    def target_devices(self) -> list[TargetDevice]:\n        '''What target devices are affected by this traffic rule.'''\n        pass\nCorresponding class implementation:\n\nfrom .api import ApiItem, ApiRequestV2\n\nclass TrafficRule(ApiItem):\n    \"\"\"Represent a traffic rule configuration.\"\"\"\n    raw: TypedTrafficRule\n\n    @property\n    def id(self) -> str:\n        \"\"\"ID of traffic rule.\"\"\"\n        return self.raw['_id']\n\n    @property\n    def description(self) -> str:\n        \"\"\"Description given by user to traffic rule.\"\"\"\n        return self.raw.get('description', '')\n\n    @property\n    def enabled(self) -> bool:\n        \"\"\"Is traffic rule enabled.\"\"\"\n        return self.raw['enabled']\n\n    @property\n    def action(self) -> str:\n        \"\"\"What action is defined by this traffic rule.\"\"\"\n        return self.raw['action']\n\n    @property\n    def matching_target(self) -> str:\n        \"\"\"What target is matched by this traffic rule.\"\"\"\n        return self.raw['matching_target']\n\n    @property\n    def target_devices(self) -> list[TargetDevice]:\n        \"\"\"What target devices are affected by this traffic rule.\"\"\"\n        return self.raw['target_devices']\n\nExample skeleton:\n\n\nclass ProjectContext(threading.local):\n    '''A configuration class to hold global configuration.'''\n\n    def __init__(self) -> None:\n        pass\n\n    def __del__(self):\n        pass\n    @property\n    def database(self) -> 'Database':\n        '''Current database.'''\n        pass\n    @property\n    def database_path(self) -> Path:\n        '''Path to the metadata storage directory.'''\n        pass\n    @property\n    def datadir(self) -> str:\n        '''Define a name of the folder for storing datasets.'''\n        pass\n    @datadir.setter\n    def datadir(self) -> str:\n        '''Set the current datadir.'''\n        pass\n    @property\n    def dataset_images_path(self) -> Path:\n        '''Return a ``Path`` instance of Renku dataset metadata folder.'''\n        pass\n    @property\n    def project_image_pathname(self) -> Path:\n        '''Return the path to the project's image file.'''\n        pass\n    @property\n    def dockerfile_path(self) -> Path:\n        '''Path to the Dockerfile.'''\n        pass\n    @property\n    def ssh_authorized_keys_path(self) -> Path:\n        '''Path to SSH authorized keys.'''\n        pass\n    @property\n    def global_config_dir(self) -> str:\n        '''Return user's config directory.'''\n        pass\n    @property\n    def global_config_path(self) -> Path:\n        '''Renku global (user's) config path.'''\n        pass\n    @property\n    def latest_agent(self) -> Optional[str]:\n        '''Returns latest agent version used in the repository.'''\n        pass\n    @property\n    def local_config_path(self) -> Path:\n        '''Renku local (project) config path.'''\n        pass\n    @property\n    def lock(self):\n        '''Create a Renku config lock.'''\n        pass\n    @property\n    def metadata_path(self) -> Path:\n        '''Current project's metadata (RENKU_HOME) path.'''\n        pass\n    @property\n    def path(self) -> Path:\n        '''Current project path.'''\n        pass\n    @property\n    def pointers_path(self) -> Path:\n        '''Return a ``Path`` instance of Renku pointer files folder.'''\n        pass\n    @property\n    def project_image_pathname(self) -> Path:\n        '''Return the Project instance.'''\n        pass\n    @property\n    def remote(self) -> 'ProjectRemote':\n        '''Return host, owner and name of the remote if it exists.'''\n        pass\n    @property\n    def repository(self) -> 'Repository':\n        '''Return current context's repository.'''\n        pass\n    @repository.setter\n    def repository(self) -> 'Repository':\n        '''Set the current repository.'''\n        pass\n    @property\n    def template_checksums_path(self):\n        '''Return a ``Path`` instance to the template checksums file.'''\n        pass\n    @property\n    def transaction_id(self) -> str:\n        '''Get a transaction id for the current context to be used for grouping git commits.'''\n        pass\n    @property\n    def _top(self) -> 'ProjectProperties':\n        '''Return current context.'''\n        pass\n\n    def has_context(self, path: Optional[Union[Path, str]]=None) -> bool:\n        '''Return if at least one context which is equal to path (if not None) is pushed.'''\n        pass\n\n    def clear(self) -> None:\n        '''Remove all contexts and reset the state without committing intermediate changes.\n        NOTE: This method should be used only in tests.\n        '''\n        pass\n\n    def pop_context(self) -> 'ProjectProperties':\n        '''Pop current project context from stack.\n        Returns:\n            Path: the popped project path.\n        '''\n        pass\n\n    def push_path(self, path: Union[Path, str], save_changes: bool=False) -> None:\n        '''Push a new project path to the stack.\n        Arguments:\n            path(Union[Path, str]): The path to push.\n            save_changes(bool): Whether to save changes to the database or not.\n        '''\n        pass\n\n    def replace_path(self, path: Union[Path, str]):\n        '''Replace the current project path with a new one if they are different.\n        Arguments:\n            path(Union[Path, str]): The path to replace with.\n        '''\n        pass\n    @contextlib.contextmanager\n    def with_path(self, path: Union[Path, str], save_changes: bool=False) -> Generator['ProjectProperties', None, None]:\n        '''Temporarily push a new project path to the stack.\n        Arguments:\n            path(Union[Path, str]): The path to push.\n            save_changes(bool): Whether to save changes to the database or not.\n        '''\n        pass\n    @contextlib.contextmanager\n    def with_rollback(self) -> Generator[None, None, None]:\n        '''Rollback to the current state.\n        NOTE: This won't work correctly if the current context is popped or swapped.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom typing import TYPE_CHECKING, Generator, List, NamedTuple, Optional, Union\nfrom pathlib import Path\nimport threading\nfrom renku.core.constant import APP_NAME, CONFIG_NAME, DATA_DIR_CONFIG_KEY, DATABASE_PATH, DATASET_IMAGES, DEFAULT_DATA_DIR, DOCKERFILE, IMAGES, LOCK_SUFFIX, POINTERS, RENKU_HOME, TEMPLATE_CHECKSUMS\nfrom renku.core import errors\nimport uuid\nimport contextlib\n\nclass ProjectContext(threading.local):\n    \"\"\"A configuration class to hold global configuration.\"\"\"\n    external_storage_requested = True\n    'External storage (e.g. LFS) requested for Renku command.'\n\n    def __init__(self) -> None:\n        self._context_stack: List[ProjectProperties] = []\n\n    def __del__(self):\n        self.clear()\n\n    @property\n    def database(self) -> 'Database':\n        \"\"\"Current database.\"\"\"\n        if not self._top.database:\n            from renku.infrastructure.database import Database\n            self._top.database = Database.from_path(self.database_path)\n        return self._top.database\n\n    @property\n    def database_path(self) -> Path:\n        \"\"\"Path to the metadata storage directory.\"\"\"\n        return self.metadata_path / DATABASE_PATH\n\n    @property\n    def datadir(self) -> str:\n        \"\"\"Define a name of the folder for storing datasets.\"\"\"\n        from renku.core.config import get_value\n        from renku.domain_model.enums import ConfigFilter\n        if not self._top.datadir:\n            datadir = get_value('renku', DATA_DIR_CONFIG_KEY, config_filter=ConfigFilter.LOCAL_ONLY)\n            self._top.datadir = datadir or DEFAULT_DATA_DIR\n        return self._top.datadir\n\n    @datadir.setter\n    def datadir(self, value: str):\n        \"\"\"Set the current datadir.\"\"\"\n        self._top.datadir = value\n\n    @property\n    def dataset_images_path(self) -> Path:\n        \"\"\"Return a ``Path`` instance of Renku dataset metadata folder.\"\"\"\n        return self.path / RENKU_HOME / DATASET_IMAGES\n\n    @property\n    def project_image_pathname(self) -> Path:\n        \"\"\"Return the path to the project's image file.\"\"\"\n        return self.path / RENKU_HOME / IMAGES / 'project' / '0.png'\n\n    @property\n    def dockerfile_path(self) -> Path:\n        \"\"\"Path to the Dockerfile.\"\"\"\n        return self.path / DOCKERFILE\n\n    @property\n    def ssh_authorized_keys_path(self) -> Path:\n        \"\"\"Path to SSH authorized keys.\"\"\"\n        return self.path / '.ssh' / 'authorized_keys'\n\n    @property\n    def global_config_dir(self) -> str:\n        \"\"\"Return user's config directory.\"\"\"\n        import click\n        return click.get_app_dir(APP_NAME, force_posix=True)\n\n    @property\n    def global_config_path(self) -> Path:\n        \"\"\"Renku global (user's) config path.\"\"\"\n        config = Path(self.global_config_dir)\n        if not config.exists():\n            config.mkdir(parents=True)\n        return config / CONFIG_NAME\n\n    @property\n    def latest_agent(self) -> Optional[str]:\n        \"\"\"Returns latest agent version used in the repository.\"\"\"\n        try:\n            return self.project.agent_version\n        except ValueError as e:\n            if 'Project name not set' in str(e):\n                return None\n            raise\n\n    @property\n    def local_config_path(self) -> Path:\n        \"\"\"Renku local (project) config path.\"\"\"\n        return self.metadata_path / CONFIG_NAME\n\n    @property\n    def lock(self):\n        \"\"\"Create a Renku config lock.\"\"\"\n        from renku.core.util.contexts import Lock\n        return Lock(filename=self.metadata_path.with_suffix(LOCK_SUFFIX), mode='exclusive')\n\n    @property\n    def metadata_path(self) -> Path:\n        \"\"\"Current project's metadata (RENKU_HOME) path.\"\"\"\n        return self.path / RENKU_HOME\n\n    @property\n    def path(self) -> Path:\n        \"\"\"Current project path.\"\"\"\n        return self._top.path\n\n    @property\n    def pointers_path(self) -> Path:\n        \"\"\"Return a ``Path`` instance of Renku pointer files folder.\"\"\"\n        path = self.path / RENKU_HOME / POINTERS\n        path.mkdir(exist_ok=True)\n        return path\n\n    @property\n    def project(self) -> 'Project':\n        \"\"\"Return the Project instance.\"\"\"\n        from renku.command.command_builder.command import inject\n        from renku.core.interface.project_gateway import IProjectGateway\n        project_gateway = inject.instance(IProjectGateway)\n        return project_gateway.get_project()\n\n    @property\n    def remote(self) -> 'ProjectRemote':\n        \"\"\"Return host, owner and name of the remote if it exists.\"\"\"\n        from renku.core.util.git import get_remote\n        repository = self.repository\n        remote = get_remote(repository=repository)\n        if not remote and len(repository.remotes) > 1:\n            remote = repository.remotes.get('origin')\n        return ProjectRemote.from_remote(remote=remote)\n\n    @property\n    def repository(self) -> 'Repository':\n        \"\"\"Return current context's repository.\"\"\"\n        if not self._top.repository:\n            from renku.infrastructure.repository import Repository\n            try:\n                self._top.repository = Repository(project_context.path)\n            except errors.GitError as e:\n                raise ValueError from e\n        return self._top.repository\n\n    @repository.setter\n    def repository(self, value: Optional['Repository']):\n        \"\"\"Set the current repository.\"\"\"\n        self._top.repository = value\n\n    @property\n    def template_checksums_path(self):\n        \"\"\"Return a ``Path`` instance to the template checksums file.\"\"\"\n        return self.metadata_path / TEMPLATE_CHECKSUMS\n\n    @property\n    def transaction_id(self) -> str:\n        \"\"\"Get a transaction id for the current context to be used for grouping git commits.\"\"\"\n        if not self._top.transaction_id:\n            self._top.transaction_id = uuid.uuid4().hex\n        return f'\\n\\nrenku-transaction: {self._top.transaction_id}'\n\n    @property\n    def _top(self) -> 'ProjectProperties':\n        \"\"\"Return current context.\"\"\"\n        if self._context_stack:\n            return self._context_stack[-1]\n        raise errors.ProjectContextError('No project context was pushed')\n\n    def has_context(self, path: Optional[Union[Path, str]]=None) -> bool:\n        \"\"\"Return if at least one context which is equal to path (if not None) is pushed.\"\"\"\n        return True if self._context_stack and (path is None or self.path == Path(path).resolve()) else False\n\n    def clear(self) -> None:\n        \"\"\"Remove all contexts and reset the state without committing intermediate changes.\n\n        NOTE: This method should be used only in tests.\n        \"\"\"\n        while self._context_stack:\n            if self._top.repository:\n                self._top.repository.close()\n            self._context_stack.pop()\n        self.external_storage_requested = True\n\n    def pop_context(self) -> 'ProjectProperties':\n        \"\"\"Pop current project context from stack.\n\n        Returns:\n            Path: the popped project path.\n        \"\"\"\n        if self._context_stack:\n            if self._top.save_changes and self._top.database:\n                self._top.database.commit()\n            if self._top.repository:\n                self._top.repository.close()\n            return self._context_stack.pop()\n        else:\n            raise IndexError('No more context to pop.')\n\n    def push_path(self, path: Union[Path, str], save_changes: bool=False) -> None:\n        \"\"\"Push a new project path to the stack.\n\n        Arguments:\n            path(Union[Path, str]): The path to push.\n            save_changes(bool): Whether to save changes to the database or not.\n        \"\"\"\n        path = Path(path).resolve()\n        self._context_stack.append(ProjectProperties(path=path, save_changes=save_changes))\n\n    def replace_path(self, path: Union[Path, str]):\n        \"\"\"Replace the current project path with a new one if they are different.\n\n        Arguments:\n            path(Union[Path, str]): The path to replace with.\n        \"\"\"\n        path = Path(path).resolve()\n        if not self._context_stack:\n            self.push_path(path)\n        elif self._top.path != path:\n            self._context_stack[-1] = ProjectProperties(path=path)\n\n    @contextlib.contextmanager\n    def with_path(self, path: Union[Path, str], save_changes: bool=False) -> Generator['ProjectProperties', None, None]:\n        \"\"\"Temporarily push a new project path to the stack.\n\n        Arguments:\n            path(Union[Path, str]): The path to push.\n            save_changes(bool): Whether to save changes to the database or not.\n        \"\"\"\n        with self.with_rollback():\n            self.push_path(path=path, save_changes=save_changes)\n            yield self._top\n\n    @contextlib.contextmanager\n    def with_rollback(self) -> Generator[None, None, None]:\n        \"\"\"Rollback to the current state.\n\n        NOTE: This won't work correctly if the current context is popped or swapped.\n        \"\"\"\n        before_top = self._top if self._context_stack else None\n        try:\n            yield\n        finally:\n            could_rollback = False\n            while self._context_stack:\n                if self._top == before_top:\n                    could_rollback = True\n                    break\n                self.pop_context()\n            if not could_rollback and before_top is not None:\n                raise errors.ProjectContextError(f'Cannot rollback to {before_top.path}.')\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass CacheKeyBuilder:\n    '''Helper class to build standardized cache keys.'''\n    @staticmethod\n    def alerts_key(agent_id: Optional[str]=None, time_range: str='24h', level: Optional[int]=None) -> Dict[str, Any]:\n        '''Build cache key for alerts.'''\n        pass\n    @staticmethod\n    def agent_health_key(agent_id: str) -> Dict[str, Any]:\n        '''Build cache key for agent health.'''\n        pass\n    @staticmethod\n    def vulnerabilities_key(agent_id: Optional[str]=None, severity: Optional[str]=None) -> Dict[str, Any]:\n        '''Build cache key for vulnerabilities.'''\n        pass\n    @staticmethod\n    def processes_key(agent_id: str, include_children: bool=True) -> Dict[str, Any]:\n        '''Build cache key for processes.'''\n        pass\n    @staticmethod\n    def ports_key(agent_id: str, state: list[str]=None, protocol: list[str]=None) -> Dict[str, Any]:\n        '''Build cache key for ports.'''\n        pass"
  }
]