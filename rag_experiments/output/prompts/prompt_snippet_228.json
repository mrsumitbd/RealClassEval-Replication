[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass SASKernel(MetaKernel):\n    '''\n    SAS Kernel for Jupyter implementation. This module relies on SASPy\n    '''\n\n    def __init__(self, **kwargs):\n        pass\n\n    def do_apply(self, content, bufs, msg_id, reply_metadata):\n        pass\n\n    def do_clear(self):\n        pass\n\n    def get_usage(self):\n        pass\n\n    def _get_config_names(self):\n        '''\n        get the config file used by SASPy\n        '''\n        pass\n\n    def _start_sas(self, **kwargs):\n        pass\n\n    def _colorize_log(self, log: str) -> str:\n        '''\n        takes a SAS log (str) and then looks for errors.\n        Returns a tuple of error count, list of error messages\n        '''\n        pass\n\n    def _is_error_log(self, log: str) -> Tuple:\n        '''\n        takes a SAS log (str) and then looks for errors.\n        Returns a tuple of error count, list of error messages\n        '''\n        pass\n\n    def _which_display(self, log: str, output: str='') -> str:\n        '''\n        Determines if the log or lst should be returned as the\n        results for the cell based on parsing the log\n        looking for errors and the presence of lst output.\n        :param log: str log from code submission\n        :param output: None or str lst output if there was any\n        :return: The correct results based on log and lst\n        :rtype: str\n        '''\n        pass\n\n    def do_execute_direct(self, code: str, silent: bool=False) -> Union[str, dict]:\n        '''\n        This is the main method that takes code from the Jupyter cell\n        and submits it to the SAS server.\n        :param code: code from the cell\n        :param silent:\n        :return: str with either the log or list\n        '''\n        pass\n\n    def get_completions(self, info):\n        '''\n        Get completions from kernel for procs and statements.\n        '''\n        pass\n    @staticmethod\n    def _get_right_list(s):\n        pass\n\n    def initialize_debug(self, code):\n        '''SAS does not have formal debug tools from this interface'''\n        pass\n\n    def do_shutdown(self, restart):\n        '''\n        Shut down the app gracefully, saving history.\n        '''\n        pass\nCorresponding class implementation:\n\nimport importlib.machinery\nimport types\nfrom IPython.display import HTML\nimport json\nimport re\nfrom typing import Tuple, Union\nfrom .version import __version__\nfrom metakernel import MetaKernel\nimport sys\nimport os\nimport saspy\n\nclass SASKernel(MetaKernel):\n    \"\"\"\n    SAS Kernel for Jupyter implementation. This module relies on SASPy\n    \"\"\"\n    implementation = 'sas_kernel'\n    implementation_version = __version__\n    language = 'sas'\n    language_version = ('9.4+',)\n    banner = 'SAS Kernel'\n    language_info = {'name': 'sas', 'mimetype': 'text/x-sas', 'codemirror_mode': 'sas', 'file_extension': '.sas'}\n\n    def __init__(self, **kwargs):\n        with open(os.path.dirname(os.path.realpath(__file__)) + '/data/' + 'sasproclist.json') as proclist:\n            self.proclist = json.load(proclist)\n        with open(os.path.dirname(os.path.realpath(__file__)) + '/data/' + 'sasgrammardictionary.json') as compglo:\n            self.compglo = json.load(compglo)\n        self.strproclist = '\\n'.join((str(x) for x in self.proclist))\n        self.promptDict = {}\n        MetaKernel.__init__(self, **kwargs)\n        self.lst_len = 0\n        self.mva = None\n        self.cachedlog = None\n        self._allow_stdin = False\n\n    def do_apply(self, content, bufs, msg_id, reply_metadata):\n        pass\n\n    def do_clear(self):\n        pass\n\n    def get_usage(self):\n        return 'This is the SAS kernel.'\n\n    def _get_config_names(self):\n        \"\"\"\n        get the config file used by SASPy\n        \"\"\"\n        loader = importlib.machinery.SourceFileLoader('foo', saspy.SAScfg)\n        cfg = types.ModuleType(loader.name)\n        loader.exec_module(cfg)\n        return cfg.SAS_config_names\n\n    def _start_sas(self, **kwargs):\n        session_params = kwargs\n        if session_params is not None:\n            for _, v in session_params.items():\n                assert isinstance(v, str)\n        try:\n            self.mva = saspy.SASsession(kernel=self, **kwargs)\n        except KeyError:\n            self.mva = None\n        except OSError:\n            msg = 'Failed to connect to SAS!\\n    Please check your connection configuration here:{0}\\n    Here are the valid configurations:{1}\\n    You can load the configuration file into a Jupyter Lab cell using this command:\\n        %load {0}\\n    If the URL/Path are correct the issue is likely your username and/or password\\n    '.format(saspy.list_configs()[0], ', '.join(self._get_config_names()))\n            self.Error_display(msg)\n            self.mva = None\n        except Exception:\n            self.Error_display(str([l for l in sys.exc_info()]))\n\n    def _colorize_log(self, log: str) -> str:\n        \"\"\"\n        takes a SAS log (str) and then looks for errors.\n        Returns a tuple of error count, list of error messages\n        \"\"\"\n        regex_note = '(?m)(^NOTE.*((\\\\n|\\\\t|\\\\n\\\\t)[ ]([^WEN].*)(.*))*)'\n        regex_warn = '(?m)(^WARNING.*((\\\\n|\\\\t|\\\\n\\\\t)[ ]([^WEN].*)(.*))*)'\n        regex_error = '(?m)(^ERROR.*((\\\\n|\\\\t|\\\\n\\\\t)[ ]([^WEN].*)(.*))*)'\n        sub_note = '\\x1b[38;5;21m\\\\1\\x1b[0m'\n        sub_warn = '\\x1b[38;5;2m\\\\1\\x1b[0m'\n        sub_error = '\\x1b[1m\\x1b[38;5;9m\\\\1\\x1b[0m\\x1b[0m'\n        color_pattern = [(regex_error, sub_error), (regex_note, sub_note), (regex_warn, sub_warn)]\n        colored_log = log\n        for pat, sub in color_pattern:\n            colored_log = re.sub(pat, sub, colored_log)\n        return colored_log\n\n    def _is_error_log(self, log: str) -> Tuple:\n        \"\"\"\n        takes a SAS log (str) and then looks for errors.\n        Returns a tuple of error count, list of error messages\n        \"\"\"\n        lines = re.split('[\\\\n]\\\\s*', log)\n        error_count = 0\n        error_log_msg_list = []\n        error_log_line_list = []\n        for index, line in enumerate(lines):\n            if line.startswith('ERROR'):\n                error_count += 1\n                error_log_msg_list.append(line)\n                error_log_line_list.append(index)\n        return (error_count, error_log_msg_list, error_log_line_list)\n\n    def _which_display(self, log: str, output: str='') -> str:\n        \"\"\"\n        Determines if the log or lst should be returned as the\n        results for the cell based on parsing the log\n        looking for errors and the presence of lst output.\n\n        :param log: str log from code submission\n        :param output: None or str lst output if there was any\n        :return: The correct results based on log and lst\n        :rtype: str\n        \"\"\"\n        error_count, msg_list, error_line_list = self._is_error_log(log)\n        if error_count == 0 and len(output) > self.lst_len:\n            return self.Display(HTML(output))\n        elif error_count > 0 and len(output) > self.lst_len:\n            regex_around_error = '(.*)(.*\\\\n){6}^ERROR(.*\\\\n){6}'\n            e_log = re.search(regex_around_error, log, re.MULTILINE).group()\n            assert error_count == len(error_line_list), \"Error count and count of line number don't match\"\n            return self.Error_display(msg_list[0], print(self._colorize_log(e_log)), HTML(output))\n        return self.Print(self._colorize_log(log))\n\n    def do_execute_direct(self, code: str, silent: bool=False) -> Union[str, dict]:\n        \"\"\"\n        This is the main method that takes code from the Jupyter cell\n        and submits it to the SAS server.\n\n        :param code: code from the cell\n        :param silent:\n        :return: str with either the log or list\n        \"\"\"\n        if not code.strip():\n            return {'status': 'ok', 'execution_count': self.execution_count, 'payload': [], 'user_expressions': {}}\n        if self.mva is None:\n            self._allow_stdin = True\n            self._start_sas()\n        if not code.startswith('showSASLog_11092015') and (not code.startswith('CompleteshowSASLog_11092015')):\n            if code.startswith('/*SASKernelTest*/'):\n                res = self.mva.submit(code, 'text')\n            else:\n                res = self.mva.submit(code, prompt=self.promptDict)\n                self.promptDict = {}\n            if res['LOG'].find('SAS process has terminated unexpectedly') > -1:\n                print(res['LOG'], '\\nRestarting SAS session on your behalf')\n                self.do_shutdown(True)\n                return res['LOG']\n            self.cachedlog = self._colorize_log(res['LOG'])\n            error_count, error_log_msg, _ = self._is_error_log(res['LOG'])\n            if error_count > 0 and len(res['LST']) <= self.lst_len:\n                return self.Error(error_log_msg[0], print(self._colorize_log(res['LOG'])))\n            return self._which_display(res['LOG'], res['LST'])\n        elif code.startswith('CompleteshowSASLog_11092015') and (not code.startswith('showSASLog_11092015')):\n            return self.Print(self._colorize_log(self.mva.saslog()))\n        else:\n            return self.Print(self._colorize_log(self.cachedlog))\n\n    def get_completions(self, info):\n        \"\"\"\n        Get completions from kernel for procs and statements.\n        \"\"\"\n        if info['line_num'] > 1:\n            relstart = info['column'] - (info['help_pos'] - info['start'])\n        else:\n            relstart = info['start']\n        seg = info['line'][:relstart]\n        try:\n            if relstart > 0 and re.match('(?i)proc', seg.rsplit(None, 1)[-1]):\n                potentials = re.findall('(?i)^' + info['obj'] + '.*', self.strproclist, re.MULTILINE)\n                return potentials\n        except:\n            pass\n        lastproc = info['code'].lower()[:info['help_pos']].rfind('proc')\n        lastdata = info['code'].lower()[:info['help_pos']].rfind('data ')\n        proc = False\n        data = False\n        if lastproc + lastdata == -2:\n            pass\n        elif lastproc > lastdata:\n            proc = True\n        else:\n            data = True\n        if proc:\n            lastsemi = info['code'].rfind(';')\n            mykey = 's'\n            if lastproc > lastsemi:\n                mykey = 'p'\n            procer = re.search('(?i)proc\\\\s\\\\w+', info['code'][lastproc:])\n            method = procer.group(0).split(' ')[-1].upper() + mykey\n            mylist = self.compglo[method][0]\n            potentials = re.findall('(?i)' + info['obj'] + '.+', '\\n'.join((str(x) for x in mylist)), re.MULTILINE)\n            return potentials\n        elif data:\n            lastsemi = info['code'].rfind(';')\n            mykey = 's'\n            if lastproc > lastsemi:\n                mykey = 'p'\n            mylist = self.compglo['DATA' + mykey][0]\n            potentials = re.findall('(?i)^' + info['obj'] + '.*', '\\n'.join((str(x) for x in mylist)), re.MULTILINE)\n            return potentials\n        else:\n            potentials = ['']\n            return potentials\n\n    @staticmethod\n    def _get_right_list(s):\n        proc_opt = re.search('proc\\\\s(\\\\w+).*?[^;]\\\\Z', s, re.IGNORECASE | re.MULTILINE)\n        proc_stmt = re.search('\\\\s*proc\\\\s*(\\\\w+).*;.*\\\\Z', s, re.IGNORECASE | re.MULTILINE)\n        data_opt = re.search('\\\\s*data\\\\s*[^=].*[^;]?.*$', s, re.IGNORECASE | re.MULTILINE)\n        data_stmt = re.search('\\\\s*data\\\\s*[^=].*[^;]?.*$', s, re.IGNORECASE | re.MULTILINE)\n        print(s)\n        if proc_opt:\n            return proc_opt.group(1).upper() + 'p'\n        elif proc_stmt:\n            return proc_stmt.group(1).upper() + 's'\n        elif data_opt:\n            return 'DATA' + 'p'\n        elif data_stmt:\n            return 'DATA' + 's'\n        else:\n            return None\n\n    def initialize_debug(self, code):\n        \"\"\"SAS does not have formal debug tools from this interface\"\"\"\n        print(code)\n        return None\n\n    def do_shutdown(self, restart):\n        \"\"\"\n        Shut down the app gracefully, saving history.\n        \"\"\"\n        print('in shutdown function')\n        if self.hist_file:\n            with open(self.hist_file, 'wb') as fid:\n                data = '\\n'.join(self.hist_cache[-self.max_hist_cache:])\n                fid.write(data.encode('utf-8'))\n        if self.mva:\n            self.mva._endsas()\n            self.mva = None\n        if restart:\n            self.Print('Restarting kernel...')\n            self.reload_magics()\n            self.restart_kernel()\n            self.Print('Done!')\n        return {'status': 'ok', 'restart': restart}\n\nExample skeleton:\n\n\nclass AliasManager(object):\n\n    def __init__(self, **kwargs):\n        pass\n\n    def load_alias_table(self):\n        '''\n        Load (create, if not exist) the alias config file.\n        '''\n        pass\n\n    def load_alias_hash(self):\n        '''\n        Load (create, if not exist) the alias hash file.\n        '''\n        pass\n\n    def load_collided_alias(self):\n        '''\n        Load (create, if not exist) the collided alias file.\n        '''\n        pass\n\n    def detect_alias_config_change(self):\n        '''\n        Change if the alias configuration has changed since the last run.\n        Returns:\n            False if the alias configuration file has not been changed since the last run.\n            Otherwise, return True.\n        '''\n        pass\n\n    def transform(self, args):\n        '''\n        Transform any aliases in args to their respective commands.\n        Args:\n            args: A list of space-delimited command input extracted directly from the console.\n        Returns:\n            A list of transformed commands according to the alias configuration file.\n        '''\n        pass\n\n    def get_full_alias(self, query):\n        '''\n        Get the full alias given a search query.\n        Args:\n            query: The query this function performs searching on.\n        Returns:\n            The full alias (with the placeholders, if any).\n        '''\n        pass\n\n    def load_full_command_table(self):\n        '''\n        Perform a full load of the command table to get all the reserved command words.\n        '''\n        pass\n\n    def post_transform(self, args):\n        '''\n        Inject environment variables, and write hash to alias hash file after transforming alias to commands.\n        Args:\n            args: A list of args to post-transform.\n        '''\n        pass\n\n    def parse_error(self):\n        '''\n        Check if there is a configuration parsing error.\n        A parsing error has occurred if there are strings inside the alias config file\n        but there is no alias loaded in self.alias_table.\n        Returns:\n            True if there is an error parsing the alias configuration file. Otherwises, false.\n        '''\n        pass\n    @staticmethod\n    def build_collision_table(aliases, levels=COLLISION_CHECK_LEVEL_DEPTH):\n        '''\n        Build the collision table according to the alias configuration file against the entire command table.\n        self.collided_alias is structured as:\n        {\n            'collided_alias': [the command level at which collision happens]\n        }\n        For example:\n        {\n            'account': [1, 2]\n        }\n        This means that 'account' is a reserved command in level 1 and level 2 of the command tree because\n        (az account ...) and (az storage account ...)\n             lvl 1                        lvl 2\n        Args:\n            levels: the amount of levels we tranverse through the command table tree.\n        '''\n        pass\n    @staticmethod\n    def write_alias_config_hash(alias_config_hash='', empty_hash=False):\n        '''\n        Write self.alias_config_hash to the alias hash file.\n        Args:\n            empty_hash: True if we want to write an empty string into the file. Empty string in the alias hash file\n                means that we have to perform a full load of the command table in the next run.\n        '''\n        pass\n    @staticmethod\n    def write_collided_alias(collided_alias_dict):\n        '''\n        Write the collided aliases string into the collided alias file.\n        '''\n        pass\n    @staticmethod\n    def process_exception_message(exception):\n        '''\n        Process an exception message.\n        Args:\n            exception: The exception to process.\n        Returns:\n            A filtered string summarizing the exception.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom azext_alias._const import GLOBAL_CONFIG_DIR, ALIAS_FILE_NAME, ALIAS_HASH_FILE_NAME, COLLIDED_ALIAS_FILE_NAME, CONFIG_PARSING_ERROR, DEBUG_MSG, COLLISION_CHECK_LEVEL_DEPTH, POS_ARG_DEBUG_MSG\nfrom collections import defaultdict\nimport azext_alias\nimport hashlib\nimport shlex\nfrom azext_alias.util import is_alias_command, cache_reserved_commands, get_config_parser, build_tab_completion_table\nimport os\nimport json\nfrom azext_alias.argument import build_pos_args_table, render_template\nimport re\nfrom azext_alias import telemetry\n\nclass AliasManager(object):\n\n    def __init__(self, **kwargs):\n        self.alias_table = get_config_parser()\n        self.kwargs = kwargs\n        self.collided_alias = defaultdict(list)\n        self.alias_config_str = ''\n        self.alias_config_hash = ''\n        self.load_alias_table()\n        self.load_alias_hash()\n\n    def load_alias_table(self):\n        \"\"\"\n        Load (create, if not exist) the alias config file.\n        \"\"\"\n        try:\n            open_mode = 'r+' if os.path.exists(GLOBAL_ALIAS_PATH) else 'w+'\n            with open(GLOBAL_ALIAS_PATH, open_mode) as alias_config_file:\n                self.alias_config_str = alias_config_file.read()\n            self.alias_table.read(GLOBAL_ALIAS_PATH)\n            telemetry.set_number_of_aliases_registered(len(self.alias_table.sections()))\n        except Exception as exception:\n            logger.warning(CONFIG_PARSING_ERROR, AliasManager.process_exception_message(exception))\n            self.alias_table = get_config_parser()\n            telemetry.set_exception(exception)\n\n    def load_alias_hash(self):\n        \"\"\"\n        Load (create, if not exist) the alias hash file.\n        \"\"\"\n        open_mode = 'r+' if os.path.exists(GLOBAL_ALIAS_HASH_PATH) else 'w+'\n        with open(GLOBAL_ALIAS_HASH_PATH, open_mode) as alias_config_hash_file:\n            self.alias_config_hash = alias_config_hash_file.read()\n\n    def load_collided_alias(self):\n        \"\"\"\n        Load (create, if not exist) the collided alias file.\n        \"\"\"\n        open_mode = 'r+' if os.path.exists(GLOBAL_COLLIDED_ALIAS_PATH) else 'w+'\n        with open(GLOBAL_COLLIDED_ALIAS_PATH, open_mode) as collided_alias_file:\n            collided_alias_str = collided_alias_file.read()\n            try:\n                self.collided_alias = json.loads(collided_alias_str if collided_alias_str else '{}')\n            except Exception:\n                self.collided_alias = {}\n\n    def detect_alias_config_change(self):\n        \"\"\"\n        Change if the alias configuration has changed since the last run.\n\n        Returns:\n            False if the alias configuration file has not been changed since the last run.\n            Otherwise, return True.\n        \"\"\"\n        if self.parse_error():\n            return False\n        alias_config_sha1 = hashlib.sha1(self.alias_config_str.encode('utf-8')).hexdigest()\n        if alias_config_sha1 != self.alias_config_hash:\n            self.alias_config_hash = alias_config_sha1\n            return True\n        return False\n\n    def transform(self, args):\n        \"\"\"\n        Transform any aliases in args to their respective commands.\n\n        Args:\n            args: A list of space-delimited command input extracted directly from the console.\n\n        Returns:\n            A list of transformed commands according to the alias configuration file.\n        \"\"\"\n        if self.parse_error():\n            AliasManager.write_alias_config_hash(empty_hash=True)\n            return args\n        if self.detect_alias_config_change():\n            self.load_full_command_table()\n            self.collided_alias = AliasManager.build_collision_table(self.alias_table.sections())\n            build_tab_completion_table(self.alias_table)\n        else:\n            self.load_collided_alias()\n        transformed_commands = []\n        alias_iter = enumerate(args, 1)\n        for alias_index, alias in alias_iter:\n            is_collided_alias = alias in self.collided_alias and alias_index in self.collided_alias[alias]\n            is_named_arg = alias_index > 1 and args[alias_index - 2].startswith('-')\n            is_named_arg_flag = alias.startswith('-')\n            excluded_commands = is_alias_command(['remove', 'export'], transformed_commands)\n            if not alias or is_collided_alias or is_named_arg or is_named_arg_flag or excluded_commands:\n                transformed_commands.append(alias)\n                continue\n            full_alias = self.get_full_alias(alias)\n            if self.alias_table.has_option(full_alias, 'command'):\n                cmd_derived_from_alias = self.alias_table.get(full_alias, 'command')\n                telemetry.set_alias_hit(full_alias)\n            else:\n                transformed_commands.append(alias)\n                continue\n            pos_args_table = build_pos_args_table(full_alias, args, alias_index)\n            if pos_args_table:\n                logger.debug(POS_ARG_DEBUG_MSG, full_alias, cmd_derived_from_alias, pos_args_table)\n                transformed_commands += render_template(cmd_derived_from_alias, pos_args_table)\n                for pos_arg in pos_args_table:\n                    next(alias_iter)\n            else:\n                logger.debug(DEBUG_MSG, full_alias, cmd_derived_from_alias)\n                transformed_commands += shlex.split(cmd_derived_from_alias)\n        return self.post_transform(transformed_commands)\n\n    def get_full_alias(self, query):\n        \"\"\"\n        Get the full alias given a search query.\n\n        Args:\n            query: The query this function performs searching on.\n\n        Returns:\n            The full alias (with the placeholders, if any).\n        \"\"\"\n        if query in self.alias_table.sections():\n            return query\n        return next((section for section in self.alias_table.sections() if section.split()[0] == query), '')\n\n    def load_full_command_table(self):\n        \"\"\"\n        Perform a full load of the command table to get all the reserved command words.\n        \"\"\"\n        load_cmd_tbl_func = self.kwargs.get('load_cmd_tbl_func', lambda _: {})\n        cache_reserved_commands(load_cmd_tbl_func)\n        telemetry.set_full_command_table_loaded()\n\n    def post_transform(self, args):\n        \"\"\"\n        Inject environment variables, and write hash to alias hash file after transforming alias to commands.\n\n        Args:\n            args: A list of args to post-transform.\n        \"\"\"\n        args = args[1:] if args and args[0] == 'az' else args\n        post_transform_commands = []\n        for i, arg in enumerate(args):\n            if is_alias_command(['create'], args) and i > 0 and (args[i - 1] in ['-c', '--command']):\n                post_transform_commands.append(arg)\n            else:\n                post_transform_commands.append(os.path.expandvars(arg))\n        AliasManager.write_alias_config_hash(self.alias_config_hash)\n        AliasManager.write_collided_alias(self.collided_alias)\n        return post_transform_commands\n\n    def parse_error(self):\n        \"\"\"\n        Check if there is a configuration parsing error.\n\n        A parsing error has occurred if there are strings inside the alias config file\n        but there is no alias loaded in self.alias_table.\n\n        Returns:\n            True if there is an error parsing the alias configuration file. Otherwises, false.\n        \"\"\"\n        return not self.alias_table.sections() and self.alias_config_str\n\n    @staticmethod\n    def build_collision_table(aliases, levels=COLLISION_CHECK_LEVEL_DEPTH):\n        \"\"\"\n        Build the collision table according to the alias configuration file against the entire command table.\n\n        self.collided_alias is structured as:\n        {\n            'collided_alias': [the command level at which collision happens]\n        }\n        For example:\n        {\n            'account': [1, 2]\n        }\n        This means that 'account' is a reserved command in level 1 and level 2 of the command tree because\n        (az account ...) and (az storage account ...)\n             lvl 1                        lvl 2\n\n        Args:\n            levels: the amount of levels we tranverse through the command table tree.\n        \"\"\"\n        collided_alias = defaultdict(list)\n        for alias in aliases:\n            word = alias.split()[0]\n            for level in range(1, levels + 1):\n                collision_regex = '^{}{}($|\\\\s)'.format('([a-z\\\\-]*\\\\s)' * (level - 1), word.lower())\n                if list(filter(re.compile(collision_regex).match, azext_alias.cached_reserved_commands)) and level not in collided_alias[word]:\n                    collided_alias[word].append(level)\n        telemetry.set_collided_aliases(list(collided_alias.keys()))\n        return collided_alias\n\n    @staticmethod\n    def write_alias_config_hash(alias_config_hash='', empty_hash=False):\n        \"\"\"\n        Write self.alias_config_hash to the alias hash file.\n\n        Args:\n            empty_hash: True if we want to write an empty string into the file. Empty string in the alias hash file\n                means that we have to perform a full load of the command table in the next run.\n        \"\"\"\n        with open(GLOBAL_ALIAS_HASH_PATH, 'w') as alias_config_hash_file:\n            alias_config_hash_file.write('' if empty_hash else alias_config_hash)\n\n    @staticmethod\n    def write_collided_alias(collided_alias_dict):\n        \"\"\"\n        Write the collided aliases string into the collided alias file.\n        \"\"\"\n        open_mode = 'r+' if os.path.exists(GLOBAL_COLLIDED_ALIAS_PATH) else 'w+'\n        with open(GLOBAL_COLLIDED_ALIAS_PATH, open_mode) as collided_alias_file:\n            collided_alias_file.truncate()\n            collided_alias_file.write(json.dumps(collided_alias_dict))\n\n    @staticmethod\n    def process_exception_message(exception):\n        \"\"\"\n        Process an exception message.\n\n        Args:\n            exception: The exception to process.\n\n        Returns:\n            A filtered string summarizing the exception.\n        \"\"\"\n        exception_message = str(exception)\n        for replace_char in ['\\t', '\\n', '\\\\n']:\n            exception_message = exception_message.replace(replace_char, '' if replace_char != '\\t' else ' ')\n        return exception_message.replace('section', 'alias')\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass ClipboardService:\n    '''Service for interacting with the system clipboard.'''\n\n    def __init__(self):\n        '''Initialize the clipboard service.'''\n        pass\n\n    def write_text(self, content: str) -> Dict[str, Any]:\n        '''\n        Write text content to the clipboard.\n        Args:\n            content: Text content to write to clipboard\n        Returns:\n            Dict containing success status and any error information\n        '''\n        pass\n\n    def _create_temp_file_from_image(self, image: Image.Image) -> Optional[str]:\n        '''\n        Create a temporary file from a PIL Image.\n        Args:\n            image: PIL Image object\n        Returns:\n            Path to the temporary file or None if failed\n        '''\n        pass\n\n    def read(self) -> Dict[str, Any]:\n        '''\n        Read content from the clipboard and automatically determine the content type.\n        Returns:\n            Dict containing the clipboard content or error information\n        '''\n        pass\n\n    def read_and_process_paste(self) -> Dict[str, Any]:\n        '''\n        Read clipboard content and if it's an image or binary file, create a temporary file\n        and return a file command that can be processed.\n        Returns:\n            Dict containing either processed file command or regular text content\n        '''\n        pass\n\n    def cleanup_temp_files(self):\n        '''Clean up any temporary files created by this service.'''\n        pass\n\n    def write_text(self, content: str) -> Dict[str, Any]:\n        '''\n        Write content to the clipboard.\n        Args:\n            content: Content to write to clipboard\n        Returns:\n            Dict containing success status and any error information\n        '''\n        pass\n\n    def __del__(self):\n        '''Cleanup temporary files when the service is destroyed.'''\n        pass"
  }
]