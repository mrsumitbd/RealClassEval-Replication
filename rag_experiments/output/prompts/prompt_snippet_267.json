[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass BloomTokenizerFast(PreTrainedTokenizerFast):\n    '''\n    Construct a \"fast\" Bloom tokenizer (backed by HuggingFace's *tokenizers* library). Based on byte-level\n    Byte-Pair-Encoding.\n    This tokenizer has been trained to treat spaces like parts of the tokens (a bit like sentencepiece) so a word will\n    be encoded differently whether it is at the beginning of the sentence (without space) or not:\n    ```python\n    >>> from transformers import BloomTokenizerFast\n    >>> tokenizer = BloomTokenizerFast.from_pretrained(\"bigscience/bloom\")\n    >>> tokenizer(\"Hello world\")[\"input_ids\"]\n    [59414, 8876]\n    >>> tokenizer(\" Hello world\")[\"input_ids\"]\n    [86153, 8876]\n    ```\n    You can get around that behavior by passing `add_prefix_space=True` when instantiating this tokenizer, but since\n    the model was not pretrained this way, it might yield a decrease in performance.\n    <Tip>\n    When used with `is_split_into_words=True`, this tokenizer needs to be instantiated with `add_prefix_space=True`.\n    </Tip>\n    This tokenizer inherits from [`PreTrainedTokenizerFast`] which contains most of the main methods. Users should\n    refer to this superclass for more information regarding those methods.\n    Args:\n        vocab_file (`str`):\n            Path to the vocabulary file.\n        merges_file (`str`):\n            Path to the merges file.\n        errors (`str`, *optional*, defaults to `\"replace\"`):\n            Paradigm to follow when decoding bytes to UTF-8. See\n            [bytes.decode](https://docs.python.org/3/library/stdtypes.html#bytes.decode) for more information.\n        unk_token (`str`, *optional*, defaults to `<|endoftext|>`):\n            The unknown token. A token that is not in the vocabulary cannot be converted to an ID and is set to be this\n            token instead.\n        bos_token (`str`, *optional*, defaults to `<|endoftext|>`):\n            The beginning of sequence token.\n        eos_token (`str`, *optional*, defaults to `<|endoftext|>`):\n            The end of sequence token.\n        add_prefix_space (`bool`, *optional*, defaults to `False`):\n            Whether or not to add an initial space to the input. This allows to treat the leading word just as any\n            other word. (Bloom tokenizer detect beginning of words by the preceding space).\n        trim_offsets (`bool`, *optional*, defaults to `True`):\n            Whether or not the post-processing step should trim offsets to avoid including whitespaces.\n    '''\n\n    def __init__(self, vocab_file=None, merges_file=None, tokenizer_file=None, unk_token='<unk>', bos_token='<s>', eos_token='</s>', pad_token='<pad>', add_prefix_space=False, clean_up_tokenization_spaces=False, **kwargs):\n        pass\n\n    def _batch_encode_plus(self, *args, **kwargs) -> BatchEncoding:\n        pass\n\n    def _encode_plus(self, *args, **kwargs) -> BatchEncoding:\n        pass\n\n    def save_vocabulary(self, save_directory: str, filename_prefix: Optional[str]=None) -> tuple[str]:\n        pass\nCorresponding class implementation:\n\nfrom ...tokenization_utils_base import BatchEncoding\nimport pickle\nfrom ...tokenization_utils_fast import PreTrainedTokenizerFast\nfrom typing import Optional\n\nclass BloomTokenizerFast(PreTrainedTokenizerFast):\n    \"\"\"\n    Construct a \"fast\" Bloom tokenizer (backed by HuggingFace's *tokenizers* library). Based on byte-level\n    Byte-Pair-Encoding.\n\n    This tokenizer has been trained to treat spaces like parts of the tokens (a bit like sentencepiece) so a word will\n    be encoded differently whether it is at the beginning of the sentence (without space) or not:\n\n    ```python\n    >>> from transformers import BloomTokenizerFast\n\n    >>> tokenizer = BloomTokenizerFast.from_pretrained(\"bigscience/bloom\")\n    >>> tokenizer(\"Hello world\")[\"input_ids\"]\n    [59414, 8876]\n\n    >>> tokenizer(\" Hello world\")[\"input_ids\"]\n    [86153, 8876]\n    ```\n\n    You can get around that behavior by passing `add_prefix_space=True` when instantiating this tokenizer, but since\n    the model was not pretrained this way, it might yield a decrease in performance.\n\n    <Tip>\n\n    When used with `is_split_into_words=True`, this tokenizer needs to be instantiated with `add_prefix_space=True`.\n\n    </Tip>\n\n    This tokenizer inherits from [`PreTrainedTokenizerFast`] which contains most of the main methods. Users should\n    refer to this superclass for more information regarding those methods.\n\n    Args:\n        vocab_file (`str`):\n            Path to the vocabulary file.\n        merges_file (`str`):\n            Path to the merges file.\n        errors (`str`, *optional*, defaults to `\"replace\"`):\n            Paradigm to follow when decoding bytes to UTF-8. See\n            [bytes.decode](https://docs.python.org/3/library/stdtypes.html#bytes.decode) for more information.\n        unk_token (`str`, *optional*, defaults to `<|endoftext|>`):\n            The unknown token. A token that is not in the vocabulary cannot be converted to an ID and is set to be this\n            token instead.\n        bos_token (`str`, *optional*, defaults to `<|endoftext|>`):\n            The beginning of sequence token.\n        eos_token (`str`, *optional*, defaults to `<|endoftext|>`):\n            The end of sequence token.\n        add_prefix_space (`bool`, *optional*, defaults to `False`):\n            Whether or not to add an initial space to the input. This allows to treat the leading word just as any\n            other word. (Bloom tokenizer detect beginning of words by the preceding space).\n        trim_offsets (`bool`, *optional*, defaults to `True`):\n            Whether or not the post-processing step should trim offsets to avoid including whitespaces.\n    \"\"\"\n    vocab_files_names = VOCAB_FILES_NAMES\n    model_input_names = ['input_ids', 'attention_mask']\n    slow_tokenizer_class = None\n\n    def __init__(self, vocab_file=None, merges_file=None, tokenizer_file=None, unk_token='<unk>', bos_token='<s>', eos_token='</s>', pad_token='<pad>', add_prefix_space=False, clean_up_tokenization_spaces=False, **kwargs):\n        super().__init__(vocab_file=vocab_file, merges_file=merges_file, tokenizer_file=tokenizer_file, unk_token=unk_token, bos_token=bos_token, eos_token=eos_token, pad_token=pad_token, add_prefix_space=add_prefix_space, clean_up_tokenization_spaces=clean_up_tokenization_spaces, **kwargs)\n        pre_tok_state = pickle.dumps(self.backend_tokenizer.pre_tokenizer)\n        decoder_state = pickle.dumps(self.backend_tokenizer.decoder)\n        if add_prefix_space:\n            pre_tok_state = pre_tok_state.replace(b'\"add_prefix_space\":false', b'\"add_prefix_space\": true')\n            decoder_state = decoder_state.replace(b'\"add_prefix_space\":false', b'\"add_prefix_space\": true')\n        self.backend_tokenizer.pre_tokenizer = pickle.loads(pre_tok_state)\n        self.backend_tokenizer.decoder = pickle.loads(decoder_state)\n        self.add_prefix_space = add_prefix_space\n\n    def _batch_encode_plus(self, *args, **kwargs) -> BatchEncoding:\n        is_split_into_words = kwargs.get('is_split_into_words', False)\n        if not (self.add_prefix_space or not is_split_into_words):\n            raise Exception(f'You need to instantiate {self.__class__.__name__} with add_prefix_space=True to use it with pretokenized inputs.')\n        return super()._batch_encode_plus(*args, **kwargs)\n\n    def _encode_plus(self, *args, **kwargs) -> BatchEncoding:\n        is_split_into_words = kwargs.get('is_split_into_words', False)\n        if not (self.add_prefix_space or not is_split_into_words):\n            raise Exception(f'You need to instantiate {self.__class__.__name__} with add_prefix_space=True to use it with pretokenized inputs.')\n        return super()._encode_plus(*args, **kwargs)\n\n    def save_vocabulary(self, save_directory: str, filename_prefix: Optional[str]=None) -> tuple[str]:\n        files = self._tokenizer.model.save(save_directory, name=filename_prefix)\n        return tuple(files)\n\nExample skeleton:\n\n\nclass Qwen2_5_VLProcessor(Qwen2VLProcessor):\n    '''\n    Constructs a Qwen2.5-VL processor which wraps a Qwen2.5-VL image processor and a Qwen2 tokenizer into a single processor.\n    [`Qwen2_5_VLProcessor`] offers all the functionalities of [`Qwen2VLImageProcessor`] and [`Qwen2TokenizerFast`]. See the\n    [`~Qwen2_5_VLProcessor.__call__`] and [`~Qwen2_5_VLProcessor.decode`] for more information.\n    Args:\n        image_processor ([`Qwen2VLImageProcessor`], *optional*):\n            The image processor is a required input.\n        tokenizer ([`Qwen2TokenizerFast`], *optional*):\n            The tokenizer is a required input.\n        video_processor ([`Qwen2_5_VLVideoProcessor`], *optional*):\n            The video processor is a required input.\n        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n            in a chat into a tokenizable string.\n    '''\n    @property\n    def model_input_names(self):\n        pass\n\n    def __call__(self, images: Optional[ImageInput]=None, text: Union[TextInput, PreTokenizedInput, list[TextInput], list[PreTokenizedInput]]=None, videos: Optional[VideoInput]=None, **kwargs: Unpack[Qwen2_5_VLProcessorKwargs]) -> BatchFeature:\n        '''\n        Main method to prepare for the model one or several sequences(s) and image(s). This method forwards the `text`\n        and `kwargs` arguments to Qwen2TokenizerFast's [`~Qwen2TokenizerFast.__call__`] if `text` is not `None` to encode\n        the text. To prepare the vision inputs, this method forwards the `vision_infos` and `kwargs` arguments to\n        Qwen2VLImageProcessor's [`~Qwen2VLImageProcessor.__call__`] if `vision_infos` is not `None`.\n        Args:\n            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `list[PIL.Image.Image]`, `list[np.ndarray]`, `list[torch.Tensor]`):\n                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n                tensor. Both channels-first and channels-last formats are supported.\n            text (`str`, `list[str]`, `list[list[str]]`):\n                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n            videos (`np.ndarray`, `torch.Tensor`, `list[np.ndarray]`, `list[torch.Tensor]`):\n                The image or batch of videos to be prepared. Each video can be a 4D NumPy array or PyTorch\n                tensor, or a nested list of 3D frames. Both channels-first and channels-last formats are supported.\n            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n                If set, will return tensors of a particular framework. Acceptable values are:\n                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n                - `'np'`: Return NumPy `np.ndarray` objects.\n        Returns:\n            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n            - **input_ids** -- List of token ids to be fed to a model. Returned when `text` is not `None`.\n            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n              `None`).\n            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n            - **pixel_values_videos** -- Pixel values of videos to be fed to a model. Returned when `videos` is not `None`.\n            - **image_grid_thw** -- List of image 3D grid in LLM. Returned when `images` is not `None`.\n            - **video_grid_thw** -- List of video 3D grid in LLM. Returned when `videos` is not `None`.\n            - **second_per_grid_ts** -- List of video seconds per time grid. Returned when `videos` is not `None`.\n        '''\n        pass\n\n    def _get_num_multimodal_tokens(self, image_sizes=None, video_sizes=None, **kwargs):\n        '''\n        Computes the number of placeholder tokens needed for multimodal inputs with the given sizes.\n        Args:\n            image_sizes (`list[list[int]]`, *optional*):\n                The input sizes formatted as (height, width) per each image.\n            video_sizes (`list[list[int]]`, *optional*):\n                The input sizes formatted as (num_frames, height, width) per each video.\n        Returns:\n            `MultiModalData`: A `MultiModalData` object holding number of tokens per each of the provided\n            input modalities, along with other useful data.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom transformers.models.qwen2_vl.processing_qwen2_vl import Qwen2VLImagesKwargs, Qwen2VLProcessor\nfrom ...tokenization_utils_base import PreTokenizedInput, TextInput\nimport numpy as np\nfrom ...feature_extraction_utils import BatchFeature\nfrom ...processing_utils import MultiModalData, ProcessingKwargs, Unpack, VideosKwargs\nfrom ...video_utils import VideoInput\nfrom ...image_utils import ImageInput\nfrom typing import Optional, Union\n\nclass Qwen2_5_VLProcessor(Qwen2VLProcessor):\n    \"\"\"\n    Constructs a Qwen2.5-VL processor which wraps a Qwen2.5-VL image processor and a Qwen2 tokenizer into a single processor.\n    [`Qwen2_5_VLProcessor`] offers all the functionalities of [`Qwen2VLImageProcessor`] and [`Qwen2TokenizerFast`]. See the\n    [`~Qwen2_5_VLProcessor.__call__`] and [`~Qwen2_5_VLProcessor.decode`] for more information.\n    Args:\n        image_processor ([`Qwen2VLImageProcessor`], *optional*):\n            The image processor is a required input.\n        tokenizer ([`Qwen2TokenizerFast`], *optional*):\n            The tokenizer is a required input.\n        video_processor ([`Qwen2_5_VLVideoProcessor`], *optional*):\n            The video processor is a required input.\n        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n            in a chat into a tokenizable string.\n    \"\"\"\n    image_processor_class = 'AutoImageProcessor'\n\n    @property\n    def model_input_names(self):\n        tokenizer_input_names = self.tokenizer.model_input_names\n        image_processor_input_names = self.image_processor.model_input_names\n        names_from_processor = list(dict.fromkeys(tokenizer_input_names + image_processor_input_names))\n        return names_from_processor + ['second_per_grid_ts']\n\n    def __call__(self, images: Optional[ImageInput]=None, text: Union[TextInput, PreTokenizedInput, list[TextInput], list[PreTokenizedInput]]=None, videos: Optional[VideoInput]=None, **kwargs: Unpack[Qwen2_5_VLProcessorKwargs]) -> BatchFeature:\n        \"\"\"\n        Main method to prepare for the model one or several sequences(s) and image(s). This method forwards the `text`\n        and `kwargs` arguments to Qwen2TokenizerFast's [`~Qwen2TokenizerFast.__call__`] if `text` is not `None` to encode\n        the text. To prepare the vision inputs, this method forwards the `vision_infos` and `kwargs` arguments to\n        Qwen2VLImageProcessor's [`~Qwen2VLImageProcessor.__call__`] if `vision_infos` is not `None`.\n\n        Args:\n            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `list[PIL.Image.Image]`, `list[np.ndarray]`, `list[torch.Tensor]`):\n                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n                tensor. Both channels-first and channels-last formats are supported.\n            text (`str`, `list[str]`, `list[list[str]]`):\n                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n            videos (`np.ndarray`, `torch.Tensor`, `list[np.ndarray]`, `list[torch.Tensor]`):\n                The image or batch of videos to be prepared. Each video can be a 4D NumPy array or PyTorch\n                tensor, or a nested list of 3D frames. Both channels-first and channels-last formats are supported.\n            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n                If set, will return tensors of a particular framework. Acceptable values are:\n                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n                - `'np'`: Return NumPy `np.ndarray` objects.\n\n        Returns:\n            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n\n            - **input_ids** -- List of token ids to be fed to a model. Returned when `text` is not `None`.\n            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n              `None`).\n            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n            - **pixel_values_videos** -- Pixel values of videos to be fed to a model. Returned when `videos` is not `None`.\n            - **image_grid_thw** -- List of image 3D grid in LLM. Returned when `images` is not `None`.\n            - **video_grid_thw** -- List of video 3D grid in LLM. Returned when `videos` is not `None`.\n            - **second_per_grid_ts** -- List of video seconds per time grid. Returned when `videos` is not `None`.\n        \"\"\"\n        output_kwargs = self._merge_kwargs(Qwen2_5_VLProcessorKwargs, tokenizer_init_kwargs=self.tokenizer.init_kwargs, **kwargs)\n        image_inputs = videos_inputs = {}\n        if images is not None:\n            image_inputs = self.image_processor(images=images, **output_kwargs['images_kwargs'])\n            image_grid_thw = image_inputs['image_grid_thw']\n        if videos is not None:\n            fps = output_kwargs['videos_kwargs'].get('fps', 2.0)\n            videos_inputs = self.video_processor(videos=videos, **output_kwargs['videos_kwargs'])\n            video_grid_thw = videos_inputs['video_grid_thw']\n            if isinstance(fps, (int, float)):\n                second_per_grid_ts = [self.video_processor.temporal_patch_size / fps] * len(video_grid_thw)\n            elif hasattr(fps, '__len__') and len(fps) == len(video_grid_thw):\n                second_per_grid_ts = [self.video_processor.temporal_patch_size / tmp for tmp in fps]\n            else:\n                raise ValueError(f\"The length of fps ({(len(fps) if hasattr(fps, '__len__') else fps)}) must be equal to the length of video_grid_thw ({len(video_grid_thw)}) or fps should be a single number.\")\n            videos_inputs.update({'second_per_grid_ts': second_per_grid_ts})\n        if not isinstance(text, list):\n            text = [text]\n        text = text.copy()\n        if images is not None:\n            merge_length = self.image_processor.merge_size ** 2\n            index = 0\n            for i in range(len(text)):\n                while self.image_token in text[i]:\n                    num_image_tokens = image_grid_thw[index].prod() // merge_length\n                    text[i] = text[i].replace(self.image_token, '<|placeholder|>' * num_image_tokens, 1)\n                    index += 1\n                text[i] = text[i].replace('<|placeholder|>', self.image_token)\n        if videos is not None:\n            merge_length = self.video_processor.merge_size ** 2\n            index = 0\n            for i in range(len(text)):\n                while self.video_token in text[i]:\n                    num_video_tokens = video_grid_thw[index].prod() // merge_length\n                    text[i] = text[i].replace(self.video_token, '<|placeholder|>' * num_video_tokens, 1)\n                    index += 1\n                text[i] = text[i].replace('<|placeholder|>', self.video_token)\n        return_tensors = output_kwargs['text_kwargs'].pop('return_tensors', None)\n        return_mm_token_type_ids = output_kwargs['text_kwargs'].pop('return_mm_token_type_ids', None)\n        text_inputs = self.tokenizer(text, **output_kwargs['text_kwargs'])\n        self._check_special_mm_tokens(text, text_inputs, modalities=['image', 'video'])\n        if return_mm_token_type_ids:\n            array_ids = np.array(text_inputs['input_ids'])\n            mm_token_type_ids = np.zeros_like(text_inputs['input_ids'])\n            mm_token_type_ids[array_ids == self.image_token_id] = 1\n            text_inputs['mm_token_type_ids'] = mm_token_type_ids.tolist()\n        return BatchFeature(data={**text_inputs, **image_inputs, **videos_inputs}, tensor_type=return_tensors)\n\n    def _get_num_multimodal_tokens(self, image_sizes=None, video_sizes=None, **kwargs):\n        \"\"\"\n        Computes the number of placeholder tokens needed for multimodal inputs with the given sizes.\n        Args:\n            image_sizes (`list[list[int]]`, *optional*):\n                The input sizes formatted as (height, width) per each image.\n            video_sizes (`list[list[int]]`, *optional*):\n                The input sizes formatted as (num_frames, height, width) per each video.\n        Returns:\n            `MultiModalData`: A `MultiModalData` object holding number of tokens per each of the provided\n            input modalities, along with other useful data.\n        \"\"\"\n        vision_data = {}\n        if image_sizes is not None:\n            images_kwargs = Qwen2_5_VLProcessorKwargs._defaults.get('images_kwargs', {})\n            images_kwargs.update(kwargs)\n            merge_size = images_kwargs.get('merge_size', None) or self.image_processor.merge_size\n            num_image_patches = [self.image_processor.get_number_of_image_patches(*image_size, images_kwargs) for image_size in image_sizes]\n            num_image_tokens = [num_patches // merge_size ** 2 for num_patches in num_image_patches]\n            vision_data.update({'num_image_tokens': num_image_tokens, 'num_image_patches': num_image_patches})\n        if video_sizes is not None:\n            videos_kwargs = Qwen2_5_VLProcessorKwargs._defaults.get('videos_kwargs', {})\n            videos_kwargs.update(kwargs)\n            num_video_patches = [self.video_processor.get_number_of_video_patches(*video_size, videos_kwargs) for video_size in video_sizes]\n            num_video_tokens = [num_patches // merge_size ** 2 for num_patches in num_video_patches]\n            vision_data['num_video_tokens'] = num_video_tokens\n        return MultiModalData(**vision_data)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass KokoroTTS:\n    '''\n    KokoroTTS class for text-to-speech generation using the Kokoro model.\n    This class provides a simple interface for loading and using the Kokoro model\n    to generate speech from text prompts.\n    Example:\n        ```python\n        # Initialize the KokoroTTS model\n        # ðŸ‡ºðŸ‡¸ 'a' => American English, ðŸ‡¬ðŸ‡§ 'b' => British English, ðŸ‡ªðŸ‡¸ 'e' => Spanish, etc.\n        tts = KokoroTTS(lang_code=\"a\")\n        # Generate speech from text\n        text = \"The sky above the port was the color of television, tuned to a dead channel.\"\n        audios = tts(text=text, voice=\"af_heart\", output_prefix=\"output\")\n        # To listen in a notebook:\n        # from IPython.display import Audio, display\n        # display(Audio(audios[0], rate=24000))\n        ```\n    '''\n\n    def __init__(self, lang_code: str='a'):\n        '''\n        Initialize the KokoroTTS model.\n        Args:\n            lang_code (str): Language code for the model. Default is \"a\".\n                - ðŸ‡ºðŸ‡¸ 'a': American English\n                - ðŸ‡¬ðŸ‡§ 'b': British English\n                - ðŸ‡ªðŸ‡¸ 'e': Spanish\n                - ðŸ‡«ðŸ‡· 'f': French\n                - ðŸ‡®ðŸ‡³ 'h': Hindi\n                - ðŸ‡®ðŸ‡¹ 'i': Italian\n                - ðŸ‡¯ðŸ‡µ 'j': Japanese (requires `pip install misaki[ja]`)\n                - ðŸ‡§ðŸ‡· 'p': Brazilian Portuguese\n                - ðŸ‡¨ðŸ‡³ 'z': Mandarin Chinese (requires `pip install misaki[zh]`)\n        '''\n        pass\n\n    def __call__(self, text: str, voice: str='af_heart', speed: float=1.0, output_prefix: str='output', split_pattern: str='\\\\n+'):\n        '''\n        Generate speech from text and save it to files.\n        Args:\n            text (str): Text to convert to speech.\n            voice (str): The voice to use for generation. Default is \"af_heart\".\n                         Can also be a path to a voice tensor.\n            speed (float): Speaking speed. Default is 1.0.\n            output_prefix (str): Prefix for the output audio files.\n                                 Files will be saved as {output_prefix}_0.wav, etc.\n            split_pattern (str): Regex pattern to split the input text into segments.\n                                 Default is r'\n+'.\n        Returns:\n            list: A list of audio data numpy arrays.\n        '''\n        pass"
  }
]