[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass YaleAuth:\n    '''Handle authentication and creating authorized calls on the yale apis.'''\n\n    def __init__(self, username: str, password: str) -> None:\n        '''Initialize Authentication module.'''\n        pass\n    @property\n    def auth_headers(self) -> dict[str, str]:\n        '''Return authentication headers.'''\n        pass\n\n    def get_authenticated(self, endpoint: str) -> dict[str, Any]:\n        '''Execute an GET request on an endpoint.\n        Args:\n            endpoint: parts of an url.\n        Returns:\n            a dictionary with the response.\n        '''\n        pass\n\n    def post_authenticated(self, endpoint: str, params: dict[Any, Any] | None=None) -> dict[str, Any]:\n        '''Execute a POST request on an endpoint.\n        Args:\n            endpoint: URL endpoint to connect to.\n            params: The parameters to send in the POST request\n        Returns:\n            A dictionary with the response.\n        '''\n        pass\n\n    def put_authenticated(self, endpoint: str) -> dict[str, Any]:\n        '''Execute an PUT request on an endpoint.\n        Args:\n            endpoint: parts of an url.\n        Returns:\n            a dictionary with the response.\n        '''\n        pass\n\n    def _update_services(self) -> None:\n        pass\n\n    def _authorize(self) -> tuple[str, str]:\n        pass\nCorresponding class implementation:\n\nfrom .const import DEFAULT_REQUEST_TIMEOUT, ENDPOINT_SERVICES, ENDPOINT_TOKEN, HOST, YALE_AUTH_TOKEN, YALE_AUTHENTICATION_ACCESS_TOKEN, YALE_AUTHENTICATION_REFRESH_TOKEN\nimport requests\nfrom .exceptions import AuthenticationError, UnknownError\nfrom requests.exceptions import ConnectionError, HTTPError, RequestException, Timeout\nfrom typing import Any, cast\n\nclass YaleAuth:\n    \"\"\"Handle authentication and creating authorized calls on the yale apis.\"\"\"\n\n    def __init__(self, username: str, password: str) -> None:\n        \"\"\"Initialize Authentication module.\"\"\"\n        self._host = HOST\n        self.username = username\n        self.password = password\n        self.refresh_token: str | None = None\n        self.access_token: str | None = None\n        self._authorize()\n\n    @property\n    def auth_headers(self) -> dict[str, str]:\n        \"\"\"Return authentication headers.\"\"\"\n        if self.access_token:\n            return {'Authorization': 'Bearer ' + self.access_token}\n        return {'Authorization': 'Bearer '}\n\n    def get_authenticated(self, endpoint: str) -> dict[str, Any]:\n        \"\"\"Execute an GET request on an endpoint.\n\n        Args:\n            endpoint: parts of an url.\n\n        Returns:\n            a dictionary with the response.\n\n        \"\"\"\n        url = self._host + endpoint\n        try:\n            response = requests.get(url, headers=self.auth_headers, timeout=DEFAULT_REQUEST_TIMEOUT)\n            response.raise_for_status()\n        except HTTPError as error:\n            _LOGGER.debug('Http Error: %s', error)\n            if response.status_code in [401, 403]:\n                self.refresh_token = None\n                self.access_token = None\n                self._authorize()\n                self.get_authenticated(endpoint)\n            raise ConnectionError(f'Connection error {error}') from error\n        except ConnectionError as error:\n            _LOGGER.debug('Connection Error: %s', error)\n            raise ConnectionError(f'Connection error {error}') from error\n        except Timeout as error:\n            _LOGGER.debug('Timeout Error: %s', error)\n            raise TimeoutError(f'Timeout {error}') from error\n        except RequestException as error:\n            _LOGGER.debug('Requests Error: %s', error)\n            raise UnknownError(f'Requests error {error}') from error\n        except Exception as error:\n            _LOGGER.debug('Unknown Error: %s', error)\n            raise UnknownError(f'Unknown error {error}') from error\n        return cast(dict[str, Any], response.json())\n\n    def post_authenticated(self, endpoint: str, params: dict[Any, Any] | None=None) -> dict[str, Any]:\n        \"\"\"Execute a POST request on an endpoint.\n\n        Args:\n            endpoint: URL endpoint to connect to.\n            params: The parameters to send in the POST request\n\n        Returns:\n            A dictionary with the response.\n\n        \"\"\"\n        if 'panic' in endpoint:\n            url = self._host[:-5] + endpoint\n        else:\n            url = self._host + endpoint\n        try:\n            response = requests.post(url, headers=self.auth_headers, data=params, timeout=DEFAULT_REQUEST_TIMEOUT)\n            response.raise_for_status()\n        except HTTPError as error:\n            _LOGGER.debug('Http Error: %s', error)\n            if response.status_code in [401, 403]:\n                self.refresh_token = None\n                self.access_token = None\n                self._authorize()\n                self.post_authenticated(endpoint, params)\n            raise ConnectionError(f'Connection error {error}') from error\n        except ConnectionError as error:\n            _LOGGER.debug('Connection Error: %s', error)\n            raise ConnectionError(f'Connection error {error}') from error\n        except Timeout as error:\n            _LOGGER.debug('Timeout Error: %s', error)\n            raise TimeoutError(f'Timeout {error}') from error\n        except RequestException as error:\n            _LOGGER.debug('Requests Error: %s', error)\n            raise UnknownError(f'Requests error {error}') from error\n        except Exception as error:\n            _LOGGER.debug('Unknown Error: %s', error)\n            raise UnknownError(f'Unknown error {error}') from error\n        if 'panic' in endpoint:\n            return {'panic': 'triggered'}\n        return cast(dict[str, Any], response.json())\n\n    def put_authenticated(self, endpoint: str) -> dict[str, Any]:\n        \"\"\"Execute an PUT request on an endpoint.\n\n        Args:\n            endpoint: parts of an url.\n\n        Returns:\n            a dictionary with the response.\n\n        \"\"\"\n        url = self._host + endpoint\n        try:\n            response = requests.put(url, headers=self.auth_headers, timeout=DEFAULT_REQUEST_TIMEOUT)\n            response.raise_for_status()\n        except HTTPError as error:\n            _LOGGER.debug('Http Error: %s', error)\n            if response.status_code in [401, 403]:\n                self.refresh_token = None\n                self.access_token = None\n                self._authorize()\n                self.put_authenticated(endpoint)\n            raise ConnectionError(f'Connection error {error}') from error\n        except ConnectionError as error:\n            _LOGGER.debug('Connection Error: %s', error)\n            raise ConnectionError(f'Connection error {error}') from error\n        except Timeout as error:\n            _LOGGER.debug('Timeout Error: %s', error)\n            raise TimeoutError(f'Timeout {error}') from error\n        except RequestException as error:\n            _LOGGER.debug('Requests Error: %s', error)\n            raise UnknownError(f'Requests error {error}') from error\n        except Exception as error:\n            _LOGGER.debug('Unknown Error: %s', error)\n            raise UnknownError(f'Unknown error {error}') from error\n        return cast(dict[str, Any], response.json())\n\n    def _update_services(self) -> None:\n        data = self.get_authenticated(ENDPOINT_SERVICES)\n        url: str | None = data.get('yapi')\n        if url is not None:\n            if len(url) > 0:\n                _LOGGER.debug('Yale URL updated: %s', url)\n                url.removesuffix('/')\n                self._host = url\n            else:\n                _LOGGER.debug('Services URL is empty')\n        else:\n            _LOGGER.debug('Unable to fetch services')\n\n    def _authorize(self) -> tuple[str, str]:\n        if self.refresh_token:\n            payload = {'grant_type': 'refresh_token', 'refresh_token': self.refresh_token}\n        else:\n            payload = {'grant_type': 'password', 'username': self.username, 'password': self.password}\n        headers = {'Authorization': 'Basic ' + YALE_AUTH_TOKEN}\n        url = self._host + ENDPOINT_TOKEN\n        _LOGGER.debug('Attempting authorization')\n        try:\n            response = requests.post(url, headers=headers, data=payload, timeout=DEFAULT_REQUEST_TIMEOUT)\n            response.raise_for_status()\n        except HTTPError as error:\n            _LOGGER.debug('Http Error: %s', error)\n            if response.status_code in [401, 403]:\n                raise AuthenticationError(f'Failed to authenticate {error}') from error\n            raise ConnectionError(f'Connection error {error}') from error\n        except ConnectionError as error:\n            _LOGGER.debug('Connection Error: %s', error)\n            raise ConnectionError(f'Connection error {error}') from error\n        except Timeout as error:\n            _LOGGER.debug('Timeout Error: %s', error)\n            raise TimeoutError(f'Timeout {error}') from error\n        except RequestException as error:\n            _LOGGER.debug('Requests Error: %s', error)\n            raise UnknownError(f'Requests error {error}') from error\n        except Exception as error:\n            _LOGGER.debug('Unknown Error: %s', error)\n            raise UnknownError(f'Unknown error {error}') from error\n        data = response.json()\n        _LOGGER.debug('Authorization response: %s', data)\n        _LOGGER.info('Authorization to Yale Alarm API successful')\n        self.refresh_token = data.get(YALE_AUTHENTICATION_REFRESH_TOKEN)\n        self.access_token = data.get(YALE_AUTHENTICATION_ACCESS_TOKEN)\n        if self.refresh_token is None or self.access_token is None:\n            raise AuthenticationError('Failed to authenticate with Yale Smart Alarm. Invalid token.')\n        self._update_services()\n        return (self.access_token, self.refresh_token)\n\nExample skeleton:\n\n@dataclass\nclass ClientReconnectRequest(ApiRequest):\n    '''Request object for client reconnect.'''\n    @classmethod\n    def create(cls, mac: str) -> Self:\n        '''Create client reconnect request.'''\n        pass\nCorresponding class implementation:\n\nfrom typing import Self, TypedDict, cast\nfrom dataclasses import dataclass\nfrom .api import ApiItem, ApiRequest\n\n@dataclass\nclass ClientReconnectRequest(ApiRequest):\n    \"\"\"Request object for client reconnect.\"\"\"\n\n    @classmethod\n    def create(cls, mac: str) -> Self:\n        \"\"\"Create client reconnect request.\"\"\"\n        return cls(method='post', path='/cmd/stamgr', data={'cmd': 'kick-sta', 'mac': mac})\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass LocalBedrockAgentCoreClient:\n    '''Local Bedrock AgentCore client for invoking endpoints.'''\n\n    def __init__(self, endpoint: str):\n        '''Initialize the local client with the given endpoint.'''\n        pass\n\n    def invoke_endpoint(self, session_id: str, payload: str, workload_access_token: str):\n        '''Invoke the endpoint with the given parameters.'''\n        pass"
  }
]