[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass AtariPlayer(gym.Env):\n    '''\n    A wrapper for ALE emulator, with configurations to mimic DeepMind DQN settings.\n    Info:\n        score: the accumulated reward in the current game\n        gameOver: True when the current game is Over\n    '''\n\n    def __init__(self, rom_file, viz=0, frame_skip=4, nullop_start=30, live_lost_as_eoe=True, max_num_frames=0, grayscale=True):\n        '''\n        Args:\n            rom_file: path to the rom\n            frame_skip: skip every k frames and repeat the action\n            viz: visualization to be done.\n                Set to 0 to disable.\n                Set to a positive number to be the delay between frames to show.\n                Set to a string to be a directory to store frames.\n            nullop_start: start with random number of null ops.\n            live_losts_as_eoe: consider lost of lives as end of episode. Useful for training.\n            max_num_frames: maximum number of frames per episode.\n            grayscale (bool): if True, return 2D image. Otherwise return HWC image.\n        '''\n        pass\n\n    def get_action_meanings(self):\n        pass\n\n    def _grab_raw_image(self):\n        '''\n        :returns: the current 3-channel image\n        '''\n        pass\n\n    def _current_state(self):\n        '''\n        :returns: a gray-scale (h, w) uint8 image\n        '''\n        pass\n\n    def _restart_episode(self):\n        pass\n\n    def reset(self):\n        pass\n\n    def render(self, *args, **kwargs):\n        pass\n\n    def step(self, act):\n        pass\nCorresponding class implementation:\n\nimport os\nimport gym\nfrom ale_py import ALEInterface, Action, LoggerMode\nimport numpy as np\nfrom tensorpack.utils.fs import get_dataset_path\nimport six\nimport cv2\nfrom gym import spaces\nfrom tensorpack.utils import logger, execute_only_once, get_rng\n\nclass AtariPlayer(gym.Env):\n    \"\"\"\n    A wrapper for ALE emulator, with configurations to mimic DeepMind DQN settings.\n\n    Info:\n        score: the accumulated reward in the current game\n        gameOver: True when the current game is Over\n    \"\"\"\n\n    def __init__(self, rom_file, viz=0, frame_skip=4, nullop_start=30, live_lost_as_eoe=True, max_num_frames=0, grayscale=True):\n        \"\"\"\n        Args:\n            rom_file: path to the rom\n            frame_skip: skip every k frames and repeat the action\n            viz: visualization to be done.\n                Set to 0 to disable.\n                Set to a positive number to be the delay between frames to show.\n                Set to a string to be a directory to store frames.\n            nullop_start: start with random number of null ops.\n            live_losts_as_eoe: consider lost of lives as end of episode. Useful for training.\n            max_num_frames: maximum number of frames per episode.\n            grayscale (bool): if True, return 2D image. Otherwise return HWC image.\n        \"\"\"\n        super(AtariPlayer, self).__init__()\n        if not os.path.isfile(rom_file) and '/' not in rom_file:\n            rom_file = get_dataset_path('atari_rom', rom_file)\n        assert os.path.isfile(rom_file), 'ROM {} not found. Please download at {}'.format(rom_file, ROM_URL)\n        try:\n            ALEInterface.setLoggerMode(LoggerMode.Error)\n        except AttributeError:\n            if execute_only_once():\n                logger.warn(\"You're not using latest ALE\")\n        with _ALE_LOCK:\n            self.ale = ALEInterface()\n            self.rng = get_rng(self)\n            self.ale.setInt(b'random_seed', self.rng.randint(0, 30000))\n            self.ale.setInt(b'max_num_frames_per_episode', max_num_frames)\n            self.ale.setInt(b'frame_skip', 1)\n            self.ale.setBool(b'color_averaging', False)\n            self.ale.setFloat(b'repeat_action_probability', 0.0)\n            if isinstance(viz, six.string_types):\n                assert os.path.isdir(viz), viz\n                self.ale.setString(b'record_screen_dir', viz)\n                viz = 0\n            if isinstance(viz, int):\n                viz = float(viz)\n            self.viz = viz\n            if self.viz and isinstance(self.viz, float):\n                self.windowname = os.path.basename(rom_file)\n                cv2.namedWindow(self.windowname)\n            self.ale.loadROM(rom_file.encode('utf-8'))\n        self.width, self.height = self.ale.getScreenDims()\n        self.actions = self.ale.getMinimalActionSet()\n        self.live_lost_as_eoe = live_lost_as_eoe\n        self.frame_skip = frame_skip\n        self.nullop_start = nullop_start\n        self.action_space = spaces.Discrete(len(self.actions))\n        self.grayscale = grayscale\n        shape = (self.height, self.width) if grayscale else (self.height, self.width, 3)\n        self.observation_space = spaces.Box(low=0, high=255, shape=shape, dtype=np.uint8)\n        self._restart_episode()\n\n    def get_action_meanings(self):\n        keys = Action.__members__.values()\n        values = Action.__members__.keys()\n        mapping = dict(zip(keys, values))\n        return [mapping[action] for action in self.actions]\n\n    def _grab_raw_image(self):\n        \"\"\"\n        :returns: the current 3-channel image\n        \"\"\"\n        m = self.ale.getScreenRGB()\n        return m.reshape((self.height, self.width, 3))\n\n    def _current_state(self):\n        \"\"\"\n        :returns: a gray-scale (h, w) uint8 image\n        \"\"\"\n        ret = self._grab_raw_image()\n        ret = np.maximum(ret, self.last_raw_screen)\n        if self.viz:\n            if isinstance(self.viz, float):\n                cv2.imshow(self.windowname, ret)\n                cv2.waitKey(int(self.viz * 1000))\n        if self.grayscale:\n            ret = cv2.cvtColor(ret, cv2.COLOR_RGB2GRAY)\n        return ret.astype('uint8')\n\n    def _restart_episode(self):\n        with _ALE_LOCK:\n            self.ale.reset_game()\n        n = self.rng.randint(self.nullop_start)\n        self.last_raw_screen = self._grab_raw_image()\n        for k in range(n):\n            if k == n - 1:\n                self.last_raw_screen = self._grab_raw_image()\n            self.ale.act(0)\n\n    def reset(self):\n        if self.ale.game_over():\n            self._restart_episode()\n        return self._current_state()\n\n    def render(self, *args, **kwargs):\n        pass\n\n    def step(self, act):\n        oldlives = self.ale.lives()\n        r = 0\n        for k in range(self.frame_skip):\n            if k == self.frame_skip - 1:\n                self.last_raw_screen = self._grab_raw_image()\n            r += self.ale.act(self.actions[act])\n            newlives = self.ale.lives()\n            if self.ale.game_over() or (self.live_lost_as_eoe and newlives < oldlives):\n                break\n        isOver = self.ale.game_over()\n        if self.live_lost_as_eoe:\n            isOver = isOver or newlives < oldlives\n        info = {'ale.lives': newlives}\n        return (self._current_state(), r, isOver, info)\n\nExample skeleton:\n\n\nclass GeopediaWmsRequest(GeopediaRequest):\n    '''Web Map Service request class for Geopedia\n    Creates an instance of Geopedia's WMS (Web Map Service) GetMap request, which provides access to WMS layers in\n    Geopedia.\n    '''\n\n    def __init__(self, layer: str | int, theme: str, bbox: BBox, *, width: int | None=None, height: int | None=None, **kwargs: Any):\n        '''\n        :param layer: Geopedia layer which contains requested data\n        :param theme: Geopedia's theme endpoint string for which the layer is defined.\n        :param bbox: Bounding box of the requested data\n        :param width: width (number of columns) of the returned image (array)\n        :param height: height (number of rows) of the returned image (array)\n        :param image_format: Format of the returned image by the Sentinel Hub's WMS getMap service. Default is\n            ``constants.MimeType.PNG``.\n        :param data_folder: Location of the directory where the fetched data will be saved.\n        :param config: A custom instance of config class to override parameters from the saved configuration.\n        '''\n        pass\n\n    def create_request(self) -> None:\n        '''Set download requests\n        Create a list of DownloadRequests for all Sentinel-2 acquisitions within request's time interval and\n        acceptable cloud coverage.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom ..geometry import BBox\nfrom ..constants import CRS, MimeType, ServiceType\nfrom .core import GeopediaFeatureIterator, GeopediaImageService, GeopediaSession, GeopediaWmsService\nfrom typing import Any\n\nclass GeopediaWmsRequest(GeopediaRequest):\n    \"\"\"Web Map Service request class for Geopedia\n\n    Creates an instance of Geopedia's WMS (Web Map Service) GetMap request, which provides access to WMS layers in\n    Geopedia.\n    \"\"\"\n\n    def __init__(self, layer: str | int, theme: str, bbox: BBox, *, width: int | None=None, height: int | None=None, **kwargs: Any):\n        \"\"\"\n        :param layer: Geopedia layer which contains requested data\n        :param theme: Geopedia's theme endpoint string for which the layer is defined.\n        :param bbox: Bounding box of the requested data\n        :param width: width (number of columns) of the returned image (array)\n        :param height: height (number of rows) of the returned image (array)\n        :param image_format: Format of the returned image by the Sentinel Hub's WMS getMap service. Default is\n            ``constants.MimeType.PNG``.\n        :param data_folder: Location of the directory where the fetched data will be saved.\n        :param config: A custom instance of config class to override parameters from the saved configuration.\n        \"\"\"\n        self.size_x = width\n        self.size_y = height\n        super().__init__(layer=layer, theme=theme, bbox=bbox, service_type=ServiceType.WMS, **kwargs)\n\n    def create_request(self) -> None:\n        \"\"\"Set download requests\n\n        Create a list of DownloadRequests for all Sentinel-2 acquisitions within request's time interval and\n        acceptable cloud coverage.\n        \"\"\"\n        gpd_service = GeopediaWmsService(config=self.config)\n        self.download_list = gpd_service.get_request(self)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass LoadScreenshots:\n    '''\n    Ultralytics screenshot dataloader for capturing and processing screen images.\n    This class manages the loading of screenshot images for processing with YOLO. It is suitable for use with\n    `yolo predict source=screen`.\n    Attributes:\n        source (str): The source input indicating which screen to capture.\n        screen (int): The screen number to capture.\n        left (int): The left coordinate for screen capture area.\n        top (int): The top coordinate for screen capture area.\n        width (int): The width of the screen capture area.\n        height (int): The height of the screen capture area.\n        mode (str): Set to 'stream' indicating real-time capture.\n        frame (int): Counter for captured frames.\n        sct (mss.mss): Screen capture object from `mss` library.\n        bs (int): Batch size, set to 1.\n        fps (int): Frames per second, set to 30.\n        monitor (Dict[str, int]): Monitor configuration details.\n    Methods:\n        __iter__: Returns an iterator object.\n        __next__: Captures the next screenshot and returns it.\n    Examples:\n        >>> loader = LoadScreenshots(\"0 100 100 640 480\")  # screen 0, top-left (100,100), 640x480\n        >>> for source, im, im0s, vid_cap, s in loader:\n        ...     print(f\"Captured frame: {im.shape}\")\n    '''\n\n    def __init__(self, source):\n        '''Initialize screenshot capture with specified screen and region parameters.'''\n        pass\n\n    def __iter__(self):\n        '''Yields the next screenshot image from the specified screen or region for processing.'''\n        pass\n\n    def __next__(self):\n        '''Captures and returns the next screenshot as a numpy array using the mss library.'''\n        pass"
  }
]