[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Lambda(Transform):\n    '''Apply a user-defined function as a transform.\n    This transform does not support torchscript.\n    Args:\n        lambd (function): Lambda/function to be used for transform.\n    '''\n\n    def __init__(self, lambd: Callable[[Any], Any], *types: type):\n        pass\n\n    def transform(self, inpt: Any, params: dict[str, Any]) -> Any:\n        pass\n\n    def extra_repr(self) -> str:\n        pass\nCorresponding class implementation:\n\nfrom torchvision.transforms.v2 import functional as F, Transform\nfrom typing import Any, Callable, Optional, Union\n\nclass Lambda(Transform):\n    \"\"\"Apply a user-defined function as a transform.\n\n    This transform does not support torchscript.\n\n    Args:\n        lambd (function): Lambda/function to be used for transform.\n    \"\"\"\n    _transformed_types = (object,)\n\n    def __init__(self, lambd: Callable[[Any], Any], *types: type):\n        super().__init__()\n        self.lambd = lambd\n        self.types = types or self._transformed_types\n\n    def transform(self, inpt: Any, params: dict[str, Any]) -> Any:\n        if isinstance(inpt, self.types):\n            return self.lambd(inpt)\n        else:\n            return inpt\n\n    def extra_repr(self) -> str:\n        extras = []\n        name = getattr(self.lambd, '__name__', None)\n        if name:\n            extras.append(name)\n        extras.append(f'types={[type.__name__ for type in self.types]}')\n        return ', '.join(extras)\n\nExample skeleton:\n\n\nclass Iterator(xgboost.DataIter):\n    '''A custom iterator for loading files in batches.'''\n\n    def __init__(self, device: Literal['cpu', 'cuda'], file_paths: List[Tuple[str, str]]) -> None:\n        pass\n\n    def load_file(self) -> Tuple[np.ndarray, np.ndarray]:\n        '''Load a single batch of data.'''\n        pass\n\n    def next(self, input_data: Callable) -> bool:\n        '''Advance the iterator by 1 step and pass the data to XGBoost.  This function\n        is called by XGBoost during the construction of ``DMatrix``\n        '''\n        pass\n\n    def reset(self) -> None:\n        '''Reset the iterator to its beginning'''\n        pass\nCorresponding class implementation:\n\nimport numpy as np\nimport xgboost\nfrom typing import Callable, List, Literal, Tuple\nimport os\n\nclass Iterator(xgboost.DataIter):\n    \"\"\"A custom iterator for loading files in batches.\"\"\"\n\n    def __init__(self, device: Literal['cpu', 'cuda'], file_paths: List[Tuple[str, str]]) -> None:\n        self.device = device\n        self._file_paths = file_paths\n        self._it = 0\n        super().__init__(cache_prefix=os.path.join('.', 'cache'))\n\n    def load_file(self) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Load a single batch of data.\"\"\"\n        X_path, y_path = self._file_paths[self._it]\n        if self.device == 'cpu':\n            X = np.load(X_path)\n            y = np.load(y_path)\n        else:\n            X = cp.load(X_path)\n            y = cp.load(y_path)\n        assert X.shape[0] == y.shape[0]\n        return (X, y)\n\n    def next(self, input_data: Callable) -> bool:\n        \"\"\"Advance the iterator by 1 step and pass the data to XGBoost.  This function\n        is called by XGBoost during the construction of ``DMatrix``\n\n        \"\"\"\n        if self._it == len(self._file_paths):\n            return False\n        X, y = self.load_file()\n        input_data(data=X, label=y)\n        self._it += 1\n        return True\n\n    def reset(self) -> None:\n        \"\"\"Reset the iterator to its beginning\"\"\"\n        self._it = 0\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass ChromaEmbeddingFunction:\n    '''Chroma Embedding Function.\n    Embeds the text of the chunks using the embedding model and \n    adds the embeddings to the chunks for use in downstream tasks\n    like upserting into a vector database.\n    Args:\n        embedding_model: The embedding model to use.\n        **kwargs: Additional keyword arguments.\n    '''\n\n    def __init__(self, embedding_model: Union[str, BaseEmbeddings]='minishlab/potion-retrieval-32M', **kwargs: Dict[str, Any]) -> None:\n        '''Initialize the ChromaEmbeddingFunction.'''\n        pass\n\n    def name(self) -> str:\n        '''Return the name of the embedding model for ChromaDB compatibility.'''\n        pass\n\n    def __call__(self, input: Union[str, List[str]]) -> Union['np.ndarray', List['np.ndarray']]:\n        '''Call the ChromaEmbeddingFunction.'''\n        pass"
  }
]