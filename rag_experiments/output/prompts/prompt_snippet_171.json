[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Type(IntEnum):\n    '''[Type] L2TP Type'''\n    @staticmethod\n    def get(key: 'int | str', default: 'int'=-1) -> 'Type':\n        '''Backport support for original codes.\n        Args:\n            key: Key to get enum item.\n            default: Default value if not found.\n        :meta private:\n                        '''\n                        pass\n    @classmethod\n    def _missing_(cls, value: 'int') -> 'Type':\n        '''Lookup function used when value is not found.\n        Args:\n            value: Value to get enum item.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom aenum import IntEnum, extend_enum\n\nclass Type(IntEnum):\n    \"\"\"[Type] L2TP Type\"\"\"\n    Control = 0\n    Data = 1\n\n    @staticmethod\n    def get(key: 'int | str', default: 'int'=-1) -> 'Type':\n        \"\"\"Backport support for original codes.\n\n        Args:\n            key: Key to get enum item.\n            default: Default value if not found.\n\n        :meta private:\n        \"\"\"\n        if isinstance(key, int):\n            return Type(key)\n        if key not in Type._member_map_:\n            return extend_enum(Type, key, default)\n        return Type[key]\n\n    @classmethod\n    def _missing_(cls, value: 'int') -> 'Type':\n        \"\"\"Lookup function used when value is not found.\n\n        Args:\n            value: Value to get enum item.\n\n        \"\"\"\n        if not (isinstance(value, int) and 0 <= value <= 1):\n            raise ValueError('%r is not a valid %s' % (value, cls.__name__))\n        return extend_enum(cls, 'Unassigned_%d' % value, value)\n\nExample skeleton:\n\n\nclass AttributeTypes(ObjectCollectionABC):\n    '''AttributeTypes Collection.\n    # Example of params input\n    {\n        \"result_limit\": 100,  # Limit the retrieved results.\n        \"result_start\": 10,  # Starting count used for pagination.\n        \"fields\": [\"caseId\", \"summary\"]  # Select additional return fields.\n    }\n    Args:\n        session (Session): Session object configured with TC API Auth.\n        tql_filters (list): List of TQL filters.\n        params (dict): Additional query params (see example above).\n    '''\n\n    def __init__(self, **kwargs):\n        '''Initialize instance properties.'''\n        pass\n\n    def __iter__(self) -> Iterator[AttributeType]:\n        '''Return CM objects.'''\n        pass\n    @property\n    def _api_endpoint(self) -> str:\n        '''Return the type specific API endpoint.'''\n        pass\n    @property\n    def filter(self) -> AttributeTypeFilter:\n        '''Return the type specific filter object.'''\n        pass\nCorresponding class implementation:\n\nfrom tcex.api.tc.v3.object_collection_abc import ObjectCollectionABC\nfrom tcex.api.tc.v3.attribute_types.attribute_type_filter import AttributeTypeFilter\nfrom tcex.api.tc.v3.api_endpoints import ApiEndpoints\nfrom tcex.api.tc.v3.attribute_types.attribute_type_model import AttributeTypeModel, AttributeTypesModel\nfrom collections.abc import Iterator\n\nclass AttributeTypes(ObjectCollectionABC):\n    \"\"\"AttributeTypes Collection.\n\n    # Example of params input\n    {\n        \"result_limit\": 100,  # Limit the retrieved results.\n        \"result_start\": 10,  # Starting count used for pagination.\n        \"fields\": [\"caseId\", \"summary\"]  # Select additional return fields.\n    }\n\n    Args:\n        session (Session): Session object configured with TC API Auth.\n        tql_filters (list): List of TQL filters.\n        params (dict): Additional query params (see example above).\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize instance properties.\"\"\"\n        super().__init__(kwargs.pop('session', None), kwargs.pop('tql_filter', None), kwargs.pop('params', None))\n        self._model = AttributeTypesModel(**kwargs)\n        self.type_ = 'attribute_types'\n\n    def __iter__(self) -> Iterator[AttributeType]:\n        \"\"\"Return CM objects.\"\"\"\n        return self.iterate(base_class=AttributeType)\n\n    @property\n    def _api_endpoint(self) -> str:\n        \"\"\"Return the type specific API endpoint.\"\"\"\n        return ApiEndpoints.ATTRIBUTE_TYPES.value\n\n    @property\n    def filter(self) -> AttributeTypeFilter:\n        \"\"\"Return the type specific filter object.\"\"\"\n        return AttributeTypeFilter(self.tql)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass VersionComparator:\n    '''版本号比较器\n    支持语义化版本号比较，自动处理snapshot版本，并支持向前兼容性检查\n    '''\n    @staticmethod\n    def normalize_version(version: str) -> str:\n        '''标准化版本号，移除snapshot标识\n        Args:\n            version: 原始版本号，如 \"0.8.0-snapshot.1\"\n        Returns:\n            str: 标准化后的版本号，如 \"0.8.0\"\n        '''\n        pass\n    @staticmethod\n    def parse_version(version: str) -> Tuple[int, int, int]:\n        '''解析版本号为元组\n        Args:\n            version: 版本号字符串\n        Returns:\n            Tuple[int, int, int]: (major, minor, patch)\n        '''\n        pass\n    @staticmethod\n    def compare_versions(version1: str, version2: str) -> int:\n        '''比较两个版本号\n        Args:\n            version1: 第一个版本号\n            version2: 第二个版本号\n        Returns:\n            int: -1 if version1 < version2, 0 if equal, 1 if version1 > version2\n        '''\n        pass\n    @staticmethod\n    def check_forward_compatibility(current_version: str, max_version: str) -> Tuple[bool, str]:\n        '''检查向前兼容性（仅使用兼容性映射表）\n        Args:\n            current_version: 当前版本\n            max_version: 插件声明的最大支持版本\n        Returns:\n            Tuple[bool, str]: (是否兼容, 兼容信息)\n        '''\n        pass\n    @staticmethod\n    def is_version_in_range(version: str, min_version: str='', max_version: str='') -> Tuple[bool, str]:\n        '''检查版本是否在指定范围内，支持兼容性检查\n        Args:\n            version: 要检查的版本号\n            min_version: 最小版本号（可选）\n            max_version: 最大版本号（可选）\n        Returns:\n            Tuple[bool, str]: (是否兼容, 错误信息或兼容信息)\n        '''\n        pass\n    @staticmethod\n    def get_current_host_version() -> str:\n        '''获取当前主机应用版本\n        Returns:\n            str: 当前版本号\n        '''\n        pass\n    @staticmethod\n    def add_compatibility_mapping(base_version: str, compatible_versions: list) -> None:\n        '''动态添加兼容性映射\n        Args:\n            base_version: 基础版本（插件声明的最大支持版本）\n            compatible_versions: 兼容的版本列表\n        '''\n        pass\n    @staticmethod\n    def get_compatibility_info() -> Dict[str, list]:\n        '''获取当前的兼容性映射表\n        Returns:\n            Dict[str, list]: 兼容性映射表的副本\n        '''\n        pass"
  }
]