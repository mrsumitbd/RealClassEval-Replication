[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass ThreadABC(metaclass=abc.ABCMeta):\n    '''Implemented by thread-like classes.\n    This is private to implement.\n    '''\n    @property\n    @abc.abstractmethod\n    def session(self) -> _session.Session:\n        '''The session to use when making requests.'''\n        pass\n    @property\n    @abc.abstractmethod\n    def id(self) -> str:\n        '''The unique identifier of the thread.'''\n        pass\n    @abc.abstractmethod\n    def _to_send_data(self) -> MutableMapping[str, str]:\n        pass\n    @abc.abstractmethod\n    def _copy(self) -> 'ThreadABC':\n        '''It may or may not be a good idea to attach the current thread to new objects.\n        So for now, we use this method to create a new thread.\n        This should return the minimal representation of the thread (e.g. not UserData).\n        '''\n        pass\n\n    def fetch(self):\n        pass\n\n    def wave(self, first: bool=True) -> str:\n        '''Wave hello to the thread.\n        Args:\n            first: Whether to wave first or wave back\n        Example:\n            Wave back to the thread.\n            >>> thread.wave(False)\n        '''\n        pass\n\n    def send_text(self, text: str, mentions: Iterable['_models.Mention']=None, files: Iterable[Tuple[str, str]]=None, reply_to_id: str=None) -> str:\n        '''Send a message to the thread.\n        Args:\n            text: Text to send\n            mentions: Optional mentions\n            files: Optional tuples, each containing an uploaded file's ID and mimetype.\n                See `ThreadABC.send_files` for an example.\n            reply_to_id: Optional message to reply to\n        Example:\n            Send a message with a mention to a thread.\n            >>> mention = fbchat.Mention(thread_id=\"1234\", offset=5, length=2)\n            >>> message_id = thread.send_text(\"A message\", mentions=[mention])\n            Reply to the message.\n            >>> thread.send_text(\"A reply\", reply_to_id=message_id)\n        Returns:\n            The sent message\n        '''\n        pass\n\n    def send_emoji(self, emoji: str, size: '_models.EmojiSize') -> str:\n        '''Send an emoji to the thread.\n        Args:\n            emoji: The emoji to send\n            size: The size of the emoji\n        Example:\n            >>> thread.send_emoji(\"ğŸ˜€\", size=fbchat.EmojiSize.LARGE)\n        Returns:\n            The sent message\n        '''\n        pass\n\n    def send_sticker(self, sticker_id: str) -> str:\n        '''Send a sticker to the thread.\n        Args:\n            sticker_id: ID of the sticker to send\n        Example:\n            Send a sticker with the id \"1889713947839631\"\n            >>> thread.send_sticker(\"1889713947839631\")\n        Returns:\n            The sent message\n        '''\n        pass\n\n    def _send_location(self, current, latitude, longitude):\n        pass\n\n    def send_location(self, latitude: float, longitude: float):\n        '''Send a given location to a thread as the user's current location.\n        Args:\n            latitude: The location latitude\n            longitude: The location longitude\n        Example:\n            Send a location in London, United Kingdom.\n            >>> thread.send_location(51.5287718, -0.2416815)\n        '''\n        pass\n\n    def send_pinned_location(self, latitude: float, longitude: float):\n        '''Send a given location to a thread as a pinned location.\n        Args:\n            latitude: The location latitude\n            longitude: The location longitude\n        Example:\n            Send a pinned location in Beijing, China.\n            >>> thread.send_pinned_location(39.9390731, 116.117273)\n        '''\n        pass\n\n    def send_files(self, files: Iterable[Tuple[str, str]]):\n        '''Send files from file IDs to a thread.\n        `files` should be a list of tuples, with a file's ID and mimetype.\n        Example:\n            Upload and send a video to a thread.\n            >>> with open(\"video.mp4\", \"rb\") as f:\n            ...     files = client.upload([(\"video.mp4\", f, \"video/mp4\")])\n            >>>\n            >>> thread.send_files(files)\n        '''\n        pass\n\n    def _search_messages(self, query, offset, limit):\n        pass\n\n    def search_messages(self, query: str, limit: int) -> Iterable[_models.MessageSnippet]:\n        '''Find and get message IDs by query.\n        Warning! If someone send a message to the thread that matches the query, while\n        we're searching, some snippets will get returned twice.\n        This is fundamentally not fixable, it's just how the endpoint is implemented.\n        The returned message snippets are ordered by last sent first.\n        Args:\n            query: Text to search for\n            limit: Max. number of message snippets to retrieve\n        Example:\n            Fetch the latest message in the thread that matches the query.\n            >>> (message,) = thread.search_messages(\"abc\", limit=1)\n            >>> message.text\n            \"Some text and abc\"\n        '''\n        pass\n\n    def _fetch_messages(self, limit, before):\n        pass\n\n    def fetch_messages(self, limit: Optional[int]) -> Iterable['_models.Message']:\n        '''Fetch messages in a thread.\n        The returned messages are ordered by last sent first.\n        Args:\n            limit: Max. number of threads to retrieve. If ``None``, all threads will be\n                retrieved.\n        Example:\n            >>> for message in thread.fetch_messages(limit=5)\n            ...     print(message.text)\n            ...\n            A message\n            Another message\n            None\n            A fourth message\n        '''\n        pass\n\n    def _fetch_images(self, limit, after):\n        pass\n\n    def fetch_images(self, limit: Optional[int]) -> Iterable['_models.Attachment']:\n        '''Fetch images/videos posted in the thread.\n        The returned images are ordered by last sent first.\n        Args:\n            limit: Max. number of images to retrieve. If ``None``, all images will be\n                retrieved.\n        Example:\n            >>> for image in thread.fetch_messages(limit=3)\n            ...     print(image.id)\n            ...\n            1234\n            2345\n        '''\n        pass\n\n    def set_nickname(self, user_id: str, nickname: str):\n        '''Change the nickname of a user in the thread.\n        Args:\n            user_id: User that will have their nickname changed\n            nickname: New nickname\n        Example:\n            >>> thread.set_nickname(\"1234\", \"A nickname\")\n        '''\n        pass\n\n    def set_color(self, color: str):\n        '''Change thread color.\n        The new color must be one of the following::\n            \"#0084ff\", \"#44bec7\", \"#ffc300\", \"#fa3c4c\", \"#d696bb\", \"#6699cc\",\n            \"#13cf13\", \"#ff7e29\", \"#e68585\", \"#7646ff\", \"#20cef5\", \"#67b868\",\n            \"#d4a88c\", \"#ff5ca1\", \"#a695c7\", \"#ff7ca8\", \"#1adb5b\", \"#f01d6a\",\n            \"#ff9c19\" or \"#0edcde\".\n        This list is subject to change in the future!\n        The default when creating a new thread is ``\"#0084ff\"``.\n        Args:\n            color: New thread color\n        Example:\n            Set the thread color to \"Coral Pink\".\n            >>> thread.set_color(\"#e68585\")\n        '''\n        pass\n\n    def set_emoji(self, emoji: Optional[str]):\n        '''Change thread emoji.\n        Args:\n            emoji: New thread emoji. If ``None``, will be set to the default \"LIKE\" icon\n        Example:\n            Set the thread emoji to \"ğŸ˜Š\".\n            >>> thread.set_emoji(\"ğŸ˜Š\")\n        '''\n        pass\n\n    def forward_attachment(self, attachment_id: str):\n        '''Forward an attachment.\n        Args:\n            attachment_id: Attachment ID to forward\n        Example:\n            >>> thread.forward_attachment(\"1234\")\n        '''\n        pass\n\n    def _set_typing(self, typing):\n        pass\n\n    def start_typing(self):\n        '''Set the current user to start typing in the thread.\n        Example:\n            >>> thread.start_typing()\n        '''\n        pass\n\n    def stop_typing(self):\n        '''Set the current user to stop typing in the thread.\n        Example:\n            >>> thread.stop_typing()\n        '''\n        pass\n\n    def create_plan(self, name: str, at: datetime.datetime, location_name: str=None, location_id: str=None):\n        '''Create a new plan.\n        # TODO: Arguments\n        Args:\n            name: Name of the new plan\n            at: When the plan is for\n        Example:\n            >>> thread.create_plan(...)\n        '''\n        pass\n\n    def create_poll(self, question: str, options: Mapping[str, bool]):\n        '''Create poll in a thread.\n        Args:\n            question: The question\n            options: Options and whether you want to select the option\n        Example:\n            >>> thread.create_poll(\"Test poll\", {\"Option 1\": True, \"Option 2\": False})\n        '''\n        pass\n\n    def mute(self, duration: datetime.timedelta=None):\n        '''Mute the thread.\n        Args:\n            duration: Time to mute, use ``None`` to mute forever\n        Example:\n            >>> import datetime\n            >>> thread.mute(datetime.timedelta(days=2))\n        '''\n        pass\n\n    def unmute(self):\n        '''Unmute the thread.\n        Example:\n            >>> thread.unmute()\n        '''\n        pass\n\n    def _mute_reactions(self, mode: bool):\n        pass\n\n    def mute_reactions(self):\n        '''Mute thread reactions.'''\n        pass\n\n    def unmute_reactions(self):\n        '''Unmute thread reactions.'''\n        pass\n\n    def _mute_mentions(self, mode: bool):\n        pass\n\n    def mute_mentions(self):\n        '''Mute thread mentions.'''\n        pass\n\n    def unmute_mentions(self):\n        '''Unmute thread mentions.'''\n        pass\n\n    def mark_as_spam(self):\n        '''Mark the thread as spam, and delete it.'''\n        pass\n    @staticmethod\n    def _delete_many(session, thread_ids):\n        pass\n\n    def delete(self):\n        '''Delete the thread.\n        If you want to delete multiple threads, please use `Client.delete_threads`.\n        Example:\n            >>> message.delete()\n        '''\n        pass\n\n    def _forced_fetch(self, message_id: str) -> dict:\n        pass\n    @staticmethod\n    def _parse_color(inp: Optional[str]) -> str:\n        pass\n    @staticmethod\n    def _parse_customization_info(data: Any) -> MutableMapping[str, Any]:\n        pass\n    @staticmethod\n    def _parse_participants(session, data) -> Iterable['ThreadABC']:\n        pass\nCorresponding class implementation:\n\nimport abc\nimport datetime\nimport collections\nfrom .. import _util, _exception, _session, _graphql, _models\nfrom typing import MutableMapping, Mapping, Any, Iterable, Tuple, Optional\nfrom .._common import log, attrs_default\n\nclass ThreadABC(metaclass=abc.ABCMeta):\n    \"\"\"Implemented by thread-like classes.\n\n    This is private to implement.\n    \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def session(self) -> _session.Session:\n        \"\"\"The session to use when making requests.\"\"\"\n        raise NotImplementedError\n\n    @property\n    @abc.abstractmethod\n    def id(self) -> str:\n        \"\"\"The unique identifier of the thread.\"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def _to_send_data(self) -> MutableMapping[str, str]:\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def _copy(self) -> 'ThreadABC':\n        \"\"\"It may or may not be a good idea to attach the current thread to new objects.\n\n        So for now, we use this method to create a new thread.\n\n        This should return the minimal representation of the thread (e.g. not UserData).\n        \"\"\"\n        raise NotImplementedError\n\n    def fetch(self):\n        raise NotImplementedError\n\n    def wave(self, first: bool=True) -> str:\n        \"\"\"Wave hello to the thread.\n\n        Args:\n            first: Whether to wave first or wave back\n\n        Example:\n            Wave back to the thread.\n\n            >>> thread.wave(False)\n        \"\"\"\n        data = self._to_send_data()\n        data['action_type'] = 'ma-type:user-generated-message'\n        data['lightweight_action_attachment[lwa_state]'] = 'INITIATED' if first else 'RECIPROCATED'\n        data['lightweight_action_attachment[lwa_type]'] = 'WAVE'\n        message_id, thread_id = self.session._do_send_request(data)\n        return message_id\n\n    def send_text(self, text: str, mentions: Iterable['_models.Mention']=None, files: Iterable[Tuple[str, str]]=None, reply_to_id: str=None) -> str:\n        \"\"\"Send a message to the thread.\n\n        Args:\n            text: Text to send\n            mentions: Optional mentions\n            files: Optional tuples, each containing an uploaded file's ID and mimetype.\n                See `ThreadABC.send_files` for an example.\n            reply_to_id: Optional message to reply to\n\n        Example:\n            Send a message with a mention to a thread.\n\n            >>> mention = fbchat.Mention(thread_id=\"1234\", offset=5, length=2)\n            >>> message_id = thread.send_text(\"A message\", mentions=[mention])\n\n            Reply to the message.\n\n            >>> thread.send_text(\"A reply\", reply_to_id=message_id)\n\n        Returns:\n            The sent message\n        \"\"\"\n        data = self._to_send_data()\n        data['action_type'] = 'ma-type:user-generated-message'\n        if text is not None:\n            data['body'] = text\n        for i, mention in enumerate(mentions or ()):\n            data.update(mention._to_send_data(i))\n        if files:\n            data['has_attachment'] = True\n        for i, (file_id, mimetype) in enumerate(files or ()):\n            data['{}s[{}]'.format(_util.mimetype_to_key(mimetype), i)] = file_id\n        if reply_to_id:\n            data['replied_to_message_id'] = reply_to_id\n        return self.session._do_send_request(data)\n\n    def send_emoji(self, emoji: str, size: '_models.EmojiSize') -> str:\n        \"\"\"Send an emoji to the thread.\n\n        Args:\n            emoji: The emoji to send\n            size: The size of the emoji\n\n        Example:\n            >>> thread.send_emoji(\"ğŸ˜€\", size=fbchat.EmojiSize.LARGE)\n\n        Returns:\n            The sent message\n        \"\"\"\n        data = self._to_send_data()\n        data['action_type'] = 'ma-type:user-generated-message'\n        data['body'] = emoji\n        data['tags[0]'] = 'hot_emoji_size:{}'.format(size.name.lower())\n        return self.session._do_send_request(data)\n\n    def send_sticker(self, sticker_id: str) -> str:\n        \"\"\"Send a sticker to the thread.\n\n        Args:\n            sticker_id: ID of the sticker to send\n\n        Example:\n            Send a sticker with the id \"1889713947839631\"\n\n            >>> thread.send_sticker(\"1889713947839631\")\n\n        Returns:\n            The sent message\n        \"\"\"\n        data = self._to_send_data()\n        data['action_type'] = 'ma-type:user-generated-message'\n        data['sticker_id'] = sticker_id\n        return self.session._do_send_request(data)\n\n    def _send_location(self, current, latitude, longitude):\n        data = self._to_send_data()\n        data['action_type'] = 'ma-type:user-generated-message'\n        data['location_attachment[coordinates][latitude]'] = latitude\n        data['location_attachment[coordinates][longitude]'] = longitude\n        data['location_attachment[is_current_location]'] = current\n        return self.session._do_send_request(data)\n\n    def send_location(self, latitude: float, longitude: float):\n        \"\"\"Send a given location to a thread as the user's current location.\n\n        Args:\n            latitude: The location latitude\n            longitude: The location longitude\n\n        Example:\n            Send a location in London, United Kingdom.\n\n            >>> thread.send_location(51.5287718, -0.2416815)\n        \"\"\"\n        self._send_location(True, latitude=latitude, longitude=longitude)\n\n    def send_pinned_location(self, latitude: float, longitude: float):\n        \"\"\"Send a given location to a thread as a pinned location.\n\n        Args:\n            latitude: The location latitude\n            longitude: The location longitude\n\n        Example:\n            Send a pinned location in Beijing, China.\n\n            >>> thread.send_pinned_location(39.9390731, 116.117273)\n        \"\"\"\n        self._send_location(False, latitude=latitude, longitude=longitude)\n\n    def send_files(self, files: Iterable[Tuple[str, str]]):\n        \"\"\"Send files from file IDs to a thread.\n\n        `files` should be a list of tuples, with a file's ID and mimetype.\n\n        Example:\n            Upload and send a video to a thread.\n\n            >>> with open(\"video.mp4\", \"rb\") as f:\n            ...     files = client.upload([(\"video.mp4\", f, \"video/mp4\")])\n            >>>\n            >>> thread.send_files(files)\n        \"\"\"\n        return self.send_text(text=None, files=files)\n\n    def _search_messages(self, query, offset, limit):\n        data = {'query': query, 'snippetOffset': offset, 'snippetLimit': limit, 'identifier': 'thread_fbid', 'thread_fbid': self.id}\n        j = self.session._payload_post('/ajax/mercury/search_snippets.php?dpr=1', data)\n        result = j['search_snippets'][query].get(self.id)\n        if not result:\n            return (0, [])\n        thread = self._copy()\n        snippets = [_models.MessageSnippet._parse(thread, snippet) for snippet in result['snippets']]\n        return (result['num_total_snippets'], snippets)\n\n    def search_messages(self, query: str, limit: int) -> Iterable[_models.MessageSnippet]:\n        \"\"\"Find and get message IDs by query.\n\n        Warning! If someone send a message to the thread that matches the query, while\n        we're searching, some snippets will get returned twice.\n\n        This is fundamentally not fixable, it's just how the endpoint is implemented.\n\n        The returned message snippets are ordered by last sent first.\n\n        Args:\n            query: Text to search for\n            limit: Max. number of message snippets to retrieve\n\n        Example:\n            Fetch the latest message in the thread that matches the query.\n\n            >>> (message,) = thread.search_messages(\"abc\", limit=1)\n            >>> message.text\n            \"Some text and abc\"\n        \"\"\"\n        offset = 0\n        for limit in _util.get_limits(limit, max_limit=50):\n            _, snippets = self._search_messages(query, offset, limit)\n            yield from snippets\n            if len(snippets) < limit:\n                return\n            offset += limit\n\n    def _fetch_messages(self, limit, before):\n        params = {'id': self.id, 'message_limit': limit, 'load_messages': True, 'load_read_receipts': True, 'before': _util.datetime_to_millis(before) if before else None}\n        j, = self.session._graphql_requests(_graphql.from_doc_id('1860982147341344', params))\n        if j.get('message_thread') is None:\n            raise _exception.ParseError('Could not fetch messages', data=j)\n        read_receipts = j['message_thread']['read_receipts']['nodes']\n        thread = self._copy()\n        return [_models.MessageData._from_graphql(thread, message, read_receipts) for message in j['message_thread']['messages']['nodes']]\n\n    def fetch_messages(self, limit: Optional[int]) -> Iterable['_models.Message']:\n        \"\"\"Fetch messages in a thread.\n\n        The returned messages are ordered by last sent first.\n\n        Args:\n            limit: Max. number of threads to retrieve. If ``None``, all threads will be\n                retrieved.\n\n        Example:\n            >>> for message in thread.fetch_messages(limit=5)\n            ...     print(message.text)\n            ...\n            A message\n            Another message\n            None\n            A fourth message\n        \"\"\"\n        MAX_BATCH_LIMIT = 100\n        before = None\n        for limit in _util.get_limits(limit, MAX_BATCH_LIMIT):\n            messages = self._fetch_messages(limit, before)\n            messages.reverse()\n            if before:\n                yield from messages[1:]\n            else:\n                yield from messages\n            if len(messages) < MAX_BATCH_LIMIT:\n                return\n            before = messages[-1].created_at\n\n    def _fetch_images(self, limit, after):\n        data = {'id': self.id, 'first': limit, 'after': after}\n        j, = self.session._graphql_requests(_graphql.from_query_id('515216185516880', data))\n        if not j[self.id]:\n            raise _exception.ParseError('Could not find images', data=j)\n        result = j[self.id]['message_shared_media']\n        rtn = []\n        for edge in result['edges']:\n            node = edge['node']\n            type_ = node['__typename']\n            if type_ == 'MessageImage':\n                rtn.append(_models.ImageAttachment._from_list(node))\n            elif type_ == 'MessageVideo':\n                rtn.append(_models.VideoAttachment._from_list(node))\n            else:\n                log.warning('Unknown image type %s, data: %s', type_, edge)\n                rtn.append(None)\n        return (result['page_info']['end_cursor'], rtn)\n\n    def fetch_images(self, limit: Optional[int]) -> Iterable['_models.Attachment']:\n        \"\"\"Fetch images/videos posted in the thread.\n\n        The returned images are ordered by last sent first.\n\n        Args:\n            limit: Max. number of images to retrieve. If ``None``, all images will be\n                retrieved.\n\n        Example:\n            >>> for image in thread.fetch_messages(limit=3)\n            ...     print(image.id)\n            ...\n            1234\n            2345\n        \"\"\"\n        cursor = None\n        for limit in _util.get_limits(limit, max_limit=1000):\n            cursor, images = self._fetch_images(limit, cursor)\n            if not images:\n                return\n            for image in images:\n                if image:\n                    yield image\n\n    def set_nickname(self, user_id: str, nickname: str):\n        \"\"\"Change the nickname of a user in the thread.\n\n        Args:\n            user_id: User that will have their nickname changed\n            nickname: New nickname\n\n        Example:\n            >>> thread.set_nickname(\"1234\", \"A nickname\")\n        \"\"\"\n        data = {'nickname': nickname, 'participant_id': user_id, 'thread_or_other_fbid': self.id}\n        j = self.session._payload_post('/messaging/save_thread_nickname/?source=thread_settings&dpr=1', data)\n\n    def set_color(self, color: str):\n        \"\"\"Change thread color.\n\n        The new color must be one of the following::\n\n            \"#0084ff\", \"#44bec7\", \"#ffc300\", \"#fa3c4c\", \"#d696bb\", \"#6699cc\",\n            \"#13cf13\", \"#ff7e29\", \"#e68585\", \"#7646ff\", \"#20cef5\", \"#67b868\",\n            \"#d4a88c\", \"#ff5ca1\", \"#a695c7\", \"#ff7ca8\", \"#1adb5b\", \"#f01d6a\",\n            \"#ff9c19\" or \"#0edcde\".\n\n        This list is subject to change in the future!\n\n        The default when creating a new thread is ``\"#0084ff\"``.\n\n        Args:\n            color: New thread color\n\n        Example:\n            Set the thread color to \"Coral Pink\".\n\n            >>> thread.set_color(\"#e68585\")\n        \"\"\"\n        if color not in SETABLE_COLORS:\n            raise ValueError('Invalid color! Please use one of: {}'.format(SETABLE_COLORS))\n        if color == DEFAULT_COLOR:\n            color = ''\n        data = {'color_choice': color, 'thread_or_other_fbid': self.id}\n        j = self.session._payload_post('/messaging/save_thread_color/?source=thread_settings&dpr=1', data)\n\n    def set_emoji(self, emoji: Optional[str]):\n        \"\"\"Change thread emoji.\n\n        Args:\n            emoji: New thread emoji. If ``None``, will be set to the default \"LIKE\" icon\n\n        Example:\n            Set the thread emoji to \"ğŸ˜Š\".\n\n            >>> thread.set_emoji(\"ğŸ˜Š\")\n        \"\"\"\n        data = {'emoji_choice': emoji, 'thread_or_other_fbid': self.id}\n        j = self.session._payload_post('/messaging/save_thread_emoji/?source=thread_settings&dpr=1', data)\n\n    def forward_attachment(self, attachment_id: str):\n        \"\"\"Forward an attachment.\n\n        Args:\n            attachment_id: Attachment ID to forward\n\n        Example:\n            >>> thread.forward_attachment(\"1234\")\n        \"\"\"\n        data = {'attachment_id': attachment_id, 'recipient_map[{}]'.format(_util.generate_offline_threading_id()): self.id}\n        j = self.session._payload_post('/mercury/attachments/forward/', data)\n        if not j.get('success'):\n            raise _exception.ExternalError('Failed forwarding attachment', j['error'])\n\n    def _set_typing(self, typing):\n        data = {'typ': '1' if typing else '0', 'thread': self.id, 'source': 'mercury-chat'}\n        j = self.session._payload_post('/ajax/messaging/typ.php', data)\n\n    def start_typing(self):\n        \"\"\"Set the current user to start typing in the thread.\n\n        Example:\n            >>> thread.start_typing()\n        \"\"\"\n        self._set_typing(True)\n\n    def stop_typing(self):\n        \"\"\"Set the current user to stop typing in the thread.\n\n        Example:\n            >>> thread.stop_typing()\n        \"\"\"\n        self._set_typing(False)\n\n    def create_plan(self, name: str, at: datetime.datetime, location_name: str=None, location_id: str=None):\n        \"\"\"Create a new plan.\n\n        # TODO: Arguments\n\n        Args:\n            name: Name of the new plan\n            at: When the plan is for\n\n        Example:\n            >>> thread.create_plan(...)\n        \"\"\"\n        return _models.Plan._create(self, name, at, location_name, location_id)\n\n    def create_poll(self, question: str, options: Mapping[str, bool]):\n        \"\"\"Create poll in a thread.\n\n        Args:\n            question: The question\n            options: Options and whether you want to select the option\n\n        Example:\n            >>> thread.create_poll(\"Test poll\", {\"Option 1\": True, \"Option 2\": False})\n        \"\"\"\n        data = collections.OrderedDict([('question_text', question), ('target_id', self.id)])\n        for i, (text, vote) in enumerate(options.items()):\n            data['option_text_array[{}]'.format(i)] = text\n            data['option_is_selected_array[{}]'.format(i)] = '1' if vote else '0'\n        j = self.session._payload_post('/messaging/group_polling/create_poll/?dpr=1', data)\n        if j.get('status') != 'success':\n            raise _exception.ExternalError('Failed creating poll: {}'.format(j.get('errorTitle')), j.get('errorMessage'))\n\n    def mute(self, duration: datetime.timedelta=None):\n        \"\"\"Mute the thread.\n\n        Args:\n            duration: Time to mute, use ``None`` to mute forever\n\n        Example:\n            >>> import datetime\n            >>> thread.mute(datetime.timedelta(days=2))\n        \"\"\"\n        if duration is None:\n            setting = '-1'\n        else:\n            setting = str(_util.timedelta_to_seconds(duration))\n        data = {'mute_settings': setting, 'thread_fbid': self.id}\n        j = self.session._payload_post('/ajax/mercury/change_mute_thread.php?dpr=1', data)\n\n    def unmute(self):\n        \"\"\"Unmute the thread.\n\n        Example:\n            >>> thread.unmute()\n        \"\"\"\n        return self.mute(datetime.timedelta(0))\n\n    def _mute_reactions(self, mode: bool):\n        data = {'reactions_mute_mode': '1' if mode else '0', 'thread_fbid': self.id}\n        j = self.session._payload_post('/ajax/mercury/change_reactions_mute_thread/?dpr=1', data)\n\n    def mute_reactions(self):\n        \"\"\"Mute thread reactions.\"\"\"\n        self._mute_reactions(True)\n\n    def unmute_reactions(self):\n        \"\"\"Unmute thread reactions.\"\"\"\n        self._mute_reactions(False)\n\n    def _mute_mentions(self, mode: bool):\n        data = {'mentions_mute_mode': '1' if mode else '0', 'thread_fbid': self.id}\n        j = self.session._payload_post('/ajax/mercury/change_mentions_mute_thread/?dpr=1', data)\n\n    def mute_mentions(self):\n        \"\"\"Mute thread mentions.\"\"\"\n        self._mute_mentions(True)\n\n    def unmute_mentions(self):\n        \"\"\"Unmute thread mentions.\"\"\"\n        self._mute_mentions(False)\n\n    def mark_as_spam(self):\n        \"\"\"Mark the thread as spam, and delete it.\"\"\"\n        data = {'id': self.id}\n        j = self.session._payload_post('/ajax/mercury/mark_spam.php?dpr=1', data)\n\n    @staticmethod\n    def _delete_many(session, thread_ids):\n        data = {}\n        for i, id_ in enumerate(thread_ids):\n            data['ids[{}]'.format(i)] = id_\n        j = session._payload_post('/ajax/mercury/delete_thread.php', data)\n\n    def delete(self):\n        \"\"\"Delete the thread.\n\n        If you want to delete multiple threads, please use `Client.delete_threads`.\n\n        Example:\n            >>> message.delete()\n        \"\"\"\n        self._delete_many(self.session, [self.id])\n\n    def _forced_fetch(self, message_id: str) -> dict:\n        params = {'thread_and_message_id': {'thread_id': self.id, 'message_id': message_id}}\n        j, = self.session._graphql_requests(_graphql.from_doc_id('1768656253222505', params))\n        return j\n\n    @staticmethod\n    def _parse_color(inp: Optional[str]) -> str:\n        if not inp:\n            return DEFAULT_COLOR\n        return '#{}'.format(inp[2:].lower())\n\n    @staticmethod\n    def _parse_customization_info(data: Any) -> MutableMapping[str, Any]:\n        if not data or not data.get('customization_info'):\n            return {'emoji': None, 'color': DEFAULT_COLOR}\n        info = data['customization_info']\n        rtn = {'emoji': info.get('emoji'), 'color': ThreadABC._parse_color(info.get('outgoing_bubble_color'))}\n        if data.get('thread_type') == 'GROUP' or data.get('is_group_thread') or data.get('thread_key', {}).get('thread_fbid'):\n            rtn['nicknames'] = {}\n            for k in info.get('participant_customizations', []):\n                rtn['nicknames'][k['participant_id']] = k.get('nickname')\n        elif info.get('participant_customizations'):\n            user_id = data.get('thread_key', {}).get('other_user_id') or data.get('id')\n            pc = info['participant_customizations']\n            if len(pc) > 0:\n                if pc[0].get('participant_id') == user_id:\n                    rtn['nickname'] = pc[0].get('nickname')\n                else:\n                    rtn['own_nickname'] = pc[0].get('nickname')\n            if len(pc) > 1:\n                if pc[1].get('participant_id') == user_id:\n                    rtn['nickname'] = pc[1].get('nickname')\n                else:\n                    rtn['own_nickname'] = pc[1].get('nickname')\n        return rtn\n\n    @staticmethod\n    def _parse_participants(session, data) -> Iterable['ThreadABC']:\n        from . import _user, _group, _page\n        for node in data['nodes']:\n            actor = node['messaging_actor']\n            typename = actor['__typename']\n            thread_id = actor['id']\n            if typename == 'User':\n                yield _user.User(session=session, id=thread_id)\n            elif typename == 'MessageThread':\n                yield _group.Group(session=session, id=thread_id)\n            elif typename == 'Page':\n                yield _page.Page(session=session, id=thread_id)\n            elif typename == 'Group':\n                pass\n            else:\n                log.warning('Unknown type %r in %s', typename, data)\n\nExample skeleton:\n\n\nclass ProjectContext(threading.local):\n    '''A configuration class to hold global configuration.'''\n\n    def __init__(self) -> None:\n        pass\n\n    def __del__(self):\n        pass\n    @property\n    def database(self) -> 'Database':\n        '''Current database.'''\n        pass\n    @property\n    def database_path(self) -> Path:\n        '''Path to the metadata storage directory.'''\n        pass\n    @property\n    def datadir(self) -> str:\n        '''Define a name of the folder for storing datasets.'''\n        pass\n    @datadir.setter\n    def datadir(self) -> str:\n        '''Set the current datadir.'''\n        pass\n    @property\n    def dataset_images_path(self) -> Path:\n        '''Return a ``Path`` instance of Renku dataset metadata folder.'''\n        pass\n    @property\n    def project_image_pathname(self) -> Path:\n        '''Return the path to the project's image file.'''\n        pass\n    @property\n    def dockerfile_path(self) -> Path:\n        '''Path to the Dockerfile.'''\n        pass\n    @property\n    def ssh_authorized_keys_path(self) -> Path:\n        '''Path to SSH authorized keys.'''\n        pass\n    @property\n    def global_config_dir(self) -> str:\n        '''Return user's config directory.'''\n        pass\n    @property\n    def global_config_path(self) -> Path:\n        '''Renku global (user's) config path.'''\n        pass\n    @property\n    def latest_agent(self) -> Optional[str]:\n        '''Returns latest agent version used in the repository.'''\n        pass\n    @property\n    def local_config_path(self) -> Path:\n        '''Renku local (project) config path.'''\n        pass\n    @property\n    def lock(self):\n        '''Create a Renku config lock.'''\n        pass\n    @property\n    def metadata_path(self) -> Path:\n        '''Current project's metadata (RENKU_HOME) path.'''\n        pass\n    @property\n    def path(self) -> Path:\n        '''Current project path.'''\n        pass\n    @property\n    def pointers_path(self) -> Path:\n        '''Return a ``Path`` instance of Renku pointer files folder.'''\n        pass\n    @property\n    def project_image_pathname(self) -> Path:\n        '''Return the Project instance.'''\n        pass\n    @property\n    def remote(self) -> 'ProjectRemote':\n        '''Return host, owner and name of the remote if it exists.'''\n        pass\n    @property\n    def repository(self) -> 'Repository':\n        '''Return current context's repository.'''\n        pass\n    @repository.setter\n    def repository(self) -> 'Repository':\n        '''Set the current repository.'''\n        pass\n    @property\n    def template_checksums_path(self):\n        '''Return a ``Path`` instance to the template checksums file.'''\n        pass\n    @property\n    def transaction_id(self) -> str:\n        '''Get a transaction id for the current context to be used for grouping git commits.'''\n        pass\n    @property\n    def _top(self) -> 'ProjectProperties':\n        '''Return current context.'''\n        pass\n\n    def has_context(self, path: Optional[Union[Path, str]]=None) -> bool:\n        '''Return if at least one context which is equal to path (if not None) is pushed.'''\n        pass\n\n    def clear(self) -> None:\n        '''Remove all contexts and reset the state without committing intermediate changes.\n        NOTE: This method should be used only in tests.\n        '''\n        pass\n\n    def pop_context(self) -> 'ProjectProperties':\n        '''Pop current project context from stack.\n        Returns:\n            Path: the popped project path.\n        '''\n        pass\n\n    def push_path(self, path: Union[Path, str], save_changes: bool=False) -> None:\n        '''Push a new project path to the stack.\n        Arguments:\n            path(Union[Path, str]): The path to push.\n            save_changes(bool): Whether to save changes to the database or not.\n        '''\n        pass\n\n    def replace_path(self, path: Union[Path, str]):\n        '''Replace the current project path with a new one if they are different.\n        Arguments:\n            path(Union[Path, str]): The path to replace with.\n        '''\n        pass\n    @contextlib.contextmanager\n    def with_path(self, path: Union[Path, str], save_changes: bool=False) -> Generator['ProjectProperties', None, None]:\n        '''Temporarily push a new project path to the stack.\n        Arguments:\n            path(Union[Path, str]): The path to push.\n            save_changes(bool): Whether to save changes to the database or not.\n        '''\n        pass\n    @contextlib.contextmanager\n    def with_rollback(self) -> Generator[None, None, None]:\n        '''Rollback to the current state.\n        NOTE: This won't work correctly if the current context is popped or swapped.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom typing import TYPE_CHECKING, Generator, List, NamedTuple, Optional, Union\nfrom pathlib import Path\nimport threading\nfrom renku.core.constant import APP_NAME, CONFIG_NAME, DATA_DIR_CONFIG_KEY, DATABASE_PATH, DATASET_IMAGES, DEFAULT_DATA_DIR, DOCKERFILE, IMAGES, LOCK_SUFFIX, POINTERS, RENKU_HOME, TEMPLATE_CHECKSUMS\nfrom renku.core import errors\nimport uuid\nimport contextlib\n\nclass ProjectContext(threading.local):\n    \"\"\"A configuration class to hold global configuration.\"\"\"\n    external_storage_requested = True\n    'External storage (e.g. LFS) requested for Renku command.'\n\n    def __init__(self) -> None:\n        self._context_stack: List[ProjectProperties] = []\n\n    def __del__(self):\n        self.clear()\n\n    @property\n    def database(self) -> 'Database':\n        \"\"\"Current database.\"\"\"\n        if not self._top.database:\n            from renku.infrastructure.database import Database\n            self._top.database = Database.from_path(self.database_path)\n        return self._top.database\n\n    @property\n    def database_path(self) -> Path:\n        \"\"\"Path to the metadata storage directory.\"\"\"\n        return self.metadata_path / DATABASE_PATH\n\n    @property\n    def datadir(self) -> str:\n        \"\"\"Define a name of the folder for storing datasets.\"\"\"\n        from renku.core.config import get_value\n        from renku.domain_model.enums import ConfigFilter\n        if not self._top.datadir:\n            datadir = get_value('renku', DATA_DIR_CONFIG_KEY, config_filter=ConfigFilter.LOCAL_ONLY)\n            self._top.datadir = datadir or DEFAULT_DATA_DIR\n        return self._top.datadir\n\n    @datadir.setter\n    def datadir(self, value: str):\n        \"\"\"Set the current datadir.\"\"\"\n        self._top.datadir = value\n\n    @property\n    def dataset_images_path(self) -> Path:\n        \"\"\"Return a ``Path`` instance of Renku dataset metadata folder.\"\"\"\n        return self.path / RENKU_HOME / DATASET_IMAGES\n\n    @property\n    def project_image_pathname(self) -> Path:\n        \"\"\"Return the path to the project's image file.\"\"\"\n        return self.path / RENKU_HOME / IMAGES / 'project' / '0.png'\n\n    @property\n    def dockerfile_path(self) -> Path:\n        \"\"\"Path to the Dockerfile.\"\"\"\n        return self.path / DOCKERFILE\n\n    @property\n    def ssh_authorized_keys_path(self) -> Path:\n        \"\"\"Path to SSH authorized keys.\"\"\"\n        return self.path / '.ssh' / 'authorized_keys'\n\n    @property\n    def global_config_dir(self) -> str:\n        \"\"\"Return user's config directory.\"\"\"\n        import click\n        return click.get_app_dir(APP_NAME, force_posix=True)\n\n    @property\n    def global_config_path(self) -> Path:\n        \"\"\"Renku global (user's) config path.\"\"\"\n        config = Path(self.global_config_dir)\n        if not config.exists():\n            config.mkdir(parents=True)\n        return config / CONFIG_NAME\n\n    @property\n    def latest_agent(self) -> Optional[str]:\n        \"\"\"Returns latest agent version used in the repository.\"\"\"\n        try:\n            return self.project.agent_version\n        except ValueError as e:\n            if 'Project name not set' in str(e):\n                return None\n            raise\n\n    @property\n    def local_config_path(self) -> Path:\n        \"\"\"Renku local (project) config path.\"\"\"\n        return self.metadata_path / CONFIG_NAME\n\n    @property\n    def lock(self):\n        \"\"\"Create a Renku config lock.\"\"\"\n        from renku.core.util.contexts import Lock\n        return Lock(filename=self.metadata_path.with_suffix(LOCK_SUFFIX), mode='exclusive')\n\n    @property\n    def metadata_path(self) -> Path:\n        \"\"\"Current project's metadata (RENKU_HOME) path.\"\"\"\n        return self.path / RENKU_HOME\n\n    @property\n    def path(self) -> Path:\n        \"\"\"Current project path.\"\"\"\n        return self._top.path\n\n    @property\n    def pointers_path(self) -> Path:\n        \"\"\"Return a ``Path`` instance of Renku pointer files folder.\"\"\"\n        path = self.path / RENKU_HOME / POINTERS\n        path.mkdir(exist_ok=True)\n        return path\n\n    @property\n    def project(self) -> 'Project':\n        \"\"\"Return the Project instance.\"\"\"\n        from renku.command.command_builder.command import inject\n        from renku.core.interface.project_gateway import IProjectGateway\n        project_gateway = inject.instance(IProjectGateway)\n        return project_gateway.get_project()\n\n    @property\n    def remote(self) -> 'ProjectRemote':\n        \"\"\"Return host, owner and name of the remote if it exists.\"\"\"\n        from renku.core.util.git import get_remote\n        repository = self.repository\n        remote = get_remote(repository=repository)\n        if not remote and len(repository.remotes) > 1:\n            remote = repository.remotes.get('origin')\n        return ProjectRemote.from_remote(remote=remote)\n\n    @property\n    def repository(self) -> 'Repository':\n        \"\"\"Return current context's repository.\"\"\"\n        if not self._top.repository:\n            from renku.infrastructure.repository import Repository\n            try:\n                self._top.repository = Repository(project_context.path)\n            except errors.GitError as e:\n                raise ValueError from e\n        return self._top.repository\n\n    @repository.setter\n    def repository(self, value: Optional['Repository']):\n        \"\"\"Set the current repository.\"\"\"\n        self._top.repository = value\n\n    @property\n    def template_checksums_path(self):\n        \"\"\"Return a ``Path`` instance to the template checksums file.\"\"\"\n        return self.metadata_path / TEMPLATE_CHECKSUMS\n\n    @property\n    def transaction_id(self) -> str:\n        \"\"\"Get a transaction id for the current context to be used for grouping git commits.\"\"\"\n        if not self._top.transaction_id:\n            self._top.transaction_id = uuid.uuid4().hex\n        return f'\\n\\nrenku-transaction: {self._top.transaction_id}'\n\n    @property\n    def _top(self) -> 'ProjectProperties':\n        \"\"\"Return current context.\"\"\"\n        if self._context_stack:\n            return self._context_stack[-1]\n        raise errors.ProjectContextError('No project context was pushed')\n\n    def has_context(self, path: Optional[Union[Path, str]]=None) -> bool:\n        \"\"\"Return if at least one context which is equal to path (if not None) is pushed.\"\"\"\n        return True if self._context_stack and (path is None or self.path == Path(path).resolve()) else False\n\n    def clear(self) -> None:\n        \"\"\"Remove all contexts and reset the state without committing intermediate changes.\n\n        NOTE: This method should be used only in tests.\n        \"\"\"\n        while self._context_stack:\n            if self._top.repository:\n                self._top.repository.close()\n            self._context_stack.pop()\n        self.external_storage_requested = True\n\n    def pop_context(self) -> 'ProjectProperties':\n        \"\"\"Pop current project context from stack.\n\n        Returns:\n            Path: the popped project path.\n        \"\"\"\n        if self._context_stack:\n            if self._top.save_changes and self._top.database:\n                self._top.database.commit()\n            if self._top.repository:\n                self._top.repository.close()\n            return self._context_stack.pop()\n        else:\n            raise IndexError('No more context to pop.')\n\n    def push_path(self, path: Union[Path, str], save_changes: bool=False) -> None:\n        \"\"\"Push a new project path to the stack.\n\n        Arguments:\n            path(Union[Path, str]): The path to push.\n            save_changes(bool): Whether to save changes to the database or not.\n        \"\"\"\n        path = Path(path).resolve()\n        self._context_stack.append(ProjectProperties(path=path, save_changes=save_changes))\n\n    def replace_path(self, path: Union[Path, str]):\n        \"\"\"Replace the current project path with a new one if they are different.\n\n        Arguments:\n            path(Union[Path, str]): The path to replace with.\n        \"\"\"\n        path = Path(path).resolve()\n        if not self._context_stack:\n            self.push_path(path)\n        elif self._top.path != path:\n            self._context_stack[-1] = ProjectProperties(path=path)\n\n    @contextlib.contextmanager\n    def with_path(self, path: Union[Path, str], save_changes: bool=False) -> Generator['ProjectProperties', None, None]:\n        \"\"\"Temporarily push a new project path to the stack.\n\n        Arguments:\n            path(Union[Path, str]): The path to push.\n            save_changes(bool): Whether to save changes to the database or not.\n        \"\"\"\n        with self.with_rollback():\n            self.push_path(path=path, save_changes=save_changes)\n            yield self._top\n\n    @contextlib.contextmanager\n    def with_rollback(self) -> Generator[None, None, None]:\n        \"\"\"Rollback to the current state.\n\n        NOTE: This won't work correctly if the current context is popped or swapped.\n        \"\"\"\n        before_top = self._top if self._context_stack else None\n        try:\n            yield\n        finally:\n            could_rollback = False\n            while self._context_stack:\n                if self._top == before_top:\n                    could_rollback = True\n                    break\n                self.pop_context()\n            if not could_rollback and before_top is not None:\n                raise errors.ProjectContextError(f'Cannot rollback to {before_top.path}.')\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass BedrockAgentCoreContext:\n    '''Unified context manager for Bedrock AgentCore.'''\n    @classmethod\n    def set_workload_access_token(cls, token: str):\n        '''Set the workload access token in the context.'''\n        pass\n    @classmethod\n    def get_workload_access_token(cls) -> Optional[str]:\n        '''Get the workload access token from the context.'''\n        pass\n    @classmethod\n    def set_request_context(cls, request_id: str, session_id: Optional[str]=None):\n        '''Set request-scoped identifiers.'''\n        pass\n    @classmethod\n    def get_request_id(cls) -> Optional[str]:\n        '''Get current request ID.'''\n        pass\n    @classmethod\n    def get_session_id(cls) -> Optional[str]:\n        '''Get current session ID.'''\n        pass"
  }
]