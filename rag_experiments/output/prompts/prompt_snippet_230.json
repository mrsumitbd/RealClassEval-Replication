[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass FivetranClient:\n    '''This class exposes methods on top of the Fivetran REST API.'''\n\n    def __init__(self, api_key: str, api_secret: str, request_max_retries: int, request_retry_delay: float, disable_schedule_on_trigger: bool):\n        pass\n    @property\n    def _auth(self) -> HTTPBasicAuth:\n        pass\n    @property\n    @cached_method\n    def _log(self) -> logging.Logger:\n        pass\n    @property\n    def api_base_url(self) -> str:\n        pass\n    @property\n    def api_connector_url(self) -> str:\n        pass\n\n    def _make_connector_request(self, method: str, endpoint: str, data: Optional[str]=None) -> Mapping[str, Any]:\n        pass\n\n    def _make_and_handle_request(self, method: str, endpoint: str, data: Optional[str]=None, params: Optional[Mapping[str, Any]]=None) -> Mapping[str, Any]:\n        '''Creates, sends and handles a request to the desired Fivetran API endpoint.\n        Args:\n            method (str): The http method to use for this request (e.g. \"POST\", \"GET\", \"PATCH\").\n            endpoint (str): The Fivetran API endpoint to send this request to.\n            data (Optional[str]): JSON-formatted data string to be included in the request.\n            params (Optional[Dict[str, Any]]): JSON-formatted query params to be included in the request.\n        Returns:\n            Dict[str, Any]: Parsed json data from the response to this request.\n        '''\n        pass\n\n    def _make_request(self, method: str, endpoint: str, data: Optional[str]=None, params: Optional[Mapping[str, Any]]=None) -> requests.Response:\n        '''Creates and sends a request to the desired Fivetran API endpoint.\n        Args:\n            method (str): The http method to use for this request (e.g. \"POST\", \"GET\", \"PATCH\").\n            endpoint (str): The Fivetran API endpoint to send this request to.\n            data (Optional[str]): JSON-formatted data string to be included in the request.\n            params (Optional[Dict[str, Any]]): JSON-formatted query params to be included in the request.\n        Returns:\n            Optional[requests.Response]: The `requests.Response` object for the request.\n        '''\n        pass\n\n    def get_connector_details(self, connector_id: str) -> Mapping[str, Any]:\n        '''Gets details about a given connector from the Fivetran API.\n        Args:\n            connector_id (str): The Fivetran Connector ID. You can retrieve this value from the\n                \"Setup\" tab of a given connector in the Fivetran UI.\n        Returns:\n            Dict[str, Any]: Parsed json data from the response to this request.\n        '''\n        pass\n\n    def list_connectors_for_group(self, group_id: str) -> Sequence[Mapping[str, Any]]:\n        '''Fetches a list of all connectors for a given group from the Fivetran API.\n        Args:\n            group_id (str): The Fivetran Group ID.\n        Returns:\n            List[Dict[str, Any]]: A List of parsed json data from the response to this request.\n        '''\n        pass\n\n    def get_schema_config_for_connector(self, connector_id: str, raise_on_not_found_error: bool=True) -> Mapping[str, Any]:\n        '''Fetches the connector schema config for a given connector from the Fivetran API.\n        Args:\n            connector_id (str): The Fivetran Connector ID.\n            raise_on_not_found_error (bool):\n                Whether to raise an exception if a 404 error is encountered. Defaults to True.\n        Returns:\n            Dict[str, Any]: Parsed json data from the response to this request.\n        '''\n        pass\n\n    def get_destination_details(self, destination_id: str) -> Mapping[str, Any]:\n        '''Fetches details about a given destination from the Fivetran API.\n        Args:\n            destination_id (str): The Fivetran Destination ID.\n        Returns:\n            Dict[str, Any]: Parsed json data from the response to this request.\n        '''\n        pass\n\n    def get_groups(self) -> Mapping[str, Any]:\n        '''Fetches all groups from the Fivetran API.\n        Returns:\n            Dict[str, Any]: Parsed json data from the response to this request.\n        '''\n        pass\n\n    def update_schedule_type_for_connector(self, connector_id: str, schedule_type: str) -> Mapping[str, Any]:\n        '''Updates the schedule type property of the connector to either \"auto\" or \"manual\".\n        Args:\n            connector_id (str): The Fivetran Connector ID. You can retrieve this value from the\n                \"Setup\" tab of a given connector in the Fivetran UI.\n            schedule_type (str): Either \"auto\" (to turn the schedule on) or \"manual\" (to\n                turn it off).\n        Returns:\n            Dict[str, Any]: Parsed json data representing the API response.\n        '''\n        pass\n\n    def get_columns_config_for_table(self, connector_id: str, schema_name: str, table_name: str) -> Mapping[str, Any]:\n        '''Fetches the source table columns config for a given table from the Fivetran API.\n        Args:\n            connector_id (str): The Fivetran Connector ID.\n            schema_name (str): The Fivetran Schema name.\n            table_name (str): The Fivetran Table name.\n        Returns:\n            Dict[str, Any]: Parsed json data from the response to this request.\n        '''\n        pass\n\n    def start_sync(self, connector_id: str) -> None:\n        '''Initiates a sync of a Fivetran connector.\n        Args:\n            connector_id (str): The Fivetran Connector ID. You can retrieve this value from the\n                \"Setup\" tab of a given connector in the Fivetran UI.\n        '''\n        pass\n\n    def start_resync(self, connector_id: str, resync_parameters: Optional[Mapping[str, Sequence[str]]]=None) -> None:\n        '''Initiates a historical sync of all data for multiple schema tables within a Fivetran connector.\n        Args:\n            connector_id (str): The Fivetran Connector ID. You can retrieve this value from the\n                \"Setup\" tab of a given connector in the Fivetran UI.\n            resync_parameters (Optional[Dict[str, List[str]]]): Optional resync parameters to send to the Fivetran API.\n                An example payload can be found here: https://fivetran.com/docs/rest-api/connectors#request_7\n        '''\n        pass\n\n    def _start_sync(self, request_fn: Callable[[], Mapping[str, Any]], connector_id: str) -> None:\n        pass\n\n    def poll_sync(self, connector_id: str, previous_sync_completed_at: datetime, poll_interval: float=DEFAULT_POLL_INTERVAL, poll_timeout: Optional[float]=None) -> Mapping[str, Any]:\n        '''Given a Fivetran connector and the timestamp at which the previous sync completed, poll\n        until the next sync completes.\n        The previous sync completion time is necessary because the only way to tell when a sync\n        completes is when this value changes.\n        Args:\n            connector_id (str): The Fivetran Connector ID. You can retrieve this value from the\n                \"Setup\" tab of a given connector in the Fivetran UI.\n            previous_sync_completed_at (datetime.datetime): The datetime of the previous completed sync\n                (successful or otherwise) for this connector, prior to running this method.\n            poll_interval (float): The time (in seconds) that will be waited between successive polls.\n            poll_timeout (float): The maximum time that will wait before this operation is timed\n                out. By default, this will never time out.\n        Returns:\n            Dict[str, Any]: Parsed json data representing the API response.\n        '''\n        pass\n\n    def sync_and_poll(self, connector_id: str, poll_interval: float=DEFAULT_POLL_INTERVAL, poll_timeout: Optional[float]=None) -> Optional[FivetranOutput]:\n        '''Initializes a sync operation for the given connector, and polls until it completes.\n        Args:\n            connector_id (str): The Fivetran Connector ID. You can retrieve this value from the\n                \"Setup\" tab of a given connector in the Fivetran UI.\n            poll_interval (float): The time (in seconds) that will be waited between successive polls.\n            poll_timeout (float): The maximum time that will wait before this operation is timed\n                out. By default, this will never time out.\n        Returns:\n            Optional[FivetranOutput]:\n                Returns a :py:class:`~FivetranOutput` object containing details\n                about the connector and the tables it synced. If the connector is not synced, None is returned.\n        '''\n        pass\n\n    def resync_and_poll(self, connector_id: str, poll_interval: float=DEFAULT_POLL_INTERVAL, poll_timeout: Optional[float]=None, resync_parameters: Optional[Mapping[str, Sequence[str]]]=None) -> Optional[FivetranOutput]:\n        '''Initializes a historical resync operation for the given connector, and polls until it completes.\n        Args:\n            connector_id (str): The Fivetran Connector ID. You can retrieve this value from the\n                \"Setup\" tab of a given connector in the Fivetran UI.\n            resync_parameters (Dict[str, List[str]]): The payload to send to the Fivetran API.\n                This should be a dictionary with schema names as the keys and a list of tables\n                to resync as the values.\n            poll_interval (float): The time (in seconds) that will be waited between successive polls.\n            poll_timeout (float): The maximum time that will wait before this operation is timed\n                out. By default, this will never time out.\n        Returns:\n            Optional[FivetranOutput]:\n                Returns a :py:class:`~FivetranOutput` object containing details\n                about the connector and the tables it synced. If the connector is not synced, None is returned.\n        '''\n        pass\n\n    def _sync_and_poll(self, sync_fn: Callable, connector_id: str, poll_interval: float=DEFAULT_POLL_INTERVAL, poll_timeout: Optional[float]=None) -> Optional[FivetranOutput]:\n        pass\nCorresponding class implementation:\n\nimport time\nimport logging\nfrom dagster_fivetran.translator import ConnectorSelectorFn, DagsterFivetranTranslator, FivetranConnector, FivetranConnectorScheduleType, FivetranConnectorTableProps, FivetranDestination, FivetranMetadataSet, FivetranSchemaConfig, FivetranWorkspaceData\nfrom collections.abc import Mapping, Sequence\nimport os\nfrom datetime import datetime, timedelta\nfrom requests.auth import HTTPBasicAuth\nfrom functools import cached_property, partial\nimport json\nimport requests\nfrom dagster import AssetExecutionContext, AssetMaterialization, Definitions, Failure, InitResourceContext, MaterializeResult, MetadataValue, __version__, _check as check, get_dagster_logger, resource\nfrom dagster._utils.cached_method import cached_method\nfrom dagster_fivetran.types import FivetranOutput\nfrom typing import Any, Callable, Optional, Union\nfrom requests.exceptions import RequestException\n\nclass FivetranClient:\n    \"\"\"This class exposes methods on top of the Fivetran REST API.\"\"\"\n\n    def __init__(self, api_key: str, api_secret: str, request_max_retries: int, request_retry_delay: float, disable_schedule_on_trigger: bool):\n        self.api_key = api_key\n        self.api_secret = api_secret\n        self.request_max_retries = request_max_retries\n        self.request_retry_delay = request_retry_delay\n        self.disable_schedule_on_trigger = disable_schedule_on_trigger\n\n    @property\n    def _auth(self) -> HTTPBasicAuth:\n        return HTTPBasicAuth(self.api_key, self.api_secret)\n\n    @property\n    @cached_method\n    def _log(self) -> logging.Logger:\n        return get_dagster_logger()\n\n    @property\n    def api_base_url(self) -> str:\n        return f'{FIVETRAN_API_BASE}/{FIVETRAN_API_VERSION}'\n\n    @property\n    def api_connector_url(self) -> str:\n        return f'{self.api_base_url}/{FIVETRAN_CONNECTOR_ENDPOINT}'\n\n    def _make_connector_request(self, method: str, endpoint: str, data: Optional[str]=None) -> Mapping[str, Any]:\n        return self._make_and_handle_request(method, f'{FIVETRAN_CONNECTOR_ENDPOINT}/{endpoint}', data)\n\n    def _make_and_handle_request(self, method: str, endpoint: str, data: Optional[str]=None, params: Optional[Mapping[str, Any]]=None) -> Mapping[str, Any]:\n        \"\"\"Creates, sends and handles a request to the desired Fivetran API endpoint.\n\n        Args:\n            method (str): The http method to use for this request (e.g. \"POST\", \"GET\", \"PATCH\").\n            endpoint (str): The Fivetran API endpoint to send this request to.\n            data (Optional[str]): JSON-formatted data string to be included in the request.\n            params (Optional[Dict[str, Any]]): JSON-formatted query params to be included in the request.\n\n        Returns:\n            Dict[str, Any]: Parsed json data from the response to this request.\n        \"\"\"\n        response = self._make_request(method=method, endpoint=endpoint, data=data, params=params)\n        try:\n            response.raise_for_status()\n            resp_dict = response.json()\n            return resp_dict['data'] if 'data' in resp_dict else resp_dict\n        except RequestException as e:\n            raise Failure(f'Max retries ({self.request_max_retries}) exceeded with url: {response.url}. Caused by {e}')\n\n    def _make_request(self, method: str, endpoint: str, data: Optional[str]=None, params: Optional[Mapping[str, Any]]=None) -> requests.Response:\n        \"\"\"Creates and sends a request to the desired Fivetran API endpoint.\n\n        Args:\n            method (str): The http method to use for this request (e.g. \"POST\", \"GET\", \"PATCH\").\n            endpoint (str): The Fivetran API endpoint to send this request to.\n            data (Optional[str]): JSON-formatted data string to be included in the request.\n            params (Optional[Dict[str, Any]]): JSON-formatted query params to be included in the request.\n\n        Returns:\n            Optional[requests.Response]: The `requests.Response` object for the request.\n        \"\"\"\n        url = f'{self.api_base_url}/{endpoint}'\n        headers = {'User-Agent': f'dagster-fivetran/{__version__}', 'Content-Type': 'application/json;version=2'}\n        num_retries = 0\n        while True:\n            try:\n                response = requests.request(method=method, url=url, headers=headers, auth=self._auth, data=data, params=params, timeout=int(os.getenv('DAGSTER_FIVETRAN_API_REQUEST_TIMEOUT', '60')))\n                response.raise_for_status()\n                return response\n            except RequestException as e:\n                self._log.error('Request to Fivetran API failed: %s', e)\n                if num_retries == self.request_max_retries:\n                    return response\n                num_retries += 1\n                time.sleep(self.request_retry_delay)\n\n    def get_connector_details(self, connector_id: str) -> Mapping[str, Any]:\n        \"\"\"Gets details about a given connector from the Fivetran API.\n\n        Args:\n            connector_id (str): The Fivetran Connector ID. You can retrieve this value from the\n                \"Setup\" tab of a given connector in the Fivetran UI.\n\n        Returns:\n            Dict[str, Any]: Parsed json data from the response to this request.\n        \"\"\"\n        return self._make_connector_request(method='GET', endpoint=connector_id)\n\n    def list_connectors_for_group(self, group_id: str) -> Sequence[Mapping[str, Any]]:\n        \"\"\"Fetches a list of all connectors for a given group from the Fivetran API.\n\n        Args:\n            group_id (str): The Fivetran Group ID.\n\n        Returns:\n            List[Dict[str, Any]]: A List of parsed json data from the response to this request.\n        \"\"\"\n        results = []\n        cursor = None\n        while True:\n            data = self._make_and_handle_request(method='GET', endpoint=f'groups/{group_id}/connectors', params={'limit': DAGSTER_FIVETRAN_LIST_CONNECTIONS_FOR_GROUP_INDIVIDUAL_REQUEST_LIMIT, **({'cursor': cursor} if cursor else {})})\n            connectors = data['items']\n            cursor = data.get('nextCursor')\n            results.extend(connectors)\n            if not cursor:\n                break\n        return results\n\n    def get_schema_config_for_connector(self, connector_id: str, raise_on_not_found_error: bool=True) -> Mapping[str, Any]:\n        \"\"\"Fetches the connector schema config for a given connector from the Fivetran API.\n\n        Args:\n            connector_id (str): The Fivetran Connector ID.\n            raise_on_not_found_error (bool):\n                Whether to raise an exception if a 404 error is encountered. Defaults to True.\n\n        Returns:\n            Dict[str, Any]: Parsed json data from the response to this request.\n        \"\"\"\n        response = self._make_request('GET', f'connectors/{connector_id}/schemas')\n        try:\n            response.raise_for_status()\n            resp_dict = response.json()\n            return resp_dict['data'] if 'data' in resp_dict else resp_dict\n        except RequestException as e:\n            if not raise_on_not_found_error and e.response is not None and (e.response.status_code == 404):\n                self._log.warning(f'Schema config was not found for connector with ID {connector_id}.')\n                return {}\n            else:\n                raise Failure(f'Max retries ({self.request_max_retries}) exceeded with url: {response.url}. Caused by {e}')\n\n    def get_destination_details(self, destination_id: str) -> Mapping[str, Any]:\n        \"\"\"Fetches details about a given destination from the Fivetran API.\n\n        Args:\n            destination_id (str): The Fivetran Destination ID.\n\n        Returns:\n            Dict[str, Any]: Parsed json data from the response to this request.\n        \"\"\"\n        return self._make_and_handle_request('GET', f'destinations/{destination_id}')\n\n    def get_groups(self) -> Mapping[str, Any]:\n        \"\"\"Fetches all groups from the Fivetran API.\n\n        Returns:\n            Dict[str, Any]: Parsed json data from the response to this request.\n        \"\"\"\n        return self._make_and_handle_request('GET', 'groups')\n\n    def update_schedule_type_for_connector(self, connector_id: str, schedule_type: str) -> Mapping[str, Any]:\n        \"\"\"Updates the schedule type property of the connector to either \"auto\" or \"manual\".\n\n        Args:\n            connector_id (str): The Fivetran Connector ID. You can retrieve this value from the\n                \"Setup\" tab of a given connector in the Fivetran UI.\n            schedule_type (str): Either \"auto\" (to turn the schedule on) or \"manual\" (to\n                turn it off).\n\n        Returns:\n            Dict[str, Any]: Parsed json data representing the API response.\n        \"\"\"\n        schedule_types = {s for s in FivetranConnectorScheduleType}\n        if schedule_type not in schedule_types:\n            check.failed(f\"The schedule_type for connector {connector_id} must be in {schedule_types}: got '{schedule_type}'\")\n        return self._make_connector_request(method='PATCH', endpoint=connector_id, data=json.dumps({'schedule_type': schedule_type}))\n\n    def get_columns_config_for_table(self, connector_id: str, schema_name: str, table_name: str) -> Mapping[str, Any]:\n        \"\"\"Fetches the source table columns config for a given table from the Fivetran API.\n\n        Args:\n            connector_id (str): The Fivetran Connector ID.\n            schema_name (str): The Fivetran Schema name.\n            table_name (str): The Fivetran Table name.\n\n        Returns:\n            Dict[str, Any]: Parsed json data from the response to this request.\n        \"\"\"\n        return self._make_connector_request(method='GET', endpoint=f'{connector_id}/schemas/{schema_name}/tables/{table_name}/columns')\n\n    def start_sync(self, connector_id: str) -> None:\n        \"\"\"Initiates a sync of a Fivetran connector.\n\n        Args:\n            connector_id (str): The Fivetran Connector ID. You can retrieve this value from the\n                \"Setup\" tab of a given connector in the Fivetran UI.\n\n        \"\"\"\n        request_fn = partial(self._make_connector_request, method='POST', endpoint=f'{connector_id}/force')\n        self._start_sync(request_fn=request_fn, connector_id=connector_id)\n\n    def start_resync(self, connector_id: str, resync_parameters: Optional[Mapping[str, Sequence[str]]]=None) -> None:\n        \"\"\"Initiates a historical sync of all data for multiple schema tables within a Fivetran connector.\n\n        Args:\n            connector_id (str): The Fivetran Connector ID. You can retrieve this value from the\n                \"Setup\" tab of a given connector in the Fivetran UI.\n            resync_parameters (Optional[Dict[str, List[str]]]): Optional resync parameters to send to the Fivetran API.\n                An example payload can be found here: https://fivetran.com/docs/rest-api/connectors#request_7\n        \"\"\"\n        request_fn = partial(self._make_connector_request, method='POST', endpoint=f'{connector_id}/schemas/tables/resync' if resync_parameters is not None else f'{connector_id}/resync', data=json.dumps(resync_parameters) if resync_parameters is not None else None)\n        self._start_sync(request_fn=request_fn, connector_id=connector_id)\n\n    def _start_sync(self, request_fn: Callable[[], Mapping[str, Any]], connector_id: str) -> None:\n        connector = FivetranConnector.from_connector_details(connector_details=self.get_connector_details(connector_id))\n        connector.validate_syncable()\n        if self.disable_schedule_on_trigger:\n            self._log.info(f'Disabling Fivetran sync schedule for connector {connector_id}.')\n            self.update_schedule_type_for_connector(connector_id, 'manual')\n        request_fn()\n        self._log.info(f'Sync initialized for connector {connector_id}. View this sync in the Fivetran UI: ' + connector.url)\n\n    def poll_sync(self, connector_id: str, previous_sync_completed_at: datetime, poll_interval: float=DEFAULT_POLL_INTERVAL, poll_timeout: Optional[float]=None) -> Mapping[str, Any]:\n        \"\"\"Given a Fivetran connector and the timestamp at which the previous sync completed, poll\n        until the next sync completes.\n\n        The previous sync completion time is necessary because the only way to tell when a sync\n        completes is when this value changes.\n\n        Args:\n            connector_id (str): The Fivetran Connector ID. You can retrieve this value from the\n                \"Setup\" tab of a given connector in the Fivetran UI.\n            previous_sync_completed_at (datetime.datetime): The datetime of the previous completed sync\n                (successful or otherwise) for this connector, prior to running this method.\n            poll_interval (float): The time (in seconds) that will be waited between successive polls.\n            poll_timeout (float): The maximum time that will wait before this operation is timed\n                out. By default, this will never time out.\n\n        Returns:\n            Dict[str, Any]: Parsed json data representing the API response.\n        \"\"\"\n        poll_start = datetime.now()\n        while True:\n            connector_details = self.get_connector_details(connector_id)\n            connector = FivetranConnector.from_connector_details(connector_details=connector_details)\n            self._log.info(f\"Polled '{connector_id}'. Status: [{connector.sync_state}]\")\n            if connector.last_sync_completed_at > previous_sync_completed_at:\n                break\n            if poll_timeout and datetime.now() > poll_start + timedelta(seconds=poll_timeout):\n                raise Failure(f\"Sync for connector '{connector_id}' timed out after {datetime.now() - poll_start}.\")\n            time.sleep(poll_interval)\n        if not connector.is_last_sync_successful:\n            raise Failure(f\"Sync for connector '{connector_id}' failed!\", metadata={'connector_details': MetadataValue.json(connector_details), 'log_url': MetadataValue.url(connector.url)})\n        return connector_details\n\n    def sync_and_poll(self, connector_id: str, poll_interval: float=DEFAULT_POLL_INTERVAL, poll_timeout: Optional[float]=None) -> Optional[FivetranOutput]:\n        \"\"\"Initializes a sync operation for the given connector, and polls until it completes.\n\n        Args:\n            connector_id (str): The Fivetran Connector ID. You can retrieve this value from the\n                \"Setup\" tab of a given connector in the Fivetran UI.\n            poll_interval (float): The time (in seconds) that will be waited between successive polls.\n            poll_timeout (float): The maximum time that will wait before this operation is timed\n                out. By default, this will never time out.\n\n        Returns:\n            Optional[FivetranOutput]:\n                Returns a :py:class:`~FivetranOutput` object containing details\n                about the connector and the tables it synced. If the connector is not synced, None is returned.\n        \"\"\"\n        return self._sync_and_poll(sync_fn=self.start_sync, connector_id=connector_id, poll_interval=poll_interval, poll_timeout=poll_timeout)\n\n    def resync_and_poll(self, connector_id: str, poll_interval: float=DEFAULT_POLL_INTERVAL, poll_timeout: Optional[float]=None, resync_parameters: Optional[Mapping[str, Sequence[str]]]=None) -> Optional[FivetranOutput]:\n        \"\"\"Initializes a historical resync operation for the given connector, and polls until it completes.\n\n        Args:\n            connector_id (str): The Fivetran Connector ID. You can retrieve this value from the\n                \"Setup\" tab of a given connector in the Fivetran UI.\n            resync_parameters (Dict[str, List[str]]): The payload to send to the Fivetran API.\n                This should be a dictionary with schema names as the keys and a list of tables\n                to resync as the values.\n            poll_interval (float): The time (in seconds) that will be waited between successive polls.\n            poll_timeout (float): The maximum time that will wait before this operation is timed\n                out. By default, this will never time out.\n\n        Returns:\n            Optional[FivetranOutput]:\n                Returns a :py:class:`~FivetranOutput` object containing details\n                about the connector and the tables it synced. If the connector is not synced, None is returned.\n        \"\"\"\n        return self._sync_and_poll(sync_fn=partial(self.start_resync, resync_parameters=resync_parameters), connector_id=connector_id, poll_interval=poll_interval, poll_timeout=poll_timeout)\n\n    def _sync_and_poll(self, sync_fn: Callable, connector_id: str, poll_interval: float=DEFAULT_POLL_INTERVAL, poll_timeout: Optional[float]=None) -> Optional[FivetranOutput]:\n        schema_config_details = self.get_schema_config_for_connector(connector_id)\n        connector = FivetranConnector.from_connector_details(connector_details=self.get_connector_details(connector_id))\n        if connector.paused:\n            self._log.warning(f'Cannot sync connector {connector.name} with ID {connector.id} because the connector is paused. Make sure the connector is enabled before syncing it.')\n            return None\n        sync_fn(connector_id=connector_id)\n        final_details = self.poll_sync(connector_id=connector_id, previous_sync_completed_at=connector.last_sync_completed_at, poll_interval=poll_interval, poll_timeout=poll_timeout)\n        return FivetranOutput(connector_details=final_details, schema_config=schema_config_details)\n\nExample skeleton:\n\n\nclass SearchSettingsConversationalSearch:\n    '''\n    Configuration settings for conversational search.\n    :param bool enabled: Whether to enable conversational search.\n    :param SearchSettingsConversationalSearchResponseLength response_length:\n          (optional)\n    :param SearchSettingsConversationalSearchSearchConfidence search_confidence:\n          (optional)\n    '''\n\n    def __init__(self, enabled: bool, *, response_length: Optional['SearchSettingsConversationalSearchResponseLength']=None, search_confidence: Optional['SearchSettingsConversationalSearchSearchConfidence']=None) -> None:\n        '''\n        Initialize a SearchSettingsConversationalSearch object.\n        :param bool enabled: Whether to enable conversational search.\n        :param SearchSettingsConversationalSearchResponseLength response_length:\n               (optional)\n        :param SearchSettingsConversationalSearchSearchConfidence\n               search_confidence: (optional)\n        '''\n        pass\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'SearchSettingsConversationalSearch':\n        '''Initialize a SearchSettingsConversationalSearch object from a json dictionary.'''\n        pass\n    @classmethod\n    def _from_dict(cls, _dict):\n        '''Initialize a SearchSettingsConversationalSearch object from a json dictionary.'''\n        pass\n\n    def to_dict(self) -> Dict:\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def _to_dict(self):\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Return a `str` version of this SearchSettingsConversationalSearch object.'''\n        pass\n\n    def __eq__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        '''Return `true` when self and other are equal, false otherwise.'''\n        pass\n\n    def __ne__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        '''Return `true` when self and other are not equal, false otherwise.'''\n        pass\nCorresponding class implementation:\n\nimport json\nfrom typing import BinaryIO, Dict, List, Optional\n\nclass SearchSettingsConversationalSearch:\n    \"\"\"\n    Configuration settings for conversational search.\n\n    :param bool enabled: Whether to enable conversational search.\n    :param SearchSettingsConversationalSearchResponseLength response_length:\n          (optional)\n    :param SearchSettingsConversationalSearchSearchConfidence search_confidence:\n          (optional)\n    \"\"\"\n\n    def __init__(self, enabled: bool, *, response_length: Optional['SearchSettingsConversationalSearchResponseLength']=None, search_confidence: Optional['SearchSettingsConversationalSearchSearchConfidence']=None) -> None:\n        \"\"\"\n        Initialize a SearchSettingsConversationalSearch object.\n\n        :param bool enabled: Whether to enable conversational search.\n        :param SearchSettingsConversationalSearchResponseLength response_length:\n               (optional)\n        :param SearchSettingsConversationalSearchSearchConfidence\n               search_confidence: (optional)\n        \"\"\"\n        self.enabled = enabled\n        self.response_length = response_length\n        self.search_confidence = search_confidence\n\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'SearchSettingsConversationalSearch':\n        \"\"\"Initialize a SearchSettingsConversationalSearch object from a json dictionary.\"\"\"\n        args = {}\n        if (enabled := _dict.get('enabled')) is not None:\n            args['enabled'] = enabled\n        else:\n            raise ValueError(\"Required property 'enabled' not present in SearchSettingsConversationalSearch JSON\")\n        if (response_length := _dict.get('response_length')) is not None:\n            args['response_length'] = SearchSettingsConversationalSearchResponseLength.from_dict(response_length)\n        if (search_confidence := _dict.get('search_confidence')) is not None:\n            args['search_confidence'] = SearchSettingsConversationalSearchSearchConfidence.from_dict(search_confidence)\n        return cls(**args)\n\n    @classmethod\n    def _from_dict(cls, _dict):\n        \"\"\"Initialize a SearchSettingsConversationalSearch object from a json dictionary.\"\"\"\n        return cls.from_dict(_dict)\n\n    def to_dict(self) -> Dict:\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        _dict = {}\n        if hasattr(self, 'enabled') and self.enabled is not None:\n            _dict['enabled'] = self.enabled\n        if hasattr(self, 'response_length') and self.response_length is not None:\n            if isinstance(self.response_length, dict):\n                _dict['response_length'] = self.response_length\n            else:\n                _dict['response_length'] = self.response_length.to_dict()\n        if hasattr(self, 'search_confidence') and self.search_confidence is not None:\n            if isinstance(self.search_confidence, dict):\n                _dict['search_confidence'] = self.search_confidence\n            else:\n                _dict['search_confidence'] = self.search_confidence.to_dict()\n        return _dict\n\n    def _to_dict(self):\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        return self.to_dict()\n\n    def __str__(self) -> str:\n        \"\"\"Return a `str` version of this SearchSettingsConversationalSearch object.\"\"\"\n        return json.dumps(self.to_dict(), indent=2)\n\n    def __eq__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        \"\"\"Return `true` when self and other are equal, false otherwise.\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        \"\"\"Return `true` when self and other are not equal, false otherwise.\"\"\"\n        return not self == other\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass TavilySearchService:\n    '''Service for interacting with the Tavily Search API using the official SDK.'''\n\n    def __init__(self):\n        '''Initialize the Tavily search service with API key from environment.'''\n        pass\n\n    def search(self, query: str, search_depth: str='basic', topic: str='general', include_domains: List[str] | None=None, exclude_domains: List[str] | None=None, max_results: int=5) -> Dict[str, Any]:\n        '''\n        Perform a web search using Tavily API.\n        Args:\n            query: The search query\n            search_depth: 'basic' or 'advanced' search depth\n            include_domains: List of domains to include in search\n            exclude_domains: List of domains to exclude from search\n            max_results: Maximum number of results to return\n        Returns:\n            Dict containing search results\n        '''\n        pass\n\n    def extract(self, url: str) -> Dict[str, Any]:\n        '''\n        Extract content from a specific URL using Tavily API.\n        Args:\n            url: The URL to extract content from\n        Returns:\n            Dict containing the extracted content\n        '''\n        pass\n\n    def format_search_results(self, results: Dict[str, Any]) -> str:\n        '''Format search results into a readable string.'''\n        pass\n\n    def format_extract_results(self, results: Dict[str, Any]) -> str:\n        '''Format extract results into a readable string.'''\n        pass"
  }
]