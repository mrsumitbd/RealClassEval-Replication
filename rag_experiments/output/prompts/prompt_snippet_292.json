[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Event(object):\n    '''\n    A simple signal/event mechanism, to be used like this::\n        def mycallback(arg, **kwargs):\n            print arg, kwargs['foo']\n        myevent = Event()\n        myevent.connect(mycallback)\n        myevent.emit('test', foo = 'bar')\n        # Or just: myevent('test', foo = 'bar')\n    '''\n\n    def __init__(self):\n        '''\n        Constructor.\n        '''\n        pass\n\n    def __call__(self, *args, **kwargs):\n        '''\n        Like emit().\n        '''\n        pass\n\n    def connect(self, callback, *args, **kwargs):\n        '''\n        Connects the event with the given callback.\n        When the signal is emitted, the callback is invoked.\n        .. note::\n            The signal handler is stored with a hard reference, so you\n            need to make sure to call :class:`disconnect()` if you want the\n            handler\n            to be garbage collected.\n        :type  callback: object\n        :param callback: The callback function.\n        :type  args: tuple\n        :param args: Optional arguments passed to the callback.\n        :type  kwargs: dict\n        :param kwargs: Optional keyword arguments passed to the callback.\n        '''\n        pass\n\n    def listen(self, callback, *args, **kwargs):\n        '''\n        Like :class:`connect()`, but uses a weak reference instead of a\n        normal reference.\n        The signal is automatically disconnected as soon as the handler\n        is garbage collected.\n        .. note::\n            Storing signal handlers as weak references means that if\n            your handler is a local function, it may be garbage collected. To\n            prevent this, use :class:`connect()` instead.\n        :type  callback: object\n        :param callback: The callback function.\n        :type  args: tuple\n        :param args: Optional arguments passed to the callback.\n        :type  kwargs: dict\n        :param kwargs: Optional keyword arguments passed to the callback.\n        :rtype:  :class:`Exscript.util.weakmethod.WeakMethod`\n        :returns: The newly created weak reference to the callback.\n        '''\n        pass\n\n    def n_subscribers(self):\n        '''\n        Returns the number of connected subscribers.\n        :rtype:  int\n        :returns: The number of subscribers.\n        '''\n        pass\n\n    def _hard_callbacks(self):\n        pass\n\n    def _weakly_connected_index(self, callback):\n        pass\n\n    def is_connected(self, callback):\n        '''\n        Returns True if the event is connected to the given function.\n        :type  callback: object\n        :param callback: The callback function.\n        :rtype:  bool\n        :returns: Whether the signal is connected to the given function.\n        '''\n        pass\n\n    def emit(self, *args, **kwargs):\n        '''\n        Emits the signal, passing the given arguments to the callbacks.\n        If one of the callbacks returns a value other than None, no further\n        callbacks are invoked and the return value of the callback is\n        returned to the caller of emit().\n        :type  args: tuple\n        :param args: Optional arguments passed to the callbacks.\n        :type  kwargs: dict\n        :param kwargs: Optional keyword arguments passed to the callbacks.\n        :rtype:  object\n        :returns: Returns None if all callbacks returned None. Returns\n                 the return value of the last invoked callback otherwise.\n        '''\n        pass\n\n    def _try_disconnect(self, ref):\n        '''\n        Called by the weak reference when its target dies.\n        In other words, we can assert that self.weak_subscribers is not\n        None at this time.\n        '''\n        pass\n\n    def disconnect(self, callback):\n        '''\n        Disconnects the signal from the given function.\n        :type  callback: object\n        :param callback: The callback function.\n        '''\n        pass\n\n    def disconnect_all(self):\n        '''\n        Disconnects all connected functions from all signals.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom threading import Lock\nfrom . import weakmethod\n\nclass Event(object):\n    \"\"\"\n    A simple signal/event mechanism, to be used like this::\n\n        def mycallback(arg, **kwargs):\n            print arg, kwargs['foo']\n\n        myevent = Event()\n        myevent.connect(mycallback)\n        myevent.emit('test', foo = 'bar')\n        # Or just: myevent('test', foo = 'bar')\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Constructor.\n        \"\"\"\n        self.lock = None\n        self.weak_subscribers = None\n        self.hard_subscribers = None\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"\n        Like emit().\n        \"\"\"\n        return self.emit(*args, **kwargs)\n\n    def connect(self, callback, *args, **kwargs):\n        \"\"\"\n        Connects the event with the given callback.\n        When the signal is emitted, the callback is invoked.\n\n        .. note::\n\n            The signal handler is stored with a hard reference, so you\n            need to make sure to call :class:`disconnect()` if you want the\n            handler\n            to be garbage collected.\n\n        :type  callback: object\n        :param callback: The callback function.\n        :type  args: tuple\n        :param args: Optional arguments passed to the callback.\n        :type  kwargs: dict\n        :param kwargs: Optional keyword arguments passed to the callback.\n        \"\"\"\n        if self.is_connected(callback):\n            raise AttributeError('callback is already connected')\n        if self.hard_subscribers is None:\n            self.hard_subscribers = []\n        self.hard_subscribers.append((callback, args, kwargs))\n\n    def listen(self, callback, *args, **kwargs):\n        \"\"\"\n        Like :class:`connect()`, but uses a weak reference instead of a\n        normal reference.\n        The signal is automatically disconnected as soon as the handler\n        is garbage collected.\n\n        .. note::\n\n            Storing signal handlers as weak references means that if\n            your handler is a local function, it may be garbage collected. To\n            prevent this, use :class:`connect()` instead.\n\n        :type  callback: object\n        :param callback: The callback function.\n        :type  args: tuple\n        :param args: Optional arguments passed to the callback.\n        :type  kwargs: dict\n        :param kwargs: Optional keyword arguments passed to the callback.\n        :rtype:  :class:`Exscript.util.weakmethod.WeakMethod`\n        :returns: The newly created weak reference to the callback.\n        \"\"\"\n        if self.lock is None:\n            self.lock = Lock()\n        with self.lock:\n            if self.is_connected(callback):\n                raise AttributeError('callback is already connected')\n            if self.weak_subscribers is None:\n                self.weak_subscribers = []\n            ref = weakmethod.ref(callback, self._try_disconnect)\n            self.weak_subscribers.append((ref, args, kwargs))\n        return ref\n\n    def n_subscribers(self):\n        \"\"\"\n        Returns the number of connected subscribers.\n\n        :rtype:  int\n        :returns: The number of subscribers.\n        \"\"\"\n        hard = self.hard_subscribers and len(self.hard_subscribers) or 0\n        weak = self.weak_subscribers and len(self.weak_subscribers) or 0\n        return hard + weak\n\n    def _hard_callbacks(self):\n        return [s[0] for s in self.hard_subscribers]\n\n    def _weakly_connected_index(self, callback):\n        if self.weak_subscribers is None:\n            return None\n        weak = [s[0].get_function() for s in self.weak_subscribers]\n        try:\n            return weak.index(callback)\n        except ValueError:\n            return None\n\n    def is_connected(self, callback):\n        \"\"\"\n        Returns True if the event is connected to the given function.\n\n        :type  callback: object\n        :param callback: The callback function.\n        :rtype:  bool\n        :returns: Whether the signal is connected to the given function.\n        \"\"\"\n        index = self._weakly_connected_index(callback)\n        if index is not None:\n            return True\n        if self.hard_subscribers is None:\n            return False\n        return callback in self._hard_callbacks()\n\n    def emit(self, *args, **kwargs):\n        \"\"\"\n        Emits the signal, passing the given arguments to the callbacks.\n        If one of the callbacks returns a value other than None, no further\n        callbacks are invoked and the return value of the callback is\n        returned to the caller of emit().\n\n        :type  args: tuple\n        :param args: Optional arguments passed to the callbacks.\n        :type  kwargs: dict\n        :param kwargs: Optional keyword arguments passed to the callbacks.\n        :rtype:  object\n        :returns: Returns None if all callbacks returned None. Returns\n                 the return value of the last invoked callback otherwise.\n        \"\"\"\n        if self.hard_subscribers is not None:\n            for callback, user_args, user_kwargs in self.hard_subscribers:\n                kwargs.update(user_kwargs)\n                result = callback(*args + user_args, **kwargs)\n                if result is not None:\n                    return result\n        if self.weak_subscribers is not None:\n            for callback, user_args, user_kwargs in self.weak_subscribers:\n                kwargs.update(user_kwargs)\n                cb_func = callback.get_function()\n                if cb_func is None:\n                    continue\n                result = cb_func(*args + user_args, **kwargs)\n                if result is not None:\n                    return result\n\n    def _try_disconnect(self, ref):\n        \"\"\"\n        Called by the weak reference when its target dies.\n        In other words, we can assert that self.weak_subscribers is not\n        None at this time.\n        \"\"\"\n        with self.lock:\n            weak = [s[0] for s in self.weak_subscribers]\n            try:\n                index = weak.index(ref)\n            except ValueError:\n                pass\n            else:\n                self.weak_subscribers.pop(index)\n\n    def disconnect(self, callback):\n        \"\"\"\n        Disconnects the signal from the given function.\n\n        :type  callback: object\n        :param callback: The callback function.\n        \"\"\"\n        if self.weak_subscribers is not None:\n            with self.lock:\n                index = self._weakly_connected_index(callback)\n                if index is not None:\n                    self.weak_subscribers.pop(index)[0]\n        if self.hard_subscribers is not None:\n            try:\n                index = self._hard_callbacks().index(callback)\n            except ValueError:\n                pass\n            else:\n                self.hard_subscribers.pop(index)\n\n    def disconnect_all(self):\n        \"\"\"\n        Disconnects all connected functions from all signals.\n        \"\"\"\n        self.hard_subscribers = None\n        self.weak_subscribers = None\n\nExample skeleton:\n\n\nclass StateTransitionWrapper(Generic[_P, _R, _T]):\n    '''\n    Wraps :class:`StateTransition` with the context of the object it is accessed from.\n    Automatically constructed by :class:`StateTransition`.\n        '''\n\n    def __init__(self, statetransition: StateTransition[_P, _R], obj: _T) -> None:\n        pass\n    @property\n    def data(self) -> dict[str, Any]:\n        '''Return data as provided to the :meth:`~StateManager.transition` decorator.'''\n        pass\n\n    def _validate_available(self) -> Optional[tuple[StateManager, Any, Any]]:\n        '''\n        If the state is invalid for the transition, return details on what didn't match.\n        :return: Tuple of (state manager, current state, label for current state)\n        '''\n        pass\n    @property\n    def is_available(self) -> bool:\n        '''Property that indicates whether this transition is currently available.'''\n        pass\n\n    def __getattr__(self, name: str) -> Any:\n        pass\n\n    def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -> _R:\n        '''Perform the state transition.'''\n        pass\nCorresponding class implementation:\n\nfrom typing import TYPE_CHECKING, Any, Callable, Generic, NoReturn, Optional, Union, cast, overload\nfrom ..utils import LabeledEnum, NameTitle, is_collection\n\nclass StateTransitionWrapper(Generic[_P, _R, _T]):\n    \"\"\"\n    Wraps :class:`StateTransition` with the context of the object it is accessed from.\n\n    Automatically constructed by :class:`StateTransition`.\n    \"\"\"\n\n    def __init__(self, statetransition: StateTransition[_P, _R], obj: _T) -> None:\n        self.statetransition = statetransition\n        self.obj = obj\n\n    @property\n    def data(self) -> dict[str, Any]:\n        \"\"\"Return data as provided to the :meth:`~StateManager.transition` decorator.\"\"\"\n        return self.statetransition.data\n\n    def _validate_available(self) -> Optional[tuple[StateManager, Any, Any]]:\n        \"\"\"\n        If the state is invalid for the transition, return details on what didn't match.\n\n        :return: Tuple of (state manager, current state, label for current state)\n        \"\"\"\n        for statemanager, conditions in self.statetransition.transitions.items():\n            current_state_value = statemanager._get_state_value(self.obj)\n            if conditions.from_ is None:\n                state_valid = True\n            else:\n                mstate = conditions.from_.get(current_state_value)\n                state_valid = mstate is not None and mstate.is_current_in(self.obj)\n            if not state_valid:\n                return (statemanager, current_state_value, statemanager.lenum.get(current_state_value))\n        return None\n\n    @property\n    def is_available(self) -> bool:\n        \"\"\"Property that indicates whether this transition is currently available.\"\"\"\n        return not self._validate_available()\n\n    def __getattr__(self, name: str) -> Any:\n        return getattr(self.statetransition, name)\n\n    def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -> _R:\n        \"\"\"Perform the state transition.\"\"\"\n        state_invalid = self._validate_available()\n        if state_invalid:\n            transition_error.send(self.obj, transition=self.statetransition, statemanager=state_invalid[0])\n            label = state_invalid[2]\n            if isinstance(label, NameTitle):\n                label = label.title\n            raise StateTransitionError(f'Invalid state for transition {self.statetransition.name}: {state_invalid[0]!r} = {label}')\n        transition_before.send(self.obj, transition=self.statetransition)\n        try:\n            result = self.statetransition.func(self.obj, *args, **kwargs)\n        except AbortTransition as e:\n            transition_exception.send(self.obj, transition=self.statetransition, exception=e)\n            return e.result\n        except Exception as e:\n            transition_exception.send(self.obj, transition=self.statetransition, exception=e)\n            raise\n        for statemanager, conditions in self.statetransition.transitions.items():\n            if conditions.to is not None:\n                statemanager._set_state_value(self.obj, conditions.to.value)\n        transition_after.send(self.obj, transition=self.statetransition)\n        return result\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass BaseHook(ABC):\n    '''\n    Base class for registering and managing PyTorch forward hooks on model layers.\n    This class is used to create specific hook classes, like `ResponseHook` and `ActivationHook`.\n        '''\n\n    def __init__(self, layer_key, hook_fn, agent):\n        '''\n        :param layer_key: Dotted module path in model.named_modules().\n        :type layer_key: str\n        :param hook_fn: Callable with signature (module, input, output).\n        :type hook_fn: Callable\n        :param agent: Owning agent (may be None for generic hooks).\n        :type agent: Any\n        '''\n        pass\n\n    def _hook(self):\n        '''Placeholder hook (override in subclasses).'''\n        pass\n\n    def register(self, model):\n        '''\n        Registers the hook on the given model using the layer_key.\n        :param model: Model whose layer will be hooked.\n        :type model: torch.nn.Module\n        :return: The hook handle.\n        :rtype: Any\n        '''\n        pass\n\n    def remove(self):\n        '''\n        Removes the hook if it is registered.\n        '''\n        pass"
  }
]