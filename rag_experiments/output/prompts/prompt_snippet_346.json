[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass ArgsDataModel(BaseModel):\n    '''Parameter hook args.'''\n    @field_validator('policies', mode='before')\n    @classmethod\n    def _convert_policies(cls, v: list[dict[str, Any]] | str | Any) -> str:\n        '''Convert policies to acceptable value.'''\n        pass\n    @field_validator('tags', mode='before')\n    @classmethod\n    def _convert_tags(cls, v: dict[str, str] | list[dict[str, str]] | Any) -> list[dict[str, str]]:\n        '''Convert tags to acceptable value.'''\n        pass\nCorresponding class implementation:\n\nimport json\nfrom ..utils import TagDataModel\nfrom pydantic import ConfigDict, Field, field_validator\nfrom ....utils import BaseModel, JsonEncoder\nfrom typing_extensions import Literal, TypedDict\nfrom typing import TYPE_CHECKING, Annotated, Any, ClassVar, cast\n\nclass ArgsDataModel(BaseModel):\n    \"\"\"Parameter hook args.\"\"\"\n    model_config = ConfigDict(extra='ignore', populate_by_name=True)\n    allowed_pattern: Annotated[str | None, Field(alias='AllowedPattern')] = None\n    'A regular expression used to validate the parameter value.'\n    data_type: Annotated[Literal['aws:ec2:image', 'text'] | None, Field(alias='DataType')] = None\n    'The data type for a String parameter.\\n\\n    Supported data types include plain text and Amazon Machine Image IDs.\\n\\n    '\n    description: Annotated[str | None, Field(alias='Description')] = None\n    'Information about the parameter.'\n    force: bool = False\n    'Skip checking the current value of the parameter, just put it.\\n\\n    Can be used alongside ``overwrite`` to always update a parameter.\\n\\n    '\n    key_id: Annotated[str | None, Field(alias='KeyId')] = None\n    'The KMS Key ID that you want to use to encrypt a parameter.\\n\\n    Either the default AWS Key Management Service (AWS KMS) key automatically\\n    assigned to your AWS account or a custom key.\\n    Required for parameters that use the ``SecureString`` data type.\\n\\n    '\n    name: Annotated[str, Field(alias='Name')]\n    'The fully qualified name of the parameter that you want to add to the system.'\n    overwrite: Annotated[bool, Field(alias='Overwrite')] = True\n    'Allow overwriting an existing parameter.'\n    policies: Annotated[str | None, Field(alias='Policies')] = None\n    'One or more policies to apply to a parameter. This field takes a JSON array.'\n    tags: Annotated[list[TagDataModel] | None, Field(alias='Tags')] = None\n    'Optional metadata that you assign to a resource.'\n    tier: Annotated[ParameterTierType, Field(alias='Tier')] = 'Standard'\n    'The parameter tier to assign to a parameter.'\n    type: Annotated[Literal['String', 'StringList', 'SecureString'], Field(alias='Type')]\n    'The type of parameter.'\n    value: Annotated[str | None, Field(alias='Value')] = None\n    'The parameter value that you want to add to the system.\\n\\n    Standard parameters have a value limit of 4 KB.\\n    Advanced parameters have a value limit of 8 KB.\\n\\n    '\n\n    @field_validator('policies', mode='before')\n    @classmethod\n    def _convert_policies(cls, v: list[dict[str, Any]] | str | Any) -> str:\n        \"\"\"Convert policies to acceptable value.\"\"\"\n        if isinstance(v, str):\n            return v\n        if isinstance(v, list):\n            return json.dumps(v, cls=JsonEncoder)\n        raise ValueError(f'unexpected type {type(v)}; permitted: list[dict[str, Any]] | str | None')\n\n    @field_validator('tags', mode='before')\n    @classmethod\n    def _convert_tags(cls, v: dict[str, str] | list[dict[str, str]] | Any) -> list[dict[str, str]]:\n        \"\"\"Convert tags to acceptable value.\"\"\"\n        if isinstance(v, list):\n            return cast('list[dict[str, str]]', v)\n        if isinstance(v, dict):\n            return [{'Key': k, 'Value': v} for k, v in cast('dict[str, str]', v).items()]\n        raise ValueError(f'unexpected type {type(v)}; permitted: dict[str, str] | list[dict[str, str]] | none')\n\nExample skeleton:\n\n\nclass BaseGlobalIDType:\n    '''\n    Base class that define the required attributes/method for a type.\n        '''\n    @classmethod\n    def resolve_global_id(cls, info, global_id):\n        pass\n    @classmethod\n    def to_global_id(cls, _type, _id):\n        pass\nCorresponding class implementation:\n\nfrom ..types import ID, UUID\nfrom ..types.base import BaseType\nfrom typing import Type\n\nclass BaseGlobalIDType:\n    \"\"\"\n    Base class that define the required attributes/method for a type.\n    \"\"\"\n    graphene_type: Type[BaseType] = ID\n\n    @classmethod\n    def resolve_global_id(cls, info, global_id):\n        raise NotImplementedError\n\n    @classmethod\n    def to_global_id(cls, _type, _id):\n        raise NotImplementedError\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass EventDataNormalizer:\n    '''事件数据标准化器'''\n    @staticmethod\n    def normalize_event_data(event_type: str, event_data: Dict[str, Any]) -> Dict[str, Any]:\n        '''标准化事件数据格式'''\n        pass\n    @staticmethod\n    def extract_user_id(event_data: Dict[str, Any]) -> Optional[str]:\n        '''从事件数据中提取用户ID'''\n        pass\n    @staticmethod\n    def extract_target_info(event_data: Dict[str, Any]) -> tuple[Optional[str], bool]:\n        '''从事件数据中提取目标信息，返回(target_id, is_group)'''\n        pass"
  }
]