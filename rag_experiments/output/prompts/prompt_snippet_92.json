[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass DatasetFolder(VisionDataset):\n    '''A generic data loader.\n    This default directory structure can be customized by overriding the\n    :meth:`find_classes` method.\n    Args:\n        root (str or ``pathlib.Path``): Root directory path.\n        loader (callable): A function to load a sample given its path.\n        extensions (tuple[string]): A list of allowed extensions.\n            both extensions and is_valid_file should not be passed.\n        transform (callable, optional): A function/transform that takes in\n            a sample and returns a transformed version.\n            E.g, ``transforms.RandomCrop`` for images.\n        target_transform (callable, optional): A function/transform that takes\n            in the target and transforms it.\n        is_valid_file (callable, optional): A function that takes path of a file\n            and check if the file is a valid file (used to check of corrupt files)\n            both extensions and is_valid_file should not be passed.\n        allow_empty(bool, optional): If True, empty folders are considered to be valid classes.\n            An error is raised on empty folders if False (default).\n     Attributes:\n        classes (list): List of the class names sorted alphabetically.\n        class_to_idx (dict): Dict with items (class_name, class_index).\n        samples (list): List of (sample path, class_index) tuples\n        targets (list): The class_index value for each image in the dataset\n            '''\n\n    def __init__(self, root: Union[str, Path], loader: Callable[[str], Any], extensions: Optional[tuple[str, ...]]=None, transform: Optional[Callable]=None, target_transform: Optional[Callable]=None, is_valid_file: Optional[Callable[[str], bool]]=None, allow_empty: bool=False) -> None:\n        pass\n    @staticmethod\n    def make_dataset(directory: Union[str, Path], class_to_idx: dict[str, int], extensions: Optional[tuple[str, ...]]=None, is_valid_file: Optional[Callable[[str], bool]]=None, allow_empty: bool=False) -> list[tuple[str, int]]:\n        '''Generates a list of samples of a form (path_to_sample, class).\n        This can be overridden to e.g. read files from a compressed zip file instead of from the disk.\n        Args:\n            directory (str): root dataset directory, corresponding to ``self.root``.\n            class_to_idx (Dict[str, int]): Dictionary mapping class name to class index.\n            extensions (optional): A list of allowed extensions.\n                Either extensions or is_valid_file should be passed. Defaults to None.\n            is_valid_file (optional): A function that takes path of a file\n                and checks if the file is a valid file\n                (used to check of corrupt files) both extensions and\n                is_valid_file should not be passed. Defaults to None.\n            allow_empty(bool, optional): If True, empty folders are considered to be valid classes.\n                An error is raised on empty folders if False (default).\n        Raises:\n            ValueError: In case ``class_to_idx`` is empty.\n            ValueError: In case ``extensions`` and ``is_valid_file`` are None or both are not None.\n            FileNotFoundError: In case no valid file was found for any class.\n        Returns:\n            List[Tuple[str, int]]: samples of a form (path_to_sample, class)\n                        '''\n                        pass\n\n    def find_classes(self, directory: Union[str, Path]) -> tuple[list[str], dict[str, int]]:\n        '''Find the class folders in a dataset structured as follows::\n            directory/\n            ├── class_x\n            │   ├── xxx.ext\n            │   ├── xxy.ext\n            │   └── ...\n            │       └── xxz.ext\n            └── class_y\n                ├── 123.ext\n                ├── nsdf3.ext\n                └── ...\n                └── asd932_.ext\n        This method can be overridden to only consider\n        a subset of classes, or to adapt to a different dataset directory structure.\n        Args:\n            directory(str): Root directory path, corresponding to ``self.root``\n        Raises:\n            FileNotFoundError: If ``dir`` has no class folders.\n        Returns:\n            (Tuple[List[str], Dict[str, int]]): List of all classes and dictionary mapping each class to an index.\n        '''\n        pass\n\n    def __getitem__(self, index: int) -> tuple[Any, Any]:\n        '''\n        Args:\n            index (int): Index\n        Returns:\n            tuple: (sample, target) where target is class_index of the target class.\n        '''\n        pass\n\n    def __len__(self) -> int:\n        pass\nCorresponding class implementation:\n\nfrom .vision import VisionDataset\nfrom typing import Any, Callable, cast, Optional, Union\nfrom pathlib import Path\n\nclass DatasetFolder(VisionDataset):\n    \"\"\"A generic data loader.\n\n    This default directory structure can be customized by overriding the\n    :meth:`find_classes` method.\n\n    Args:\n        root (str or ``pathlib.Path``): Root directory path.\n        loader (callable): A function to load a sample given its path.\n        extensions (tuple[string]): A list of allowed extensions.\n            both extensions and is_valid_file should not be passed.\n        transform (callable, optional): A function/transform that takes in\n            a sample and returns a transformed version.\n            E.g, ``transforms.RandomCrop`` for images.\n        target_transform (callable, optional): A function/transform that takes\n            in the target and transforms it.\n        is_valid_file (callable, optional): A function that takes path of a file\n            and check if the file is a valid file (used to check of corrupt files)\n            both extensions and is_valid_file should not be passed.\n        allow_empty(bool, optional): If True, empty folders are considered to be valid classes.\n            An error is raised on empty folders if False (default).\n\n     Attributes:\n        classes (list): List of the class names sorted alphabetically.\n        class_to_idx (dict): Dict with items (class_name, class_index).\n        samples (list): List of (sample path, class_index) tuples\n        targets (list): The class_index value for each image in the dataset\n    \"\"\"\n\n    def __init__(self, root: Union[str, Path], loader: Callable[[str], Any], extensions: Optional[tuple[str, ...]]=None, transform: Optional[Callable]=None, target_transform: Optional[Callable]=None, is_valid_file: Optional[Callable[[str], bool]]=None, allow_empty: bool=False) -> None:\n        super().__init__(root, transform=transform, target_transform=target_transform)\n        classes, class_to_idx = self.find_classes(self.root)\n        samples = self.make_dataset(self.root, class_to_idx=class_to_idx, extensions=extensions, is_valid_file=is_valid_file, allow_empty=allow_empty)\n        self.loader = loader\n        self.extensions = extensions\n        self.classes = classes\n        self.class_to_idx = class_to_idx\n        self.samples = samples\n        self.targets = [s[1] for s in samples]\n\n    @staticmethod\n    def make_dataset(directory: Union[str, Path], class_to_idx: dict[str, int], extensions: Optional[tuple[str, ...]]=None, is_valid_file: Optional[Callable[[str], bool]]=None, allow_empty: bool=False) -> list[tuple[str, int]]:\n        \"\"\"Generates a list of samples of a form (path_to_sample, class).\n\n        This can be overridden to e.g. read files from a compressed zip file instead of from the disk.\n\n        Args:\n            directory (str): root dataset directory, corresponding to ``self.root``.\n            class_to_idx (Dict[str, int]): Dictionary mapping class name to class index.\n            extensions (optional): A list of allowed extensions.\n                Either extensions or is_valid_file should be passed. Defaults to None.\n            is_valid_file (optional): A function that takes path of a file\n                and checks if the file is a valid file\n                (used to check of corrupt files) both extensions and\n                is_valid_file should not be passed. Defaults to None.\n            allow_empty(bool, optional): If True, empty folders are considered to be valid classes.\n                An error is raised on empty folders if False (default).\n\n        Raises:\n            ValueError: In case ``class_to_idx`` is empty.\n            ValueError: In case ``extensions`` and ``is_valid_file`` are None or both are not None.\n            FileNotFoundError: In case no valid file was found for any class.\n\n        Returns:\n            List[Tuple[str, int]]: samples of a form (path_to_sample, class)\n        \"\"\"\n        if class_to_idx is None:\n            raise ValueError('The class_to_idx parameter cannot be None.')\n        return make_dataset(directory, class_to_idx, extensions=extensions, is_valid_file=is_valid_file, allow_empty=allow_empty)\n\n    def find_classes(self, directory: Union[str, Path]) -> tuple[list[str], dict[str, int]]:\n        \"\"\"Find the class folders in a dataset structured as follows::\n\n            directory/\n            ├── class_x\n            │   ├── xxx.ext\n            │   ├── xxy.ext\n            │   └── ...\n            │       └── xxz.ext\n            └── class_y\n                ├── 123.ext\n                ├── nsdf3.ext\n                └── ...\n                └── asd932_.ext\n\n        This method can be overridden to only consider\n        a subset of classes, or to adapt to a different dataset directory structure.\n\n        Args:\n            directory(str): Root directory path, corresponding to ``self.root``\n\n        Raises:\n            FileNotFoundError: If ``dir`` has no class folders.\n\n        Returns:\n            (Tuple[List[str], Dict[str, int]]): List of all classes and dictionary mapping each class to an index.\n        \"\"\"\n        return find_classes(directory)\n\n    def __getitem__(self, index: int) -> tuple[Any, Any]:\n        \"\"\"\n        Args:\n            index (int): Index\n\n        Returns:\n            tuple: (sample, target) where target is class_index of the target class.\n        \"\"\"\n        path, target = self.samples[index]\n        sample = self.loader(path)\n        if self.transform is not None:\n            sample = self.transform(sample)\n        if self.target_transform is not None:\n            target = self.target_transform(target)\n        return (sample, target)\n\n    def __len__(self) -> int:\n        return len(self.samples)\n\nExample skeleton:\n\n@utils.registerPlexObject\nclass MediaPart(PlexObject):\n    ''' Represents a single media part (often a single file) for the media this belongs to.\n        Attributes:\n            TAG (str): 'Part'\n            accessible (bool): True if the file is accessible.\n                Requires reloading the media with ``checkFiles=True``.\n                Refer to :func:`~plexapi.base.PlexObject.reload`.\n            audioProfile (str): The audio profile of the file.\n            container (str): The container type of the file (ex: avi).\n            decision (str): Unknown.\n            deepAnalysisVersion (int): The Plex deep analysis version for the file.\n            duration (int): The duration of the file in milliseconds.\n            exists (bool): True if the file exists.\n                Requires reloading the media with ``checkFiles=True``.\n                Refer to :func:`~plexapi.base.PlexObject.reload`.\n            file (str): The path to this file on disk (ex: /media/Movies/Cars (2006)/Cars (2006).mkv)\n            has64bitOffsets (bool): True if the file has 64 bit offsets.\n            hasThumbnail (bool): True if the file (track) has an embedded thumbnail.\n            id (int): The unique ID for this media part on the server.\n            indexes (str, None): sd if the file has generated preview (BIF) thumbnails.\n            key (str): API URL (ex: /library/parts/46618/1389985872/file.mkv).\n            optimizedForStreaming (bool): True if the file is optimized for streaming.\n            packetLength (int): The packet length of the file.\n            requiredBandwidths (str): The required bandwidths to stream the file.\n            selected (bool): True if this media part is selected.\n            size (int): The size of the file in bytes (ex: 733884416).\n            streams (List<:class:`~plexapi.media.MediaPartStream`>): List of stream objects.\n            syncItemId (int): The unique ID for this media part if it is synced.\n            syncState (str): The sync state for this media part.\n            videoProfile (str): The video profile of the file.\n    '''\n\n    def _loadData(self, data):\n        ''' Load attribute values from Plex XML response. '''\n        pass\n\n    def _buildStreams(self, data):\n        ''' Returns a list of :class:`~plexapi.media.MediaPartStream` objects in this MediaPart. '''\n        pass\n    @property\n    def hasPreviewThumbnails(self):\n        ''' Returns True if the media part has generated preview (BIF) thumbnails. '''\n        pass\n\n    def videoStreams(self):\n        ''' Returns a list of :class:`~plexapi.media.VideoStream` objects in this MediaPart. '''\n        pass\n\n    def audioStreams(self):\n        ''' Returns a list of :class:`~plexapi.media.AudioStream` objects in this MediaPart. '''\n        pass\n\n    def subtitleStreams(self):\n        ''' Returns a list of :class:`~plexapi.media.SubtitleStream` objects in this MediaPart. '''\n        pass\n\n    def lyricStreams(self):\n        ''' Returns a list of :class:`~plexapi.media.LyricStream` objects in this MediaPart. '''\n        pass\n\n    def setSelectedAudioStream(self, stream):\n        ''' Set the selected :class:`~plexapi.media.AudioStream` for this MediaPart.\n            Parameters:\n                stream (:class:`~plexapi.media.AudioStream`): Audio stream to set as selected\n        '''\n        pass\n\n    def setSelectedSubtitleStream(self, stream):\n        ''' Set the selected :class:`~plexapi.media.SubtitleStream` for this MediaPart.\n            Parameters:\n                stream (:class:`~plexapi.media.SubtitleStream`): Subtitle stream to set as selected.\n        '''\n        pass\n\n    def resetSelectedSubtitleStream(self):\n        ''' Set the selected subtitle of this MediaPart to 'None'. '''\n        pass\n    @deprecated('Use \"setSelectedAudioStream\" instead.')\n    def setDefaultAudioStream(self, stream):\n        pass\n    @deprecated('Use \"setSelectedSubtitleStream\" instead.')\n    def setDefaultSubtitleStream(self, stream):\n        pass\n    @deprecated('Use \"resetSelectedSubtitleStream\" instead.')\n    def resetDefaultSubtitleStream(self):\n        pass\nCorresponding class implementation:\n\nfrom plexapi.utils import deprecated\nfrom plexapi.base import PlexObject, cached_data_property\nfrom plexapi import log, settings, utils\n\n@utils.registerPlexObject\nclass MediaPart(PlexObject):\n    \"\"\" Represents a single media part (often a single file) for the media this belongs to.\n\n        Attributes:\n            TAG (str): 'Part'\n            accessible (bool): True if the file is accessible.\n                Requires reloading the media with ``checkFiles=True``.\n                Refer to :func:`~plexapi.base.PlexObject.reload`.\n            audioProfile (str): The audio profile of the file.\n            container (str): The container type of the file (ex: avi).\n            decision (str): Unknown.\n            deepAnalysisVersion (int): The Plex deep analysis version for the file.\n            duration (int): The duration of the file in milliseconds.\n            exists (bool): True if the file exists.\n                Requires reloading the media with ``checkFiles=True``.\n                Refer to :func:`~plexapi.base.PlexObject.reload`.\n            file (str): The path to this file on disk (ex: /media/Movies/Cars (2006)/Cars (2006).mkv)\n            has64bitOffsets (bool): True if the file has 64 bit offsets.\n            hasThumbnail (bool): True if the file (track) has an embedded thumbnail.\n            id (int): The unique ID for this media part on the server.\n            indexes (str, None): sd if the file has generated preview (BIF) thumbnails.\n            key (str): API URL (ex: /library/parts/46618/1389985872/file.mkv).\n            optimizedForStreaming (bool): True if the file is optimized for streaming.\n            packetLength (int): The packet length of the file.\n            requiredBandwidths (str): The required bandwidths to stream the file.\n            selected (bool): True if this media part is selected.\n            size (int): The size of the file in bytes (ex: 733884416).\n            streams (List<:class:`~plexapi.media.MediaPartStream`>): List of stream objects.\n            syncItemId (int): The unique ID for this media part if it is synced.\n            syncState (str): The sync state for this media part.\n            videoProfile (str): The video profile of the file.\n    \"\"\"\n    TAG = 'Part'\n\n    def _loadData(self, data):\n        \"\"\" Load attribute values from Plex XML response. \"\"\"\n        self.accessible = utils.cast(bool, data.attrib.get('accessible'))\n        self.audioProfile = data.attrib.get('audioProfile')\n        self.container = data.attrib.get('container')\n        self.decision = data.attrib.get('decision')\n        self.deepAnalysisVersion = utils.cast(int, data.attrib.get('deepAnalysisVersion'))\n        self.duration = utils.cast(int, data.attrib.get('duration'))\n        self.exists = utils.cast(bool, data.attrib.get('exists'))\n        self.file = data.attrib.get('file')\n        self.has64bitOffsets = utils.cast(bool, data.attrib.get('has64bitOffsets'))\n        self.hasThumbnail = utils.cast(bool, data.attrib.get('hasThumbnail'))\n        self.id = utils.cast(int, data.attrib.get('id'))\n        self.indexes = data.attrib.get('indexes')\n        self.key = data.attrib.get('key')\n        self.optimizedForStreaming = utils.cast(bool, data.attrib.get('optimizedForStreaming'))\n        self.packetLength = utils.cast(int, data.attrib.get('packetLength'))\n        self.protocol = data.attrib.get('protocol')\n        self.requiredBandwidths = data.attrib.get('requiredBandwidths')\n        self.selected = utils.cast(bool, data.attrib.get('selected'))\n        self.size = utils.cast(int, data.attrib.get('size'))\n        self.streams = self._buildStreams(data)\n        self.syncItemId = utils.cast(int, data.attrib.get('syncItemId'))\n        self.syncState = data.attrib.get('syncState')\n        self.videoProfile = data.attrib.get('videoProfile')\n\n    def _buildStreams(self, data):\n        \"\"\" Returns a list of :class:`~plexapi.media.MediaPartStream` objects in this MediaPart. \"\"\"\n        return self.findItems(data)\n\n    @property\n    def hasPreviewThumbnails(self):\n        \"\"\" Returns True if the media part has generated preview (BIF) thumbnails. \"\"\"\n        return self.indexes == 'sd'\n\n    def videoStreams(self):\n        \"\"\" Returns a list of :class:`~plexapi.media.VideoStream` objects in this MediaPart. \"\"\"\n        return [stream for stream in self.streams if isinstance(stream, VideoStream)]\n\n    def audioStreams(self):\n        \"\"\" Returns a list of :class:`~plexapi.media.AudioStream` objects in this MediaPart. \"\"\"\n        return [stream for stream in self.streams if isinstance(stream, AudioStream)]\n\n    def subtitleStreams(self):\n        \"\"\" Returns a list of :class:`~plexapi.media.SubtitleStream` objects in this MediaPart. \"\"\"\n        return [stream for stream in self.streams if isinstance(stream, SubtitleStream)]\n\n    def lyricStreams(self):\n        \"\"\" Returns a list of :class:`~plexapi.media.LyricStream` objects in this MediaPart. \"\"\"\n        return [stream for stream in self.streams if isinstance(stream, LyricStream)]\n\n    def setSelectedAudioStream(self, stream):\n        \"\"\" Set the selected :class:`~plexapi.media.AudioStream` for this MediaPart.\n\n            Parameters:\n                stream (:class:`~plexapi.media.AudioStream`): Audio stream to set as selected\n        \"\"\"\n        key = f'/library/parts/{self.id}'\n        params = {'allParts': 1}\n        if isinstance(stream, AudioStream):\n            params['audioStreamID'] = stream.id\n        else:\n            params['audioStreamID'] = stream\n        self._server.query(key, method=self._server._session.put, params=params)\n        return self\n\n    def setSelectedSubtitleStream(self, stream):\n        \"\"\" Set the selected :class:`~plexapi.media.SubtitleStream` for this MediaPart.\n\n            Parameters:\n                stream (:class:`~plexapi.media.SubtitleStream`): Subtitle stream to set as selected.\n        \"\"\"\n        key = f'/library/parts/{self.id}'\n        params = {'allParts': 1}\n        if isinstance(stream, SubtitleStream):\n            params['subtitleStreamID'] = stream.id\n        else:\n            params['subtitleStreamID'] = stream\n        self._server.query(key, method=self._server._session.put, params=params)\n        return self\n\n    def resetSelectedSubtitleStream(self):\n        \"\"\" Set the selected subtitle of this MediaPart to 'None'. \"\"\"\n        key = f'/library/parts/{self.id}'\n        params = {'subtitleStreamID': 0, 'allParts': 1}\n        self._server.query(key, method=self._server._session.put, params=params)\n        return self\n\n    @deprecated('Use \"setSelectedAudioStream\" instead.')\n    def setDefaultAudioStream(self, stream):\n        return self.setSelectedAudioStream(stream)\n\n    @deprecated('Use \"setSelectedSubtitleStream\" instead.')\n    def setDefaultSubtitleStream(self, stream):\n        return self.setSelectedSubtitleStream(stream)\n\n    @deprecated('Use \"resetSelectedSubtitleStream\" instead.')\n    def resetDefaultSubtitleStream(self):\n        return self.resetSelectedSubtitleStream()\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass LoadStreams:\n    '''\n    Stream Loader for various types of video streams.\n    Supports RTSP, RTMP, HTTP, and TCP streams. This class handles the loading and processing of multiple video\n    streams simultaneously, making it suitable for real-time video analysis tasks.\n    Attributes:\n        sources (List[str]): The source input paths or URLs for the video streams.\n        vid_stride (int): Video frame-rate stride.\n        buffer (bool): Whether to buffer input streams.\n        running (bool): Flag to indicate if the streaming thread is running.\n        mode (str): Set to 'stream' indicating real-time capture.\n        imgs (List[List[np.ndarray]]): List of image frames for each stream.\n        fps (List[float]): List of FPS for each stream.\n        frames (List[int]): List of total frames for each stream.\n        threads (List[Thread]): List of threads for each stream.\n        shape (List[Tuple[int, int, int]]): List of shapes for each stream.\n        caps (List[cv2.VideoCapture]): List of cv2.VideoCapture objects for each stream.\n        bs (int): Batch size for processing.\n    Methods:\n        update: Read stream frames in daemon thread.\n        close: Close stream loader and release resources.\n        __iter__: Returns an iterator object for the class.\n        __next__: Returns source paths, transformed, and original images for processing.\n        __len__: Return the length of the sources object.\n    Examples:\n        >>> stream_loader = LoadStreams(\"rtsp://example.com/stream1.mp4\")\n        >>> for sources, imgs, _ in stream_loader:\n        ...     # Process the images\n        ...     pass\n        >>> stream_loader.close()\n    Notes:\n        - The class uses threading to efficiently load frames from multiple streams simultaneously.\n        - It automatically handles YouTube links, converting them to the best available stream URL.\n        - The class implements a buffer system to manage frame storage and retrieval.\n            '''\n\n    def __init__(self, sources='file.streams', vid_stride=1, buffer=False):\n        '''Initialize stream loader for multiple video sources, supporting various stream types.'''\n        pass\n\n    def update(self, i, cap, stream):\n        '''Read stream frames in daemon thread and update image buffer.'''\n        pass\n\n    def close(self):\n        '''Terminates stream loader, stops threads, and releases video capture resources.'''\n        pass\n\n    def __iter__(self):\n        '''Iterates through YOLO image feed and re-opens unresponsive streams.'''\n        pass\n\n    def __next__(self):\n        '''Returns the next batch of frames from multiple video streams for processing.'''\n        pass\n\n    def __len__(self):\n        '''Return the number of video streams in the LoadStreams object.'''\n        pass"
  }
]