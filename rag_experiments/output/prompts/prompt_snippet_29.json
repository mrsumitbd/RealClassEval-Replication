[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Scenes:\n    '''Class for storing and accessing .'''\n\n    def __init__(self, pyvlx: 'PyVLX'):\n        '''Initialize Scenes class.'''\n        pass\n\n    def __iter__(self) -> Iterator[Scene]:\n        '''Iterate.'''\n        pass\n\n    def __getitem__(self, key: Union[str, int]) -> Scene:\n        '''Return scene by name or by index.'''\n        pass\n\n    def __len__(self) -> int:\n        '''Return number of scenes.'''\n        pass\n\n    def add(self, scene: Scene) -> None:\n        '''Add scene, replace existing scene if scene with scene_id is present.'''\n        pass\n\n    def clear(self) -> None:\n        '''Clear internal scenes array.'''\n        pass\n\n    async def load(self) -> None:\n        '''Load scenes from KLF 200.'''\n        pass\nCorresponding class implementation:\n\nfrom .scene import Scene\nfrom typing import TYPE_CHECKING, Iterator, List, Union\nfrom .api import GetSceneList\nfrom .exception import PyVLXException\n\nclass Scenes:\n    \"\"\"Class for storing and accessing .\"\"\"\n\n    def __init__(self, pyvlx: 'PyVLX'):\n        \"\"\"Initialize Scenes class.\"\"\"\n        self.pyvlx = pyvlx\n        self.__scenes: List[Scene] = []\n\n    def __iter__(self) -> Iterator[Scene]:\n        \"\"\"Iterate.\"\"\"\n        yield from self.__scenes\n\n    def __getitem__(self, key: Union[str, int]) -> Scene:\n        \"\"\"Return scene by name or by index.\"\"\"\n        if isinstance(key, int):\n            for scene in self.__scenes:\n                if scene.scene_id == key:\n                    return scene\n        for scene in self.__scenes:\n            if scene.name == key:\n                return scene\n        raise KeyError\n\n    def __len__(self) -> int:\n        \"\"\"Return number of scenes.\"\"\"\n        return len(self.__scenes)\n\n    def add(self, scene: Scene) -> None:\n        \"\"\"Add scene, replace existing scene if scene with scene_id is present.\"\"\"\n        if not isinstance(scene, Scene):\n            raise TypeError()\n        for i, j in enumerate(self.__scenes):\n            if j.scene_id == scene.scene_id:\n                self.__scenes[i] = scene\n                return\n        self.__scenes.append(scene)\n\n    def clear(self) -> None:\n        \"\"\"Clear internal scenes array.\"\"\"\n        self.__scenes = []\n\n    async def load(self) -> None:\n        \"\"\"Load scenes from KLF 200.\"\"\"\n        get_scene_list = GetSceneList(pyvlx=self.pyvlx)\n        await get_scene_list.do_api_call()\n        if not get_scene_list.success:\n            raise PyVLXException('Unable to retrieve scene information')\n        for scene in get_scene_list.scenes:\n            self.add(Scene(pyvlx=self.pyvlx, scene_id=scene[0], name=scene[1]))\n\nExample skeleton:\n\n\nclass LinuxSSH(CiscoSSHConnection):\n\n    def session_preparation(self) -> None:\n        '''Prepare the session after the connection has been established.'''\n        pass\n\n    def _enter_shell(self) -> str:\n        '''Already in shell.'''\n        pass\n\n    def _return_cli(self) -> str:\n        '''The shell is the CLI.'''\n        pass\n\n    def disable_paging(self, *args: Any, **kwargs: Any) -> str:\n        '''Linux doesn't have paging by default.'''\n        pass\n\n    def find_prompt(self, delay_factor: float=1.0, pattern: Optional[str]=None) -> str:\n        pass\n\n    def set_base_prompt(self, pri_prompt_terminator: str=LINUX_PROMPT_PRI, alt_prompt_terminator: str=LINUX_PROMPT_ALT, delay_factor: float=1.0, pattern: Optional[str]=None) -> str:\n        '''Determine base prompt.'''\n        pass\n\n    def send_config_set(self, config_commands: Union[str, Sequence[str], Iterator[str], TextIO, None]=None, exit_config_mode: bool=True, **kwargs: Any) -> str:\n        '''Can't exit from root (if root)'''\n        pass\n\n    def check_config_mode(self, check_string: str=LINUX_PROMPT_ROOT, pattern: str='', force_regex: bool=False) -> bool:\n        '''Verify root'''\n        pass\n\n    def config_mode(self, config_command: str='sudo -s', pattern: str='ssword', re_flags: int=re.IGNORECASE) -> str:\n        '''Attempt to become root.'''\n        pass\n\n    def exit_config_mode(self, exit_config: str='exit', pattern: str='') -> str:\n        pass\n\n    def check_enable_mode(self, check_string: str=LINUX_PROMPT_ROOT) -> bool:\n        '''Verify root'''\n        pass\n\n    def exit_enable_mode(self, exit_command: str='exit') -> str:\n        '''Exit enable mode.'''\n        pass\n\n    def enable(self, cmd: str='sudo -s', pattern: str='ssword', enable_pattern: Optional[str]=None, check_state: bool=True, re_flags: int=re.IGNORECASE) -> str:\n        '''Attempt to become root.'''\n        pass\n\n    def cleanup(self, command: str='exit') -> None:\n        '''Gracefully exit the SSH session.'''\n        pass\n\n    def save_config(self, *args: Any, **kwargs: Any) -> str:\n        '''Not Implemented'''\n        pass\nCorresponding class implementation:\n\nfrom netmiko.cisco_base_connection import CiscoSSHConnection\nfrom netmiko.exceptions import ReadTimeout\nfrom typing import Any, Optional, TYPE_CHECKING, Union, Sequence, Iterator, TextIO\nimport re\n\nclass LinuxSSH(CiscoSSHConnection):\n    prompt_pattern = f'[{re.escape(LINUX_PROMPT_PRI)}{re.escape(LINUX_PROMPT_ALT)}]'\n\n    def session_preparation(self) -> None:\n        \"\"\"Prepare the session after the connection has been established.\"\"\"\n        self.ansi_escape_codes = True\n        self._test_channel_read(pattern=self.prompt_pattern)\n        self.set_base_prompt()\n\n    def _enter_shell(self) -> str:\n        \"\"\"Already in shell.\"\"\"\n        return ''\n\n    def _return_cli(self) -> str:\n        \"\"\"The shell is the CLI.\"\"\"\n        return ''\n\n    def disable_paging(self, *args: Any, **kwargs: Any) -> str:\n        \"\"\"Linux doesn't have paging by default.\"\"\"\n        return ''\n\n    def find_prompt(self, delay_factor: float=1.0, pattern: Optional[str]=None) -> str:\n        if pattern is None:\n            pattern = self.prompt_pattern\n        return super().find_prompt(delay_factor=delay_factor, pattern=pattern)\n\n    def set_base_prompt(self, pri_prompt_terminator: str=LINUX_PROMPT_PRI, alt_prompt_terminator: str=LINUX_PROMPT_ALT, delay_factor: float=1.0, pattern: Optional[str]=None) -> str:\n        \"\"\"Determine base prompt.\"\"\"\n        if pattern is None:\n            pattern = self.prompt_pattern\n        return super().set_base_prompt(pri_prompt_terminator=pri_prompt_terminator, alt_prompt_terminator=alt_prompt_terminator, delay_factor=delay_factor, pattern=pattern)\n\n    def send_config_set(self, config_commands: Union[str, Sequence[str], Iterator[str], TextIO, None]=None, exit_config_mode: bool=True, **kwargs: Any) -> str:\n        \"\"\"Can't exit from root (if root)\"\"\"\n        if self.username == 'root':\n            exit_config_mode = False\n        return super().send_config_set(config_commands=config_commands, exit_config_mode=exit_config_mode, **kwargs)\n\n    def check_config_mode(self, check_string: str=LINUX_PROMPT_ROOT, pattern: str='', force_regex: bool=False) -> bool:\n        \"\"\"Verify root\"\"\"\n        return self.check_enable_mode(check_string=check_string)\n\n    def config_mode(self, config_command: str='sudo -s', pattern: str='ssword', re_flags: int=re.IGNORECASE) -> str:\n        \"\"\"Attempt to become root.\"\"\"\n        return self.enable(cmd=config_command, pattern=pattern, re_flags=re_flags)\n\n    def exit_config_mode(self, exit_config: str='exit', pattern: str='') -> str:\n        return self.exit_enable_mode(exit_command=exit_config)\n\n    def check_enable_mode(self, check_string: str=LINUX_PROMPT_ROOT) -> bool:\n        \"\"\"Verify root\"\"\"\n        return super().check_enable_mode(check_string=check_string)\n\n    def exit_enable_mode(self, exit_command: str='exit') -> str:\n        \"\"\"Exit enable mode.\"\"\"\n        output = ''\n        if self.check_enable_mode():\n            self.write_channel(self.normalize_cmd(exit_command))\n            output += self.read_until_pattern(pattern=exit_command)\n            output += self.read_until_pattern(pattern=self.prompt_pattern)\n            self.set_base_prompt(pattern=self.prompt_pattern)\n            if self.check_enable_mode():\n                raise ValueError('Failed to exit enable mode.')\n        return output\n\n    def enable(self, cmd: str='sudo -s', pattern: str='ssword', enable_pattern: Optional[str]=None, check_state: bool=True, re_flags: int=re.IGNORECASE) -> str:\n        \"\"\"Attempt to become root.\"\"\"\n        msg = \"\\n\\nNetmiko failed to elevate privileges.\\n\\nPlease ensure you pass the sudo password into ConnectHandler\\nusing the 'secret' argument and that the user has sudo\\npermissions.\\n\\n\"\n        output = ''\n        if check_state and self.check_enable_mode():\n            return output\n        self.write_channel(self.normalize_cmd(cmd))\n        root_prompt = f'(?m:{LINUX_PROMPT_ROOT}\\\\s*$)'\n        prompt_or_password = f'({root_prompt}|{pattern})'\n        output += self.read_until_pattern(pattern=prompt_or_password)\n        if re.search(pattern, output, flags=re_flags):\n            self.write_channel(self.normalize_cmd(self.secret))\n            try:\n                output += self.read_until_pattern(pattern=root_prompt)\n            except ReadTimeout:\n                raise ValueError(msg)\n        self.set_base_prompt(pattern=root_prompt)\n        if not self.check_enable_mode():\n            raise ValueError(msg)\n        return output\n\n    def cleanup(self, command: str='exit') -> None:\n        \"\"\"Gracefully exit the SSH session.\"\"\"\n        try:\n            if self.username != 'root' and self.check_config_mode():\n                self.exit_config_mode()\n        except Exception:\n            pass\n        if self.session_log:\n            self.session_log.fin = True\n        self.write_channel(command + self.RETURN)\n\n    def save_config(self, *args: Any, **kwargs: Any) -> str:\n        \"\"\"Not Implemented\"\"\"\n        raise NotImplementedError\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass LastUsedParams:\n    '''Manages last used parameters persistence (moved from last_used.py).'''\n\n    def __init__(self, config_dir: Optional[Path]=None) -> None:\n        '''Initialize with config directory.'''\n        pass\n\n    def save(self, settings: 'Settings') -> None:\n        '''Save current settings as last used.'''\n        pass\n\n    def load(self) -> Dict[str, Any]:\n        '''Load last used parameters.'''\n        pass\n\n    def clear(self) -> None:\n        '''Clear last used parameters.'''\n        pass\n\n    def exists(self) -> bool:\n        '''Check if last used params exist.'''\n        pass"
  }
]