[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Platform:\n\n    def __init__(self, display_func=print):\n        pass\n    @property\n    def modules(self):\n        '''\n        Accessor for lazily loading modules that either take multiple milliseconds to import\n        (like `shutil` and `subprocess`) or are not used on all platforms (like `shlex`).\n        '''\n        pass\n\n    def format_for_subprocess(self, command: str | list[str], *, shell: bool):\n        '''\n        Format the given command in a cross-platform manner for immediate consumption by subprocess utilities.\n        '''\n        pass\n\n    def exit_with_code(self, code):\n        pass\n\n    def _run_command_integrated(self, command: str | list[str], shell=False, **kwargs):\n        pass\n\n    def run_command(self, command: str | list[str], shell=False, **kwargs):\n        '''\n        Equivalent to the standard library's `subprocess.run`, with the command first being properly formatted.\n        '''\n        pass\n\n    def check_command(self, command: str | list[str], shell=False, on_error: Callable[[int], None] | None=None, **kwargs):\n        '''\n        Equivalent to `run_command`, but non-zero exit codes will gracefully end program execution.\n        If `on_error` is provided, it will be called with the exit code.\n        '''\n        pass\n\n    def check_command_output(self, command: str | list[str], shell=False, on_error: Callable[[int, str], None] | None=None, print_output: bool=False, **kwargs) -> str:\n        '''\n        Equivalent to the output from the process returned by `capture_process`,\n        but non-zero exit codes will gracefully end program execution.\n        If `on_error` is provided, it will be called with the exit code and the stdout of the command.\n        The `print_output` parameter is used to control whether the output of the command is printed to the console\n        in real-time.\n        The output will always be printed to the console if the command fails, even if `print_output` is False.\n        '''\n        pass\n\n    def capture_process(self, command: str | list[str], shell=False, **kwargs):\n        '''\n        Equivalent to the standard library's `subprocess.Popen`, with all output\n        captured by `stdout` and the command first being properly formatted.\n        '''\n        pass\n    @staticmethod\n    def stream_process_output(process):\n        pass\n    @property\n    def format_file_uri(self):\n        pass\n    @property\n    def windows(self):\n        '''\n        Indicates whether ddev is running on Windows.\n        '''\n        pass\n    @property\n    def macos(self):\n        '''\n        Indicates whether ddev is running on macOS.\n        '''\n        pass\n    @property\n    def linux(self):\n        '''\n        Indicates whether ddev is running on neither Windows nor macOS.\n        '''\n        pass\n\n    def exit_with_command(self, command: list[str]):\n        '''\n        Run the given command and exit with its exit code. On non-Windows systems, this uses the standard library's\n        `os.execvp`.\n        '''\n        pass\n    @property\n    def name(self):\n        '''\n        One of the following:\n        - `linux`\n        - `windows`\n        - `macos`\n        '''\n        pass\nCorresponding class implementation:\n\nfrom collections.abc import Callable\nimport os\nimport sys\n\nclass Platform:\n\n    def __init__(self, display_func=print):\n        self.__display_func = display_func\n        self.__default_shell = None\n        self.__format_file_uri = None\n        self.__join_command_args = None\n        self.__name = None\n        self.displaying_status = False\n        self.__modules = LazilyLoadedModules()\n\n    @property\n    def modules(self):\n        \"\"\"\n        Accessor for lazily loading modules that either take multiple milliseconds to import\n        (like `shutil` and `subprocess`) or are not used on all platforms (like `shlex`).\n        \"\"\"\n        return self.__modules\n\n    def format_for_subprocess(self, command: str | list[str], *, shell: bool):\n        \"\"\"\n        Format the given command in a cross-platform manner for immediate consumption by subprocess utilities.\n        \"\"\"\n        if self.windows:\n            if not shell and (not isinstance(command, str)):\n                executable = command[0]\n                new_command = [self.modules.shutil.which(executable) or executable]\n                new_command.extend(command[1:])\n                return new_command\n        elif not shell and isinstance(command, str):\n            return self.modules.shlex.split(command)\n        return command\n\n    def exit_with_code(self, code):\n        return sys.exit(code)\n\n    def _run_command_integrated(self, command: str | list[str], shell=False, **kwargs):\n        with self.capture_process(command, shell=shell, **kwargs) as process:\n            for line in self.stream_process_output(process):\n                self.__display_func(line, end='')\n            stdout, stderr = process.communicate()\n        return self.modules.subprocess.CompletedProcess(process.args, process.poll(), stdout, stderr)\n\n    def run_command(self, command: str | list[str], shell=False, **kwargs):\n        \"\"\"\n        Equivalent to the standard library's `subprocess.run`, with the command first being properly formatted.\n        \"\"\"\n        if self.displaying_status and (not kwargs.get('capture_output')):\n            return self._run_command_integrated(command, shell=shell, **kwargs)\n        return self.modules.subprocess.run(self.format_for_subprocess(command, shell=shell), shell=shell, **kwargs)\n\n    def check_command(self, command: str | list[str], shell=False, on_error: Callable[[int], None] | None=None, **kwargs):\n        \"\"\"\n        Equivalent to `run_command`, but non-zero exit codes will gracefully end program execution.\n\n        If `on_error` is provided, it will be called with the exit code.\n        \"\"\"\n        process = self.run_command(command, shell=shell, **kwargs)\n        if process.returncode:\n            if on_error is not None:\n                on_error(process.returncode)\n            self.exit_with_code(process.returncode)\n        return process\n\n    def check_command_output(self, command: str | list[str], shell=False, on_error: Callable[[int, str], None] | None=None, print_output: bool=False, **kwargs) -> str:\n        \"\"\"\n        Equivalent to the output from the process returned by `capture_process`,\n        but non-zero exit codes will gracefully end program execution.\n\n        If `on_error` is provided, it will be called with the exit code and the stdout of the command.\n\n        The `print_output` parameter is used to control whether the output of the command is printed to the console\n        in real-time.\n\n        The output will always be printed to the console if the command fails, even if `print_output` is False.\n        \"\"\"\n        if print_output:\n            kwargs['bufsize'] = 1\n            kwargs['encoding'] = 'utf-8'\n        with self.capture_process(command, shell=shell, **kwargs) as process:\n            if print_output:\n                stdout = ''\n                for line in iter(process.stdout.readline, ''):\n                    stdout += line\n                    self.__display_func(line, end='')\n            else:\n                stdout, _ = process.communicate()\n        if process.returncode:\n            if not print_output:\n                self.__display_func(stdout)\n            if on_error is not None:\n                on_error(process.returncode, stdout)\n            self.exit_with_code(process.returncode)\n        return stdout\n\n    def capture_process(self, command: str | list[str], shell=False, **kwargs):\n        \"\"\"\n        Equivalent to the standard library's `subprocess.Popen`, with all output\n        captured by `stdout` and the command first being properly formatted.\n        \"\"\"\n        return self.modules.subprocess.Popen(self.format_for_subprocess(command, shell=shell), shell=shell, stdout=self.modules.subprocess.PIPE, stderr=self.modules.subprocess.STDOUT, **kwargs)\n\n    @staticmethod\n    def stream_process_output(process):\n        for line in iter(process.stdout.readline, b''):\n            yield line.decode('utf-8')\n\n    @property\n    def format_file_uri(self):\n        if self.__format_file_uri is None:\n            if self.windows:\n                self.__format_file_uri = lambda p: f'file:///{p}'.replace('\\\\', '/')\n            else:\n                self.__format_file_uri = lambda p: f'file://{p}'\n        return self.__format_file_uri\n\n    @property\n    def windows(self):\n        \"\"\"\n        Indicates whether ddev is running on Windows.\n        \"\"\"\n        return self.name == 'windows'\n\n    @property\n    def macos(self):\n        \"\"\"\n        Indicates whether ddev is running on macOS.\n        \"\"\"\n        return self.name == 'macos'\n\n    @property\n    def linux(self):\n        \"\"\"\n        Indicates whether ddev is running on neither Windows nor macOS.\n        \"\"\"\n        return not (self.windows or self.macos)\n\n    def exit_with_command(self, command: list[str]):\n        \"\"\"\n        Run the given command and exit with its exit code. On non-Windows systems, this uses the standard library's\n        `os.execvp`.\n        \"\"\"\n        if self.windows:\n            process = self.run_command(command)\n            self.exit_with_code(process.returncode)\n        else:\n            return os.execvp(command[0], command)\n\n    @property\n    def name(self):\n        \"\"\"\n        One of the following:\n\n        - `linux`\n        - `windows`\n        - `macos`\n        \"\"\"\n        if self.__name is None:\n            self.__name = get_platform_name()\n        return self.__name\n\nExample skeleton:\n\n\nclass SqlQuery:\n    '''\n    Support class for making SQLite query.\n        '''\n    @classmethod\n    def make_update(cls, table: str, set_query: Union[str, Sequence[Set]], where: Optional[WhereQuery]=None) -> str:\n        '''\n        Make UPDATE query.\n        :param str table: Table name of executing the query.\n        :param str set_query: SET part of the UPDATE query.\n        :param str where:\n            Add a WHERE clause to execute query,\n            if the value is not |None|.\n        :return: Query of SQLite.\n        :rtype: str\n        :raises ValueError: If ``set_query`` is empty string.\n        :raises simplesqlite.NameValidationError:\n            |raises_validate_table_name|\n        '''\n        pass\n    @classmethod\n    def make_where_in(cls, key: str, value_list: Sequence[str]) -> str:\n        '''\n        Make part of WHERE IN query.\n        :param str key: Attribute name of the key.\n        :param Sequence[str] value_list:\n            List of values that the right hand side associated with the key.\n        :return: Part of WHERE query of SQLite.\n        :rtype: str\n        :Examples:\n            >>> from simplesqlite.sqlquery import SqlQuery\n            >>> SqlQuery.make_where_in(\"key\", [\"hoge\", \"foo\", \"bar\"])\n            \"key IN ('hoge', 'foo', 'bar')\"\n        '''\n        pass\n    @classmethod\n    def make_where_not_in(cls, key: str, value_list: Sequence[str]) -> str:\n        '''\n        Make part of WHERE NOT IN query.\n        :param str key: Attribute name of the key.\n        :param Sequence[str] value_list:\n            List of values that the right hand side associated with the key.\n        :return: Part of WHERE query of SQLite.\n        :rtype: str\n        :Example:\n            >>> from simplesqlite.sqlquery import SqlQuery\n            >>> SqlQuery.make_where_not_in(\"key\", [\"hoge\", \"foo\", \"bar\"])\n            \"key NOT IN ('hoge', 'foo', 'bar')\"\n        '''\n        pass\nCorresponding class implementation:\n\nfrom typing import Optional, Union\nimport typepy\nfrom ._func import validate_table_name\nfrom .query import And, Attr, Or, Set, Table, Value, Where, WhereQuery\nfrom collections.abc import Sequence\n\nclass SqlQuery:\n    \"\"\"\n    Support class for making SQLite query.\n    \"\"\"\n\n    @classmethod\n    def make_update(cls, table: str, set_query: Union[str, Sequence[Set]], where: Optional[WhereQuery]=None) -> str:\n        \"\"\"\n        Make UPDATE query.\n\n        :param str table: Table name of executing the query.\n        :param str set_query: SET part of the UPDATE query.\n        :param str where:\n            Add a WHERE clause to execute query,\n            if the value is not |None|.\n        :return: Query of SQLite.\n        :rtype: str\n        :raises ValueError: If ``set_query`` is empty string.\n        :raises simplesqlite.NameValidationError:\n            |raises_validate_table_name|\n        \"\"\"\n        if isinstance(set_query, str):\n            norm_set_query = set_query\n        else:\n            norm_set_query = ', '.join([query.to_query() for query in set_query])\n        validate_table_name(table)\n        if typepy.is_null_string(norm_set_query):\n            raise ValueError('SET query is null')\n        query_list = [f'UPDATE {Table(table):s}', f'SET {norm_set_query:s}']\n        if where and isinstance(where, (str, Where, And, Or)):\n            query_list.append(f'WHERE {where:s}')\n        return ' '.join(query_list)\n\n    @classmethod\n    def make_where_in(cls, key: str, value_list: Sequence[str]) -> str:\n        \"\"\"\n        Make part of WHERE IN query.\n\n        :param str key: Attribute name of the key.\n        :param Sequence[str] value_list:\n            List of values that the right hand side associated with the key.\n        :return: Part of WHERE query of SQLite.\n        :rtype: str\n\n        :Examples:\n            >>> from simplesqlite.sqlquery import SqlQuery\n            >>> SqlQuery.make_where_in(\"key\", [\"hoge\", \"foo\", \"bar\"])\n            \"key IN ('hoge', 'foo', 'bar')\"\n        \"\"\"\n        return '{:s} IN ({:s})'.format(Attr(key), ', '.join([Value(value).to_query() for value in value_list]))\n\n    @classmethod\n    def make_where_not_in(cls, key: str, value_list: Sequence[str]) -> str:\n        \"\"\"\n        Make part of WHERE NOT IN query.\n\n        :param str key: Attribute name of the key.\n        :param Sequence[str] value_list:\n            List of values that the right hand side associated with the key.\n        :return: Part of WHERE query of SQLite.\n        :rtype: str\n\n        :Example:\n            >>> from simplesqlite.sqlquery import SqlQuery\n            >>> SqlQuery.make_where_not_in(\"key\", [\"hoge\", \"foo\", \"bar\"])\n            \"key NOT IN ('hoge', 'foo', 'bar')\"\n        \"\"\"\n        return '{:s} NOT IN ({:s})'.format(Attr(key), ', '.join([Value(value).to_query() for value in value_list]))\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass TargetPython:\n    '''\n    Encapsulates the properties of a Python interpreter one is targeting\n    for a package install, download, etc.\n    '''\n\n    def __init__(self, platforms: Optional[List[str]]=None, py_version_info: Optional[Tuple[int, ...]]=None, abis: Optional[List[str]]=None, implementation: Optional[str]=None) -> None:\n        '''\n        :param platforms: A list of strings or None. If None, searches for\n            packages that are supported by the current system. Otherwise, will\n            find packages that can be built on the platforms passed in. These\n            packages will only be downloaded for distribution: they will\n            not be built locally.\n        :param py_version_info: An optional tuple of ints representing the\n            Python version information to use (e.g. `sys.version_info[:3]`).\n            This can have length 1, 2, or 3 when provided.\n        :param abis: A list of strings or None. This is passed to\n            compatibility_tags.py's get_supported() function as is.\n        :param implementation: A string or None. This is passed to\n            compatibility_tags.py's get_supported() function as is.\n        '''\n        pass\n\n    def format_given(self) -> str:\n        '''\n        Format the given, non-None attributes for display.\n        '''\n        pass\n\n    def get_sorted_tags(self) -> List[Tag]:\n        '''\n        Return the supported PEP 425 tags to check wheel candidates against.\n        The tags are returned in order of preference (most preferred first).\n        '''\n        pass\n\n    def get_unsorted_tags(self) -> Set[Tag]:\n        '''Exactly the same as get_sorted_tags, but returns a set.\n        This is important for performance.\n        '''\n        pass"
  }
]