[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\nclass AnalyzersManager(object):\n    '''Class that implements the analyzers manager.'''\n    @classmethod\n    def DeregisterAnalyzer(cls, analyzer_class):\n        '''Deregisters a analyzer class.\n        The analyzer classes are identified based on their lower case name.\n        Args:\n          analyzer_class (type): class object of the analyzer.\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzersInformation(cls):\n        '''Retrieves the analyzers information.\n        Returns:\n          list[tuple]: containing:\n            str: analyzer name.\n            str: analyzer description.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzerInstance(cls, analyzer_name):\n        '''Retrieves an instance of a specific analyzer.\n        Args:\n          analyzer_name (str): name of the analyzer to retrieve.\n        Returns:\n          BaseAnalyzer: analyzer instance.\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzerInstances(cls, analyzer_names):\n        '''Retrieves instances for all the specified analyzers.\n        Args:\n          analyzer_names (list[str]): names of the analyzers to retrieve.\n        Returns:\n          list[BaseAnalyzer]: analyzer instances.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzerNames(cls):\n        '''Retrieves the names of all loaded analyzers.\n        Returns:\n          list[str]: of analyzer names.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzersInformation(cls):\n        '''Retrieves the registered analyzers.\n        Yields:\n          tuple: containing:\n            str: the uniquely identifying name of the analyzer\n            type: the analyzer class.\n        '''\n        pass\n    @classmethod\n    def RegisterAnalyzer(cls, analyzer_class):\n        '''Registers a analyzer class.\n        The analyzer classes are identified by their lower case name.\n        Args:\n          analyzer_class (type): the analyzer class to register.\n        Raises:\n          KeyError: if analyzer class is already set for the corresponding name.\n        '''\n        pass\nCorresponding class implementation:\n\nclass AnalyzersManager(object):\n    \"\"\"Class that implements the analyzers manager.\"\"\"\n    _analyzer_classes = {}\n\n    @classmethod\n    def DeregisterAnalyzer(cls, analyzer_class):\n        \"\"\"Deregisters a analyzer class.\n\n        The analyzer classes are identified based on their lower case name.\n\n        Args:\n          analyzer_class (type): class object of the analyzer.\n\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        \"\"\"\n        analyzer_name = analyzer_class.NAME.lower()\n        if analyzer_name not in cls._analyzer_classes:\n            raise KeyError(f'analyzer class not set for name: {analyzer_class.NAME:s}')\n        del cls._analyzer_classes[analyzer_name]\n\n    @classmethod\n    def GetAnalyzersInformation(cls):\n        \"\"\"Retrieves the analyzers information.\n\n        Returns:\n          list[tuple]: containing:\n\n            str: analyzer name.\n            str: analyzer description.\n        \"\"\"\n        analyzer_information = []\n        for _, analyzer_class in cls.GetAnalyzers():\n            description = getattr(analyzer_class, 'DESCRIPTION', '')\n            analyzer_information.append((analyzer_class.NAME, description))\n        return analyzer_information\n\n    @classmethod\n    def GetAnalyzerInstance(cls, analyzer_name):\n        \"\"\"Retrieves an instance of a specific analyzer.\n\n        Args:\n          analyzer_name (str): name of the analyzer to retrieve.\n\n        Returns:\n          BaseAnalyzer: analyzer instance.\n\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        \"\"\"\n        analyzer_name = analyzer_name.lower()\n        if analyzer_name not in cls._analyzer_classes:\n            raise KeyError(f'analyzer class not set for name: {analyzer_name:s}.')\n        analyzer_class = cls._analyzer_classes[analyzer_name]\n        return analyzer_class()\n\n    @classmethod\n    def GetAnalyzerInstances(cls, analyzer_names):\n        \"\"\"Retrieves instances for all the specified analyzers.\n\n        Args:\n          analyzer_names (list[str]): names of the analyzers to retrieve.\n\n        Returns:\n          list[BaseAnalyzer]: analyzer instances.\n        \"\"\"\n        analyzer_instances = []\n        for analyzer_name, analyzer_class in cls.GetAnalyzers():\n            if analyzer_name in analyzer_names:\n                analyzer_instances.append(analyzer_class())\n        return analyzer_instances\n\n    @classmethod\n    def GetAnalyzerNames(cls):\n        \"\"\"Retrieves the names of all loaded analyzers.\n\n        Returns:\n          list[str]: of analyzer names.\n        \"\"\"\n        return cls._analyzer_classes.keys()\n\n    @classmethod\n    def GetAnalyzers(cls):\n        \"\"\"Retrieves the registered analyzers.\n\n        Yields:\n          tuple: containing:\n\n            str: the uniquely identifying name of the analyzer\n            type: the analyzer class.\n        \"\"\"\n        for analyzer_name, analyzer_class in cls._analyzer_classes.items():\n            yield (analyzer_name, analyzer_class)\n\n    @classmethod\n    def RegisterAnalyzer(cls, analyzer_class):\n        \"\"\"Registers a analyzer class.\n\n        The analyzer classes are identified by their lower case name.\n\n        Args:\n          analyzer_class (type): the analyzer class to register.\n\n        Raises:\n          KeyError: if analyzer class is already set for the corresponding name.\n        \"\"\"\n        analyzer_name = analyzer_class.NAME.lower()\n        if analyzer_name in cls._analyzer_classes:\n            raise KeyError(f'analyzer class already set for name: {analyzer_class.NAME:s}.')\n        cls._analyzer_classes[analyzer_name] = analyzer_class\n\nExample skeleton:\n\n\nclass State:\n    '''State class that allows the reading and writing of state to a given\n    path. Input and output state transformations can be supplied in read_fn and\n    write_fn respectively. The input state transformation takes in a string\n    while the output transformation outputs a string. If run inside a GitHub\n    Action, the saved state file could be committed to GitHub so that on next\n    run the state is available in the repository.\n    Args:\n        path (str): Path to save state file\n        read_fn (Callable[[str], Any]): Input state transformation. Defaults to lambda x: x.\n        write_fn: Callable[[Any], str]: Output state transformation. Defaults to lambda x: x.\n    '''\n\n    def __init__(self, path: str, read_fn: Callable[[str], Any]=lambda x: x, write_fn: Callable[[Any], str]=lambda x: x) -> None:\n        pass\n\n    def __enter__(self) -> 'State':\n        '''Allow usage of with.\n        Returns:\n            State: SavedState object\n        '''\n        pass\n\n    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None:\n        '''Allow usage of with.\n        Args:\n            exc_type (Any): Exception type\n            exc_value (Any): Exception value\n            traceback (Any): Traceback\n        Returns:\n            None\n        '''\n        pass\n\n    def read(self) -> Any:\n        '''Read state from file\n        Returns:\n            Any: State\n        '''\n        pass\n\n    def write(self) -> None:\n        '''Write state to file\n        Returns:\n            None\n        '''\n        pass\n\n    def get(self) -> Any:\n        '''Get the state\n        Returns:\n            Any: State\n        '''\n        pass\n\n    def set(self, state: Any):\n        '''Set the state\n        Args:\n            state (Any): State\n        Returns:\n            None\n        '''\n        pass\n    @staticmethod\n    def dates_str_to_country_date_dict(dates_str: str) -> Dict:\n        '''Convert a comma separated string of key=date string pairs eg.\n        \"default=2017-01-01,afg=2019-01-01\" to a dictionary of key date\n        mappings eg.\n        {\"default\": 2017-01-01 as datetime, \"afg\": 2019-01-01 as datetime}\n        Args:\n            dates_str (str): Comma separated string of key=date string pairs\n        Returns:\n            Dict: Dictionary of key date mappings\n        '''\n        pass\n    @staticmethod\n    def country_date_dict_to_dates_str(country_date_dict: Dict) -> str:\n        '''Convert a dictionary of key date mappings eg.\n        {\"default\": 2017-01-01 as datetime, \"afg\": 2019-01-01 as datetime}\n        to a comma separated string of key=date string pairs eg.\n        \"default=2017-01-01,afg=2019-01-01\"\n        Args:\n            country_date_dict (Dict): Dictionary of key date mappings\n        Returns:\n            str: Comma separated string of key=date string pairs\n        '''\n        pass\nCorresponding class implementation:\n\nfrom typing import Any, Callable, Dict\nfrom hdx.utilities.loader import load_text\nfrom hdx.utilities.dateparse import iso_string_from_datetime, parse_date\nfrom hdx.utilities.saver import save_text\n\nclass State:\n    \"\"\"State class that allows the reading and writing of state to a given\n    path. Input and output state transformations can be supplied in read_fn and\n    write_fn respectively. The input state transformation takes in a string\n    while the output transformation outputs a string. If run inside a GitHub\n    Action, the saved state file could be committed to GitHub so that on next\n    run the state is available in the repository.\n\n    Args:\n        path (str): Path to save state file\n        read_fn (Callable[[str], Any]): Input state transformation. Defaults to lambda x: x.\n        write_fn: Callable[[Any], str]: Output state transformation. Defaults to lambda x: x.\n    \"\"\"\n\n    def __init__(self, path: str, read_fn: Callable[[str], Any]=lambda x: x, write_fn: Callable[[Any], str]=lambda x: x) -> None:\n        self.path = path\n        self.read_fn = read_fn\n        self.write_fn = write_fn\n        self.state = self.read()\n\n    def __enter__(self) -> 'State':\n        \"\"\"Allow usage of with.\n\n        Returns:\n            State: SavedState object\n        \"\"\"\n        return self\n\n    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None:\n        \"\"\"Allow usage of with.\n\n        Args:\n            exc_type (Any): Exception type\n            exc_value (Any): Exception value\n            traceback (Any): Traceback\n\n        Returns:\n            None\n        \"\"\"\n        self.write()\n\n    def read(self) -> Any:\n        \"\"\"Read state from file\n\n        Returns:\n            Any: State\n        \"\"\"\n        value = self.read_fn(load_text(self.path))\n        logger.info(f'State read from {self.path} = {value}')\n        return value\n\n    def write(self) -> None:\n        \"\"\"Write state to file\n\n        Returns:\n            None\n        \"\"\"\n        logger.info(f'State written to {self.path} = {self.state}')\n        save_text(self.write_fn(self.state), self.path)\n\n    def get(self) -> Any:\n        \"\"\"Get the state\n\n        Returns:\n            Any: State\n        \"\"\"\n        return self.state\n\n    def set(self, state: Any):\n        \"\"\"Set the state\n\n        Args:\n            state (Any): State\n\n        Returns:\n            None\n        \"\"\"\n        self.state = state\n\n    @staticmethod\n    def dates_str_to_country_date_dict(dates_str: str) -> Dict:\n        \"\"\"Convert a comma separated string of key=date string pairs eg.\n        \"default=2017-01-01,afg=2019-01-01\" to a dictionary of key date\n        mappings eg.\n        {\"default\": 2017-01-01 as datetime, \"afg\": 2019-01-01 as datetime}\n\n        Args:\n            dates_str (str): Comma separated string of key=date string pairs\n\n        Returns:\n            Dict: Dictionary of key date mappings\n        \"\"\"\n        result = {}\n        for keyvalue in dates_str.split(','):\n            key, value = keyvalue.split('=')\n            result[key] = parse_date(value)\n        return result\n\n    @staticmethod\n    def country_date_dict_to_dates_str(country_date_dict: Dict) -> str:\n        \"\"\"Convert a dictionary of key date mappings eg.\n        {\"default\": 2017-01-01 as datetime, \"afg\": 2019-01-01 as datetime}\n        to a comma separated string of key=date string pairs eg.\n        \"default=2017-01-01,afg=2019-01-01\"\n\n        Args:\n            country_date_dict (Dict): Dictionary of key date mappings\n\n        Returns:\n            str: Comma separated string of key=date string pairs\n        \"\"\"\n        strlist = []\n        for key, value in country_date_dict.items():\n            valstr = iso_string_from_datetime(value)\n            strlist.append(f'{key}={valstr}')\n        return ','.join(strlist)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass UnifiedAuthFactory:\n    '''Factory for creating model and storage authentication providers.'''\n    @staticmethod\n    def create_model_auth(provider: str, **kwargs) -> ModelAuthProvider:\n        '''Create a model endpoint authentication provider.\n        Args:\n            provider: Provider type ('openai', 'oci', 'aws-bedrock',\n                'azure-openai', 'gcp-vertex')\n            **kwargs: Provider-specific arguments\n        Returns:\n            ModelAuthProvider instance\n        Raises:\n            ValueError: If provider is not supported\n        '''\n        pass\n    @staticmethod\n    def create_storage_auth(provider: str, **kwargs) -> StorageAuthProvider:\n        '''Create a storage authentication provider.\n        Args:\n            provider: Provider type ('oci', 'aws', 'azure', 'gcp', 'github')\n            **kwargs: Provider-specific arguments\n        Returns:\n            StorageAuthProvider instance\n        Raises:\n            ValueError: If provider is not supported\n        '''\n        pass"
  }
]