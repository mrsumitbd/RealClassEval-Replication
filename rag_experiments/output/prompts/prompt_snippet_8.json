[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass SearchSettingsConversationalSearch:\n    '''\n    Configuration settings for conversational search.\n    :param bool enabled: Whether to enable conversational search.\n    :param SearchSettingsConversationalSearchResponseLength response_length:\n          (optional)\n    :param SearchSettingsConversationalSearchSearchConfidence search_confidence:\n          (optional)\n    '''\n\n    def __init__(self, enabled: bool, *, response_length: Optional['SearchSettingsConversationalSearchResponseLength']=None, search_confidence: Optional['SearchSettingsConversationalSearchSearchConfidence']=None) -> None:\n        '''\n        Initialize a SearchSettingsConversationalSearch object.\n        :param bool enabled: Whether to enable conversational search.\n        :param SearchSettingsConversationalSearchResponseLength response_length:\n               (optional)\n        :param SearchSettingsConversationalSearchSearchConfidence\n               search_confidence: (optional)\n        '''\n        pass\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'SearchSettingsConversationalSearch':\n        '''Initialize a SearchSettingsConversationalSearch object from a json dictionary.'''\n        pass\n    @classmethod\n    def _from_dict(cls, _dict):\n        '''Initialize a SearchSettingsConversationalSearch object from a json dictionary.'''\n        pass\n\n    def to_dict(self) -> Dict:\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def _to_dict(self):\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Return a `str` version of this SearchSettingsConversationalSearch object.'''\n        pass\n\n    def __eq__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        '''Return `true` when self and other are equal, false otherwise.'''\n        pass\n\n    def __ne__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        '''Return `true` when self and other are not equal, false otherwise.'''\n        pass\nCorresponding class implementation:\n\nimport json\nfrom typing import BinaryIO, Dict, List, Optional\n\nclass SearchSettingsConversationalSearch:\n    \"\"\"\n    Configuration settings for conversational search.\n\n    :param bool enabled: Whether to enable conversational search.\n    :param SearchSettingsConversationalSearchResponseLength response_length:\n          (optional)\n    :param SearchSettingsConversationalSearchSearchConfidence search_confidence:\n          (optional)\n    \"\"\"\n\n    def __init__(self, enabled: bool, *, response_length: Optional['SearchSettingsConversationalSearchResponseLength']=None, search_confidence: Optional['SearchSettingsConversationalSearchSearchConfidence']=None) -> None:\n        \"\"\"\n        Initialize a SearchSettingsConversationalSearch object.\n\n        :param bool enabled: Whether to enable conversational search.\n        :param SearchSettingsConversationalSearchResponseLength response_length:\n               (optional)\n        :param SearchSettingsConversationalSearchSearchConfidence\n               search_confidence: (optional)\n        \"\"\"\n        self.enabled = enabled\n        self.response_length = response_length\n        self.search_confidence = search_confidence\n\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'SearchSettingsConversationalSearch':\n        \"\"\"Initialize a SearchSettingsConversationalSearch object from a json dictionary.\"\"\"\n        args = {}\n        if (enabled := _dict.get('enabled')) is not None:\n            args['enabled'] = enabled\n        else:\n            raise ValueError(\"Required property 'enabled' not present in SearchSettingsConversationalSearch JSON\")\n        if (response_length := _dict.get('response_length')) is not None:\n            args['response_length'] = SearchSettingsConversationalSearchResponseLength.from_dict(response_length)\n        if (search_confidence := _dict.get('search_confidence')) is not None:\n            args['search_confidence'] = SearchSettingsConversationalSearchSearchConfidence.from_dict(search_confidence)\n        return cls(**args)\n\n    @classmethod\n    def _from_dict(cls, _dict):\n        \"\"\"Initialize a SearchSettingsConversationalSearch object from a json dictionary.\"\"\"\n        return cls.from_dict(_dict)\n\n    def to_dict(self) -> Dict:\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        _dict = {}\n        if hasattr(self, 'enabled') and self.enabled is not None:\n            _dict['enabled'] = self.enabled\n        if hasattr(self, 'response_length') and self.response_length is not None:\n            if isinstance(self.response_length, dict):\n                _dict['response_length'] = self.response_length\n            else:\n                _dict['response_length'] = self.response_length.to_dict()\n        if hasattr(self, 'search_confidence') and self.search_confidence is not None:\n            if isinstance(self.search_confidence, dict):\n                _dict['search_confidence'] = self.search_confidence\n            else:\n                _dict['search_confidence'] = self.search_confidence.to_dict()\n        return _dict\n\n    def _to_dict(self):\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        return self.to_dict()\n\n    def __str__(self) -> str:\n        \"\"\"Return a `str` version of this SearchSettingsConversationalSearch object.\"\"\"\n        return json.dumps(self.to_dict(), indent=2)\n\n    def __eq__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        \"\"\"Return `true` when self and other are equal, false otherwise.\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        \"\"\"Return `true` when self and other are not equal, false otherwise.\"\"\"\n        return not self == other\n\nExample skeleton:\n\n\nclass DatasetBatches(ImageBatchesBase):\n    '''Class which stores batches of images from the dataset.'''\n\n    def __init__(self, datastore_client, storage_client, dataset_name):\n        '''Initializes DatasetBatches.\n        Args:\n          datastore_client: instance of CompetitionDatastoreClient\n          storage_client: instance of CompetitionStorageClient\n          dataset_name: name of the dataset ('dev' or 'final')\n        '''\n        pass\n\n    def _read_image_list(self, skip_image_ids=None):\n        '''Reads list of dataset images from the datastore.'''\n        pass\n\n    def init_from_storage_write_to_datastore(self, batch_size=100, allowed_epsilon=None, skip_image_ids=None, max_num_images=None):\n        '''Initializes dataset batches from the list of images in the datastore.\n        Args:\n          batch_size: batch size\n          allowed_epsilon: list of allowed epsilon or None to use default\n          skip_image_ids: list of image ids to skip\n          max_num_images: maximum number of images to read\n        '''\n        pass\nCorresponding class implementation:\n\nimport zipfile\nimport os\nfrom io import BytesIO\nimport copy\nimport logging\n\nclass DatasetBatches(ImageBatchesBase):\n    \"\"\"Class which stores batches of images from the dataset.\"\"\"\n\n    def __init__(self, datastore_client, storage_client, dataset_name):\n        \"\"\"Initializes DatasetBatches.\n\n        Args:\n          datastore_client: instance of CompetitionDatastoreClient\n          storage_client: instance of CompetitionStorageClient\n          dataset_name: name of the dataset ('dev' or 'final')\n        \"\"\"\n        super(DatasetBatches, self).__init__(datastore_client=datastore_client, entity_kind_batches=KIND_DATASET_BATCH, entity_kind_images=KIND_DATASET_IMAGE)\n        self._storage_client = storage_client\n        self._dataset_name = dataset_name\n\n    def _read_image_list(self, skip_image_ids=None):\n        \"\"\"Reads list of dataset images from the datastore.\"\"\"\n        if skip_image_ids is None:\n            skip_image_ids = []\n        images = self._storage_client.list_blobs(prefix=os.path.join('dataset', self._dataset_name) + '/')\n        zip_files = [i for i in images if i.endswith('.zip')]\n        if len(zip_files) == 1:\n            zip_name = zip_files[0]\n            logging.info('Reading list of images from zip file %s', zip_name)\n            blob = self._storage_client.get_blob(zip_name)\n            buf = BytesIO()\n            logging.info('Downloading zip')\n            blob.download_to_file(buf)\n            buf.seek(0)\n            logging.info('Reading content of the zip')\n            with zipfile.ZipFile(buf) as f:\n                images = [os.path.join(zip_name, os.path.basename(n)) for n in f.namelist() if n.endswith('.png')]\n            buf.close()\n            logging.info('Found %d images', len(images))\n        else:\n            logging.info('Reading list of images from png files in storage')\n            images = [i for i in images if i.endswith('.png')]\n            logging.info('Found %d images', len(images))\n        images = [i for i in images if os.path.basename(i)[:-4] not in skip_image_ids]\n        images = [(DATASET_IMAGE_ID_PATTERN.format(idx), i) for idx, i in enumerate(sorted(images))]\n        return images\n\n    def init_from_storage_write_to_datastore(self, batch_size=100, allowed_epsilon=None, skip_image_ids=None, max_num_images=None):\n        \"\"\"Initializes dataset batches from the list of images in the datastore.\n\n        Args:\n          batch_size: batch size\n          allowed_epsilon: list of allowed epsilon or None to use default\n          skip_image_ids: list of image ids to skip\n          max_num_images: maximum number of images to read\n        \"\"\"\n        if allowed_epsilon is None:\n            allowed_epsilon = copy.copy(DEFAULT_EPSILON)\n        self._dataset_batches = {}\n        images = self._read_image_list(skip_image_ids)\n        if max_num_images:\n            images = images[:max_num_images]\n        for batch_idx, batch_start in enumerate(range(0, len(images), batch_size)):\n            batch = images[batch_start:batch_start + batch_size]\n            batch_id = DATASET_BATCH_ID_PATTERN.format(batch_idx)\n            batch_epsilon = allowed_epsilon[batch_idx % len(allowed_epsilon)]\n            self.add_batch(batch_id, {'epsilon': batch_epsilon})\n            for image_id, image_path in batch:\n                self.add_image(batch_id, image_id, {'dataset_image_id': os.path.basename(image_path)[:-4], 'image_path': image_path})\n        self.write_to_datastore()\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass L0KnowledgeRetriever:\n    '''L0 knowledge retriever'''\n\n    def __init__(self, embedding_service: EmbeddingService, similarity_threshold: float=0.7, max_chunks: int=3):\n        '''\n        init L0 knowledge retriever\n        Args:\n            embedding_service: Embedding service instance\n            similarity_threshold: only return contents whose similarity bigger than this value\n            max_chunks: the maximum number of return chunks\n        '''\n        pass\n\n    def retrieve(self, query: str) -> str:\n        '''\n        retrieve L0 knowledge\n        Args:\n            query: query content\n        Returns:\n            str: structured knowledge content, or empty string if no relevant knowledge found\n        '''\n        pass"
  }
]