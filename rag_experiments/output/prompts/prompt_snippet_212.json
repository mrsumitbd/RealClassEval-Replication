[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Step:\n    '''State machine for executing generic actions related to stacks.\n    Attributes:\n        fn: Function to run to execute the step.\n            This function will be ran multiple times until the step is \"done\".\n        last_updated: Time when the step was last updated.\n        logger: Logger for logging messages about the step.\n        stack: the stack associated with this step\n        status: The status of step.\n        watch_func: Function that will be called to \"tail\" the step action.\n    '''\n\n    def __init__(self, stack: Stack, *, fn: Callable[..., Any] | None=None, watch_func: Callable[..., Any] | None=None) -> None:\n        '''Instantiate class.\n        Args:\n            stack: The stack associated\n                with this step\n            fn: Function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: Function that will be called to \"tail\" the step action.\n        '''\n        pass\n\n    def run(self) -> bool:\n        '''Run this step until it has completed or been skipped.'''\n        pass\n\n    def _run_once(self) -> Status:\n        '''Run a step exactly once.'''\n        pass\n    @property\n    def name(self) -> str:\n        '''Name of the step.\n        This is equal to the name of the stack it operates on.\n        '''\n        pass\n    @property\n    def requires(self) -> set[str]:\n        '''Return a list of step names this step depends on.'''\n        pass\n    @property\n    def required_by(self) -> set[str]:\n        '''Return a list of step names that depend on this step.'''\n        pass\n    @property\n    def completed(self) -> bool:\n        '''Return True if the step is in a COMPLETE state.'''\n        pass\n    @property\n    def skipped(self) -> bool:\n        '''Return True if the step is in a SKIPPED state.'''\n        pass\n    @property\n    def failed(self) -> bool:\n        '''Return True if the step is in a FAILED state.'''\n        pass\n    @property\n    def done(self) -> bool:\n        '''Return True if the step is finished.\n        To be ``True``, status must be either COMPLETE, SKIPPED or FAILED)\n        '''\n        pass\n    @property\n    def ok(self) -> bool:\n        '''Return True if the step is finished (either COMPLETE or SKIPPED).'''\n        pass\n    @property\n    def submitted(self) -> bool:\n        '''Return True if the step is SUBMITTED, COMPLETE, or SKIPPED.'''\n        pass\n\n    def set_status(self, status: Status) -> None:\n        '''Set the current step's status.\n        Args:\n            status: The status to set the step to.\n        '''\n        pass\n    def completed(self) -> bool:\n        '''Shortcut for ``set_status(COMPLETE)``.'''\n        pass\n\n    def log_step(self) -> None:\n        '''Construct a log message for a set and log it to the UI.'''\n        pass\n    def skipped(self) -> bool:\n        '''Shortcut for ``set_status(SKIPPED)``.'''\n        pass\n    def submitted(self) -> bool:\n        '''Shortcut for ``set_status(SUBMITTED)``.'''\n        pass\n    @classmethod\n    def from_stack_name(cls, stack_name: str, context: CfnginContext, requires: list[str] | set[str] | None=None, fn: Callable[..., Status] | None=None, watch_func: Callable[..., Any] | None=None) -> Step:\n        '''Create a step using only a stack name.\n        Args:\n            stack_name: Name of a CloudFormation stack.\n            context: Context object. Required to initialize a \"fake\"\n                :class:`runway.cfngin.stack.Stack`.\n            requires: Stacks that this stack depends on.\n            fn: The function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: an optional function that will be called to \"tail\" the\n                step action.\n        '''\n        pass\n    @classmethod\n    def from_persistent_graph(cls, graph_dict: dict[str, list[str]] | dict[str, set[str]] | OrderedDict[str, set[str]], context: CfnginContext, fn: Callable[..., Status] | None=None, watch_func: Callable[..., Any] | None=None) -> list[Step]:\n        '''Create a steps for a persistent graph dict.\n        Args:\n            graph_dict: A graph dict.\n            context: Context object. Required to initialize a \"fake\"\n                :class:`runway.cfngin.stack.Stack`.\n            requires: Stacks that this stack depends on.\n            fn: The function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: an optional function that will be called to \"tail\" the\n                step action.\n        '''\n        pass\n\n    def __repr__(self) -> str:\n        '''Object represented as a string.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Object displayed as a string.'''\n        pass\nCorresponding class implementation:\n\nfrom .status import COMPLETE, FAILED, PENDING, SKIPPED, SUBMITTED, FailedStatus, SkippedStatus\nimport time\nfrom .ui import ui\nfrom .._logging import LogLevels, PrefixAdaptor\nimport threading\nfrom .exceptions import CancelExecution, GraphError, PersistentGraphLocked, PlanFailed\nfrom .stack import Stack\nfrom typing import TYPE_CHECKING, Any, Callable, NoReturn, TypeVar, overload\n\nclass Step:\n    \"\"\"State machine for executing generic actions related to stacks.\n\n    Attributes:\n        fn: Function to run to execute the step.\n            This function will be ran multiple times until the step is \"done\".\n        last_updated: Time when the step was last updated.\n        logger: Logger for logging messages about the step.\n        stack: the stack associated with this step\n        status: The status of step.\n        watch_func: Function that will be called to \"tail\" the step action.\n\n    \"\"\"\n    fn: Callable[..., Any] | None\n    last_updated: float\n    logger: PrefixAdaptor\n    stack: Stack\n    status: Status\n    watch_func: Callable[..., Any] | None\n\n    def __init__(self, stack: Stack, *, fn: Callable[..., Any] | None=None, watch_func: Callable[..., Any] | None=None) -> None:\n        \"\"\"Instantiate class.\n\n        Args:\n            stack: The stack associated\n                with this step\n            fn: Function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: Function that will be called to \"tail\" the step action.\n\n        \"\"\"\n        self.stack = stack\n        self.status = PENDING\n        self.last_updated = time.time()\n        self.logger = PrefixAdaptor(self.stack.name, LOGGER)\n        self.fn = fn\n        self.watch_func = watch_func\n\n    def run(self) -> bool:\n        \"\"\"Run this step until it has completed or been skipped.\"\"\"\n        stop_watcher = threading.Event()\n        watcher = None\n        if self.watch_func:\n            watcher = threading.Thread(target=self.watch_func, args=(self.stack, stop_watcher))\n            watcher.start()\n        try:\n            while not self.done:\n                self._run_once()\n        finally:\n            if watcher:\n                stop_watcher.set()\n                watcher.join()\n        return self.ok\n\n    def _run_once(self) -> Status:\n        \"\"\"Run a step exactly once.\"\"\"\n        if not self.fn:\n            raise TypeError('Step.fn must be type Callable[..., Status] not None')\n        try:\n            status = self.fn(self.stack, status=self.status)\n        except CancelExecution:\n            status = SkippedStatus('canceled execution')\n        except Exception as err:\n            LOGGER.exception(err)\n            status = FailedStatus(reason=str(err))\n        self.set_status(status)\n        return status\n\n    @property\n    def name(self) -> str:\n        \"\"\"Name of the step.\n\n        This is equal to the name of the stack it operates on.\n\n        \"\"\"\n        return self.stack.name\n\n    @property\n    def requires(self) -> set[str]:\n        \"\"\"Return a list of step names this step depends on.\"\"\"\n        return self.stack.requires\n\n    @property\n    def required_by(self) -> set[str]:\n        \"\"\"Return a list of step names that depend on this step.\"\"\"\n        return self.stack.required_by\n\n    @property\n    def completed(self) -> bool:\n        \"\"\"Return True if the step is in a COMPLETE state.\"\"\"\n        return self.status == COMPLETE\n\n    @property\n    def skipped(self) -> bool:\n        \"\"\"Return True if the step is in a SKIPPED state.\"\"\"\n        return self.status == SKIPPED\n\n    @property\n    def failed(self) -> bool:\n        \"\"\"Return True if the step is in a FAILED state.\"\"\"\n        return self.status == FAILED\n\n    @property\n    def done(self) -> bool:\n        \"\"\"Return True if the step is finished.\n\n        To be ``True``, status must be either COMPLETE, SKIPPED or FAILED)\n\n        \"\"\"\n        return self.completed or self.skipped or self.failed\n\n    @property\n    def ok(self) -> bool:\n        \"\"\"Return True if the step is finished (either COMPLETE or SKIPPED).\"\"\"\n        return self.completed or self.skipped\n\n    @property\n    def submitted(self) -> bool:\n        \"\"\"Return True if the step is SUBMITTED, COMPLETE, or SKIPPED.\"\"\"\n        return self.status >= SUBMITTED\n\n    def set_status(self, status: Status) -> None:\n        \"\"\"Set the current step's status.\n\n        Args:\n            status: The status to set the step to.\n\n        \"\"\"\n        if status is not self.status:\n            LOGGER.debug('setting %s state to %s...', self.stack.name, status.name)\n            self.status = status\n            self.last_updated = time.time()\n            if self.stack.logging:\n                self.log_step()\n\n    def complete(self) -> None:\n        \"\"\"Shortcut for ``set_status(COMPLETE)``.\"\"\"\n        self.set_status(COMPLETE)\n\n    def log_step(self) -> None:\n        \"\"\"Construct a log message for a set and log it to the UI.\"\"\"\n        msg = self.status.name\n        if self.status.reason:\n            msg += f' ({self.status.reason})'\n        if self.status.code == SUBMITTED.code:\n            ui.log(LogLevels.NOTICE, msg, logger=self.logger)\n        elif self.status.code == COMPLETE.code:\n            ui.log(LogLevels.SUCCESS, msg, logger=self.logger)\n        elif self.status.code == FAILED.code:\n            ui.log(LogLevels.ERROR, msg, logger=self.logger)\n        else:\n            ui.info(msg, logger=self.logger)\n\n    def skip(self) -> None:\n        \"\"\"Shortcut for ``set_status(SKIPPED)``.\"\"\"\n        self.set_status(SKIPPED)\n\n    def submit(self) -> None:\n        \"\"\"Shortcut for ``set_status(SUBMITTED)``.\"\"\"\n        self.set_status(SUBMITTED)\n\n    @classmethod\n    def from_stack_name(cls, stack_name: str, context: CfnginContext, requires: list[str] | set[str] | None=None, fn: Callable[..., Status] | None=None, watch_func: Callable[..., Any] | None=None) -> Step:\n        \"\"\"Create a step using only a stack name.\n\n        Args:\n            stack_name: Name of a CloudFormation stack.\n            context: Context object. Required to initialize a \"fake\"\n                :class:`runway.cfngin.stack.Stack`.\n            requires: Stacks that this stack depends on.\n            fn: The function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: an optional function that will be called to \"tail\" the\n                step action.\n\n        \"\"\"\n        from runway.config.models.cfngin import CfnginStackDefinitionModel\n        stack_def = CfnginStackDefinitionModel.model_construct(name=stack_name, requires=requires or [])\n        stack = Stack(stack_def, context)\n        return cls(stack, fn=fn, watch_func=watch_func)\n\n    @classmethod\n    def from_persistent_graph(cls, graph_dict: dict[str, list[str]] | dict[str, set[str]] | OrderedDict[str, set[str]], context: CfnginContext, fn: Callable[..., Status] | None=None, watch_func: Callable[..., Any] | None=None) -> list[Step]:\n        \"\"\"Create a steps for a persistent graph dict.\n\n        Args:\n            graph_dict: A graph dict.\n            context: Context object. Required to initialize a \"fake\"\n                :class:`runway.cfngin.stack.Stack`.\n            requires: Stacks that this stack depends on.\n            fn: The function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: an optional function that will be called to \"tail\" the\n                step action.\n\n        \"\"\"\n        return [cls.from_stack_name(name, context, requires, fn, watch_func) for name, requires in graph_dict.items()]\n\n    def __repr__(self) -> str:\n        \"\"\"Object represented as a string.\"\"\"\n        return f'<CFNgin.plan.Step:{self.stack.name}>'\n\n    def __str__(self) -> str:\n        \"\"\"Object displayed as a string.\"\"\"\n        return self.stack.name\n\nExample skeleton:\n\n\nclass CfnginConfig(BaseConfig[CfnginConfigDefinitionModel]):\n    '''Python representation of a CFNgin config file.\n    This is used internally by CFNgin to parse and validate a YAML formatted\n    CFNgin configuration file, but can also be used in scripts to generate a\n    CFNgin config file before handing it off to CFNgin to deploy/destroy.\n    Example::\n        from runway.cfngin.config import dump, Config, Stack\n        vpc = Stack({\n            \"name\": \"vpc\",\n            \"class_path\": \"blueprints.VPC\"})\n        config = Config()\n        config.namespace = \"prod\"\n        config.stacks = [vpc]\n        print dump(config)\n    '''\n\n    def __init__(self, data: CfnginConfigDefinitionModel, *, path: Path | None=None, work_dir: Path | None=None) -> None:\n        '''Instantiate class.\n        Args:\n            data: The data model of the config file.\n            path: Path to the config file.\n            work_dir: Working directory.\n        '''\n        pass\n\n    def load(self) -> None:\n        '''Load config options into the current environment/session.'''\n        pass\n    @classmethod\n    def find_config_file(cls, path: Path | None=None, *, exclude: list[str] | None=None) -> list[Path]:\n        '''Find a config file in the provided path.\n        Args:\n            path: The path to search for a config file.\n            exclude: List of file names to exclude. This list is appended to\n                the global exclude list.\n        Raises:\n            ConfigNotFound: Could not find a config file in the provided path.\n            ValueError: More than one config file found in the provided path.\n        '''\n        pass\n    @classmethod\n    def parse_file(cls, *, path: Path | None=None, file_path: Path | None=None, parameters: MutableMapping[str, Any] | None=None, work_dir: Path | None=None, **kwargs: Any) -> CfnginConfig:\n        '''Parse a YAML file to create a config object.\n        Args:\n            path: The path to search for a config file.\n            file_path: Exact path to a file to parse.\n            parameters: Values to use when resolving a raw config.\n            work_dir: Explicit working directory.\n            **kwargs: Arbitrary keyword arguments.\n        Raises:\n            ConfigNotFound: Provided config file was not found.\n        '''\n        pass\n    @classmethod\n    def parse_obj(cls, obj: Any, *, path: Path | None=None, work_dir: Path | None=None) -> CfnginConfig:\n        '''Parse a python object.\n        Args:\n            obj: A python object to parse as a CFNgin config.\n            path: The path to the config file that was parsed into the object.\n            work_dir: Working directory.\n        '''\n        pass\n    @classmethod\n    def parse_raw(cls, data: str, *, parameters: MutableMapping[str, Any] | None=None, path: Path | None=None, skip_package_sources: bool=False, work_dir: Path | None=None) -> CfnginConfig:\n        '''Parse raw data.\n        Args:\n            data: The raw data to parse.\n            parameters: Values to use when resolving a raw config.\n            path: The path to search for a config file.\n            skip_package_sources: Skip processing package sources.\n            work_dir: Explicit working directory.\n        '''\n        pass\n    @classmethod\n    def process_package_sources(cls, raw_data: str, *, parameters: MutableMapping[str, Any] | None=None, work_dir: Path | None=None) -> str:\n        '''Process the package sources defined in a rendered config.\n        Args:\n            raw_data: Raw configuration data.\n            cache_dir: Directory to use when caching remote sources.\n            parameters: Values to use when resolving a raw config.\n            work_dir: Explicit working directory.\n        '''\n        pass\n    @staticmethod\n    def resolve_raw_data(raw_data: str, *, parameters: MutableMapping[str, Any] | None=None) -> str:\n        '''Resolve raw data.\n        Args:\n            raw_data: Raw configuration data.\n            parameters: Values to use when resolving a raw config.\n        Raises:\n            MissingEnvironment: A value required by the config was not provided\n                in parameters.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom string import Template\nfrom ..cfngin.utils import SourceProcessor\nimport re\nfrom ..utils import merge_dicts\nfrom ..exceptions import ConfigNotFound\nimport sys\nfrom typing import TYPE_CHECKING, Any, ClassVar, Generic, TypeVar, cast\nimport yaml\nfrom pathlib import Path\nfrom .models.cfngin import CfnginConfigDefinitionModel, CfnginHookDefinitionModel, CfnginPackageSourcesDefinitionModel, CfnginStackDefinitionModel\nfrom ..cfngin import exceptions\nfrom ..cfngin.lookups.registry import register_lookup_handler\n\nclass CfnginConfig(BaseConfig[CfnginConfigDefinitionModel]):\n    \"\"\"Python representation of a CFNgin config file.\n\n    This is used internally by CFNgin to parse and validate a YAML formatted\n    CFNgin configuration file, but can also be used in scripts to generate a\n    CFNgin config file before handing it off to CFNgin to deploy/destroy.\n\n    Example::\n\n        from runway.cfngin.config import dump, Config, Stack\n\n        vpc = Stack({\n            \"name\": \"vpc\",\n            \"class_path\": \"blueprints.VPC\"})\n\n        config = Config()\n        config.namespace = \"prod\"\n        config.stacks = [vpc]\n\n        print dump(config)\n\n    \"\"\"\n    EXCLUDE_REGEX: ClassVar[str] = '(?x)^(bitbucket-pipelines|buildspec|docker-compose|runway)(\\\\..*)?\\\\.(yml|yaml)'\n    'Regex for file names to exclude when looking for config files.'\n    EXCLUDE_LIST: ClassVar[list[str]] = []\n    'Explicit files names to ignore when looking for config files.'\n    cfngin_bucket: str | None\n    'Bucket to use for CFNgin resources. (e.g. CloudFormation templates).\\n    May be an empty string.\\n    '\n    cfngin_bucket_region: str | None\n    'Explicit region to use for :attr:`CfnginConfig.cfngin_bucket`'\n    cfngin_cache_dir: Path\n    'Local directory to use for caching.'\n    log_formats: dict[str, str]\n    'Custom formatting for log messages.'\n    lookups: dict[str, str]\n    'Register custom lookups.'\n    mappings: dict[str, dict[str, dict[str, Any]]]\n    'Mappings that will be added to all stacks.'\n    namespace: str\n    'Namespace to prepend to everything.'\n    namespace_delimiter: str\n    'Character used to separate :attr:`CfnginConfig.namespace` and anything it prepends.'\n    package_sources: CfnginPackageSourcesDefinitionModel\n    'Remote source locations.'\n    persistent_graph_key: str | None = None\n    'S3 object key were the persistent graph is stored.'\n    post_deploy: list[CfnginHookDefinitionModel]\n    'Hooks to run after a deploy action.'\n    post_destroy: list[CfnginHookDefinitionModel]\n    'Hooks to run after a destroy action.'\n    pre_deploy: list[CfnginHookDefinitionModel]\n    'Hooks to run before a deploy action.'\n    pre_destroy: list[CfnginHookDefinitionModel]\n    'Hooks to run before a destroy action.'\n    service_role: str | None\n    'IAM role for CloudFormation to use.'\n    stacks: list[CfnginStackDefinitionModel]\n    'Stacks to be processed.'\n    sys_path: Path | None\n    'Relative or absolute path to use as the work directory.'\n    tags: dict[str, str] | None\n    'Tags to apply to all resources.'\n    template_indent: int\n    'Spaces to use per-indent level when outputting a template to json.'\n\n    def __init__(self, data: CfnginConfigDefinitionModel, *, path: Path | None=None, work_dir: Path | None=None) -> None:\n        \"\"\"Instantiate class.\n\n        Args:\n            data: The data model of the config file.\n            path: Path to the config file.\n            work_dir: Working directory.\n\n        \"\"\"\n        super().__init__(data, path=path)\n        self.cfngin_bucket = self._data.cfngin_bucket\n        self.cfngin_bucket_region = self._data.cfngin_bucket_region\n        if self._data.cfngin_cache_dir:\n            self.cfngin_cache_dir = self._data.cfngin_cache_dir\n        elif work_dir:\n            self.cfngin_cache_dir = work_dir / 'cache'\n        elif path:\n            self.cfngin_cache_dir = path.parent / '.runway' / 'cache'\n        else:\n            self.cfngin_cache_dir = Path().cwd() / '.runway' / 'cache'\n        self.log_formats = self._data.log_formats\n        self.lookups = self._data.lookups\n        self.mappings = self._data.mappings\n        self.namespace = self._data.namespace\n        self.namespace_delimiter = self._data.namespace_delimiter\n        self.package_sources = self._data.package_sources\n        self.persistent_graph_key = self._data.persistent_graph_key\n        self.post_deploy = cast('list[CfnginHookDefinitionModel]', self._data.post_deploy)\n        self.post_destroy = cast('list[CfnginHookDefinitionModel]', self._data.post_destroy)\n        self.pre_deploy = cast('list[CfnginHookDefinitionModel]', self._data.pre_deploy)\n        self.pre_destroy = cast('list[CfnginHookDefinitionModel]', self._data.pre_destroy)\n        self.service_role = self._data.service_role\n        self.stacks = cast('list[CfnginStackDefinitionModel]', self._data.stacks)\n        self.sys_path = self._data.sys_path\n        self.tags = self._data.tags\n        self.template_indent = self._data.template_indent\n\n    def load(self) -> None:\n        \"\"\"Load config options into the current environment/session.\"\"\"\n        if self.sys_path:\n            LOGGER.debug('appending to sys.path: %s', self.sys_path)\n            sys.path.append(str(self.sys_path))\n            LOGGER.debug('sys.path: %s', sys.path)\n        if self.lookups:\n            for key, handler in self.lookups.items():\n                register_lookup_handler(key, handler)\n\n    @classmethod\n    def find_config_file(cls, path: Path | None=None, *, exclude: list[str] | None=None) -> list[Path]:\n        \"\"\"Find a config file in the provided path.\n\n        Args:\n            path: The path to search for a config file.\n            exclude: List of file names to exclude. This list is appended to\n                the global exclude list.\n\n        Raises:\n            ConfigNotFound: Could not find a config file in the provided path.\n            ValueError: More than one config file found in the provided path.\n\n        \"\"\"\n        if not path:\n            path = Path.cwd()\n        elif path.is_file():\n            return [path]\n        exclude = exclude or []\n        result: list[Path] = []\n        exclude.extend(cls.EXCLUDE_LIST)\n        yml_files = list(path.glob('*.yml'))\n        yml_files.extend(list(path.glob('*.yaml')))\n        for f in yml_files:\n            if re.match(cls.EXCLUDE_REGEX, f.name) or f.name in exclude or f.name.startswith('.'):\n                continue\n            result.append(f)\n        result.sort()\n        return result\n\n    @classmethod\n    def parse_file(cls, *, path: Path | None=None, file_path: Path | None=None, parameters: MutableMapping[str, Any] | None=None, work_dir: Path | None=None, **kwargs: Any) -> CfnginConfig:\n        \"\"\"Parse a YAML file to create a config object.\n\n        Args:\n            path: The path to search for a config file.\n            file_path: Exact path to a file to parse.\n            parameters: Values to use when resolving a raw config.\n            work_dir: Explicit working directory.\n            **kwargs: Arbitrary keyword arguments.\n\n        Raises:\n            ConfigNotFound: Provided config file was not found.\n\n        \"\"\"\n        if file_path:\n            if not file_path.is_file():\n                raise ConfigNotFound(path=file_path)\n            return cls.parse_raw(file_path.read_text(), path=file_path, parameters=parameters or {}, work_dir=work_dir, **kwargs)\n        if path:\n            found = cls.find_config_file(path)\n            if len(found) > 1:\n                raise ValueError(f'more than one config files found: {found}')\n            return cls.parse_file(file_path=found[0], parameters=parameters or {}, work_dir=work_dir, **kwargs)\n        raise ValueError('must provide path or file_path')\n\n    @classmethod\n    def parse_obj(cls, obj: Any, *, path: Path | None=None, work_dir: Path | None=None) -> CfnginConfig:\n        \"\"\"Parse a python object.\n\n        Args:\n            obj: A python object to parse as a CFNgin config.\n            path: The path to the config file that was parsed into the object.\n            work_dir: Working directory.\n\n        \"\"\"\n        return cls(CfnginConfigDefinitionModel.model_validate(obj), path=path, work_dir=work_dir)\n\n    @classmethod\n    def parse_raw(cls, data: str, *, parameters: MutableMapping[str, Any] | None=None, path: Path | None=None, skip_package_sources: bool=False, work_dir: Path | None=None) -> CfnginConfig:\n        \"\"\"Parse raw data.\n\n        Args:\n            data: The raw data to parse.\n            parameters: Values to use when resolving a raw config.\n            path: The path to search for a config file.\n            skip_package_sources: Skip processing package sources.\n            work_dir: Explicit working directory.\n\n        \"\"\"\n        if not parameters:\n            parameters = {}\n        pre_rendered = cls.resolve_raw_data(data, parameters=parameters)\n        if skip_package_sources:\n            return cls.parse_obj(yaml.safe_load(pre_rendered))\n        config_dict = yaml.safe_load(cls.process_package_sources(pre_rendered, parameters=parameters, work_dir=work_dir))\n        return cls.parse_obj(config_dict, path=path)\n\n    @classmethod\n    def process_package_sources(cls, raw_data: str, *, parameters: MutableMapping[str, Any] | None=None, work_dir: Path | None=None) -> str:\n        \"\"\"Process the package sources defined in a rendered config.\n\n        Args:\n            raw_data: Raw configuration data.\n            cache_dir: Directory to use when caching remote sources.\n            parameters: Values to use when resolving a raw config.\n            work_dir: Explicit working directory.\n\n        \"\"\"\n        config: dict[str, Any] = yaml.safe_load(raw_data) or {}\n        processor = SourceProcessor(sources=CfnginPackageSourcesDefinitionModel.model_validate(config.get('package_sources', {})), cache_dir=Path(config.get('cfngin_cache_dir', (work_dir or Path().cwd() / '.runway') / 'cache')))\n        processor.get_package_sources()\n        if processor.configs_to_merge:\n            for i in processor.configs_to_merge:\n                LOGGER.debug('merging in remote config: %s', i)\n                with i.open('rb') as opened_file:\n                    config = merge_dicts(yaml.safe_load(opened_file), config)\n            return cls.resolve_raw_data(yaml.dump(config), parameters=parameters or {})\n        return raw_data\n\n    @staticmethod\n    def resolve_raw_data(raw_data: str, *, parameters: MutableMapping[str, Any] | None=None) -> str:\n        \"\"\"Resolve raw data.\n\n        Args:\n            raw_data: Raw configuration data.\n            parameters: Values to use when resolving a raw config.\n\n        Raises:\n            MissingEnvironment: A value required by the config was not provided\n                in parameters.\n\n        \"\"\"\n        if not parameters:\n            parameters = {}\n        template = Template(raw_data)\n        try:\n            rendered = template.substitute(**parameters)\n        except KeyError as err:\n            raise exceptions.MissingEnvironment(err.args[0]) from None\n        except ValueError:\n            rendered = template.safe_substitute(**parameters)\n        return rendered\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass VivadoRunner:\n    '''\n    Handles everything Vivado SIMPLY\n    Attributes:\n        board: current target device\n        output_dir: dir for generated vivado project\n        vivado_path: root path to xilinx vivado installation (all paths derived from here)\n        logger: attach a logger\n    '''\n\n    def __init__(self, board: str, output_dir: Path, vivado_path: str, logger: Optional[logging.Logger]=None, device_config: Optional[Dict[str, Any]]=None):\n        '''Initialize VivadoRunner with simplified configuration.\n        Args:\n            board: Target board name (e.g., \"pcileech_35t325_x1\")\n            output_dir: Directory for generated Vivado project\n            vivado_path: Root path to Xilinx Vivado installation\n            logger: Optional logger instance\n            device_config: Optional device configuration dictionary\n        '''\n        pass\n\n    def _extract_version_from_path(self, path: str) -> str:\n        '''Extract Vivado version from installation path.'''\n        pass\n\n    def _is_running_in_container(self) -> bool:\n        '''Check if we're running inside a container.'''\n        pass\n\n    def _run_vivado_on_host(self) -> None:\n        '''Drop out of container and run Vivado on the host system.'''\n        pass\n\n    def run(self) -> None:\n        '''\n        Hand-off to Vivado in batch mode using the generated scripts.\n        If running in container, drop out to host for Vivado execution.\n        Raises:\n            VivadoIntegrationError: If Vivado integration fails\n        '''\n        pass\n\n    def get_vivado_info(self) -> Dict[str, str]:\n        '''Get information about the Vivado installation.\n        Returns:\n            Dictionary with Vivado installation details\n        '''\n        pass"
  }
]