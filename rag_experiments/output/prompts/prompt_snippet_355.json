[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Step:\n    '''State machine for executing generic actions related to stacks.\n    Attributes:\n        fn: Function to run to execute the step.\n            This function will be ran multiple times until the step is \"done\".\n        last_updated: Time when the step was last updated.\n        logger: Logger for logging messages about the step.\n        stack: the stack associated with this step\n        status: The status of step.\n        watch_func: Function that will be called to \"tail\" the step action.\n    '''\n\n    def __init__(self, stack: Stack, *, fn: Callable[..., Any] | None=None, watch_func: Callable[..., Any] | None=None) -> None:\n        '''Instantiate class.\n        Args:\n            stack: The stack associated\n                with this step\n            fn: Function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: Function that will be called to \"tail\" the step action.\n        '''\n        pass\n\n    def run(self) -> bool:\n        '''Run this step until it has completed or been skipped.'''\n        pass\n\n    def _run_once(self) -> Status:\n        '''Run a step exactly once.'''\n        pass\n    @property\n    def name(self) -> str:\n        '''Name of the step.\n        This is equal to the name of the stack it operates on.\n        '''\n        pass\n    @property\n    def requires(self) -> set[str]:\n        '''Return a list of step names this step depends on.'''\n        pass\n    @property\n    def required_by(self) -> set[str]:\n        '''Return a list of step names that depend on this step.'''\n        pass\n    @property\n    def completed(self) -> bool:\n        '''Return True if the step is in a COMPLETE state.'''\n        pass\n    @property\n    def skipped(self) -> bool:\n        '''Return True if the step is in a SKIPPED state.'''\n        pass\n    @property\n    def failed(self) -> bool:\n        '''Return True if the step is in a FAILED state.'''\n        pass\n    @property\n    def done(self) -> bool:\n        '''Return True if the step is finished.\n        To be ``True``, status must be either COMPLETE, SKIPPED or FAILED)\n        '''\n        pass\n    @property\n    def ok(self) -> bool:\n        '''Return True if the step is finished (either COMPLETE or SKIPPED).'''\n        pass\n    @property\n    def submitted(self) -> bool:\n        '''Return True if the step is SUBMITTED, COMPLETE, or SKIPPED.'''\n        pass\n\n    def set_status(self, status: Status) -> None:\n        '''Set the current step's status.\n        Args:\n            status: The status to set the step to.\n        '''\n        pass\n    def completed(self) -> bool:\n        '''Shortcut for ``set_status(COMPLETE)``.'''\n        pass\n\n    def log_step(self) -> None:\n        '''Construct a log message for a set and log it to the UI.'''\n        pass\n    def skipped(self) -> bool:\n        '''Shortcut for ``set_status(SKIPPED)``.'''\n        pass\n    def submitted(self) -> bool:\n        '''Shortcut for ``set_status(SUBMITTED)``.'''\n        pass\n    @classmethod\n    def from_stack_name(cls, stack_name: str, context: CfnginContext, requires: list[str] | set[str] | None=None, fn: Callable[..., Status] | None=None, watch_func: Callable[..., Any] | None=None) -> Step:\n        '''Create a step using only a stack name.\n        Args:\n            stack_name: Name of a CloudFormation stack.\n            context: Context object. Required to initialize a \"fake\"\n                :class:`runway.cfngin.stack.Stack`.\n            requires: Stacks that this stack depends on.\n            fn: The function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: an optional function that will be called to \"tail\" the\n                step action.\n        '''\n        pass\n    @classmethod\n    def from_persistent_graph(cls, graph_dict: dict[str, list[str]] | dict[str, set[str]] | OrderedDict[str, set[str]], context: CfnginContext, fn: Callable[..., Status] | None=None, watch_func: Callable[..., Any] | None=None) -> list[Step]:\n        '''Create a steps for a persistent graph dict.\n        Args:\n            graph_dict: A graph dict.\n            context: Context object. Required to initialize a \"fake\"\n                :class:`runway.cfngin.stack.Stack`.\n            requires: Stacks that this stack depends on.\n            fn: The function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: an optional function that will be called to \"tail\" the\n                step action.\n        '''\n        pass\n\n    def __repr__(self) -> str:\n        '''Object represented as a string.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Object displayed as a string.'''\n        pass\nCorresponding class implementation:\n\nfrom .status import COMPLETE, FAILED, PENDING, SKIPPED, SUBMITTED, FailedStatus, SkippedStatus\nimport time\nfrom .ui import ui\nfrom .._logging import LogLevels, PrefixAdaptor\nimport threading\nfrom .exceptions import CancelExecution, GraphError, PersistentGraphLocked, PlanFailed\nfrom .stack import Stack\nfrom typing import TYPE_CHECKING, Any, Callable, NoReturn, TypeVar, overload\n\nclass Step:\n    \"\"\"State machine for executing generic actions related to stacks.\n\n    Attributes:\n        fn: Function to run to execute the step.\n            This function will be ran multiple times until the step is \"done\".\n        last_updated: Time when the step was last updated.\n        logger: Logger for logging messages about the step.\n        stack: the stack associated with this step\n        status: The status of step.\n        watch_func: Function that will be called to \"tail\" the step action.\n\n    \"\"\"\n    fn: Callable[..., Any] | None\n    last_updated: float\n    logger: PrefixAdaptor\n    stack: Stack\n    status: Status\n    watch_func: Callable[..., Any] | None\n\n    def __init__(self, stack: Stack, *, fn: Callable[..., Any] | None=None, watch_func: Callable[..., Any] | None=None) -> None:\n        \"\"\"Instantiate class.\n\n        Args:\n            stack: The stack associated\n                with this step\n            fn: Function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: Function that will be called to \"tail\" the step action.\n\n        \"\"\"\n        self.stack = stack\n        self.status = PENDING\n        self.last_updated = time.time()\n        self.logger = PrefixAdaptor(self.stack.name, LOGGER)\n        self.fn = fn\n        self.watch_func = watch_func\n\n    def run(self) -> bool:\n        \"\"\"Run this step until it has completed or been skipped.\"\"\"\n        stop_watcher = threading.Event()\n        watcher = None\n        if self.watch_func:\n            watcher = threading.Thread(target=self.watch_func, args=(self.stack, stop_watcher))\n            watcher.start()\n        try:\n            while not self.done:\n                self._run_once()\n        finally:\n            if watcher:\n                stop_watcher.set()\n                watcher.join()\n        return self.ok\n\n    def _run_once(self) -> Status:\n        \"\"\"Run a step exactly once.\"\"\"\n        if not self.fn:\n            raise TypeError('Step.fn must be type Callable[..., Status] not None')\n        try:\n            status = self.fn(self.stack, status=self.status)\n        except CancelExecution:\n            status = SkippedStatus('canceled execution')\n        except Exception as err:\n            LOGGER.exception(err)\n            status = FailedStatus(reason=str(err))\n        self.set_status(status)\n        return status\n\n    @property\n    def name(self) -> str:\n        \"\"\"Name of the step.\n\n        This is equal to the name of the stack it operates on.\n\n        \"\"\"\n        return self.stack.name\n\n    @property\n    def requires(self) -> set[str]:\n        \"\"\"Return a list of step names this step depends on.\"\"\"\n        return self.stack.requires\n\n    @property\n    def required_by(self) -> set[str]:\n        \"\"\"Return a list of step names that depend on this step.\"\"\"\n        return self.stack.required_by\n\n    @property\n    def completed(self) -> bool:\n        \"\"\"Return True if the step is in a COMPLETE state.\"\"\"\n        return self.status == COMPLETE\n\n    @property\n    def skipped(self) -> bool:\n        \"\"\"Return True if the step is in a SKIPPED state.\"\"\"\n        return self.status == SKIPPED\n\n    @property\n    def failed(self) -> bool:\n        \"\"\"Return True if the step is in a FAILED state.\"\"\"\n        return self.status == FAILED\n\n    @property\n    def done(self) -> bool:\n        \"\"\"Return True if the step is finished.\n\n        To be ``True``, status must be either COMPLETE, SKIPPED or FAILED)\n\n        \"\"\"\n        return self.completed or self.skipped or self.failed\n\n    @property\n    def ok(self) -> bool:\n        \"\"\"Return True if the step is finished (either COMPLETE or SKIPPED).\"\"\"\n        return self.completed or self.skipped\n\n    @property\n    def submitted(self) -> bool:\n        \"\"\"Return True if the step is SUBMITTED, COMPLETE, or SKIPPED.\"\"\"\n        return self.status >= SUBMITTED\n\n    def set_status(self, status: Status) -> None:\n        \"\"\"Set the current step's status.\n\n        Args:\n            status: The status to set the step to.\n\n        \"\"\"\n        if status is not self.status:\n            LOGGER.debug('setting %s state to %s...', self.stack.name, status.name)\n            self.status = status\n            self.last_updated = time.time()\n            if self.stack.logging:\n                self.log_step()\n\n    def complete(self) -> None:\n        \"\"\"Shortcut for ``set_status(COMPLETE)``.\"\"\"\n        self.set_status(COMPLETE)\n\n    def log_step(self) -> None:\n        \"\"\"Construct a log message for a set and log it to the UI.\"\"\"\n        msg = self.status.name\n        if self.status.reason:\n            msg += f' ({self.status.reason})'\n        if self.status.code == SUBMITTED.code:\n            ui.log(LogLevels.NOTICE, msg, logger=self.logger)\n        elif self.status.code == COMPLETE.code:\n            ui.log(LogLevels.SUCCESS, msg, logger=self.logger)\n        elif self.status.code == FAILED.code:\n            ui.log(LogLevels.ERROR, msg, logger=self.logger)\n        else:\n            ui.info(msg, logger=self.logger)\n\n    def skip(self) -> None:\n        \"\"\"Shortcut for ``set_status(SKIPPED)``.\"\"\"\n        self.set_status(SKIPPED)\n\n    def submit(self) -> None:\n        \"\"\"Shortcut for ``set_status(SUBMITTED)``.\"\"\"\n        self.set_status(SUBMITTED)\n\n    @classmethod\n    def from_stack_name(cls, stack_name: str, context: CfnginContext, requires: list[str] | set[str] | None=None, fn: Callable[..., Status] | None=None, watch_func: Callable[..., Any] | None=None) -> Step:\n        \"\"\"Create a step using only a stack name.\n\n        Args:\n            stack_name: Name of a CloudFormation stack.\n            context: Context object. Required to initialize a \"fake\"\n                :class:`runway.cfngin.stack.Stack`.\n            requires: Stacks that this stack depends on.\n            fn: The function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: an optional function that will be called to \"tail\" the\n                step action.\n\n        \"\"\"\n        from runway.config.models.cfngin import CfnginStackDefinitionModel\n        stack_def = CfnginStackDefinitionModel.model_construct(name=stack_name, requires=requires or [])\n        stack = Stack(stack_def, context)\n        return cls(stack, fn=fn, watch_func=watch_func)\n\n    @classmethod\n    def from_persistent_graph(cls, graph_dict: dict[str, list[str]] | dict[str, set[str]] | OrderedDict[str, set[str]], context: CfnginContext, fn: Callable[..., Status] | None=None, watch_func: Callable[..., Any] | None=None) -> list[Step]:\n        \"\"\"Create a steps for a persistent graph dict.\n\n        Args:\n            graph_dict: A graph dict.\n            context: Context object. Required to initialize a \"fake\"\n                :class:`runway.cfngin.stack.Stack`.\n            requires: Stacks that this stack depends on.\n            fn: The function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: an optional function that will be called to \"tail\" the\n                step action.\n\n        \"\"\"\n        return [cls.from_stack_name(name, context, requires, fn, watch_func) for name, requires in graph_dict.items()]\n\n    def __repr__(self) -> str:\n        \"\"\"Object represented as a string.\"\"\"\n        return f'<CFNgin.plan.Step:{self.stack.name}>'\n\n    def __str__(self) -> str:\n        \"\"\"Object displayed as a string.\"\"\"\n        return self.stack.name\n\nExample skeleton:\n\n\nclass State:\n    '''State class that allows the reading and writing of state to a given\n    path. Input and output state transformations can be supplied in read_fn and\n    write_fn respectively. The input state transformation takes in a string\n    while the output transformation outputs a string. If run inside a GitHub\n    Action, the saved state file could be committed to GitHub so that on next\n    run the state is available in the repository.\n    Args:\n        path (str): Path to save state file\n        read_fn (Callable[[str], Any]): Input state transformation. Defaults to lambda x: x.\n        write_fn: Callable[[Any], str]: Output state transformation. Defaults to lambda x: x.\n    '''\n\n    def __init__(self, path: str, read_fn: Callable[[str], Any]=lambda x: x, write_fn: Callable[[Any], str]=lambda x: x) -> None:\n        pass\n\n    def __enter__(self) -> 'State':\n        '''Allow usage of with.\n        Returns:\n            State: SavedState object\n        '''\n        pass\n\n    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None:\n        '''Allow usage of with.\n        Args:\n            exc_type (Any): Exception type\n            exc_value (Any): Exception value\n            traceback (Any): Traceback\n        Returns:\n            None\n        '''\n        pass\n\n    def read(self) -> Any:\n        '''Read state from file\n        Returns:\n            Any: State\n        '''\n        pass\n\n    def write(self) -> None:\n        '''Write state to file\n        Returns:\n            None\n        '''\n        pass\n\n    def get(self) -> Any:\n        '''Get the state\n        Returns:\n            Any: State\n        '''\n        pass\n\n    def set(self, state: Any):\n        '''Set the state\n        Args:\n            state (Any): State\n        Returns:\n            None\n        '''\n        pass\n    @staticmethod\n    def dates_str_to_country_date_dict(dates_str: str) -> Dict:\n        '''Convert a comma separated string of key=date string pairs eg.\n        \"default=2017-01-01,afg=2019-01-01\" to a dictionary of key date\n        mappings eg.\n        {\"default\": 2017-01-01 as datetime, \"afg\": 2019-01-01 as datetime}\n        Args:\n            dates_str (str): Comma separated string of key=date string pairs\n        Returns:\n            Dict: Dictionary of key date mappings\n        '''\n        pass\n    @staticmethod\n    def country_date_dict_to_dates_str(country_date_dict: Dict) -> str:\n        '''Convert a dictionary of key date mappings eg.\n        {\"default\": 2017-01-01 as datetime, \"afg\": 2019-01-01 as datetime}\n        to a comma separated string of key=date string pairs eg.\n        \"default=2017-01-01,afg=2019-01-01\"\n        Args:\n            country_date_dict (Dict): Dictionary of key date mappings\n        Returns:\n            str: Comma separated string of key=date string pairs\n        '''\n        pass\nCorresponding class implementation:\n\nfrom typing import Any, Callable, Dict\nfrom hdx.utilities.loader import load_text\nfrom hdx.utilities.dateparse import iso_string_from_datetime, parse_date\nfrom hdx.utilities.saver import save_text\n\nclass State:\n    \"\"\"State class that allows the reading and writing of state to a given\n    path. Input and output state transformations can be supplied in read_fn and\n    write_fn respectively. The input state transformation takes in a string\n    while the output transformation outputs a string. If run inside a GitHub\n    Action, the saved state file could be committed to GitHub so that on next\n    run the state is available in the repository.\n\n    Args:\n        path (str): Path to save state file\n        read_fn (Callable[[str], Any]): Input state transformation. Defaults to lambda x: x.\n        write_fn: Callable[[Any], str]: Output state transformation. Defaults to lambda x: x.\n    \"\"\"\n\n    def __init__(self, path: str, read_fn: Callable[[str], Any]=lambda x: x, write_fn: Callable[[Any], str]=lambda x: x) -> None:\n        self.path = path\n        self.read_fn = read_fn\n        self.write_fn = write_fn\n        self.state = self.read()\n\n    def __enter__(self) -> 'State':\n        \"\"\"Allow usage of with.\n\n        Returns:\n            State: SavedState object\n        \"\"\"\n        return self\n\n    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None:\n        \"\"\"Allow usage of with.\n\n        Args:\n            exc_type (Any): Exception type\n            exc_value (Any): Exception value\n            traceback (Any): Traceback\n\n        Returns:\n            None\n        \"\"\"\n        self.write()\n\n    def read(self) -> Any:\n        \"\"\"Read state from file\n\n        Returns:\n            Any: State\n        \"\"\"\n        value = self.read_fn(load_text(self.path))\n        logger.info(f'State read from {self.path} = {value}')\n        return value\n\n    def write(self) -> None:\n        \"\"\"Write state to file\n\n        Returns:\n            None\n        \"\"\"\n        logger.info(f'State written to {self.path} = {self.state}')\n        save_text(self.write_fn(self.state), self.path)\n\n    def get(self) -> Any:\n        \"\"\"Get the state\n\n        Returns:\n            Any: State\n        \"\"\"\n        return self.state\n\n    def set(self, state: Any):\n        \"\"\"Set the state\n\n        Args:\n            state (Any): State\n\n        Returns:\n            None\n        \"\"\"\n        self.state = state\n\n    @staticmethod\n    def dates_str_to_country_date_dict(dates_str: str) -> Dict:\n        \"\"\"Convert a comma separated string of key=date string pairs eg.\n        \"default=2017-01-01,afg=2019-01-01\" to a dictionary of key date\n        mappings eg.\n        {\"default\": 2017-01-01 as datetime, \"afg\": 2019-01-01 as datetime}\n\n        Args:\n            dates_str (str): Comma separated string of key=date string pairs\n\n        Returns:\n            Dict: Dictionary of key date mappings\n        \"\"\"\n        result = {}\n        for keyvalue in dates_str.split(','):\n            key, value = keyvalue.split('=')\n            result[key] = parse_date(value)\n        return result\n\n    @staticmethod\n    def country_date_dict_to_dates_str(country_date_dict: Dict) -> str:\n        \"\"\"Convert a dictionary of key date mappings eg.\n        {\"default\": 2017-01-01 as datetime, \"afg\": 2019-01-01 as datetime}\n        to a comma separated string of key=date string pairs eg.\n        \"default=2017-01-01,afg=2019-01-01\"\n\n        Args:\n            country_date_dict (Dict): Dictionary of key date mappings\n\n        Returns:\n            str: Comma separated string of key=date string pairs\n        \"\"\"\n        strlist = []\n        for key, value in country_date_dict.items():\n            valstr = iso_string_from_datetime(value)\n            strlist.append(f'{key}={valstr}')\n        return ','.join(strlist)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass StatusSpinner:\n    '''Console Status, encapsulates rich.status.'''\n\n    def __init__(self, app_state: AppState, console: Console) -> None:\n        '''Initialize the instance and instantiate rich.status.\n        Args:\n            app_state: App State container.\n            console: The console instance to attach the spinner to.\n        '''\n        pass\n\n    def update_state(self) -> None:\n        '''Update status message.'''\n        pass\n\n    def __enter__(self) -> 'StatusSpinner':\n        '''Enter the context by starting the spinner.\n        Returns:\n            self, so that logging methods can be called within the context.\n        '''\n        pass\n\n    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None) -> None:\n        '''Exit the context by propagating the signal to the spinner.\n        Args:\n            exc_type: The type of exception raised (if any).\n            exc_value: The exception instance (if any).\n            traceback: The traceback object (if any).\n        '''\n        pass"
  }
]