[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass activate(object):\n    '''\n    Decorator class to make use of Responses and Stack-In-A-Box\n    extremely simple to do.\n    '''\n\n    def __init__(self, uri, *args, **kwargs):\n        '''\n        Initialize the decorator instance\n        :param uri: URI Stack-In-A-Box will use to recognize the HTTP calls\n            f.e 'localhost'.\n        :param text_type access_services: name of a keyword parameter in the\n            test function to assign access to the services created in the\n            arguments to the decorator.\n        :param args: A tuple containing all the positional arguments. Any\n            StackInABoxService arguments are removed before being passed to\n            the actual function.\n        :param kwargs: A dictionary of keyword args that are passed to the\n            actual function.\n        '''\n        pass\n\n    def process_service(self, arg_based_service, raise_on_type=True):\n        pass\n\n    def __call__(self, fn):\n        '''\n        Call to actually wrap the function call.\n        '''\n        pass\n        @functools.wraps(fn)\n        def wrapped(*args, **kwargs):\n                pass\n\n            def run():\n                        pass\nCorresponding class implementation:\n\nfrom stackinabox.stack import StackInABox\nfrom stackinabox.util.responses.core import responses_registration\nfrom stackinabox.services.service import StackInABoxService\nimport types\nimport responses\nimport functools\n\nclass activate(object):\n    \"\"\"\n    Decorator class to make use of Responses and Stack-In-A-Box\n    extremely simple to do.\n    \"\"\"\n\n    def __init__(self, uri, *args, **kwargs):\n        \"\"\"\n        Initialize the decorator instance\n\n        :param uri: URI Stack-In-A-Box will use to recognize the HTTP calls\n            f.e 'localhost'.\n        :param text_type access_services: name of a keyword parameter in the\n            test function to assign access to the services created in the\n            arguments to the decorator.\n        :param args: A tuple containing all the positional arguments. Any\n            StackInABoxService arguments are removed before being passed to\n            the actual function.\n        :param kwargs: A dictionary of keyword args that are passed to the\n            actual function.\n        \"\"\"\n        self.uri = uri\n        self.services = {}\n        self.args = []\n        self.kwargs = kwargs\n        if 'access_services' in self.kwargs:\n            self.enable_service_access = self.kwargs['access_services']\n            del self.kwargs['access_services']\n        else:\n            self.enable_service_access = None\n        for arg in args:\n            if self.process_service(arg, raise_on_type=False):\n                pass\n            elif isinstance(arg, types.GeneratorType) or isinstance(arg, collections.Iterable):\n                for sub_arg in arg:\n                    self.process_service(sub_arg, raise_on_type=True)\n            else:\n                self.args.append(arg)\n\n    def process_service(self, arg_based_service, raise_on_type=True):\n        if isinstance(arg_based_service, StackInABoxService):\n            logger.debug('Registering {0}'.format(arg_based_service.name))\n            self.services[arg_based_service.name] = arg_based_service\n            return True\n        elif raise_on_type:\n            raise TypeError('Generator or Iterable must provide a StackInABoxService in all of its results.')\n        return False\n\n    def __call__(self, fn):\n        \"\"\"\n        Call to actually wrap the function call.\n        \"\"\"\n\n        @functools.wraps(fn)\n        def wrapped(*args, **kwargs):\n            args_copy = list(args)\n            for arg in self.args:\n                args_copy.append(arg)\n            args_finalized = tuple(args_copy)\n            kwargs.update(self.kwargs)\n            if self.enable_service_access is not None:\n                kwargs[self.enable_service_access] = self.services\n            return_value = None\n\n            def run():\n                responses.mock.start()\n                StackInABox.reset_services()\n                for service in self.services.values():\n                    StackInABox.register_service(service)\n                responses_registration(self.uri)\n                return_value = fn(*args_finalized, **kwargs)\n                StackInABox.reset_services()\n                responses.mock.stop()\n                responses.mock.reset()\n            with responses.RequestsMock():\n                run()\n            return return_value\n        return wrapped\n\nExample skeleton:\n\n\nclass WebhookInstance(InstanceResource):\n\n    class Method(object):\n\n    class Type(object):\n\n    def __init__(self, version: Version, payload: Dict[str, Any], service_sid: str, channel_sid: str, sid: Optional[str]=None):\n        pass\n    @property\n    def _proxy(self) -> 'WebhookContext':\n        '''\n        Generate an instance context for the instance, the context is capable of\n        performing various actions. All instance actions are proxied to the context\n        :returns: WebhookContext for this WebhookInstance\n        '''\n        pass\n\n    def delete(self) -> bool:\n        '''\n        Deletes the WebhookInstance\n\n        :returns: True if delete succeeds, False otherwise\n        '''\n        pass\n\n    async def delete_async(self) -> bool:\n        '''\n        Asynchronous coroutine that deletes the WebhookInstance\n\n        :returns: True if delete succeeds, False otherwise\n        '''\n        pass\n\n    def fetch(self) -> 'WebhookInstance':\n        '''\n        Fetch the WebhookInstance\n\n        :returns: The fetched WebhookInstance\n        '''\n        pass\n\n    async def fetch_async(self) -> 'WebhookInstance':\n        '''\n        Asynchronous coroutine to fetch the WebhookInstance\n\n        :returns: The fetched WebhookInstance\n        '''\n        pass\n\n    def update(self, configuration_url: Union[str, object]=values.unset, configuration_method: Union['WebhookInstance.Method', object]=values.unset, configuration_filters: Union[List[str], object]=values.unset, configuration_triggers: Union[List[str], object]=values.unset, configuration_flow_sid: Union[str, object]=values.unset, configuration_retry_count: Union[int, object]=values.unset) -> 'WebhookInstance':\n        '''\n        Update the WebhookInstance\n        :param configuration_url: The URL of the webhook to call using the `configuration.method`.\n        :param configuration_method:\n        :param configuration_filters: The events that cause us to call the Channel Webhook. Used when `type` is `webhook`. This parameter takes only one event. To specify more than one event, repeat this parameter for each event. For the list of possible events, see [Webhook Event Triggers](https://www.twilio.com/docs/chat/webhook-events#webhook-event-trigger).\n        :param configuration_triggers: A string that will cause us to call the webhook when it is present in a message body. This parameter takes only one trigger string. To specify more than one, repeat this parameter for each trigger string up to a total of 5 trigger strings. Used only when `type` = `trigger`.\n        :param configuration_flow_sid: The SID of the Studio [Flow](https://www.twilio.com/docs/studio/rest-api/flow) to call when an event in `configuration.filters` occurs. Used only when `type` = `studio`.\n        :param configuration_retry_count: The number of times to retry the webhook if the first attempt fails. Can be an integer between 0 and 3, inclusive, and the default is 0.\n        :returns: The updated WebhookInstance\n        '''\n        pass\n\n    async def update_async(self, configuration_url: Union[str, object]=values.unset, configuration_method: Union['WebhookInstance.Method', object]=values.unset, configuration_filters: Union[List[str], object]=values.unset, configuration_triggers: Union[List[str], object]=values.unset, configuration_flow_sid: Union[str, object]=values.unset, configuration_retry_count: Union[int, object]=values.unset) -> 'WebhookInstance':\n        '''\n        Asynchronous coroutine to update the WebhookInstance\n        :param configuration_url: The URL of the webhook to call using the `configuration.method`.\n        :param configuration_method:\n        :param configuration_filters: The events that cause us to call the Channel Webhook. Used when `type` is `webhook`. This parameter takes only one event. To specify more than one event, repeat this parameter for each event. For the list of possible events, see [Webhook Event Triggers](https://www.twilio.com/docs/chat/webhook-events#webhook-event-trigger).\n        :param configuration_triggers: A string that will cause us to call the webhook when it is present in a message body. This parameter takes only one trigger string. To specify more than one, repeat this parameter for each trigger string up to a total of 5 trigger strings. Used only when `type` = `trigger`.\n        :param configuration_flow_sid: The SID of the Studio [Flow](https://www.twilio.com/docs/studio/rest-api/flow) to call when an event in `configuration.filters` occurs. Used only when `type` = `studio`.\n        :param configuration_retry_count: The number of times to retry the webhook if the first attempt fails. Can be an integer between 0 and 3, inclusive, and the default is 0.\n        :returns: The updated WebhookInstance\n        '''\n        pass\n\n    def __repr__(self) -> str:\n        '''\n        Provide a friendly representation\n        :returns: Machine friendly representation\n        '''\n        pass\nCorresponding class implementation:\n\nfrom twilio.base import deserialize, serialize, values\nfrom twilio.base.instance_resource import InstanceResource\nfrom twilio.base.version import Version\nfrom typing import Any, Dict, List, Optional, Union, Iterator, AsyncIterator\nfrom datetime import datetime\n\nclass WebhookInstance(InstanceResource):\n\n    class Method(object):\n        GET = 'GET'\n        POST = 'POST'\n\n    class Type(object):\n        WEBHOOK = 'webhook'\n        TRIGGER = 'trigger'\n        STUDIO = 'studio'\n    '\\n    :ivar sid: The unique string that we created to identify the Channel Webhook resource.\\n    :ivar account_sid: The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Channel Webhook resource.\\n    :ivar service_sid: The SID of the [Service](https://www.twilio.com/docs/chat/rest/service-resource) the Channel Webhook resource is associated with.\\n    :ivar channel_sid: The SID of the [Channel](https://www.twilio.com/docs/chat/channels) the Channel Webhook resource belongs to.\\n    :ivar type: The type of webhook. Can be: `webhook`, `studio`, or `trigger`.\\n    :ivar url: The absolute URL of the Channel Webhook resource.\\n    :ivar configuration: The JSON string that describes how the channel webhook is configured. The configuration object contains the `url`, `method`, `filters`, and `retry_count` values that are configured by the create and update actions.\\n    :ivar date_created: The date and time in GMT when the resource was created specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.\\n    :ivar date_updated: The date and time in GMT when the resource was last updated specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format.\\n    '\n\n    def __init__(self, version: Version, payload: Dict[str, Any], service_sid: str, channel_sid: str, sid: Optional[str]=None):\n        super().__init__(version)\n        self.sid: Optional[str] = payload.get('sid')\n        self.account_sid: Optional[str] = payload.get('account_sid')\n        self.service_sid: Optional[str] = payload.get('service_sid')\n        self.channel_sid: Optional[str] = payload.get('channel_sid')\n        self.type: Optional[str] = payload.get('type')\n        self.url: Optional[str] = payload.get('url')\n        self.configuration: Optional[Dict[str, object]] = payload.get('configuration')\n        self.date_created: Optional[datetime] = deserialize.iso8601_datetime(payload.get('date_created'))\n        self.date_updated: Optional[datetime] = deserialize.iso8601_datetime(payload.get('date_updated'))\n        self._solution = {'service_sid': service_sid, 'channel_sid': channel_sid, 'sid': sid or self.sid}\n        self._context: Optional[WebhookContext] = None\n\n    @property\n    def _proxy(self) -> 'WebhookContext':\n        \"\"\"\n        Generate an instance context for the instance, the context is capable of\n        performing various actions. All instance actions are proxied to the context\n\n        :returns: WebhookContext for this WebhookInstance\n        \"\"\"\n        if self._context is None:\n            self._context = WebhookContext(self._version, service_sid=self._solution['service_sid'], channel_sid=self._solution['channel_sid'], sid=self._solution['sid'])\n        return self._context\n\n    def delete(self) -> bool:\n        \"\"\"\n        Deletes the WebhookInstance\n\n\n        :returns: True if delete succeeds, False otherwise\n        \"\"\"\n        return self._proxy.delete()\n\n    async def delete_async(self) -> bool:\n        \"\"\"\n        Asynchronous coroutine that deletes the WebhookInstance\n\n\n        :returns: True if delete succeeds, False otherwise\n        \"\"\"\n        return await self._proxy.delete_async()\n\n    def fetch(self) -> 'WebhookInstance':\n        \"\"\"\n        Fetch the WebhookInstance\n\n\n        :returns: The fetched WebhookInstance\n        \"\"\"\n        return self._proxy.fetch()\n\n    async def fetch_async(self) -> 'WebhookInstance':\n        \"\"\"\n        Asynchronous coroutine to fetch the WebhookInstance\n\n\n        :returns: The fetched WebhookInstance\n        \"\"\"\n        return await self._proxy.fetch_async()\n\n    def update(self, configuration_url: Union[str, object]=values.unset, configuration_method: Union['WebhookInstance.Method', object]=values.unset, configuration_filters: Union[List[str], object]=values.unset, configuration_triggers: Union[List[str], object]=values.unset, configuration_flow_sid: Union[str, object]=values.unset, configuration_retry_count: Union[int, object]=values.unset) -> 'WebhookInstance':\n        \"\"\"\n        Update the WebhookInstance\n\n        :param configuration_url: The URL of the webhook to call using the `configuration.method`.\n        :param configuration_method:\n        :param configuration_filters: The events that cause us to call the Channel Webhook. Used when `type` is `webhook`. This parameter takes only one event. To specify more than one event, repeat this parameter for each event. For the list of possible events, see [Webhook Event Triggers](https://www.twilio.com/docs/chat/webhook-events#webhook-event-trigger).\n        :param configuration_triggers: A string that will cause us to call the webhook when it is present in a message body. This parameter takes only one trigger string. To specify more than one, repeat this parameter for each trigger string up to a total of 5 trigger strings. Used only when `type` = `trigger`.\n        :param configuration_flow_sid: The SID of the Studio [Flow](https://www.twilio.com/docs/studio/rest-api/flow) to call when an event in `configuration.filters` occurs. Used only when `type` = `studio`.\n        :param configuration_retry_count: The number of times to retry the webhook if the first attempt fails. Can be an integer between 0 and 3, inclusive, and the default is 0.\n\n        :returns: The updated WebhookInstance\n        \"\"\"\n        return self._proxy.update(configuration_url=configuration_url, configuration_method=configuration_method, configuration_filters=configuration_filters, configuration_triggers=configuration_triggers, configuration_flow_sid=configuration_flow_sid, configuration_retry_count=configuration_retry_count)\n\n    async def update_async(self, configuration_url: Union[str, object]=values.unset, configuration_method: Union['WebhookInstance.Method', object]=values.unset, configuration_filters: Union[List[str], object]=values.unset, configuration_triggers: Union[List[str], object]=values.unset, configuration_flow_sid: Union[str, object]=values.unset, configuration_retry_count: Union[int, object]=values.unset) -> 'WebhookInstance':\n        \"\"\"\n        Asynchronous coroutine to update the WebhookInstance\n\n        :param configuration_url: The URL of the webhook to call using the `configuration.method`.\n        :param configuration_method:\n        :param configuration_filters: The events that cause us to call the Channel Webhook. Used when `type` is `webhook`. This parameter takes only one event. To specify more than one event, repeat this parameter for each event. For the list of possible events, see [Webhook Event Triggers](https://www.twilio.com/docs/chat/webhook-events#webhook-event-trigger).\n        :param configuration_triggers: A string that will cause us to call the webhook when it is present in a message body. This parameter takes only one trigger string. To specify more than one, repeat this parameter for each trigger string up to a total of 5 trigger strings. Used only when `type` = `trigger`.\n        :param configuration_flow_sid: The SID of the Studio [Flow](https://www.twilio.com/docs/studio/rest-api/flow) to call when an event in `configuration.filters` occurs. Used only when `type` = `studio`.\n        :param configuration_retry_count: The number of times to retry the webhook if the first attempt fails. Can be an integer between 0 and 3, inclusive, and the default is 0.\n\n        :returns: The updated WebhookInstance\n        \"\"\"\n        return await self._proxy.update_async(configuration_url=configuration_url, configuration_method=configuration_method, configuration_filters=configuration_filters, configuration_triggers=configuration_triggers, configuration_flow_sid=configuration_flow_sid, configuration_retry_count=configuration_retry_count)\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Provide a friendly representation\n\n        :returns: Machine friendly representation\n        \"\"\"\n        context = ' '.join(('{}={}'.format(k, v) for k, v in self._solution.items()))\n        return '<Twilio.Chat.V2.WebhookInstance {}>'.format(context)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass BoundWorkerMethod:\n    '''\n    Proxy object that binds a `WorkerTaskWrapper` to an instance (self),\n    allowing decorated instance methods to work seamlessly with all\n    background execution capabilities.\n    This enables you to use:\n        instance.method()\n        instance.method.async_call(...)\n        instance.method.run_and_wait(...)\n    without losing access to wrapper methods.\n    Attributes:\n        _wrapper: The original WorkerTaskWrapper\n        _instance: The instance to bind as the first argument\n    '''\n\n    def __init__(self, wrapper: 'WorkerTaskWrapper', instance: object):\n        '''\n        Initialize the proxy with the wrapper and the instance.\n        Args:\n            wrapper: The WorkerTaskWrapper object\n            instance: The object instance to bind to the call\n        '''\n        pass\n\n    def __call__(self, *args, **kwargs):\n        '''\n        Synchronous execution with the bound instance.\n        Equivalent to: wrapper(instance, *args, **kwargs)\n        '''\n        pass\n\n    def async_call(self, *args, **kwargs) -> str:\n        '''\n        Asynchronous execution with the bound instance.\n        Returns a worker_id.\n        '''\n        pass\n\n    def submit(self, *args, **kwargs) -> str:\n        '''\n        Alias for async_call().\n        '''\n        pass\n\n    def run_and_wait(self, *args, timeout: Optional[float]=None, **kwargs):\n        '''\n        Executes the task in the background, then waits for and returns the result.\n        Raises:\n            RuntimeError: if the task is cancelled\n            Exception: if the task failed with an error\n        '''\n        pass\n\n    def set_pool(self, pool: 'WorkerPool'):\n        '''\n        Sets a specific pool to use for this task.\n        '''\n        pass\n\n    def shutdown_default_pool(self):\n        '''\n        Shuts down the default pool used by this function, if created.\n        '''\n        pass\n\n    def __getattr__(self, name):\n        '''\n        Fallback to the wrapperâ€™s attributes for completeness.\n        This makes sure any missing attributes are forwarded.\n        '''\n        pass"
  }
]