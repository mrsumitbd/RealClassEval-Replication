[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass GCPCompute(GCPResource):\n    '''Abstraction around GCP compute resource'''\n\n    def get_new_authorized_http(self, http: AuthorizedHttp) -> AuthorizedHttp:\n        '''Generate a new AuthorizedHttp object with the given credentials.'''\n        pass\n\n    def wait_for_operation(self, operation: dict, max_polls: int=MAX_POLLS, poll_interval: int=POLL_INTERVAL) -> dict:\n        '''Poll for compute zone operation until finished.'''\n        pass\n\n    def list_instances(self, label_filters: Optional[dict]=None, is_terminated: bool=False) -> List[GCPComputeNode]:\n        pass\n\n    def get_instance(self, node_id: str) -> GCPComputeNode:\n        pass\n\n    def set_labels(self, node: GCPComputeNode, labels: dict, wait_for_operation: bool=True) -> dict:\n        pass\n\n    def _convert_resources_to_urls(self, configuration_dict: Dict[str, Any]) -> Dict[str, Any]:\n        '''Ensures that resources are in their full URL form.\n        GCP expects machineType and acceleratorType to be a full URL (e.g.\n        `zones/us-west1/machineTypes/n1-standard-2`) instead of just the\n        type (`n1-standard-2`)\n        Args:\n            configuration_dict: Dict of options that will be passed to GCP\n        Returns:\n            Input dictionary, but with possibly expanding `machineType` and\n                `acceleratorType`.\n        '''\n        pass\n\n    def create_instance(self, base_config: dict, labels: dict, wait_for_operation: bool=True) -> Tuple[dict, str]:\n        pass\n\n    def delete_instance(self, node_id: str, wait_for_operation: bool=True) -> dict:\n        pass\n\n    def stop_instance(self, node_id: str, wait_for_operation: bool=True) -> dict:\n        pass\n\n    def start_instance(self, node_id: str, wait_for_operation: bool=True) -> dict:\n        pass\nCorresponding class implementation:\n\nfrom copy import deepcopy\nimport time\nimport httplib2\nfrom typing import Any, Dict, List, Optional, Tuple, Union\nimport re\nfrom ray.autoscaler.tags import TAG_RAY_CLUSTER_NAME, TAG_RAY_NODE_NAME\nfrom google_auth_httplib2 import AuthorizedHttp\n\nclass GCPCompute(GCPResource):\n    \"\"\"Abstraction around GCP compute resource\"\"\"\n\n    def get_new_authorized_http(self, http: AuthorizedHttp) -> AuthorizedHttp:\n        \"\"\"Generate a new AuthorizedHttp object with the given credentials.\"\"\"\n        new_http = AuthorizedHttp(http.credentials, http=httplib2.Http())\n        return new_http\n\n    def wait_for_operation(self, operation: dict, max_polls: int=MAX_POLLS, poll_interval: int=POLL_INTERVAL) -> dict:\n        \"\"\"Poll for compute zone operation until finished.\"\"\"\n        logger.info(f\"wait_for_compute_zone_operation: Waiting for operation {operation['name']} to finish...\")\n        for _ in range(max_polls):\n            result = self.resource.zoneOperations().get(project=self.project_id, operation=operation['name'], zone=self.availability_zone).execute(http=self.get_new_authorized_http(self.resource._http))\n            if 'error' in result:\n                raise Exception(result['error'])\n            if result['status'] == 'DONE':\n                logger.info(f\"wait_for_compute_zone_operation: Operation {operation['name']} finished.\")\n                break\n            time.sleep(poll_interval)\n        return result\n\n    def list_instances(self, label_filters: Optional[dict]=None, is_terminated: bool=False) -> List[GCPComputeNode]:\n        label_filters = label_filters or {}\n        if label_filters:\n            label_filter_expr = '(' + ' AND '.join(['(labels.{key} = {value})'.format(key=key, value=value) for key, value in label_filters.items()]) + ')'\n        else:\n            label_filter_expr = ''\n        statuses = GCPComputeNode.TERMINATED_STATUSES if is_terminated else GCPComputeNode.NON_TERMINATED_STATUSES\n        instance_state_filter_expr = '(' + ' OR '.join(['(status = {status})'.format(status=status) for status in statuses]) + ')'\n        cluster_name_filter_expr = '(labels.{key} = {value})'.format(key=TAG_RAY_CLUSTER_NAME, value=self.cluster_name)\n        tpu_negation_filter_expr = '(NOT labels.{label}:*)'.format(label='tpu_cores')\n        not_empty_filters = [f for f in [label_filter_expr, instance_state_filter_expr, cluster_name_filter_expr, tpu_negation_filter_expr] if f]\n        filter_expr = ' AND '.join(not_empty_filters)\n        response = self.resource.instances().list(project=self.project_id, zone=self.availability_zone, filter=filter_expr).execute(http=self.get_new_authorized_http(self.resource._http))\n        instances = response.get('items', [])\n        return [GCPComputeNode(i, self) for i in instances]\n\n    def get_instance(self, node_id: str) -> GCPComputeNode:\n        instance = self.resource.instances().get(project=self.project_id, zone=self.availability_zone, instance=node_id).execute()\n        return GCPComputeNode(instance, self)\n\n    def set_labels(self, node: GCPComputeNode, labels: dict, wait_for_operation: bool=True) -> dict:\n        body = {'labels': dict(node['labels'], **labels), 'labelFingerprint': node['labelFingerprint']}\n        node_id = node['name']\n        operation = self.resource.instances().setLabels(project=self.project_id, zone=self.availability_zone, instance=node_id, body=body).execute(http=self.get_new_authorized_http(self.resource._http))\n        if wait_for_operation:\n            result = self.wait_for_operation(operation)\n        else:\n            result = operation\n        return result\n\n    def _convert_resources_to_urls(self, configuration_dict: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Ensures that resources are in their full URL form.\n\n        GCP expects machineType and acceleratorType to be a full URL (e.g.\n        `zones/us-west1/machineTypes/n1-standard-2`) instead of just the\n        type (`n1-standard-2`)\n\n        Args:\n            configuration_dict: Dict of options that will be passed to GCP\n        Returns:\n            Input dictionary, but with possibly expanding `machineType` and\n                `acceleratorType`.\n        \"\"\"\n        configuration_dict = deepcopy(configuration_dict)\n        existing_machine_type = configuration_dict['machineType']\n        if not re.search('.*/machineTypes/.*', existing_machine_type):\n            configuration_dict['machineType'] = 'zones/{zone}/machineTypes/{machine_type}'.format(zone=self.availability_zone, machine_type=configuration_dict['machineType'])\n        for accelerator in configuration_dict.get('guestAccelerators', []):\n            gpu_type = accelerator['acceleratorType']\n            if not re.search('.*/acceleratorTypes/.*', gpu_type):\n                accelerator['acceleratorType'] = 'projects/{project}/zones/{zone}/acceleratorTypes/{accelerator}'.format(project=self.project_id, zone=self.availability_zone, accelerator=gpu_type)\n        return configuration_dict\n\n    def create_instance(self, base_config: dict, labels: dict, wait_for_operation: bool=True) -> Tuple[dict, str]:\n        config = self._convert_resources_to_urls(base_config)\n        config.pop('networkConfig', None)\n        name = _generate_node_name(labels, GCPNodeType.COMPUTE.value)\n        labels = dict(config.get('labels', {}), **labels)\n        config.update({'labels': dict(labels, **{TAG_RAY_CLUSTER_NAME: self.cluster_name}), 'name': name})\n        source_instance_template = config.pop('sourceInstanceTemplate', None)\n        operation = self.resource.instances().insert(project=self.project_id, zone=self.availability_zone, sourceInstanceTemplate=source_instance_template, body=config).execute(http=self.get_new_authorized_http(self.resource._http))\n        if wait_for_operation:\n            result = self.wait_for_operation(operation)\n        else:\n            result = operation\n        return (result, name)\n\n    def delete_instance(self, node_id: str, wait_for_operation: bool=True) -> dict:\n        operation = self.resource.instances().delete(project=self.project_id, zone=self.availability_zone, instance=node_id).execute()\n        if wait_for_operation:\n            result = self.wait_for_operation(operation)\n        else:\n            result = operation\n        return result\n\n    def stop_instance(self, node_id: str, wait_for_operation: bool=True) -> dict:\n        operation = self.resource.instances().stop(project=self.project_id, zone=self.availability_zone, instance=node_id).execute()\n        if wait_for_operation:\n            result = self.wait_for_operation(operation)\n        else:\n            result = operation\n        return result\n\n    def start_instance(self, node_id: str, wait_for_operation: bool=True) -> dict:\n        operation = self.resource.instances().start(project=self.project_id, zone=self.availability_zone, instance=node_id).execute(http=self.get_new_authorized_http(self.resource._http))\n        if wait_for_operation:\n            result = self.wait_for_operation(operation)\n        else:\n            result = operation\n        return result\n\nExample skeleton:\n\n\nclass Drivers:\n    '''Class for managing the board drivers'''\n\n    def __init__(self, apio_ctx: ApioContext) -> None:\n        pass\n\n    def ftdi_install(self) -> int:\n        '''Installs the FTDI driver. Function is platform dependent.\n        Returns a process exit code.\n        '''\n        pass\n\n    def ftdi_uninstall(self) -> int:\n        '''Uninstalls the FTDI driver. Function is platform dependent.\n        Returns a process exit code.\n        '''\n        pass\n\n    def serial_install(self) -> int:\n        '''Installs the serial driver. Function is platform dependent.\n        Returns a process exit code.\n        '''\n        pass\n\n    def serial_uninstall(self) -> int:\n        '''Uninstalls the serial driver. Function is platform dependent.\n        Returns a process exit code.\n        '''\n        pass\n\n    def _ftdi_install_linux(self) -> int:\n        '''Drivers install on Linux. It copies the .rules file into\n        the corresponding folder. Return process exit code.'''\n        pass\n\n    def _ftdi_uninstall_linux(self):\n        '''Uninstall the FTDI drivers on linux. Returns process exist code.'''\n        pass\n\n    def _serial_install_linux(self):\n        '''Serial drivers install on Linux. Returns process exit code.'''\n        pass\n\n    def _serial_uninstall_linux(self) -> int:\n        '''Uninstall the serial driver on Linux. Return process exit code.'''\n        pass\n\n    def _reload_rules_linux(self):\n        '''Execute the commands for reloading the udev system'''\n        pass\n\n    def _add_dialout_group_linux(self):\n        '''Add the current user to the dialout group on Linux systems'''\n        pass\n\n    def _ftdi_install_darwin(self) -> int:\n        '''Installs FTDI driver on darwin. Returns process status code.'''\n        pass\n\n    def _ftdi_uninstall_darwin(self):\n        '''Uninstalls FTDI driver on darwin. Returns process status code.'''\n        pass\n\n    def _serial_install_darwin(self):\n        '''Installs serial driver on darwin. Returns process status code.'''\n        pass\n\n    def _serial_uninstall_darwin(self):\n        '''Uninstalls serial driver on darwin. Returns process status code.'''\n        pass\n\n    def _ftdi_install_windows(self) -> int:\n        pass\n\n    def _ftdi_uninstall_windows(self) -> int:\n        pass\n\n    def _serial_install_windows(self) -> int:\n        pass\n\n    def _serial_uninstall_windows(self) -> int:\n        pass\nCorresponding class implementation:\n\nimport subprocess\nfrom apio.managers import installer\nimport shutil\nfrom apio.utils import util\nfrom apio.common.apio_console import cout, cerror, cmarkdown\nfrom apio.common.apio_styles import INFO, SUCCESS, EMPH1, EMPH3\nimport os\nfrom apio.apio_context import ApioContext\nfrom pathlib import Path\n\nclass Drivers:\n    \"\"\"Class for managing the board drivers\"\"\"\n    resources_dir = util.get_path_in_apio_package('resources')\n    ftdi_rules_local_path = resources_dir / '80-fpga-ftdi.rules'\n    ftdi_rules_system_path = Path('/etc/udev/rules.d/80-fpga-ftdi.rules')\n    serial_rules_local_path = resources_dir / '80-fpga-serial.rules'\n    serial_rules_system_path = Path('/etc/udev/rules.d/80-fpga-serial.rules')\n    driver_c = ''\n\n    def __init__(self, apio_ctx: ApioContext) -> None:\n        self.apio_ctx = apio_ctx\n\n    def ftdi_install(self) -> int:\n        \"\"\"Installs the FTDI driver. Function is platform dependent.\n        Returns a process exit code.\n        \"\"\"\n        if self.apio_ctx.is_linux:\n            return self._ftdi_install_linux()\n        if self.apio_ctx.is_darwin:\n            return self._ftdi_install_darwin()\n        if self.apio_ctx.is_windows:\n            return self._ftdi_install_windows()\n        cerror(f\"Unknown platform type '{self.apio_ctx.platform_id}'.\")\n        return 1\n\n    def ftdi_uninstall(self) -> int:\n        \"\"\"Uninstalls the FTDI driver. Function is platform dependent.\n        Returns a process exit code.\n        \"\"\"\n        if self.apio_ctx.is_linux:\n            return self._ftdi_uninstall_linux()\n        if self.apio_ctx.is_darwin:\n            return self._ftdi_uninstall_darwin()\n        if self.apio_ctx.is_windows:\n            return self._ftdi_uninstall_windows()\n        cerror(f\"Unknown platform '{self.apio_ctx.platform_id}'.\")\n        return 1\n\n    def serial_install(self) -> int:\n        \"\"\"Installs the serial driver. Function is platform dependent.\n        Returns a process exit code.\n        \"\"\"\n        if self.apio_ctx.is_linux:\n            return self._serial_install_linux()\n        if self.apio_ctx.is_darwin:\n            return self._serial_install_darwin()\n        if self.apio_ctx.is_windows:\n            return self._serial_install_windows()\n        cerror(f\"Unknown platform '{self.apio_ctx.platform_id}'.\")\n        return 1\n\n    def serial_uninstall(self) -> int:\n        \"\"\"Uninstalls the serial driver. Function is platform dependent.\n        Returns a process exit code.\n        \"\"\"\n        if self.apio_ctx.is_linux:\n            return self._serial_uninstall_linux()\n        if self.apio_ctx.is_darwin:\n            return self._serial_uninstall_darwin()\n        if self.apio_ctx.is_windows:\n            return self._serial_uninstall_windows()\n        cerror(f\"Unknown platform '{self.apio_ctx.platform_id}'.\")\n        return 1\n\n    def _ftdi_install_linux(self) -> int:\n        \"\"\"Drivers install on Linux. It copies the .rules file into\n        the corresponding folder. Return process exit code.\"\"\"\n        cout('Configure FTDI drivers for FPGA')\n        if not self.ftdi_rules_system_path.exists():\n            util.subprocess_call(['sudo', 'cp', str(self.ftdi_rules_local_path), str(self.ftdi_rules_system_path)], exit_on_error=True)\n            self._reload_rules_linux()\n            cout('FTDI drivers installed', style=SUCCESS)\n            cout('Unplug and reconnect your board', style=INFO)\n        else:\n            cout('Already installed', style=INFO)\n        return 0\n\n    def _ftdi_uninstall_linux(self):\n        \"\"\"Uninstall the FTDI drivers on linux. Returns process exist code.\"\"\"\n        if self.ftdi_rules_system_path.exists():\n            cout('Revert FTDI drivers configuration')\n            subprocess.call(['sudo', 'rm', str(self.ftdi_rules_system_path)])\n            self._reload_rules_linux()\n            cout('FTDI drivers uninstalled', style=SUCCESS)\n            cout('Unplug and reconnect your board', style=INFO)\n        else:\n            cout('Already uninstalled', style=INFO)\n        return 0\n\n    def _serial_install_linux(self):\n        \"\"\"Serial drivers install on Linux. Returns process exit code.\"\"\"\n        cout('Configure Serial drivers for FPGA')\n        if not self.serial_rules_system_path.exists():\n            group_added = self._add_dialout_group_linux()\n            util.subprocess_call(['sudo', 'cp', str(self.serial_rules_local_path), str(self.serial_rules_system_path)], exit_on_error=True)\n            self._reload_rules_linux()\n            cout('Serial drivers installed', style=SUCCESS)\n            cout('Unplug and reconnect your board', style=INFO)\n            if group_added:\n                cout('Restart your machine to install the dialout group', style=INFO)\n        else:\n            cout('Already installed', style=INFO)\n        return 0\n\n    def _serial_uninstall_linux(self) -> int:\n        \"\"\"Uninstall the serial driver on Linux. Return process exit code.\"\"\"\n        if self.serial_rules_system_path.exists():\n            cout('Revert Serial drivers configuration')\n            subprocess.call(['sudo', 'rm', str(self.serial_rules_system_path)])\n            self._reload_rules_linux()\n            cout('Serial drivers uninstalled', style=SUCCESS)\n            cout('Unplug and reconnect your board', style=INFO)\n        else:\n            cout('Already uninstalled', style=INFO)\n        return 0\n\n    def _reload_rules_linux(self):\n        \"\"\"Execute the commands for reloading the udev system\"\"\"\n        subprocess.call(['sudo', 'udevadm', 'control', '--reload-rules'])\n        subprocess.call(['sudo', 'udevadm', 'trigger'])\n        subprocess.call(['sudo', 'service', 'udev', 'restart'])\n\n    def _add_dialout_group_linux(self):\n        \"\"\"Add the current user to the dialout group on Linux systems\"\"\"\n        groups = subprocess.check_output('groups')\n        if 'dialout' not in groups.decode():\n            subprocess.call('sudo usermod -a -G dialout $USER', shell=True)\n            return True\n        return None\n\n    def _ftdi_install_darwin(self) -> int:\n        \"\"\"Installs FTDI driver on darwin. Returns process status code.\"\"\"\n        cout(NO_DRIVERS_MSG, style=SUCCESS)\n        return 0\n\n    def _ftdi_uninstall_darwin(self):\n        \"\"\"Uninstalls FTDI driver on darwin. Returns process status code.\"\"\"\n        cout(NO_DRIVERS_MSG, style=SUCCESS)\n        return 0\n\n    def _serial_install_darwin(self):\n        \"\"\"Installs serial driver on darwin. Returns process status code.\"\"\"\n        cout(NO_DRIVERS_MSG, style=SUCCESS)\n        return 0\n\n    def _serial_uninstall_darwin(self):\n        \"\"\"Uninstalls serial driver on darwin. Returns process status code.\"\"\"\n        cout(NO_DRIVERS_MSG, style=SUCCESS)\n        return 0\n\n    def _ftdi_install_windows(self) -> int:\n        installer.install_missing_packages_on_the_fly(self.apio_ctx)\n        drivers_base_dir = self.apio_ctx.get_package_dir('drivers')\n        zadig_ini_src = drivers_base_dir / 'share' / 'zadig.ini'\n        with util.pushd(self.apio_ctx.get_tmp_dir()):\n            shutil.copyfile(zadig_ini_src, 'zadig.ini')\n            zadig_exe = drivers_base_dir / 'bin' / 'zadig.exe'\n            cout('', 'Launching zadig.exe.')\n            cmarkdown(FTDI_INSTALL_INSTRUCTIONS_WINDOWS)\n            exit_code = os.system(str(zadig_exe))\n            return exit_code\n\n    def _ftdi_uninstall_windows(self) -> int:\n        installer.install_missing_packages_on_the_fly(self.apio_ctx)\n        cout('', 'Launching the interactive Device Manager.')\n        cmarkdown(FTDI_UNINSTALL_INSTRUCTIONS_WINDOWS)\n        exit_code = os.system('mmc devmgmt.msc')\n        return exit_code\n\n    def _serial_install_windows(self) -> int:\n        installer.install_missing_packages_on_the_fly(self.apio_ctx)\n        drivers_base_dir = self.apio_ctx.get_package_dir('drivers')\n        drivers_bin_dir = drivers_base_dir / 'bin'\n        cout('', 'Launching the interactive Serial Installer.')\n        cmarkdown(SERIAL_INSTALL_INSTRUCTIONS_WINDOWS)\n        exit_code = os.system(str(Path(drivers_bin_dir) / 'serial_install.exe'))\n        return exit_code\n\n    def _serial_uninstall_windows(self) -> int:\n        installer.install_missing_packages_on_the_fly(self.apio_ctx)\n        cout('', 'Launching the interactive Device Manager.')\n        cmarkdown(SERIAL_UNINSTALL_INSTRUCTIONS_WINDOWS)\n        exit_code = os.system('mmc devmgmt.msc')\n        return exit_code\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass OptionROMManager:\n    '''Manager for Option-ROM extraction and handling'''\n\n    def __init__(self, output_dir: Optional[Path]=None, rom_file_path: Optional[str]=None):\n        '''\n        Initialize the Option-ROM manager\n        Args:\n            output_dir: Path to directory for storing extracted ROM\n            rom_file_path: Path to an existing ROM file to use instead of extraction\n        '''\n        pass\n\n    def extract_rom_linux(self, bdf: str) -> Tuple[bool, str]:\n        '''\n        Extract Option-ROM from a PCI device on Linux\n        Args:\n            bdf: PCIe Bus:Device.Function (e.g., \"0000:03:00.0\")\n        Returns:\n            Tuple of (success, rom_path)\n        '''\n        pass\n\n    def load_rom_file(self, file_path: Optional[str]=None) -> bool:\n        '''\n        Load ROM data from a file\n        Args:\n            file_path: Path to ROM file (uses self.rom_file_path if None)\n        Returns:\n            True if ROM was loaded successfully\n        '''\n        pass\n\n    def save_rom_hex(self, output_path: Optional[str]=None) -> bool:\n        '''\n        Save ROM data in a format suitable for SystemVerilog $readmemh\n        Args:\n            output_path: Path to save the hex file (default: output_dir/rom_init.hex)\n        Returns:\n            True if data was saved successfully\n        '''\n        pass\n\n    def get_rom_info(self) -> Dict[str, str]:\n        '''\n        Get information about the ROM\n        Returns:\n            Dictionary with ROM information\n        '''\n        pass\n\n    def setup_option_rom(self, bdf: str, use_existing_rom: bool=False) -> Dict[str, str]:\n        '''\n        Complete setup process: extract ROM, save hex file, and return info\n        Args:\n            bdf: PCIe Bus:Device.Function\n            use_existing_rom: Use existing ROM file if available\n        Returns:\n            Dictionary with ROM information\n        '''\n        pass"
  }
]