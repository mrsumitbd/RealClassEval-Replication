[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass OutputSTACMixin:\n    '''Adds STAC related features.'''\n    @property\n    def stac_path(self) -> MPath:\n        '''Return path to STAC JSON file.'''\n        pass\n    @property\n    def stac_item_id(self) -> str:\n        '''\n        Return STAC item ID according to configuration.\n        Defaults to path basename.\n        '''\n        pass\n    @property\n    def stac_item_metadata(self):\n        '''Custom STAC metadata.'''\n        pass\n    @property\n    def stac_asset_type(self):\n        '''Asset MIME type.'''\n        pass\nCorresponding class implementation:\n\nfrom mapchete.path import MPath\n\nclass OutputSTACMixin:\n    \"\"\"Adds STAC related features.\"\"\"\n    path: MPath\n    output_params: dict\n\n    @property\n    def stac_path(self) -> MPath:\n        \"\"\"Return path to STAC JSON file.\"\"\"\n        return self.path / f'{self.stac_item_id}.json'\n\n    @property\n    def stac_item_id(self) -> str:\n        \"\"\"\n        Return STAC item ID according to configuration.\n\n        Defaults to path basename.\n        \"\"\"\n        return self.output_params.get('stac', {}).get('id') or self.path.stem\n\n    @property\n    def stac_item_metadata(self):\n        \"\"\"Custom STAC metadata.\"\"\"\n        return self.output_params.get('stac', {})\n\n    @property\n    def stac_asset_type(self):\n        \"\"\"Asset MIME type.\"\"\"\n        raise ValueError('no MIME type set for this output')\n\nExample skeleton:\n\n@attr.s\nclass DirectorySecrets:\n    '''\n    Load secrets from a directory containing secrets in separate files.\n    Suitable for reading Docker or Kubernetes secrets from the filesystem\n    inside a container.\n    .. versionadded:: 21.1.0\n    '''\n    @classmethod\n    def from_path(cls, path: str | Path) -> DirectorySecrets:\n        '''\n        Look for secrets in *path* directory.\n        Args:\n            path: A path to directory containing secrets as files.\n        '''\n        pass\n    @classmethod\n    def from_path_in_env(cls, env_name: str, default: str | Path | None) -> DirectorySecrets:\n        '''\n        Get the path from the environment variable *env_name* and then load the\n        secrets from that directory at runtime.\n        This allows you to overwrite the path to the secrets directory in\n        development.\n        Args:\n            env_name:\n                Environment variable that is used to determine the path of the\n                secrets directory.\n            default: The default path to load from.\n                        '''\n                        pass\n\n    def secret(self, default: Any=RAISE, converter: Callable | None=None, name: str | None=None, help: str | None=None) -> Any:\n        pass\n\n    def _get(self, environ, metadata, prefix, name) -> _SecretStr:\n        pass\nCorresponding class implementation:\n\nfrom ._utils import _get_default_secret\nfrom pathlib import Path\nimport attr\nfrom environ._environ_config import CNF_KEY, RAISE, _ConfigEntry\nfrom typing import Any, Callable\n\n@attr.s\nclass DirectorySecrets:\n    \"\"\"\n    Load secrets from a directory containing secrets in separate files.\n    Suitable for reading Docker or Kubernetes secrets from the filesystem\n    inside a container.\n\n    .. versionadded:: 21.1.0\n    \"\"\"\n    secrets_dir: str | Path = attr.ib()\n    _env_name: str | None = attr.ib(default=None)\n\n    @classmethod\n    def from_path(cls, path: str | Path) -> DirectorySecrets:\n        \"\"\"\n        Look for secrets in *path* directory.\n\n        Args:\n            path: A path to directory containing secrets as files.\n        \"\"\"\n        return cls(path)\n\n    @classmethod\n    def from_path_in_env(cls, env_name: str, default: str | Path | None) -> DirectorySecrets:\n        \"\"\"\n        Get the path from the environment variable *env_name* and then load the\n        secrets from that directory at runtime.\n\n        This allows you to overwrite the path to the secrets directory in\n        development.\n\n        Args:\n            env_name:\n                Environment variable that is used to determine the path of the\n                secrets directory.\n\n            default: The default path to load from.\n        \"\"\"\n        return cls(default, env_name)\n\n    def secret(self, default: Any=RAISE, converter: Callable | None=None, name: str | None=None, help: str | None=None) -> Any:\n        return attr.ib(default=default, metadata={CNF_KEY: _ConfigEntry(name, default, None, self._get, help)}, converter=converter)\n\n    def _get(self, environ, metadata, prefix, name) -> _SecretStr:\n        ce = metadata[CNF_KEY]\n        filename = ce.name or '_'.join((*prefix[1:], name))\n        if self._env_name:\n            secrets_dir = environ.get(self._env_name, self.secrets_dir)\n        else:\n            secrets_dir = self.secrets_dir\n        secret_path = Path(secrets_dir) / filename\n        log.debug(\"looking for secret in file '%s'.\", secret_path)\n        try:\n            return _SecretStr(secret_path.read_text())\n        except FileOpenError:\n            return _get_default_secret(filename, ce.default)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass TemplateValidator:\n    '''\n    Validates template names and ensures they follow conventions.\n    '''\n    @staticmethod\n    def validate_name(name: str, target_type: str='template') -> None:\n        '''\n        Validate a template name.\n        Args:\n            name: The name to validate\n            target_type: Type of template (for error messages)\n        '''\n        pass\n    @staticmethod\n    def validate_path(path: str) -> None:\n        '''Validate a file path.'''\n        pass"
  }
]