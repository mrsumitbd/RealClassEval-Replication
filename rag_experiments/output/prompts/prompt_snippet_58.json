[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass CSFileSystem(file_system.FileSystem):\n    '''File system that uses pyfvde.'''\n\n    def __init__(self, resolver_context, path_spec):\n        '''Initializes a file system.\n        Args:\n          resolver_context (Context): resolver context.\n          path_spec (PathSpec): a path specification.\n        '''\n        pass\n\n    def _Close(self):\n        '''Closes the file system.\n        Raises:\n          IOError: if the close failed.\n        '''\n        pass\n\n    def _Open(self, mode='rb'):\n        '''Opens the file system defined by path specification.\n        Args:\n          mode (Optional[str]): file access mode. The default is 'rb'\n              read-only binary.\n        Raises:\n          AccessError: if the access to open the file was denied.\n          IOError: if the file system could not be opened.\n          PathSpecError: if the path specification is incorrect.\n          ValueError: if the path specification is invalid.\n        '''\n        pass\n\n    def FileEntryExistsByPathSpec(self, path_spec):\n        '''Determines if a file entry for a path specification exists.\n        Args:\n          path_spec (PathSpec): path specification.\n        Returns:\n          bool: True if the file entry exists.\n        '''\n        pass\n\n    def GetFileEntryByPathSpec(self, path_spec):\n        '''Retrieves a file entry for a path specification.\n        Args:\n          path_spec (PathSpec): path specification.\n        Returns:\n          CSFileEntry: a file entry or None if not available.\n        '''\n        pass\n\n    def GetFVDELogicalVolumeByPathSpec(self, path_spec):\n        '''Retrieves a Core Storage logical volume for a path specification.\n        Args:\n          path_spec (PathSpec): path specification.\n        Returns:\n          pyfvde.logical_volume: a Core Storage logical volume or None if not\n              available.\n        '''\n        pass\n\n    def GetFVDEVolumeGroup(self):\n        '''Retrieves the Core Storage volume group.\n        Returns:\n          pyfvde.volume_group: a Core Storage volume group.\n        '''\n        pass\n\n    def GetRootFileEntry(self):\n        '''Retrieves the root file entry.\n        Returns:\n          CSFileEntry: root file entry or None if not available.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom dfvfs.lib import errors\nfrom dfvfs.lib import definitions\nimport pyfvde\nfrom dfvfs.path import cs_path_spec\nfrom dfvfs.resolver import resolver\nfrom dfvfs.vfs import cs_file_entry\nfrom dfvfs.lib import cs_helper\nfrom dfvfs.vfs import file_system\n\nclass CSFileSystem(file_system.FileSystem):\n    \"\"\"File system that uses pyfvde.\"\"\"\n    TYPE_INDICATOR = definitions.TYPE_INDICATOR_CS\n\n    def __init__(self, resolver_context, path_spec):\n        \"\"\"Initializes a file system.\n\n        Args:\n          resolver_context (Context): resolver context.\n          path_spec (PathSpec): a path specification.\n        \"\"\"\n        super(CSFileSystem, self).__init__(resolver_context, path_spec)\n        self._fvde_volume = None\n        self._fvde_volume_group = None\n        self._file_object = None\n\n    def _Close(self):\n        \"\"\"Closes the file system.\n\n        Raises:\n          IOError: if the close failed.\n        \"\"\"\n        self._fvde_volume_group = None\n        self._fvde_volume.close()\n        self._fvde_volume = None\n        self._file_object = None\n\n    def _Open(self, mode='rb'):\n        \"\"\"Opens the file system defined by path specification.\n\n        Args:\n          mode (Optional[str]): file access mode. The default is 'rb'\n              read-only binary.\n\n        Raises:\n          AccessError: if the access to open the file was denied.\n          IOError: if the file system could not be opened.\n          PathSpecError: if the path specification is incorrect.\n          ValueError: if the path specification is invalid.\n        \"\"\"\n        if not self._path_spec.HasParent():\n            raise errors.PathSpecError('Unsupported path specification without parent.')\n        resolver.Resolver.key_chain.ExtractCredentialsFromPathSpec(self._path_spec)\n        file_object = resolver.Resolver.OpenFileObject(self._path_spec.parent, resolver_context=self._resolver_context)\n        fvde_volume = pyfvde.volume()\n        encrypted_root_plist = resolver.Resolver.key_chain.GetCredential(self._path_spec, 'encrypted_root_plist')\n        if encrypted_root_plist:\n            fvde_volume.read_encrypted_root_plist(encrypted_root_plist)\n        fvde_volume.open_file_object(file_object)\n        fvde_volume.open_physical_volume_files_as_file_objects([file_object])\n        fvde_volume_group = fvde_volume.get_volume_group()\n        self._file_object = file_object\n        self._fvde_volume = fvde_volume\n        self._fvde_volume_group = fvde_volume_group\n\n    def FileEntryExistsByPathSpec(self, path_spec):\n        \"\"\"Determines if a file entry for a path specification exists.\n\n        Args:\n          path_spec (PathSpec): path specification.\n\n        Returns:\n          bool: True if the file entry exists.\n        \"\"\"\n        volume_index = cs_helper.CSPathSpecGetVolumeIndex(path_spec)\n        if volume_index is None:\n            location = getattr(path_spec, 'location', None)\n            return location is not None and location == self.LOCATION_ROOT\n        return 0 <= volume_index < self._fvde_volume_group.number_of_logical_volumes\n\n    def GetFileEntryByPathSpec(self, path_spec):\n        \"\"\"Retrieves a file entry for a path specification.\n\n        Args:\n          path_spec (PathSpec): path specification.\n\n        Returns:\n          CSFileEntry: a file entry or None if not available.\n        \"\"\"\n        volume_index = cs_helper.CSPathSpecGetVolumeIndex(path_spec)\n        if volume_index is None:\n            location = getattr(path_spec, 'location', None)\n            if location is None or location != self.LOCATION_ROOT:\n                return None\n            return cs_file_entry.CSFileEntry(self._resolver_context, self, path_spec, is_root=True, is_virtual=True)\n        if volume_index < 0 or volume_index >= self._fvde_volume_group.number_of_logical_volumes:\n            return None\n        return cs_file_entry.CSFileEntry(self._resolver_context, self, path_spec)\n\n    def GetFVDELogicalVolumeByPathSpec(self, path_spec):\n        \"\"\"Retrieves a Core Storage logical volume for a path specification.\n\n        Args:\n          path_spec (PathSpec): path specification.\n\n        Returns:\n          pyfvde.logical_volume: a Core Storage logical volume or None if not\n              available.\n        \"\"\"\n        volume_index = cs_helper.CSPathSpecGetVolumeIndex(path_spec)\n        if volume_index is None:\n            return None\n        return self._fvde_volume_group.get_logical_volume(volume_index)\n\n    def GetFVDEVolumeGroup(self):\n        \"\"\"Retrieves the Core Storage volume group.\n\n        Returns:\n          pyfvde.volume_group: a Core Storage volume group.\n        \"\"\"\n        return self._fvde_volume_group\n\n    def GetRootFileEntry(self):\n        \"\"\"Retrieves the root file entry.\n\n        Returns:\n          CSFileEntry: root file entry or None if not available.\n        \"\"\"\n        path_spec = cs_path_spec.CSPathSpec(location=self.LOCATION_ROOT, parent=self._path_spec.parent)\n        return self.GetFileEntryByPathSpec(path_spec)\n\nExample skeleton:\n\n\nclass Dirichlet(object):\n    '''Represents a Dirichlet distribution.\n    See http://en.wikipedia.org/wiki/Dirichlet_distribution\n    '''\n\n    def __init__(self, n, conc=1, name=''):\n        '''Initializes a Dirichlet distribution.\n        n: number of dimensions\n        conc: concentration parameter (smaller yields more concentration)\n        name: string name\n        '''\n        pass\n\n    def Update(self, data):\n        '''Updates a Dirichlet distribution.\n        data: sequence of observations, in order corresponding to params\n        '''\n        pass\n\n    def Random(self):\n        '''Generates a random variate from this distribution.\n        Returns: normalized vector of fractions\n        '''\n        pass\n\n    def Likelihood(self, data):\n        '''Computes the likelihood of the data.\n        Selects a random vector of probabilities from this distribution.\n        Returns: float probability\n        '''\n        pass\n\n    def LogLikelihood(self, data):\n        '''Computes the log likelihood of the data.\n        Selects a random vector of probabilities from this distribution.\n        Returns: float log probability\n        '''\n        pass\n\n    def MarginalBeta(self, i):\n        '''Computes the marginal distribution of the ith element.\n        See http://en.wikipedia.org/wiki/Dirichlet_distribution\n        #Marginal_distributions\n        i: int\n        Returns: Beta object\n        '''\n        pass\n\n    def PredictivePmf(self, xs, name=''):\n        '''Makes a predictive distribution.\n        xs: values to go into the Pmf\n        Returns: Pmf that maps from x to the mean prevalence of x\n        '''\n        pass\nCorresponding class implementation:\n\nimport numpy\n\nclass Dirichlet(object):\n    \"\"\"Represents a Dirichlet distribution.\n\n    See http://en.wikipedia.org/wiki/Dirichlet_distribution\n    \"\"\"\n\n    def __init__(self, n, conc=1, name=''):\n        \"\"\"Initializes a Dirichlet distribution.\n\n        n: number of dimensions\n        conc: concentration parameter (smaller yields more concentration)\n        name: string name\n        \"\"\"\n        if n < 2:\n            raise ValueError('A Dirichlet distribution with n<2 makes no sense')\n        self.n = n\n        self.params = numpy.ones(n, dtype=numpy.float) * conc\n        self.name = name\n\n    def Update(self, data):\n        \"\"\"Updates a Dirichlet distribution.\n\n        data: sequence of observations, in order corresponding to params\n        \"\"\"\n        m = len(data)\n        self.params[:m] += data\n\n    def Random(self):\n        \"\"\"Generates a random variate from this distribution.\n\n        Returns: normalized vector of fractions\n        \"\"\"\n        p = numpy.random.gamma(self.params)\n        return p / p.sum()\n\n    def Likelihood(self, data):\n        \"\"\"Computes the likelihood of the data.\n\n        Selects a random vector of probabilities from this distribution.\n\n        Returns: float probability\n        \"\"\"\n        m = len(data)\n        if self.n < m:\n            return 0\n        x = data\n        p = self.Random()\n        q = p[:m] ** x\n        return q.prod()\n\n    def LogLikelihood(self, data):\n        \"\"\"Computes the log likelihood of the data.\n\n        Selects a random vector of probabilities from this distribution.\n\n        Returns: float log probability\n        \"\"\"\n        m = len(data)\n        if self.n < m:\n            return float('-inf')\n        x = self.Random()\n        y = numpy.log(x[:m]) * data\n        return y.sum()\n\n    def MarginalBeta(self, i):\n        \"\"\"Computes the marginal distribution of the ith element.\n\n        See http://en.wikipedia.org/wiki/Dirichlet_distribution\n        #Marginal_distributions\n\n        i: int\n\n        Returns: Beta object\n        \"\"\"\n        alpha0 = self.params.sum()\n        alpha = self.params[i]\n        return Beta(alpha, alpha0 - alpha)\n\n    def PredictivePmf(self, xs, name=''):\n        \"\"\"Makes a predictive distribution.\n\n        xs: values to go into the Pmf\n\n        Returns: Pmf that maps from x to the mean prevalence of x\n        \"\"\"\n        alpha0 = self.params.sum()\n        ps = self.params / alpha0\n        return MakePmfFromItems(zip(xs, ps), name=name)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass LUFactorization:\n    '''\n    Initial implementation of lu_factorization task.\n    This will be evolved by OpenEvolve to improve performance and correctness.\n    '''\n\n    def __init__(self):\n        '''Initialize the LUFactorization.'''\n        pass\n\n    def solve(self, problem):\n        '''\n        Solve the lu_factorization problem.\n        Args:\n            problem: Dictionary containing problem data specific to lu_factorization\n        Returns:\n            The solution in the format expected by the task\n        '''\n        pass\n\n    def is_solution(self, problem, solution):\n        '''\n        Check if the provided solution is valid.\n        Args:\n            problem: The original problem\n            solution: The proposed solution\n        Returns:\n            True if the solution is valid, False otherwise\n        '''\n        pass"
  }
]