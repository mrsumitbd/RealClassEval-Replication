[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass CachedFeatureSet(CachedArtifactMixin, FeatureSetCore):\n    '''CachedFeatureSet: Caches the method results for Workbench FeatureSets\n    Note: Cached method values may lag underlying FeatureSet changes.\n    Common Usage:\n        ```python\n        my_features = CachedFeatureSet(name)\n        my_features.details()\n        my_features.health_check()\n        my_features.workbench_meta()\n        ```\n    '''\n\n    def __init__(self, feature_set_name: str, database: str='workbench'):\n        '''CachedFeatureSet Initialization'''\n        pass\n    @CachedArtifactMixin.cache_result\n    def summary(self, **kwargs) -> dict:\n        '''Retrieve the FeatureSet Details.\n        Returns:\n            dict: A dictionary of details about the FeatureSet\n        '''\n        pass\n    @CachedArtifactMixin.cache_result\n    def details(self, **kwargs) -> dict:\n        '''Retrieve the FeatureSet Details.\n        Returns:\n            dict: A dictionary of details about the FeatureSet\n        '''\n        pass\n    @CachedArtifactMixin.cache_result\n    def health_check(self, **kwargs) -> dict:\n        '''Retrieve the FeatureSet Health Check.\n        Returns:\n            dict: A dictionary of health check details for the FeatureSet\n        '''\n        pass\n    @CachedArtifactMixin.cache_result\n    def workbench_meta(self) -> Union[str, None]:\n        '''Retrieve the Workbench Metadata for this DataSource.\n        Returns:\n            Union[dict, None]: Dictionary of Workbench metadata for this Artifact\n        '''\n        pass\n    @CachedArtifactMixin.cache_result\n    def smart_sample(self) -> pd.DataFrame:\n        '''Retrieve the Smart Sample for this FeatureSet.\n        Returns:\n            pd.DataFrame: The Smart Sample DataFrame\n        '''\n        pass\nCorresponding class implementation:\n\nimport pandas as pd\nfrom typing import Union\nfrom workbench.core.artifacts.feature_set_core import FeatureSetCore\nfrom workbench.core.artifacts.cached_artifact_mixin import CachedArtifactMixin\n\nclass CachedFeatureSet(CachedArtifactMixin, FeatureSetCore):\n    \"\"\"CachedFeatureSet: Caches the method results for Workbench FeatureSets\n\n    Note: Cached method values may lag underlying FeatureSet changes.\n\n    Common Usage:\n        ```python\n        my_features = CachedFeatureSet(name)\n        my_features.details()\n        my_features.health_check()\n        my_features.workbench_meta()\n        ```\n    \"\"\"\n\n    def __init__(self, feature_set_name: str, database: str='workbench'):\n        \"\"\"CachedFeatureSet Initialization\"\"\"\n        FeatureSetCore.__init__(self, feature_set_name=feature_set_name, use_cached_meta=True)\n\n    @CachedArtifactMixin.cache_result\n    def summary(self, **kwargs) -> dict:\n        \"\"\"Retrieve the FeatureSet Details.\n\n        Returns:\n            dict: A dictionary of details about the FeatureSet\n        \"\"\"\n        return super().summary(**kwargs)\n\n    @CachedArtifactMixin.cache_result\n    def details(self, **kwargs) -> dict:\n        \"\"\"Retrieve the FeatureSet Details.\n\n        Returns:\n            dict: A dictionary of details about the FeatureSet\n        \"\"\"\n        return super().details(**kwargs)\n\n    @CachedArtifactMixin.cache_result\n    def health_check(self, **kwargs) -> dict:\n        \"\"\"Retrieve the FeatureSet Health Check.\n\n        Returns:\n            dict: A dictionary of health check details for the FeatureSet\n        \"\"\"\n        return super().health_check(**kwargs)\n\n    @CachedArtifactMixin.cache_result\n    def workbench_meta(self) -> Union[str, None]:\n        \"\"\"Retrieve the Workbench Metadata for this DataSource.\n\n        Returns:\n            Union[dict, None]: Dictionary of Workbench metadata for this Artifact\n        \"\"\"\n        return super().workbench_meta()\n\n    @CachedArtifactMixin.cache_result\n    def smart_sample(self) -> pd.DataFrame:\n        \"\"\"Retrieve the Smart Sample for this FeatureSet.\n\n        Returns:\n            pd.DataFrame: The Smart Sample DataFrame\n        \"\"\"\n        return super().smart_sample()\n\nExample skeleton:\n\n\nclass Filter(ABC, Generic[FilterValueT]):\n    '''\n    A class representing a Lavalink audio filter.\n    Parameters\n    ----------\n    values: Union[Dict[str, Any], Sequence[Union[float, int]], float]\n        The values for this filter.\n    plugin_filter: :class:`bool`\n        Whether this filter is part of a Lavalink plugin. Typically, this will be ``True``\n        when creating your own filters.\n    Attributes\n    ----------\n    values: Union[Dict[str, Any], Sequence[Union[float, int]], float]\n        The values for this filter.\n    plugin_filter: :class:`bool`\n        Whether this filter is part of a Lavalink plugin.\n    '''\n\n    def __init__(self, values: FilterValueT, plugin_filter: bool=False):\n        pass\n    @abstractmethod\n    def update(self, **kwargs):\n        ''' Updates the internal values to match those provided. '''\n        pass\n    @abstractmethod\n    def serialize(self) -> Dict[str, FilterValueT]:\n        '''\n        Transforms the internal values into a dict matching the structure Lavalink expects.\n        Example:\n            .. code:: python\n                return {\"yourCustomFilter\": {\"gain\": 5}}\n        '''\n        pass\nCorresponding class implementation:\n\nfrom typing import TYPE_CHECKING, Any, Dict, Final, Generic, Optional, Sequence, TypeVar, Union, cast\nfrom abc import ABC, abstractmethod\n\nclass Filter(ABC, Generic[FilterValueT]):\n    \"\"\"\n    A class representing a Lavalink audio filter.\n\n    Parameters\n    ----------\n    values: Union[Dict[str, Any], Sequence[Union[float, int]], float]\n        The values for this filter.\n    plugin_filter: :class:`bool`\n        Whether this filter is part of a Lavalink plugin. Typically, this will be ``True``\n        when creating your own filters.\n\n    Attributes\n    ----------\n    values: Union[Dict[str, Any], Sequence[Union[float, int]], float]\n        The values for this filter.\n    plugin_filter: :class:`bool`\n        Whether this filter is part of a Lavalink plugin.\n    \"\"\"\n    __slots__ = ('values', 'plugin_filter')\n\n    def __init__(self, values: FilterValueT, plugin_filter: bool=False):\n        self.values: FilterValueT = values\n        self.plugin_filter: Final[bool] = plugin_filter\n\n    @abstractmethod\n    def update(self, **kwargs):\n        \"\"\" Updates the internal values to match those provided. \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def serialize(self) -> Dict[str, FilterValueT]:\n        \"\"\"\n        Transforms the internal values into a dict matching the structure Lavalink expects.\n\n        Example:\n\n            .. code:: python\n\n                return {\"yourCustomFilter\": {\"gain\": 5}}\n        \"\"\"\n        raise NotImplementedError\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass ModelOption:\n    '''A type that wraps around model options.\n    Uses sentinel values (wrapped by @@@) to provide backend and model-agnostic keys for common model options.\n    Create a dictionary containing model options like this:\n    from mellea.backends.types import ModelOption\n    model_options = { ModelOption.TEMPERATURE : 0.0, ModelOption.SYSTEM_PROMPT : \"You are a helpful assistant\" }\n    '''\n    @staticmethod\n    def replace_keys(options: dict, from_to: dict[str, str]) -> dict[str, Any]:\n        '''Returns a new dict with the keys in `options` replaced with the corresponding value for that key in `from_to`.\n        If any keys already exist in `options`, don't edit the associated value.\n        Example:\n        ```python\n        >>> options = {\"k1\": \"v1\", \"k2\": \"v2\", \"M1\": \"m1\"}\n        >>> from_to = {\"k1\": \"M1\", \"k2\": \"M2\"}\n        >>> new_options = replace_keys(options, from_to)\n        >>> print(new_options)\n        ... {\"M1\": \"m1\", \"M2\": \"v2\"}\n        ```\n        '''\n        pass\n    @staticmethod\n    def remove_special_keys(model_options) -> dict[str, Any]:\n        '''Removes all sentiel-valued keys (i.e., those that start with @@@).'''\n        pass\n    @staticmethod\n    def merge_model_options(persistent_opts: dict[str, Any], overwrite_opts: dict[str, Any] | None) -> dict[str, Any]:\n        '''Creates a new dict that contains all keys and values from persistent opts and overwrite opts. If there are duplicate keys, overwrite opts key value pairs will be used.'''\n        pass"
  }
]