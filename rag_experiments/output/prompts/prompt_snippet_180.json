[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Sample(CaseInsensitiveDict):\n    '''A single sample for a sample sheet.\n    This class is built with the keys and values in the ``\"[Data]\"`` section of\n    the sample sheet. As specified by Illumina, the only required keys are:\n        - ``\"Sample_ID\"``\n    Although this library recommends you define the following column names:\n        - ``\"Sample_ID\"``\n        - ``\"Sample_Name\"``\n        - ``\"index\"``\n    If the key ``\"Read_Structure\"`` is provided then its value is promoted to\n    the class :class:`ReadStructure` and additional functionality is enabled.\n    Args:\n        data: Mapping of key-value pairs describing this sample.\n        kwargs: Key-value pairs describing this sample.\n    Examples:\n        >>> mapping = {\"Sample_ID\": \"87\", \"Sample_Name\": \"3T\", \"index\": \"A\"}\n        >>> sample = Sample(mapping)\n        >>> sample\n        Sample({'Sample_ID': '87', 'Sample_Name': '3T', 'index': 'A'})\n        >>> sample = Sample({'Read_Structure': '151T'})\n        >>> sample.Read_Structure\n        ReadStructure(structure='151T')\n    '''\n\n    def __init__(self, data: Optional[Mapping]=None, **kwargs: Mapping) -> None:\n        pass\n\n    def to_json(self) -> Mapping:\n        '''Return the properties of this :class:`Sample` as JSON serializable.\n        '''\n        pass\n\n    def __eq__(self, other: object) -> bool:\n        '''Samples are equal if the following attributes are equal:\n            - ``\"Sample_ID\"``\n            - ``\"Library_ID\"``\n            - ``\"Lane\"``\n        '''\n        pass\n\n    def __getattr__(self, attr: Any) -> Optional[Any]:\n        '''Return ``None`` if an attribute is undefined.'''\n        pass\n\n    def __repr__(self) -> str:\n        '''Return an executeable ``__repr__()``.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Cast this object to string.'''\n        pass\nCorresponding class implementation:\n\nfrom typing import Any, Generator, Iterable, List, Mapping, Optional, Set, TextIO, Union\nimport re\nfrom requests.structures import CaseInsensitiveDict\n\nclass Sample(CaseInsensitiveDict):\n    \"\"\"A single sample for a sample sheet.\n\n    This class is built with the keys and values in the ``\"[Data]\"`` section of\n    the sample sheet. As specified by Illumina, the only required keys are:\n\n        - ``\"Sample_ID\"``\n\n    Although this library recommends you define the following column names:\n\n        - ``\"Sample_ID\"``\n        - ``\"Sample_Name\"``\n        - ``\"index\"``\n\n    If the key ``\"Read_Structure\"`` is provided then its value is promoted to\n    the class :class:`ReadStructure` and additional functionality is enabled.\n\n    Args:\n        data: Mapping of key-value pairs describing this sample.\n        kwargs: Key-value pairs describing this sample.\n\n    Examples:\n        >>> mapping = {\"Sample_ID\": \"87\", \"Sample_Name\": \"3T\", \"index\": \"A\"}\n        >>> sample = Sample(mapping)\n        >>> sample\n        Sample({'Sample_ID': '87', 'Sample_Name': '3T', 'index': 'A'})\n        >>> sample = Sample({'Read_Structure': '151T'})\n        >>> sample.Read_Structure\n        ReadStructure(structure='151T')\n\n    \"\"\"\n    _valid_index_key_pattern = re.compile('index\\\\d?')\n    _valid_index_value_pattern = re.compile('^[ACGTN]*$|^SI-[ACGTNS]{2}-[A-H]\\\\d+$')\n\n    def __init__(self, data: Optional[Mapping]=None, **kwargs: Mapping) -> None:\n        super().__init__()\n        data = {**data, **kwargs} if data is not None else kwargs\n        self._store: Mapping\n        self.sample_sheet: Optional[SampleSheet] = None\n        for key, value in data.items():\n            if key.lower().replace('_', '') == 'readstructure':\n                value = ReadStructure(str(value))\n            if self._valid_index_key_pattern.match(key) and (not bool(self._valid_index_value_pattern.match(str(value)))):\n                raise ValueError(f'Not a valid index: {value}')\n            self[key] = value\n        if self.Read_Structure is not None and self.Read_Structure.is_single_indexed and (self.index is None):\n            raise ValueError(f'If a single-indexed read structure is defined then a sample `index` must be defined also: {self}')\n        elif self.Read_Structure is not None and self.Read_Structure.is_dual_indexed and (self.index is None) and (self.index2 is None):\n            raise ValueError(f'If a dual-indexed read structure is defined then sample `index` and sample `index2` must be defined also: {self}')\n\n    def to_json(self) -> Mapping:\n        \"\"\"Return the properties of this :class:`Sample` as JSON serializable.\n\n        \"\"\"\n        return {str(x): str(y) for x, y in self.items()}\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Samples are equal if the following attributes are equal:\n\n            - ``\"Sample_ID\"``\n            - ``\"Library_ID\"``\n            - ``\"Lane\"``\n\n        \"\"\"\n        if not isinstance(other, Sample):\n            raise NotImplementedError\n        is_equal: bool = self.Sample_ID == other.Sample_ID and self.Library_ID == other.Library_ID and (self.Lane == other.Lane)\n        return is_equal\n\n    def __getattr__(self, attr: Any) -> Optional[Any]:\n        \"\"\"Return ``None`` if an attribute is undefined.\"\"\"\n        return super().get(attr)\n\n    def __repr__(self) -> str:\n        \"\"\"Return an executeable ``__repr__()``.\"\"\"\n        args = {key: getattr(self, key) for key in RECOMMENDED_KEYS}\n        args_str = args.__repr__()\n        return f'{self.__class__.__qualname__}({args_str})'\n\n    def __str__(self) -> str:\n        \"\"\"Cast this object to string.\"\"\"\n        return str(self.Sample_ID) if self.Sample_ID is not None else ''\n\nExample skeleton:\n\n\nclass AWSELBTextPlugin(interface.TextPlugin):\n    '''Text parser plugin for AWS ELB access log files.'''\n\n    def _GetValueFromGroup(self, structure, name, key_name):\n        '''Retrieves a value from a Pyparsing.Group structure.\n        Args:\n          structure (pyparsing.ParseResults): tokens from a parsed log line.\n          name (str): name of the token.\n          key_name (str): key name to retrieve the value of.\n        Returns:\n          object: value for the specified key or None if not available.\n        '''\n        pass\n\n    def _ParseRecord(self, parser_mediator, key, structure):\n        '''Parses a pyparsing structure.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          key (str): name of the parsed structure.\n          structure (pyparsing.ParseResults): tokens from a parsed log line.\n        Raises:\n          ParseError: if the structure cannot be parsed.\n        '''\n        pass\n\n    def _ParseTimeElements(self, time_elements_structure):\n        '''Parses date and time elements of a log line.\n        Args:\n          time_elements_structure (pyparsing.ParseResults): date and time elements\n              of a log line.\n        Returns:\n          dfdatetime.TimeElements: date and time value.\n        Raises:\n          ParseError: if a valid date and time value cannot be derived from\n              the time elements.\n        '''\n        pass\n\n    def CheckRequiredFormat(self, parser_mediator, text_reader):\n        '''Check if the log record has the minimal structure required by the plugin.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          text_reader (EncodedTextReader): text reader.\n        Returns:\n          bool: True if this is the correct plugin, False otherwise.\n        '''\n        pass\nCorresponding class implementation:\n\nimport pyparsing\nfrom plaso.parsers.text_plugins import interface\nfrom plaso.lib import errors\nfrom dfdatetime import time_elements as dfdatetime_time_elements\n\nclass AWSELBTextPlugin(interface.TextPlugin):\n    \"\"\"Text parser plugin for AWS ELB access log files.\"\"\"\n    NAME = 'aws_elb_access'\n    DATA_FORMAT = 'AWS ELB Access log file'\n    ENCODING = 'utf-8'\n    _BLANK = pyparsing.Literal('\"-\"') | pyparsing.Literal('-')\n    _WORD = pyparsing.Word(pyparsing.printables) | _BLANK\n    _INTEGER = pyparsing.Word(pyparsing.nums).set_parse_action(lambda tokens: int(tokens[0], 10))\n    _UNSIGNED_INTEGER = _INTEGER | _BLANK\n    _SIGNED_INTEGER = pyparsing.Word('-', pyparsing.nums) | _UNSIGNED_INTEGER\n    _FLOATING_POINT = pyparsing.Word(pyparsing.nums + '.') | pyparsing.Literal('-1')\n    _IP_ADDRESS = pyparsing.pyparsing_common.ipv4_address | pyparsing.pyparsing_common.ipv6_address\n    _PORT = pyparsing.Word(pyparsing.nums, max=6).set_parse_action(lambda tokens: int(tokens[0], 10)) | _BLANK\n    _SOURCE_IP_ADDRESS_AND_PORT = pyparsing.Group(_IP_ADDRESS.set_results_name('source_ip_address') + pyparsing.Suppress(':') + _PORT.set_results_name('source_port') | _BLANK)\n    _DESTINATION_IP_ADDRESS_AND_PORT = pyparsing.Group(_IP_ADDRESS.set_results_name('destination_ip_address') + pyparsing.Suppress(':') + _PORT.set_results_name('destination_port') | _BLANK)\n    _DATE_TIME_ISOFORMAT_STRING = pyparsing.Regex('([0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{6})Z')\n    _DATE_TIME_ISOFORMAT_STRING_WITHOUT_TIMEZONE = pyparsing.Regex('([0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2})')\n    _REQUEST = pyparsing.quotedString.set_results_name('request').set_parse_action(pyparsing.removeQuotes)\n    _USER_AGENT = pyparsing.quotedString.set_results_name('user_agent').set_parse_action(pyparsing.removeQuotes)\n    _ALPN_CLIENT_PREFERENCE_LIST = pyparsing.quotedString.set_results_name('alpn_client_preference_list').set_parse_action(pyparsing.removeQuotes)\n    _END_OF_LINE = pyparsing.Suppress(pyparsing.LineEnd())\n    _APPLICATION_LOG_LINE = _WORD.set_results_name('request_type') + _DATE_TIME_ISOFORMAT_STRING.set_results_name('response_time') + _WORD.set_results_name('resource_identifier') + _SOURCE_IP_ADDRESS_AND_PORT.set_results_name('source_ip_port') + _DESTINATION_IP_ADDRESS_AND_PORT.set_results_name('destination_ip_port') + _FLOATING_POINT.set_results_name('request_processing_duration') + _FLOATING_POINT.set_results_name('destination_processing_duration') + _FLOATING_POINT.set_results_name('response_processing_duration') + _UNSIGNED_INTEGER.set_results_name('elb_status_code') + _UNSIGNED_INTEGER.set_results_name('destination_status_code') + _UNSIGNED_INTEGER.set_results_name('received_bytes') + _UNSIGNED_INTEGER.set_results_name('sent_bytes') + _REQUEST + _USER_AGENT + _WORD.set_results_name('ssl_cipher') + _WORD.set_results_name('ssl_protocol') + _WORD.set_results_name('destination_group_arn') + pyparsing.quotedString.set_results_name('trace_identifier').set_parse_action(pyparsing.removeQuotes) + pyparsing.quotedString.set_results_name('domain_name').set_parse_action(pyparsing.removeQuotes) + pyparsing.quotedString.set_results_name('chosen_cert_arn').set_parse_action(pyparsing.removeQuotes) + _SIGNED_INTEGER.set_results_name('matched_rule_priority') + _DATE_TIME_ISOFORMAT_STRING.set_results_name('request_time') + pyparsing.quotedString.set_results_name('actions_executed').set_parse_action(pyparsing.removeQuotes) + pyparsing.quotedString.set_results_name('redirect_url').set_parse_action(pyparsing.removeQuotes) + pyparsing.quotedString.set_results_name('error_reason').set_parse_action(pyparsing.removeQuotes) + pyparsing.quotedString.set_results_name('destination_list').set_parse_action(pyparsing.removeQuotes) + pyparsing.quotedString.set_results_name('destination_status_code_list').set_parse_action(pyparsing.removeQuotes) + pyparsing.quotedString.set_results_name('classification').set_parse_action(pyparsing.removeQuotes) + pyparsing.quotedString.set_results_name('classification_reason').set_parse_action(pyparsing.removeQuotes) + _END_OF_LINE\n    _NETWORK_LOG_LINE = _WORD.set_results_name('request_type') + _WORD.set_results_name('version') + _DATE_TIME_ISOFORMAT_STRING_WITHOUT_TIMEZONE.set_results_name('response_time') + _WORD.set_results_name('resource_identifier') + _WORD.set_results_name('listener') + _SOURCE_IP_ADDRESS_AND_PORT.set_results_name('source_ip_port') + _DESTINATION_IP_ADDRESS_AND_PORT.set_results_name('destination_ip_port') + _UNSIGNED_INTEGER.set_results_name('connection_duration') + _UNSIGNED_INTEGER.set_results_name('handshake_duration') + _UNSIGNED_INTEGER.set_results_name('received_bytes') + _UNSIGNED_INTEGER.set_results_name('sent_bytes') + _WORD.set_results_name('incoming_tls_alert') + _WORD.set_results_name('chosen_cert_arn') + _WORD.set_results_name('chosen_cert_serial') + _WORD.set_results_name('tls_cipher') + _WORD.set_results_name('tls_protocol_version') + _WORD.set_results_name('tls_named_group') + _WORD.set_results_name('domain_name') + _WORD.set_results_name('alpn_front_end_protocol') + _WORD.set_results_name('alpn_back_end_protocol') + (_ALPN_CLIENT_PREFERENCE_LIST | pyparsing.Literal('-')) + _END_OF_LINE\n    _CLASSIC_LOG_LINE = _DATE_TIME_ISOFORMAT_STRING.set_results_name('response_time') + _WORD.set_results_name('resource_identifier') + _SOURCE_IP_ADDRESS_AND_PORT.set_results_name('source_ip_port') + _DESTINATION_IP_ADDRESS_AND_PORT.set_results_name('destination_ip_port') + _FLOATING_POINT.set_results_name('request_processing_duration') + _FLOATING_POINT.set_results_name('destination_processing_duration') + _FLOATING_POINT.set_results_name('response_processing_duration') + _UNSIGNED_INTEGER.set_results_name('elb_status_code') + _UNSIGNED_INTEGER.set_results_name('destination_status_code') + _SIGNED_INTEGER.set_results_name('received_bytes') + _SIGNED_INTEGER.set_results_name('sent_bytes') + _REQUEST + _USER_AGENT + _WORD.set_results_name('ssl_cipher') + _WORD.set_results_name('ssl_protocol') + _END_OF_LINE\n    _LINE_STRUCTURES = [('elb_application_accesslog', _APPLICATION_LOG_LINE), ('elb_classic_accesslog', _CLASSIC_LOG_LINE), ('elb_network_accesslog', _NETWORK_LOG_LINE)]\n    VERIFICATION_GRAMMAR = _APPLICATION_LOG_LINE ^ _CLASSIC_LOG_LINE ^ _NETWORK_LOG_LINE\n\n    def _GetValueFromGroup(self, structure, name, key_name):\n        \"\"\"Retrieves a value from a Pyparsing.Group structure.\n\n        Args:\n          structure (pyparsing.ParseResults): tokens from a parsed log line.\n          name (str): name of the token.\n          key_name (str): key name to retrieve the value of.\n\n        Returns:\n          object: value for the specified key or None if not available.\n        \"\"\"\n        structure_value = self._GetValueFromStructure(structure, name)\n        if structure_value is None:\n            return None\n        return structure_value.get(key_name)\n\n    def _ParseRecord(self, parser_mediator, key, structure):\n        \"\"\"Parses a pyparsing structure.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          key (str): name of the parsed structure.\n          structure (pyparsing.ParseResults): tokens from a parsed log line.\n\n        Raises:\n          ParseError: if the structure cannot be parsed.\n        \"\"\"\n        destination_list = self._GetValueFromStructure(structure, 'destination_list')\n        if destination_list:\n            destination_list = destination_list.split()\n        chosen_cert_serial = self._GetValueFromStructure(structure, 'chosen_cert_serial')\n        if chosen_cert_serial == '-':\n            chosen_cert_serial = None\n        classification = self._GetValueFromStructure(structure, 'classification')\n        if classification == '-':\n            classification = None\n        classification_reason = self._GetValueFromStructure(structure, 'classification_reason')\n        if classification_reason == '-':\n            classification_reason = None\n        destination_status_code = self._GetValueFromStructure(structure, 'destination_status_code')\n        if destination_status_code == '-':\n            destination_status_code = None\n        elb_status_code = self._GetValueFromStructure(structure, 'elb_status_code')\n        if elb_status_code == '-':\n            elb_status_code = None\n        error_reason = self._GetValueFromStructure(structure, 'error_reason')\n        if error_reason == '-':\n            error_reason = None\n        incoming_tls_alert = self._GetValueFromStructure(structure, 'incoming_tls_alert')\n        if incoming_tls_alert == '-':\n            incoming_tls_alert = None\n        redirect_url = self._GetValueFromStructure(structure, 'redirect_url')\n        if redirect_url == '-':\n            redirect_url = None\n        ssl_cipher = self._GetValueFromStructure(structure, 'ssl_cipher')\n        if ssl_cipher == '-':\n            ssl_cipher = None\n        ssl_protocol = self._GetValueFromStructure(structure, 'ssl_protocol')\n        if ssl_protocol == '-':\n            ssl_protocol = None\n        tls_named_group = self._GetValueFromStructure(structure, 'tls_named_group')\n        if tls_named_group == '-':\n            tls_named_group = None\n        user_agent = self._GetValueFromStructure(structure, 'user_agent')\n        if user_agent == '-':\n            user_agent = None\n        event_data = AWSELBEventData()\n        event_data.request_type = self._GetValueFromStructure(structure, 'request_type')\n        event_data.resource_identifier = self._GetValueFromStructure(structure, 'resource_identifier')\n        event_data.source_ip_address = self._GetValueFromGroup(structure, 'source_ip_port', 'source_ip_address')\n        event_data.source_port = self._GetValueFromGroup(structure, 'source_ip_port', 'source_port')\n        event_data.destination_ip_address = self._GetValueFromGroup(structure, 'destination_ip_port', 'destination_ip_address')\n        event_data.destination_port = self._GetValueFromGroup(structure, 'destination_ip_port', 'destination_port')\n        event_data.request_processing_duration = self._GetValueFromStructure(structure, 'request_processing_duration')\n        event_data.destination_processing_duration = self._GetValueFromStructure(structure, 'destination_processing_duration')\n        event_data.response_processing_duration = self._GetValueFromStructure(structure, 'response_processing_duration')\n        event_data.elb_status_code = elb_status_code\n        event_data.destination_status_code = destination_status_code\n        event_data.received_bytes = self._GetValueFromStructure(structure, 'received_bytes')\n        event_data.sent_bytes = self._GetValueFromStructure(structure, 'sent_bytes')\n        event_data.request = self._GetValueFromStructure(structure, 'request')\n        event_data.user_agent = user_agent\n        event_data.ssl_cipher = ssl_cipher\n        event_data.ssl_protocol = ssl_protocol\n        event_data.destination_group_arn = self._GetValueFromStructure(structure, 'destination_group_arn')\n        event_data.trace_identifier = self._GetValueFromStructure(structure, 'trace_identifier')\n        event_data.domain_name = self._GetValueFromStructure(structure, 'domain_name')\n        event_data.chosen_cert_arn = self._GetValueFromStructure(structure, 'chosen_cert_arn')\n        event_data.matched_rule_priority = self._GetValueFromStructure(structure, 'matched_rule_priority')\n        event_data.actions_executed = self._GetValueFromStructure(structure, 'actions_executed')\n        event_data.redirect_url = redirect_url\n        event_data.error_reason = error_reason\n        event_data.destination_status_code_list = self._GetValueFromStructure(structure, 'destination_status_code_list')\n        event_data.classification = classification\n        event_data.classification_reason = classification_reason\n        event_data.destination_list = destination_list\n        event_data.version = self._GetValueFromStructure(structure, 'version')\n        event_data.listener = self._GetValueFromStructure(structure, 'listener')\n        event_data.connection_duration = self._GetValueFromStructure(structure, 'connection_duration')\n        event_data.handshake_duration = self._GetValueFromStructure(structure, 'handshake_duration')\n        event_data.incoming_tls_alert = incoming_tls_alert\n        event_data.chosen_cert_serial = chosen_cert_serial\n        event_data.tls_named_group = tls_named_group\n        event_data.tls_cipher = self._GetValueFromStructure(structure, 'tls_cipher')\n        event_data.tls_protocol_version = self._GetValueFromStructure(structure, 'tls_protocol_version')\n        event_data.alpn_front_end_protocol = self._GetValueFromStructure(structure, 'alpn_front_end_protocol')\n        event_data.alpn_back_end_protocol = self._GetValueFromStructure(structure, 'alpn_back_end_protocol')\n        event_data.alpn_client_preference_list = self._GetValueFromStructure(structure, 'alpn_client_preference_list')\n        response_time_structure = self._GetValueFromStructure(structure, 'response_time')\n        if response_time_structure:\n            event_data.response_time = self._ParseTimeElements(response_time_structure)\n        request_time_structure = structure.get('request_time')\n        if request_time_structure:\n            event_data.request_time = self._ParseTimeElements(request_time_structure)\n        parser_mediator.ProduceEventData(event_data)\n\n    def _ParseTimeElements(self, time_elements_structure):\n        \"\"\"Parses date and time elements of a log line.\n\n        Args:\n          time_elements_structure (pyparsing.ParseResults): date and time elements\n              of a log line.\n\n        Returns:\n          dfdatetime.TimeElements: date and time value.\n\n        Raises:\n          ParseError: if a valid date and time value cannot be derived from\n              the time elements.\n        \"\"\"\n        try:\n            if len(time_elements_structure) == 27:\n                date_time = dfdatetime_time_elements.TimeElementsInMicroseconds()\n                date_time.CopyFromStringISO8601(time_elements_structure)\n            else:\n                date_time = dfdatetime_time_elements.TimeElements()\n                date_time.CopyFromStringISO8601(time_elements_structure)\n                date_time.is_local_time = True\n            return date_time\n        except (TypeError, ValueError) as exception:\n            raise errors.ParseError(f'Unable to parse time elements with error: {exception!s}')\n\n    def CheckRequiredFormat(self, parser_mediator, text_reader):\n        \"\"\"Check if the log record has the minimal structure required by the plugin.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          text_reader (EncodedTextReader): text reader.\n\n        Returns:\n          bool: True if this is the correct plugin, False otherwise.\n        \"\"\"\n        try:\n            structure = self._VerifyString(text_reader.lines)\n        except errors.ParseError:\n            return False\n        time_elements_structure = self._GetValueFromStructure(structure, 'response_time')\n        if time_elements_structure:\n            try:\n                self._ParseTimeElements(time_elements_structure)\n            except errors.ParseError:\n                return False\n        time_elements_structure = self._GetValueFromStructure(structure, 'request_time')\n        if time_elements_structure:\n            try:\n                self._ParseTimeElements(time_elements_structure)\n            except errors.ParseError:\n                return False\n        return True\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass ParameterParser:\n    '''Handles parameter parsing and validation for search requests.'''\n    @staticmethod\n    def parse_list_param(param: str | list[str] | None, param_name: str) -> list[str] | None:\n        '''Convert various input formats to lists.\n        Handles:\n        - JSON arrays: '[\"item1\", \"item2\"]' -> ['item1', 'item2']\n        - Comma-separated: 'item1, item2' -> ['item1', 'item2']\n        - Single values: 'item' -> ['item']\n        - None values: None -> None\n        - Already parsed lists: ['item'] -> ['item']\n        Args:\n            param: The parameter to parse\n            param_name: Name of the parameter for error messages\n        Returns:\n            Parsed list or None\n        Raises:\n            InvalidParameterError: If parameter cannot be parsed\n        '''\n        pass\n    @staticmethod\n    def normalize_phase(phase: str | None) -> str | None:\n        '''Normalize phase values for clinical trials.\n        Converts various formats to standard enum values:\n        - \"Phase 3\" -> \"PHASE3\"\n        - \"phase 3\" -> \"PHASE3\"\n        - \"PHASE 3\" -> \"PHASE3\"\n        - \"phase3\" -> \"PHASE3\"\n        Args:\n            phase: Phase value to normalize\n        Returns:\n            Normalized phase value or None\n        '''\n        pass\n    @staticmethod\n    def validate_page_params(page: int, page_size: int) -> tuple[int, int]:\n        '''Validate pagination parameters.\n        Args:\n            page: Page number (minimum 1)\n            page_size: Results per page (1-100)\n        Returns:\n            Validated (page, page_size) tuple\n        Raises:\n            InvalidParameterError: If parameters are invalid\n        '''\n        pass\n    @staticmethod\n    def parse_search_params(params: dict[str, Any], domain: str) -> dict[str, Any]:\n        '''Parse and validate all search parameters for a domain.\n        Args:\n            params: Raw parameters dictionary\n            domain: Domain being searched\n        Returns:\n            Validated parameters dictionary\n        '''\n        pass"
  }
]