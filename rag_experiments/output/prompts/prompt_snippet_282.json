[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass ClientBase(object):\n    '''A client for accessing the Twilio API.'''\n\n    def __init__(self, username: Optional[str]=None, password: Optional[str]=None, account_sid: Optional[str]=None, region: Optional[str]=None, http_client: Optional[HttpClient]=None, environment: Optional[MutableMapping[str, str]]=None, edge: Optional[str]=None, user_agent_extensions: Optional[List[str]]=None, credential_provider: Optional[CredentialProvider]=None):\n        '''\n        Initializes the Twilio Client\n        :param username: Username to authenticate with\n        :param password: Password to authenticate with\n        :param account_sid: Account SID, defaults to Username\n        :param region: Twilio Region to make requests to, defaults to 'us1' if an edge is provided\n        :param http_client: HttpClient, defaults to TwilioHttpClient\n        :param environment: Environment to look for auth details, defaults to os.environ\n        :param edge: Twilio Edge to make requests to, defaults to None\n        :param user_agent_extensions: Additions to the user agent string\n        :param credential_provider: credential provider for authentication method that needs to be used\n        '''\n        pass\n\n    def request(self, method: str, uri: str, params: Optional[Dict[str, object]]=None, data: Optional[Dict[str, object]]=None, headers: Optional[Dict[str, str]]=None, auth: Optional[Tuple[str, str]]=None, timeout: Optional[float]=None, allow_redirects: bool=False) -> Response:\n        '''\n        Makes a request to the Twilio API using the configured http client\n        Authentication information is automatically added if none is provided\n        :param method: HTTP Method\n        :param uri: Fully qualified url\n        :param params: Query string parameters\n        :param data: POST body data\n        :param headers: HTTP Headers\n        :param auth: Authentication\n        :param timeout: Timeout in seconds\n        :param allow_redirects: Should the client follow redirects\n        :returns: Response from the Twilio API\n        '''\n        pass\n\n    async def request_async(self, method: str, uri: str, params: Optional[Dict[str, object]]=None, data: Optional[Dict[str, object]]=None, headers: Optional[Dict[str, str]]=None, auth: Optional[Tuple[str, str]]=None, timeout: Optional[float]=None, allow_redirects: bool=False) -> Response:\n        '''\n        Asynchronously makes a request to the Twilio API  using the configured http client\n        The configured http client must be an asynchronous http client\n        Authentication information is automatically added if none is provided\n        :param method: HTTP Method\n        :param uri: Fully qualified url\n        :param params: Query string parameters\n        :param data: POST body data\n        :param headers: HTTP Headers\n        :param auth: Authentication\n        :param timeout: Timeout in seconds\n        :param allow_redirects: Should the client follow redirects\n        :returns: Response from the Twilio API\n        '''\n        pass\n\n    def copy_non_none_values(self, data):\n        pass\n\n    def get_auth(self, auth: Optional[Tuple[str, str]]) -> Tuple[str, str]:\n        '''\n        Get the request authentication object\n        :param auth: Authentication (username, password)\n        :returns: The authentication object\n        '''\n        pass\n\n    def get_headers(self, method: str, headers: Optional[Dict[str, str]]) -> Dict[str, str]:\n        '''\n        Get the request headers including user-agent, extensions, encoding, content-type, MIME type\n        :param method: HTTP method\n        :param headers: HTTP headers\n        :returns: HTTP headers\n        '''\n        pass\n\n    def get_hostname(self, uri: str) -> str:\n        '''\n        Determines the proper hostname given edge and region preferences\n        via client configuration or uri.\n        :param uri: Fully qualified url\n        :returns: The final uri used to make the request\n        '''\n        pass\n\n    def __repr__(self) -> str:\n        '''\n        Provide a friendly representation\n        :returns: Machine friendly representation\n        '''\n        pass\nCorresponding class implementation:\n\nfrom twilio import __version__\nimport platform\nfrom twilio.http.http_client import TwilioHttpClient\nfrom typing import Dict, List, MutableMapping, Optional, Tuple\nfrom twilio.http import HttpClient\nfrom urllib.parse import urlparse, urlunparse\nfrom twilio.http.response import Response\nimport os\nfrom twilio.credential.credential_provider import CredentialProvider\n\nclass ClientBase(object):\n    \"\"\"A client for accessing the Twilio API.\"\"\"\n\n    def __init__(self, username: Optional[str]=None, password: Optional[str]=None, account_sid: Optional[str]=None, region: Optional[str]=None, http_client: Optional[HttpClient]=None, environment: Optional[MutableMapping[str, str]]=None, edge: Optional[str]=None, user_agent_extensions: Optional[List[str]]=None, credential_provider: Optional[CredentialProvider]=None):\n        \"\"\"\n        Initializes the Twilio Client\n\n        :param username: Username to authenticate with\n        :param password: Password to authenticate with\n        :param account_sid: Account SID, defaults to Username\n        :param region: Twilio Region to make requests to, defaults to 'us1' if an edge is provided\n        :param http_client: HttpClient, defaults to TwilioHttpClient\n        :param environment: Environment to look for auth details, defaults to os.environ\n        :param edge: Twilio Edge to make requests to, defaults to None\n        :param user_agent_extensions: Additions to the user agent string\n        :param credential_provider: credential provider for authentication method that needs to be used\n        \"\"\"\n        environment = environment or os.environ\n        self.username = username or environment.get('TWILIO_ACCOUNT_SID')\n        ' :type : str '\n        self.password = password or environment.get('TWILIO_AUTH_TOKEN')\n        ' :type : str '\n        self.edge = edge or environment.get('TWILIO_EDGE')\n        ' :type : str '\n        self.region = region or environment.get('TWILIO_REGION')\n        ' :type : str '\n        self.user_agent_extensions = user_agent_extensions or []\n        ' :type : list[str] '\n        self.credential_provider = credential_provider or None\n        ' :type : CredentialProvider '\n        self.account_sid = account_sid or self.username\n        ' :type : str '\n        self.auth = (self.username, self.password)\n        ' :type : tuple(str, str) '\n        self.http_client: HttpClient = http_client or TwilioHttpClient()\n        ' :type : HttpClient '\n\n    def request(self, method: str, uri: str, params: Optional[Dict[str, object]]=None, data: Optional[Dict[str, object]]=None, headers: Optional[Dict[str, str]]=None, auth: Optional[Tuple[str, str]]=None, timeout: Optional[float]=None, allow_redirects: bool=False) -> Response:\n        \"\"\"\n        Makes a request to the Twilio API using the configured http client\n        Authentication information is automatically added if none is provided\n\n        :param method: HTTP Method\n        :param uri: Fully qualified url\n        :param params: Query string parameters\n        :param data: POST body data\n        :param headers: HTTP Headers\n        :param auth: Authentication\n        :param timeout: Timeout in seconds\n        :param allow_redirects: Should the client follow redirects\n\n        :returns: Response from the Twilio API\n        \"\"\"\n        headers = self.get_headers(method, headers)\n        if self.credential_provider:\n            auth_strategy = self.credential_provider.to_auth_strategy()\n            headers['Authorization'] = auth_strategy.get_auth_string()\n        elif self.username is not None and self.password is not None:\n            auth = self.get_auth(auth)\n        else:\n            auth = None\n        if method == 'DELETE':\n            del headers['Accept']\n        uri = self.get_hostname(uri)\n        filtered_data = self.copy_non_none_values(data)\n        return self.http_client.request(method, uri, params=params, data=filtered_data, headers=headers, auth=auth, timeout=timeout, allow_redirects=allow_redirects)\n\n    async def request_async(self, method: str, uri: str, params: Optional[Dict[str, object]]=None, data: Optional[Dict[str, object]]=None, headers: Optional[Dict[str, str]]=None, auth: Optional[Tuple[str, str]]=None, timeout: Optional[float]=None, allow_redirects: bool=False) -> Response:\n        \"\"\"\n        Asynchronously makes a request to the Twilio API  using the configured http client\n        The configured http client must be an asynchronous http client\n        Authentication information is automatically added if none is provided\n\n        :param method: HTTP Method\n        :param uri: Fully qualified url\n        :param params: Query string parameters\n        :param data: POST body data\n        :param headers: HTTP Headers\n        :param auth: Authentication\n        :param timeout: Timeout in seconds\n        :param allow_redirects: Should the client follow redirects\n\n        :returns: Response from the Twilio API\n        \"\"\"\n        if not self.http_client.is_async:\n            raise RuntimeError('http_client must be asynchronous to support async API requests')\n        headers = self.get_headers(method, headers)\n        if method == 'DELETE':\n            del headers['Accept']\n        if self.credential_provider:\n            auth_strategy = self.credential_provider.to_auth_strategy()\n            headers['Authorization'] = auth_strategy.get_auth_string()\n        elif self.username is not None and self.password is not None:\n            auth = self.get_auth(auth)\n        else:\n            auth = None\n        uri = self.get_hostname(uri)\n        filtered_data = self.copy_non_none_values(data)\n        return await self.http_client.request(method, uri, params=params, data=filtered_data, headers=headers, auth=auth, timeout=timeout, allow_redirects=allow_redirects)\n\n    def copy_non_none_values(self, data):\n        if isinstance(data, dict):\n            return {k: self.copy_non_none_values(v) for k, v in data.items() if v is not None}\n        elif isinstance(data, list):\n            return [self.copy_non_none_values(item) for item in data if item is not None]\n        return data\n\n    def get_auth(self, auth: Optional[Tuple[str, str]]) -> Tuple[str, str]:\n        \"\"\"\n        Get the request authentication object\n        :param auth: Authentication (username, password)\n        :returns: The authentication object\n        \"\"\"\n        return auth or self.auth\n\n    def get_headers(self, method: str, headers: Optional[Dict[str, str]]) -> Dict[str, str]:\n        \"\"\"\n        Get the request headers including user-agent, extensions, encoding, content-type, MIME type\n        :param method: HTTP method\n        :param headers: HTTP headers\n        :returns: HTTP headers\n        \"\"\"\n        headers = headers or {}\n        pkg_version = __version__\n        os_name = platform.system()\n        os_arch = platform.machine()\n        python_version = platform.python_version()\n        headers['User-Agent'] = 'twilio-python/{} ({} {}) Python/{}'.format(pkg_version, os_name, os_arch, python_version)\n        for extension in self.user_agent_extensions:\n            headers['User-Agent'] += ' {}'.format(extension)\n        headers['X-Twilio-Client'] = 'python-{}'.format(__version__)\n        headers['Accept-Charset'] = 'utf-8'\n        if (method == 'POST' or method == 'PUT') and 'Content-Type' not in headers:\n            headers['Content-Type'] = 'application/x-www-form-urlencoded'\n        if 'Accept' not in headers:\n            headers['Accept'] = 'application/json'\n        return headers\n\n    def get_hostname(self, uri: str) -> str:\n        \"\"\"\n        Determines the proper hostname given edge and region preferences\n        via client configuration or uri.\n\n        :param uri: Fully qualified url\n\n        :returns: The final uri used to make the request\n        \"\"\"\n        if not self.edge and (not self.region):\n            return uri\n        parsed_url = urlparse(uri)\n        pieces = parsed_url.netloc.split('.')\n        prefix = pieces[0]\n        suffix = '.'.join(pieces[-2:])\n        region = None\n        edge = None\n        if len(pieces) == 4:\n            region = pieces[1]\n        elif len(pieces) == 5:\n            edge = pieces[1]\n            region = pieces[2]\n        edge = self.edge or edge\n        region = self.region or region or (edge and 'us1')\n        parsed_url = parsed_url._replace(netloc='.'.join([part for part in [prefix, edge, region, suffix] if part]))\n        return str(urlunparse(parsed_url))\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Provide a friendly representation\n\n        :returns: Machine friendly representation\n        \"\"\"\n        return '<Twilio {}>'.format(self.account_sid)\n\nExample skeleton:\n\n\nclass Session(object):\n    '''A class to store credentials.\n    A Session can be initialized with a Server Token or with a set of\n    OAuth 2.0 Credentials, but not with both. A Session uses credentials\n    to properly construct requests to Uber and access protected resources.\n    '''\n\n    def __init__(self, server_token=None, oauth2credential=None):\n        '''Initialize a Session.\n        Parameters\n            sever_token (str)\n                Your application's server token. Available at\n                developer.uber.com.\n            oauth2credential (OAuth2Credential)\n                Access token and additional OAuth 2.0 credentials used\n                to access protected resources.\n        Raises\n            UberIllegalState (APIError)\n                Raised if there is an attempt to create session with\n                both server token and access token.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom uber_rides.errors import UberIllegalState\nfrom uber_rides.utils import auth\n\nclass Session(object):\n    \"\"\"A class to store credentials.\n\n    A Session can be initialized with a Server Token or with a set of\n    OAuth 2.0 Credentials, but not with both. A Session uses credentials\n    to properly construct requests to Uber and access protected resources.\n    \"\"\"\n\n    def __init__(self, server_token=None, oauth2credential=None):\n        \"\"\"Initialize a Session.\n\n        Parameters\n            sever_token (str)\n                Your application's server token. Available at\n                developer.uber.com.\n            oauth2credential (OAuth2Credential)\n                Access token and additional OAuth 2.0 credentials used\n                to access protected resources.\n\n        Raises\n            UberIllegalState (APIError)\n                Raised if there is an attempt to create session with\n                both server token and access token.\n        \"\"\"\n        if server_token and oauth2credential:\n            message = 'Session cannot have both Server and OAuth 2.0 Credentials.'\n            raise UberIllegalState(message)\n        if server_token is None and oauth2credential is None:\n            message = 'Session must have either Server Token or OAuth 2.0 Credentials.'\n            raise UberIllegalState(message)\n        if server_token:\n            self.server_token = server_token\n            self.token_type = auth.SERVER_TOKEN_TYPE\n            self.oauth2credential = None\n        elif oauth2credential:\n            self.oauth2credential = oauth2credential\n            self.token_type = auth.OAUTH_TOKEN_TYPE\n            self.server_token = None\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass SecOpsAuth:\n    '''Handles authentication for the Google SecOps SDK.'''\n\n    def __init__(self, credentials: Optional[Credentials]=None, service_account_path: Optional[str]=None, service_account_info: Optional[Dict[str, Any]]=None, impersonate_service_account: Optional[str]=None, scopes: Optional[List[str]]=None):\n        '''Initialize authentication for SecOps.\n        Args:\n            credentials: Optional pre-existing Google Auth credentials\n            service_account_path: Optional path to service account JSON key file\n            service_account_info: Optional service account JSON key data as dict\n            impersonate_service_account: Optional service account to impersonate\n            scopes: Optional list of OAuth scopes to request\n        '''\n        pass\n\n    def _get_credentials(self, credentials: Optional[Credentials], service_account_path: Optional[str], service_account_info: Optional[Dict[str, Any]], impersonate_service_account: Optional[str]) -> Credentials:\n        '''Get credentials from various sources.'''\n        pass\n    @property\n    def session(self):\n        '''Get an authorized session using the credentials.\n        Returns:\n            Authorized session for API requests\n        '''\n        pass"
  }
]