[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass PlsRecallParser(interface.FileObjectParser, dtfabric_helper.DtFabricHelper):\n    '''Parse PL/SQL Recall files.\n    This parser is based on the Delphi definition of the data type:\n      TRecallRecord = packed record\n        Sequence: Integer;\n        TimeStamp: TDateTime;\n        Username: array[0..30] of Char;\n        Database: array[0..80] of Char;\n        Text: array[0..4000] of Char;\n      end;\n      Delphi TDateTime is a little-endian 64-bit floating-point value without\n      time zone information.\n    '''\n\n    def __init__(self):\n        '''Initializes a PL/SQL Recall file parser.'''\n        pass\n\n    def _ParseTDateTimeValue(self, tdatetime_value):\n        '''Parses a TDateTime value.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          tdatetime_value (float): a TDateTime value.\n        Returns:\n          dfdatetime.DelphiDateTime: date and time value.\n        Raises:\n          ParseError: if a valid date and time value cannot be derived from\n              the TDateTime value.\n        '''\n        pass\n\n    def _VerifyFirstRecord(self, parser_mediator, pls_record):\n        '''Verifies the first PLS Recall record.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          pls_record (pls_recall_record): a PLS Recall record to verify.\n        Returns:\n          bool: True if this is a valid PLS Recall record, False otherwise.\n        '''\n        pass\n\n    def ParseFileObject(self, parser_mediator, file_object):\n        '''Parses a PLSRecall.dat file-like object.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): a file-like object.\n        Raises:\n          WrongParser: when the file cannot be parsed.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom dfdatetime import delphi_date_time as dfdatetime_delphi_date_time\nimport os\nfrom plaso.parsers import interface\nfrom plaso.lib import errors\nfrom plaso.lib import dtfabric_helper\n\nclass PlsRecallParser(interface.FileObjectParser, dtfabric_helper.DtFabricHelper):\n    \"\"\"Parse PL/SQL Recall files.\n\n    This parser is based on the Delphi definition of the data type:\n\n      TRecallRecord = packed record\n        Sequence: Integer;\n        TimeStamp: TDateTime;\n        Username: array[0..30] of Char;\n        Database: array[0..80] of Char;\n        Text: array[0..4000] of Char;\n      end;\n\n      Delphi TDateTime is a little-endian 64-bit floating-point value without\n      time zone information.\n    \"\"\"\n    NAME = 'pls_recall'\n    DATA_FORMAT = 'PL SQL cache file (PL-SQL developer recall file) format'\n    _DEFINITION_FILE = os.path.join(os.path.dirname(__file__), 'pls_recall.yaml')\n    _PLS_KEYWORD = frozenset(['begin', 'commit', 'create', 'declare', 'drop', 'end', 'exception', 'execute', 'insert', 'replace', 'rollback', 'select', 'set', 'update'])\n\n    def __init__(self):\n        \"\"\"Initializes a PL/SQL Recall file parser.\"\"\"\n        super(PlsRecallParser, self).__init__()\n        self._record_map = self._GetDataTypeMap('pls_recall_record')\n\n    def _ParseTDateTimeValue(self, tdatetime_value):\n        \"\"\"Parses a TDateTime value.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          tdatetime_value (float): a TDateTime value.\n\n        Returns:\n          dfdatetime.DelphiDateTime: date and time value.\n\n        Raises:\n          ParseError: if a valid date and time value cannot be derived from\n              the TDateTime value.\n        \"\"\"\n        if tdatetime_value < -693593.0 or tdatetime_value > 2958465.0:\n            raise errors.ParseError('Invalid TDateTime value out bounds')\n        return dfdatetime_delphi_date_time.DelphiDateTime(timestamp=tdatetime_value)\n\n    def _VerifyFirstRecord(self, parser_mediator, pls_record):\n        \"\"\"Verifies the first PLS Recall record.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          pls_record (pls_recall_record): a PLS Recall record to verify.\n\n        Returns:\n          bool: True if this is a valid PLS Recall record, False otherwise.\n        \"\"\"\n        try:\n            date_time = self._ParseTDateTimeValue(pls_record.last_written_time)\n        except errors.ParseError:\n            return False\n        if pls_record.last_written_time > -0.0001 and pls_record.last_written_time < 0.0001 and (pls_record.last_written_time != 0.0):\n            return False\n        year, _, _ = date_time.GetDate()\n        current_year = parser_mediator.GetCurrentYear()\n        if year > current_year + 6:\n            return False\n        first_word, _, _ = pls_record.query.partition(' ')\n        if first_word.lower() not in self._PLS_KEYWORD:\n            return False\n        return True\n\n    def ParseFileObject(self, parser_mediator, file_object):\n        \"\"\"Parses a PLSRecall.dat file-like object.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): a file-like object.\n\n        Raises:\n          WrongParser: when the file cannot be parsed.\n        \"\"\"\n        file_offset = 0\n        file_size = file_object.get_size()\n        while file_offset < file_size:\n            try:\n                pls_record, record_data_size = self._ReadStructureFromFileObject(file_object, file_offset, self._record_map)\n            except (ValueError, errors.ParseError) as exception:\n                if file_offset == 0:\n                    raise errors.WrongParser('Unable to parse first record.')\n                parser_mediator.ProduceExtractionWarning('unable to parse record at offset: 0x{0:08x} with error: {1!s}'.format(file_offset, exception))\n                break\n            if file_offset == 0 and (not self._VerifyFirstRecord(parser_mediator, pls_record)):\n                raise errors.WrongParser('Verification of first record failed.')\n            event_data = PlsRecallEventData()\n            event_data.database_name = pls_record.database_name\n            event_data.sequence_number = pls_record.sequence_number\n            event_data.offset = file_offset\n            event_data.query = pls_record.query\n            event_data.username = pls_record.username\n            try:\n                event_data.written_time = self._ParseTDateTimeValue(pls_record.last_written_time)\n            except errors.ParseError:\n                parser_mediator.ProduceExtractionWarning('unable to parse TDateTime value of record at offset: 0x{0:08x} with error: {1!s}'.format(file_offset, exception))\n            parser_mediator.ProduceEventData(event_data)\n            file_offset += record_data_size\n\nExample skeleton:\n\n\nclass Decrypter(object):\n    '''Decrypter interface.'''\n\n    def __init__(self, **kwargs):\n        '''Initializes a decrypter.\n        Args:\n          kwargs (dict): keyword arguments depending on the decrypter.\n        Raises:\n          ValueError: when there are unused keyword arguments.\n        '''\n        pass\n    @abc.abstractmethod\n    def Decrypt(self, encrypted_data, finalize=False):\n        '''Decrypts the encrypted data.\n        Args:\n          encrypted_data (bytes): encrypted data.\n          finalize (Optional[bool]): True if the end of data has been reached and\n              the cipher context should be finalized.\n        Returns:\n          tuple[bytes, bytes]: decrypted data and remaining encrypted data.\n        '''\n        pass\nCorresponding class implementation:\n\nimport abc\n\nclass Decrypter(object):\n    \"\"\"Decrypter interface.\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Initializes a decrypter.\n\n        Args:\n          kwargs (dict): keyword arguments depending on the decrypter.\n\n        Raises:\n          ValueError: when there are unused keyword arguments.\n        \"\"\"\n        if kwargs:\n            keyword_arguments = ', '.join(kwargs)\n            raise ValueError(f'Unused keyword arguments: {keyword_arguments:s}.')\n        super(Decrypter, self).__init__()\n\n    @abc.abstractmethod\n    def Decrypt(self, encrypted_data, finalize=False):\n        \"\"\"Decrypts the encrypted data.\n\n        Args:\n          encrypted_data (bytes): encrypted data.\n          finalize (Optional[bool]): True if the end of data has been reached and\n              the cipher context should be finalized.\n\n        Returns:\n          tuple[bytes, bytes]: decrypted data and remaining encrypted data.\n        \"\"\"\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass ConfigSpaceHexFormatter:\n    '''\n    Formats PCI configuration space data into hex files for FPGA initialization.\n    This class handles:\n    - Converting configuration space bytes to little-endian 32-bit words\n    - Generating properly formatted hex files for Vivado $readmemh\n    - Adding debug comments with register offsets\n    - Ensuring proper alignment and padding\n    '''\n\n    def __init__(self):\n        '''Initialize the hex formatter.'''\n        pass\n\n    def format_config_space_to_hex(self, config_space_data: bytes, include_comments: bool=True, words_per_line: int=1, vendor_id: Optional[str]=None, device_id: Optional[str]=None, class_code: Optional[str]=None, board: Optional[str]=None) -> str:\n        '''\n        Convert configuration space data to hex format.\n        Args:\n            config_space_data: Raw configuration space bytes\n            include_comments: Whether to include offset/register comments\n            words_per_line: Number of 32-bit words per line (default: 1)\n        Returns:\n            Formatted hex string suitable for $readmemh\n        Raises:\n            ValueError: If config space data is invalid\n        '''\n        pass\n\n    def _get_register_comment(self, offset: int) -> Optional[str]:\n        '''\n        Get a descriptive comment for a register offset.\n        Args:\n            offset: Register offset in configuration space\n        Returns:\n            Register description or None if no standard register\n        '''\n        pass\n\n    def write_hex_file(self, config_space_data: bytes, output_path: Union[str, Path], include_comments: bool=True) -> Path:\n        '''\n        Write configuration space data to a hex file.\n        Args:\n            config_space_data: Raw configuration space bytes\n            output_path: Path where hex file should be written\n            include_comments: Whether to include offset/register comments\n        Returns:\n            Path to the written hex file\n        Raises:\n            IOError: If file cannot be written\n        '''\n        pass\n\n    def validate_hex_file(self, hex_file_path: Union[str, Path]) -> bool:\n        '''\n        Validate a hex file for proper formatting.\n        Args:\n            hex_file_path: Path to hex file to validate\n        Returns:\n            True if valid, False otherwise\n        '''\n        pass\n\n    def convert_to_dword_list(self, config_space_data: bytes) -> List[int]:\n        '''\n        Convert configuration space bytes to a list of 32-bit dwords.\n        Args:\n            config_space_data: Raw configuration space bytes\n        Returns:\n            List of 32-bit integers in little-endian format\n        '''\n        pass"
  }
]