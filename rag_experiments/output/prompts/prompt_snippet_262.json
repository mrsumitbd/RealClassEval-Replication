[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass ZAPHelper(object):\n    '''ZAPHelper class for wrapping the ZAP API client.'''\n\n    def __init__(self, zap_path='', port=8090, url='http://127.0.0.1', api_key='', log_path=None, logger=None):\n        pass\n    @property\n    def scanner_groups(self):\n        '''Available scanner groups.'''\n        pass\n\n    def start(self, options=None):\n        '''Start the ZAP Daemon.'''\n        pass\n\n    def shutdown(self):\n        '''Shutdown ZAP.'''\n        pass\n\n    def wait_for_zap(self, timeout):\n        '''Wait for ZAP to be ready to receive API calls.'''\n        pass\n\n    def is_running(self):\n        '''Check if ZAP is running.'''\n        pass\n\n    def open_url(self, url, sleep_after_open=2):\n        '''Access a URL through ZAP.'''\n        pass\n\n    def run_spider(self, target_url, context_name=None, user_name=None):\n        '''Run spider against a URL.'''\n        pass\n\n    def run_active_scan(self, target_url, recursive=False, context_name=None, user_name=None):\n        '''Run an active scan against a URL.'''\n        pass\n\n    def run_ajax_spider(self, target_url):\n        '''Run AJAX Spider against a URL.'''\n        pass\n\n    def alerts(self, alert_level='High'):\n        '''Get a filtered list of alerts at the given alert level, and sorted by alert level.'''\n        pass\n\n    def enabled_scanner_ids(self):\n        '''Retrieves a list of currently enabled scanners.'''\n        pass\n\n    def enable_scanners_by_ids(self, scanner_ids):\n        '''Enable a list of scanner IDs.'''\n        pass\n\n    def disable_scanners_by_ids(self, scanner_ids):\n        '''Disable a list of scanner IDs.'''\n        pass\n\n    def enable_scanners_by_group(self, group):\n        '''\n        Enables the scanners in the group if it matches one in the scanner_group_map.\n        '''\n        pass\n\n    def disable_scanners_by_group(self, group):\n        '''\n        Disables the scanners in the group if it matches one in the scanner_group_map.\n        '''\n        pass\n\n    def enable_scanners_by_ids(self, scanner_ids):\n        '''\n        Enable the provided scanners by group and/or IDs.\n        '''\n        pass\n\n    def disable_scanners_by_ids(self, scanner_ids):\n        '''\n        Enable the provided scanners by group and/or IDs.\n        '''\n        pass\n\n    def set_enabled_scanners(self, scanners):\n        '''\n        Set only the provided scanners by group and/or IDs and disable all others.\n        '''\n        pass\n\n    def set_scanner_attack_strength(self, scanner_ids, attack_strength):\n        '''Set the attack strength for the given scanners.'''\n        pass\n\n    def set_scanner_alert_threshold(self, scanner_ids, alert_threshold):\n        '''Set the alert theshold for the given policies.'''\n        pass\n\n    def enable_policies_by_ids(self, policy_ids):\n        '''Set enabled policy from a list of IDs.'''\n        pass\n\n    def set_policy_attack_strength(self, policy_ids, attack_strength):\n        '''Set the attack strength for the given policies.'''\n        pass\n\n    def set_policy_alert_threshold(self, policy_ids, alert_threshold):\n        '''Set the alert theshold for the given policies.'''\n        pass\n\n    def exclude_from_all(self, exclude_regex):\n        '''Exclude a pattern from proxy, spider and active scanner.'''\n        pass\n\n    def xml_report(self, file_path):\n        '''Generate and save XML report'''\n        pass\n\n    def md_report(self, file_path):\n        '''Generate and save MD report'''\n        pass\n\n    def html_report(self, file_path):\n        '''Generate and save HTML report.'''\n        pass\n    @staticmethod\n    def _write_report(report, file_path):\n        '''Write report to the given file path.'''\n        pass\n\n    def get_context_info(self, context_name):\n        '''Get the context ID for a given context name.'''\n        pass\n\n    def _get_context_and_user_ids(self, context_name, user_name):\n        '''Helper to get the context ID and user ID from the given names.'''\n        pass\n\n    def _get_user_id_from_name(self, context_id, user_name):\n        '''Get a user ID from the user name.'''\n        pass\nCorresponding class implementation:\n\nfrom zapcli.exceptions import ZAPError\nimport platform\nimport time\nimport re\nimport subprocess\nfrom zapv2 import ZAPv2\nimport shlex\nfrom six import binary_type\nfrom zapcli.log import console\nimport os\nimport requests\nfrom requests.exceptions import RequestException\n\nclass ZAPHelper(object):\n    \"\"\"ZAPHelper class for wrapping the ZAP API client.\"\"\"\n    alert_levels = {'Informational': 1, 'Low': 2, 'Medium': 3, 'High': 4}\n    scanner_group_map = {'sqli': ['40018'], 'xss': ['40012', '40014', '40016', '40017'], 'xss_reflected': ['40012'], 'xss_persistent': ['40014', '40016', '40017']}\n    timeout = 60\n    _status_check_sleep = 10\n\n    def __init__(self, zap_path='', port=8090, url='http://127.0.0.1', api_key='', log_path=None, logger=None):\n        if os.path.isfile(zap_path):\n            zap_path = os.path.dirname(zap_path)\n        self.zap_path = zap_path\n        self.port = port\n        self.proxy_url = '{0}:{1}'.format(url, self.port)\n        self.zap = ZAPv2(proxies={'http': self.proxy_url, 'https': self.proxy_url}, apikey=api_key)\n        self.api_key = api_key\n        self.log_path = log_path\n        self.logger = logger or console\n\n    @property\n    def scanner_groups(self):\n        \"\"\"Available scanner groups.\"\"\"\n        return ['all'] + list(self.scanner_group_map.keys())\n\n    def start(self, options=None):\n        \"\"\"Start the ZAP Daemon.\"\"\"\n        if self.is_running():\n            self.logger.warn('ZAP is already running on port {0}'.format(self.port))\n            return\n        if platform.system() == 'Windows' or platform.system().startswith('CYGWIN'):\n            executable = 'zap.bat'\n        else:\n            executable = 'zap.sh'\n        executable_path = os.path.join(self.zap_path, executable)\n        if not os.path.isfile(executable_path):\n            raise ZAPError(('ZAP was not found in the path \"{0}\". You can set the path to where ZAP is ' + 'installed on your system using the --zap-path command line parameter or by ' + 'default using the ZAP_PATH environment variable.').format(self.zap_path))\n        zap_command = [executable_path, '-daemon', '-port', str(self.port)]\n        if options:\n            extra_options = shlex.split(options)\n            zap_command += extra_options\n        if self.log_path is None:\n            log_path = os.path.join(self.zap_path, 'zap.log')\n        else:\n            log_path = os.path.join(self.log_path, 'zap.log')\n        self.logger.debug('Starting ZAP process with command: {0}.'.format(' '.join(zap_command)))\n        self.logger.debug('Logging to {0}'.format(log_path))\n        with open(log_path, 'w+') as log_file:\n            subprocess.Popen(zap_command, cwd=self.zap_path, stdout=log_file, stderr=subprocess.STDOUT)\n        self.wait_for_zap(self.timeout)\n        self.logger.debug('ZAP started successfully.')\n\n    def shutdown(self):\n        \"\"\"Shutdown ZAP.\"\"\"\n        if not self.is_running():\n            self.logger.warn('ZAP is not running.')\n            return\n        self.logger.debug('Shutting down ZAP.')\n        self.zap.core.shutdown()\n        timeout_time = time.time() + self.timeout\n        while self.is_running():\n            if time.time() > timeout_time:\n                raise ZAPError('Timed out waiting for ZAP to shutdown.')\n            time.sleep(2)\n        self.logger.debug('ZAP shutdown successfully.')\n\n    def wait_for_zap(self, timeout):\n        \"\"\"Wait for ZAP to be ready to receive API calls.\"\"\"\n        timeout_time = time.time() + timeout\n        while not self.is_running():\n            if time.time() > timeout_time:\n                raise ZAPError('Timed out waiting for ZAP to start.')\n            time.sleep(2)\n\n    def is_running(self):\n        \"\"\"Check if ZAP is running.\"\"\"\n        try:\n            result = requests.get(self.proxy_url)\n        except RequestException:\n            return False\n        if 'ZAP-Header' in result.headers.get('Access-Control-Allow-Headers', []):\n            return True\n        raise ZAPError('Another process is listening on {0}'.format(self.proxy_url))\n\n    def open_url(self, url, sleep_after_open=2):\n        \"\"\"Access a URL through ZAP.\"\"\"\n        self.zap.urlopen(url)\n        time.sleep(sleep_after_open)\n\n    def run_spider(self, target_url, context_name=None, user_name=None):\n        \"\"\"Run spider against a URL.\"\"\"\n        self.logger.debug('Spidering target {0}...'.format(target_url))\n        context_id, user_id = self._get_context_and_user_ids(context_name, user_name)\n        if user_id:\n            self.logger.debug('Running spider in context {0} as user {1}'.format(context_id, user_id))\n            scan_id = self.zap.spider.scan_as_user(context_id, user_id, target_url)\n        else:\n            scan_id = self.zap.spider.scan(target_url)\n        if not scan_id:\n            raise ZAPError('Error running spider.')\n        elif not scan_id.isdigit():\n            raise ZAPError('Error running spider: \"{0}\"'.format(scan_id))\n        self.logger.debug('Started spider with ID {0}...'.format(scan_id))\n        while int(self.zap.spider.status()) < 100:\n            self.logger.debug('Spider progress %: {0}'.format(self.zap.spider.status()))\n            time.sleep(self._status_check_sleep)\n        self.logger.debug('Spider #{0} completed'.format(scan_id))\n\n    def run_active_scan(self, target_url, recursive=False, context_name=None, user_name=None):\n        \"\"\"Run an active scan against a URL.\"\"\"\n        self.logger.debug('Scanning target {0}...'.format(target_url))\n        context_id, user_id = self._get_context_and_user_ids(context_name, user_name)\n        if user_id:\n            self.logger.debug('Scanning in context {0} as user {1}'.format(context_id, user_id))\n            scan_id = self.zap.ascan.scan_as_user(target_url, context_id, user_id, recursive)\n        else:\n            scan_id = self.zap.ascan.scan(target_url, recurse=recursive)\n        if not scan_id:\n            raise ZAPError('Error running active scan.')\n        elif not scan_id.isdigit():\n            raise ZAPError(('Error running active scan: \"{0}\". Make sure the URL is in the site ' + 'tree by using the open-url or scanner commands before running an active ' + 'scan.').format(scan_id))\n        self.logger.debug('Started scan with ID {0}...'.format(scan_id))\n        while int(self.zap.ascan.status()) < 100:\n            self.logger.debug('Scan progress %: {0}'.format(self.zap.ascan.status()))\n            time.sleep(self._status_check_sleep)\n        self.logger.debug('Scan #{0} completed'.format(scan_id))\n\n    def run_ajax_spider(self, target_url):\n        \"\"\"Run AJAX Spider against a URL.\"\"\"\n        self.logger.debug('AJAX Spidering target {0}...'.format(target_url))\n        self.zap.ajaxSpider.scan(target_url)\n        while self.zap.ajaxSpider.status == 'running':\n            self.logger.debug('AJAX Spider: {0}'.format(self.zap.ajaxSpider.status))\n            time.sleep(self._status_check_sleep)\n        self.logger.debug('AJAX Spider completed')\n\n    def alerts(self, alert_level='High'):\n        \"\"\"Get a filtered list of alerts at the given alert level, and sorted by alert level.\"\"\"\n        alerts = self.zap.core.alerts()\n        alert_level_value = self.alert_levels[alert_level]\n        alerts = sorted((a for a in alerts if self.alert_levels[a['risk']] >= alert_level_value), key=lambda k: self.alert_levels[k['risk']], reverse=True)\n        return alerts\n\n    def enabled_scanner_ids(self):\n        \"\"\"Retrieves a list of currently enabled scanners.\"\"\"\n        enabled_scanners = []\n        scanners = self.zap.ascan.scanners()\n        for scanner in scanners:\n            if scanner['enabled'] == 'true':\n                enabled_scanners.append(scanner['id'])\n        return enabled_scanners\n\n    def enable_scanners_by_ids(self, scanner_ids):\n        \"\"\"Enable a list of scanner IDs.\"\"\"\n        scanner_ids = ','.join(scanner_ids)\n        self.logger.debug('Enabling scanners with IDs {0}'.format(scanner_ids))\n        return self.zap.ascan.enable_scanners(scanner_ids)\n\n    def disable_scanners_by_ids(self, scanner_ids):\n        \"\"\"Disable a list of scanner IDs.\"\"\"\n        scanner_ids = ','.join(scanner_ids)\n        self.logger.debug('Disabling scanners with IDs {0}'.format(scanner_ids))\n        return self.zap.ascan.disable_scanners(scanner_ids)\n\n    def enable_scanners_by_group(self, group):\n        \"\"\"\n        Enables the scanners in the group if it matches one in the scanner_group_map.\n        \"\"\"\n        if group == 'all':\n            self.logger.debug('Enabling all scanners')\n            return self.zap.ascan.enable_all_scanners()\n        try:\n            scanner_list = self.scanner_group_map[group]\n        except KeyError:\n            raise ZAPError('Invalid group \"{0}\" provided. Valid groups are: {1}'.format(group, ', '.join(self.scanner_groups)))\n        self.logger.debug('Enabling scanner group {0}'.format(group))\n        return self.enable_scanners_by_ids(scanner_list)\n\n    def disable_scanners_by_group(self, group):\n        \"\"\"\n        Disables the scanners in the group if it matches one in the scanner_group_map.\n        \"\"\"\n        if group == 'all':\n            self.logger.debug('Disabling all scanners')\n            return self.zap.ascan.disable_all_scanners()\n        try:\n            scanner_list = self.scanner_group_map[group]\n        except KeyError:\n            raise ZAPError('Invalid group \"{0}\" provided. Valid groups are: {1}'.format(group, ', '.join(self.scanner_groups)))\n        self.logger.debug('Disabling scanner group {0}'.format(group))\n        return self.disable_scanners_by_ids(scanner_list)\n\n    def enable_scanners(self, scanners):\n        \"\"\"\n        Enable the provided scanners by group and/or IDs.\n        \"\"\"\n        scanner_ids = []\n        for scanner in scanners:\n            if scanner in self.scanner_groups:\n                self.enable_scanners_by_group(scanner)\n            elif scanner.isdigit():\n                scanner_ids.append(scanner)\n            else:\n                raise ZAPError('Invalid scanner \"{0}\" provided. Must be a valid group or numeric ID.'.format(scanner))\n        if scanner_ids:\n            self.enable_scanners_by_ids(scanner_ids)\n\n    def disable_scanners(self, scanners):\n        \"\"\"\n        Enable the provided scanners by group and/or IDs.\n        \"\"\"\n        scanner_ids = []\n        for scanner in scanners:\n            if scanner in self.scanner_groups:\n                self.disable_scanners_by_group(scanner)\n            elif scanner.isdigit():\n                scanner_ids.append(scanner)\n            else:\n                raise ZAPError('Invalid scanner \"{0}\" provided. Must be a valid group or numeric ID.'.format(scanner))\n        if scanner_ids:\n            self.disable_scanners_by_ids(scanner_ids)\n\n    def set_enabled_scanners(self, scanners):\n        \"\"\"\n        Set only the provided scanners by group and/or IDs and disable all others.\n        \"\"\"\n        self.logger.debug('Disabling all current scanners')\n        self.zap.ascan.disable_all_scanners()\n        self.enable_scanners(scanners)\n\n    def set_scanner_attack_strength(self, scanner_ids, attack_strength):\n        \"\"\"Set the attack strength for the given scanners.\"\"\"\n        for scanner_id in scanner_ids:\n            self.logger.debug('Setting strength for scanner {0} to {1}'.format(scanner_id, attack_strength))\n            result = self.zap.ascan.set_scanner_attack_strength(scanner_id, attack_strength)\n            if result != 'OK':\n                raise ZAPError('Error setting strength for scanner with ID {0}: {1}'.format(scanner_id, result))\n\n    def set_scanner_alert_threshold(self, scanner_ids, alert_threshold):\n        \"\"\"Set the alert theshold for the given policies.\"\"\"\n        for scanner_id in scanner_ids:\n            self.logger.debug('Setting alert threshold for scanner {0} to {1}'.format(scanner_id, alert_threshold))\n            result = self.zap.ascan.set_scanner_alert_threshold(scanner_id, alert_threshold)\n            if result != 'OK':\n                raise ZAPError('Error setting alert threshold for scanner with ID {0}: {1}'.format(scanner_id, result))\n\n    def enable_policies_by_ids(self, policy_ids):\n        \"\"\"Set enabled policy from a list of IDs.\"\"\"\n        policy_ids = ','.join(policy_ids)\n        self.logger.debug('Setting enabled policies to IDs {0}'.format(policy_ids))\n        self.zap.ascan.set_enabled_policies(policy_ids)\n\n    def set_policy_attack_strength(self, policy_ids, attack_strength):\n        \"\"\"Set the attack strength for the given policies.\"\"\"\n        for policy_id in policy_ids:\n            self.logger.debug('Setting strength for policy {0} to {1}'.format(policy_id, attack_strength))\n            result = self.zap.ascan.set_policy_attack_strength(policy_id, attack_strength)\n            if result != 'OK':\n                raise ZAPError('Error setting strength for policy with ID {0}: {1}'.format(policy_id, result))\n\n    def set_policy_alert_threshold(self, policy_ids, alert_threshold):\n        \"\"\"Set the alert theshold for the given policies.\"\"\"\n        for policy_id in policy_ids:\n            self.logger.debug('Setting alert threshold for policy {0} to {1}'.format(policy_id, alert_threshold))\n            result = self.zap.ascan.set_policy_alert_threshold(policy_id, alert_threshold)\n            if result != 'OK':\n                raise ZAPError('Error setting alert threshold for policy with ID {0}: {1}'.format(policy_id, result))\n\n    def exclude_from_all(self, exclude_regex):\n        \"\"\"Exclude a pattern from proxy, spider and active scanner.\"\"\"\n        try:\n            re.compile(exclude_regex)\n        except re.error:\n            raise ZAPError('Invalid regex \"{0}\" provided'.format(exclude_regex))\n        self.logger.debug('Excluding {0} from proxy, spider and active scanner.'.format(exclude_regex))\n        self.zap.core.exclude_from_proxy(exclude_regex)\n        self.zap.spider.exclude_from_scan(exclude_regex)\n        self.zap.ascan.exclude_from_scan(exclude_regex)\n\n    def xml_report(self, file_path):\n        \"\"\"Generate and save XML report\"\"\"\n        self.logger.debug('Generating XML report')\n        report = self.zap.core.xmlreport()\n        self._write_report(report, file_path)\n\n    def md_report(self, file_path):\n        \"\"\"Generate and save MD report\"\"\"\n        self.logger.debug('Generating MD report')\n        report = self.zap.core.mdreport()\n        self._write_report(report, file_path)\n\n    def html_report(self, file_path):\n        \"\"\"Generate and save HTML report.\"\"\"\n        self.logger.debug('Generating HTML report')\n        report = self.zap.core.htmlreport()\n        self._write_report(report, file_path)\n\n    @staticmethod\n    def _write_report(report, file_path):\n        \"\"\"Write report to the given file path.\"\"\"\n        with open(file_path, mode='wb') as f:\n            if not isinstance(report, binary_type):\n                report = report.encode('utf-8')\n            f.write(report)\n\n    def get_context_info(self, context_name):\n        \"\"\"Get the context ID for a given context name.\"\"\"\n        context_info = self.zap.context.context(context_name)\n        if not isinstance(context_info, dict):\n            raise ZAPError('Context with name \"{0}\" wasn\\'t found'.format(context_name))\n        return context_info\n\n    def _get_context_and_user_ids(self, context_name, user_name):\n        \"\"\"Helper to get the context ID and user ID from the given names.\"\"\"\n        if context_name is None:\n            return (None, None)\n        context_id = self.get_context_info(context_name)['id']\n        user_id = None\n        if user_name:\n            user_id = self._get_user_id_from_name(context_id, user_name)\n        return (context_id, user_id)\n\n    def _get_user_id_from_name(self, context_id, user_name):\n        \"\"\"Get a user ID from the user name.\"\"\"\n        users = self.zap.users.users_list(context_id)\n        for user in users:\n            if user['name'] == user_name:\n                return user['id']\n        raise ZAPError('No user with the name \"{0}\"\" was found for context {1}'.format(user_name, context_id))\n\nExample skeleton:\n\n\nclass JobInvocationTestCase(TestCase):\n    '''Tests for :class:`nailgun.entities.JobInvocation`.'''\n    @classmethod\n    def setUpClass(cls):\n        '''Set a common ServerConfig.'''\n        pass\n\n    def test_required_param(self):\n        '''Check required parameters.'''\n        pass\n\n    def test_non_sync_run(self):\n        '''Run job asynchronously with valid parameters and check that correct request is sent.'''\n        pass\n\n    def test_sync_run(self):\n        '''Check that sync run will result in ForemanTask poll.'''\n        pass\nCorresponding class implementation:\n\nfrom unittest import TestCase, mock\nfrom nailgun import client, config, entities\n\nclass JobInvocationTestCase(TestCase):\n    \"\"\"Tests for :class:`nailgun.entities.JobInvocation`.\"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        \"\"\"Set a common ServerConfig.\"\"\"\n        cls.cfg = config.ServerConfig('http://example.com')\n\n    def test_required_param(self):\n        \"\"\"Check required parameters.\"\"\"\n        data_list = [{'inputs': 'ls', 'search_query': 'foo'}, {'feature': 'foo', 'inputs': 'ls'}, {'job_template_id': 1, 'search_query': 'foo'}, {'feature': 'foo', 'bookmark_id': 1, 'inputs': 'ls'}, {'feature': 'foo', 'job_template_id': 1, 'targeting_type': 'foo'}]\n        for data in data_list:\n            with self.assertRaises(KeyError):\n                entities.JobInvocation(self.cfg).run(data=data)\n\n    def test_non_sync_run(self):\n        \"\"\"Run job asynchronously with valid parameters and check that correct request is sent.\"\"\"\n        with mock.patch.object(client, 'post') as post:\n            entities.JobInvocation(self.cfg).run(synchronous=False, data={'job_template_id': 1, 'search_query': 'foo', 'inputs': 'ls', 'targeting_type': 'foo'})\n        self.assertEqual(post.call_count, 1)\n        self.assertEqual(len(post.call_args[0]), 1)\n\n    def test_sync_run(self):\n        \"\"\"Check that sync run will result in ForemanTask poll.\"\"\"\n        with mock.patch.object(entities, '_poll_task') as poll_task:\n            with mock.patch.object(client, 'post'):\n                entities.JobInvocation(self.cfg).run(synchronous=True, data={'job_template_id': 1, 'search_query': 'foo', 'inputs': 'ls', 'targeting_type': 'foo'})\n        self.assertEqual(poll_task.call_count, 1)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass STMessages:\n    '''A class to handle Streamlit messages.'''\n\n    def success(self, message: str='Operation completed successfully.'):\n        '''Display a success message.'''\n        pass\n\n    def warning(self, message: str='Holy! the dev forgot to write this warning messsage lol 💀.'):\n        '''Display a warning message.'''\n        pass\n\n    def error(self, message: str='An error occurred.'):\n        '''Display an error message.'''\n        pass\n\n    def skull(self, message: str='💀'):\n        '''Display a skull message.'''\n        pass"
  }
]