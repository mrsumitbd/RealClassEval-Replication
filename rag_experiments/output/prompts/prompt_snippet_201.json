[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass BooleanSetting(Setting):\n    '''Boolean setting.'''\n\n    def __init__(self, name='', default=True, required=False, prefix='', call_default=True, transform_default=False, validators=()):\n        '''\n        Initialization method.\n        Args:\n            name (str): the name of the setting.\n            default (bool): default value given to the setting.\n            required (bool): whether the setting is required or not.\n            prefix (str):\n                the setting's prefix (overrides ``AppSettings.Meta`` prefix).\n            call_default (bool): whether to call the default (if callable).\n            transform_default (bool): whether to transform the default value.\n            validators (list of callables): list of additional validators to use.\n                        '''\n                        pass\n\n    def decode_environ(self, value):\n        '''\n        Return a decoded value.\n        Try to load a valid JSON. If JSONDecodeError is raised, chcecks for other common values (True, False, yes, no,\n        0, 1).\n        Args:\n            value (string):\n        Returns:\n            bool:\n        '''\n        pass\nCorresponding class implementation:\n\nfrom .validators import DictKeysTypeValidator, DictValuesTypeValidator, FileValidator, TypeValidator, ValuesTypeValidator\n\nclass BooleanSetting(Setting):\n    \"\"\"Boolean setting.\"\"\"\n    default_validators = (TypeValidator(bool),)\n\n    def __init__(self, name='', default=True, required=False, prefix='', call_default=True, transform_default=False, validators=()):\n        \"\"\"\n        Initialization method.\n\n        Args:\n            name (str): the name of the setting.\n            default (bool): default value given to the setting.\n            required (bool): whether the setting is required or not.\n            prefix (str):\n                the setting's prefix (overrides ``AppSettings.Meta`` prefix).\n            call_default (bool): whether to call the default (if callable).\n            transform_default (bool): whether to transform the default value.\n            validators (list of callables): list of additional validators to use.\n        \"\"\"\n        super().__init__(name=name, default=default, required=required, prefix=prefix, call_default=call_default, transform_default=transform_default, validators=validators)\n\n    def decode_environ(self, value):\n        \"\"\"\n        Return a decoded value.\n\n        Try to load a valid JSON. If JSONDecodeError is raised, chcecks for other common values (True, False, yes, no,\n        0, 1).\n\n        Args:\n            value (string):\n\n        Returns:\n            bool:\n        \"\"\"\n        if value.lower() in ('true', 'yes', '1'):\n            return True\n        elif value.lower() in ('false', 'no', '0'):\n            return False\n        else:\n            raise ValueError('Invalid boolean setting %s in environ (%s)' % (self.full_name, value))\n\nExample skeleton:\n\n\nclass Type(IntEnum):\n    '''[Type] L2TP Type'''\n    @staticmethod\n    def get(key: 'int | str', default: 'int'=-1) -> 'Type':\n        '''Backport support for original codes.\n        Args:\n            key: Key to get enum item.\n            default: Default value if not found.\n        :meta private:\n                        '''\n                        pass\n    @classmethod\n    def _missing_(cls, value: 'int') -> 'Type':\n        '''Lookup function used when value is not found.\n        Args:\n            value: Value to get enum item.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom aenum import IntEnum, extend_enum\n\nclass Type(IntEnum):\n    \"\"\"[Type] L2TP Type\"\"\"\n    Control = 0\n    Data = 1\n\n    @staticmethod\n    def get(key: 'int | str', default: 'int'=-1) -> 'Type':\n        \"\"\"Backport support for original codes.\n\n        Args:\n            key: Key to get enum item.\n            default: Default value if not found.\n\n        :meta private:\n        \"\"\"\n        if isinstance(key, int):\n            return Type(key)\n        if key not in Type._member_map_:\n            return extend_enum(Type, key, default)\n        return Type[key]\n\n    @classmethod\n    def _missing_(cls, value: 'int') -> 'Type':\n        \"\"\"Lookup function used when value is not found.\n\n        Args:\n            value: Value to get enum item.\n\n        \"\"\"\n        if not (isinstance(value, int) and 0 <= value <= 1):\n            raise ValueError('%r is not a valid %s' % (value, cls.__name__))\n        return extend_enum(cls, 'Unassigned_%d' % value, value)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n@dataclass\nclass OverridableConfig:\n    '''A class that provides an interface to switch between its field values depending on an override key.'''\n\n    def __post_init__(self) -> None:\n        '''Initialize the override key to 'default'.'''\n        pass\n\n    def set_override(self, key: str, reset_to_defaults: bool=True) -> None:\n        '''Set the overridden values for the config based on the override registry.\n        Args:\n            key: The key to use for the override.\n            reset_to_defaults: If True, reset the values to their defaults if no override is found. This is useful for\n                when you switch from different non-default overrides to other non-default overrides.\n        '''\n        pass"
  }
]