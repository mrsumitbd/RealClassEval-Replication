[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass DialogSuggestionValue:\n    '''\n    An object defining the message input to be sent to the assistant if the user selects\n    the corresponding disambiguation option.\n     **Note:** This entire message input object must be included in the request body of\n    the next message sent to the assistant. Do not modify or remove any of the included\n    properties.\n    :param MessageInput input: (optional) An input object that includes the input\n          text.\n    '''\n\n    def __init__(self, *, input: Optional['MessageInput']=None) -> None:\n        '''\n        Initialize a DialogSuggestionValue object.\n        :param MessageInput input: (optional) An input object that includes the\n               input text.\n        '''\n        pass\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'DialogSuggestionValue':\n        '''Initialize a DialogSuggestionValue object from a json dictionary.'''\n        pass\n    @classmethod\n    def _from_dict(cls, _dict):\n        '''Initialize a DialogSuggestionValue object from a json dictionary.'''\n        pass\n\n    def to_dict(self) -> Dict:\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def _to_dict(self):\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Return a `str` version of this DialogSuggestionValue object.'''\n        pass\n\n    def __eq__(self, other: 'DialogSuggestionValue') -> bool:\n        '''Return `true` when self and other are equal, false otherwise.'''\n        pass\n\n    def __ne__(self, other: 'DialogSuggestionValue') -> bool:\n        '''Return `true` when self and other are not equal, false otherwise.'''\n        pass\nCorresponding class implementation:\n\nfrom typing import BinaryIO, Dict, List, Optional\nimport json\n\nclass DialogSuggestionValue:\n    \"\"\"\n    An object defining the message input to be sent to the assistant if the user selects\n    the corresponding disambiguation option.\n     **Note:** This entire message input object must be included in the request body of\n    the next message sent to the assistant. Do not modify or remove any of the included\n    properties.\n\n    :param MessageInput input: (optional) An input object that includes the input\n          text.\n    \"\"\"\n\n    def __init__(self, *, input: Optional['MessageInput']=None) -> None:\n        \"\"\"\n        Initialize a DialogSuggestionValue object.\n\n        :param MessageInput input: (optional) An input object that includes the\n               input text.\n        \"\"\"\n        self.input = input\n\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'DialogSuggestionValue':\n        \"\"\"Initialize a DialogSuggestionValue object from a json dictionary.\"\"\"\n        args = {}\n        if (input := _dict.get('input')) is not None:\n            args['input'] = MessageInput.from_dict(input)\n        return cls(**args)\n\n    @classmethod\n    def _from_dict(cls, _dict):\n        \"\"\"Initialize a DialogSuggestionValue object from a json dictionary.\"\"\"\n        return cls.from_dict(_dict)\n\n    def to_dict(self) -> Dict:\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        _dict = {}\n        if hasattr(self, 'input') and self.input is not None:\n            if isinstance(self.input, dict):\n                _dict['input'] = self.input\n            else:\n                _dict['input'] = self.input.to_dict()\n        return _dict\n\n    def _to_dict(self):\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        return self.to_dict()\n\n    def __str__(self) -> str:\n        \"\"\"Return a `str` version of this DialogSuggestionValue object.\"\"\"\n        return json.dumps(self.to_dict(), indent=2)\n\n    def __eq__(self, other: 'DialogSuggestionValue') -> bool:\n        \"\"\"Return `true` when self and other are equal, false otherwise.\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other: 'DialogSuggestionValue') -> bool:\n        \"\"\"Return `true` when self and other are not equal, false otherwise.\"\"\"\n        return not self == other\n\nExample skeleton:\n\n\nclass ThreadABC(metaclass=abc.ABCMeta):\n    '''Implemented by thread-like classes.\n    This is private to implement.\n    '''\n    @property\n    @abc.abstractmethod\n    def session(self) -> _session.Session:\n        '''The session to use when making requests.'''\n        pass\n    @property\n    @abc.abstractmethod\n    def id(self) -> str:\n        '''The unique identifier of the thread.'''\n        pass\n    @abc.abstractmethod\n    def _to_send_data(self) -> MutableMapping[str, str]:\n        pass\n    @abc.abstractmethod\n    def _copy(self) -> 'ThreadABC':\n        '''It may or may not be a good idea to attach the current thread to new objects.\n        So for now, we use this method to create a new thread.\n        This should return the minimal representation of the thread (e.g. not UserData).\n        '''\n        pass\n\n    def fetch(self):\n        pass\n\n    def wave(self, first: bool=True) -> str:\n        '''Wave hello to the thread.\n        Args:\n            first: Whether to wave first or wave back\n        Example:\n            Wave back to the thread.\n            >>> thread.wave(False)\n        '''\n        pass\n\n    def send_text(self, text: str, mentions: Iterable['_models.Mention']=None, files: Iterable[Tuple[str, str]]=None, reply_to_id: str=None) -> str:\n        '''Send a message to the thread.\n        Args:\n            text: Text to send\n            mentions: Optional mentions\n            files: Optional tuples, each containing an uploaded file's ID and mimetype.\n                See `ThreadABC.send_files` for an example.\n            reply_to_id: Optional message to reply to\n        Example:\n            Send a message with a mention to a thread.\n            >>> mention = fbchat.Mention(thread_id=\"1234\", offset=5, length=2)\n            >>> message_id = thread.send_text(\"A message\", mentions=[mention])\n            Reply to the message.\n            >>> thread.send_text(\"A reply\", reply_to_id=message_id)\n        Returns:\n            The sent message\n        '''\n        pass\n\n    def send_emoji(self, emoji: str, size: '_models.EmojiSize') -> str:\n        '''Send an emoji to the thread.\n        Args:\n            emoji: The emoji to send\n            size: The size of the emoji\n        Example:\n            >>> thread.send_emoji(\"😀\", size=fbchat.EmojiSize.LARGE)\n        Returns:\n            The sent message\n        '''\n        pass\n\n    def send_sticker(self, sticker_id: str) -> str:\n        '''Send a sticker to the thread.\n        Args:\n            sticker_id: ID of the sticker to send\n        Example:\n            Send a sticker with the id \"1889713947839631\"\n            >>> thread.send_sticker(\"1889713947839631\")\n        Returns:\n            The sent message\n        '''\n        pass\n\n    def _send_location(self, current, latitude, longitude):\n        pass\n\n    def send_location(self, latitude: float, longitude: float):\n        '''Send a given location to a thread as the user's current location.\n        Args:\n            latitude: The location latitude\n            longitude: The location longitude\n        Example:\n            Send a location in London, United Kingdom.\n            >>> thread.send_location(51.5287718, -0.2416815)\n        '''\n        pass\n\n    def send_pinned_location(self, latitude: float, longitude: float):\n        '''Send a given location to a thread as a pinned location.\n        Args:\n            latitude: The location latitude\n            longitude: The location longitude\n        Example:\n            Send a pinned location in Beijing, China.\n            >>> thread.send_pinned_location(39.9390731, 116.117273)\n        '''\n        pass\n\n    def send_files(self, files: Iterable[Tuple[str, str]]):\n        '''Send files from file IDs to a thread.\n        `files` should be a list of tuples, with a file's ID and mimetype.\n        Example:\n            Upload and send a video to a thread.\n            >>> with open(\"video.mp4\", \"rb\") as f:\n            ...     files = client.upload([(\"video.mp4\", f, \"video/mp4\")])\n            >>>\n            >>> thread.send_files(files)\n        '''\n        pass\n\n    def _search_messages(self, query, offset, limit):\n        pass\n\n    def search_messages(self, query: str, limit: int) -> Iterable[_models.MessageSnippet]:\n        '''Find and get message IDs by query.\n        Warning! If someone send a message to the thread that matches the query, while\n        we're searching, some snippets will get returned twice.\n        This is fundamentally not fixable, it's just how the endpoint is implemented.\n        The returned message snippets are ordered by last sent first.\n        Args:\n            query: Text to search for\n            limit: Max. number of message snippets to retrieve\n        Example:\n            Fetch the latest message in the thread that matches the query.\n            >>> (message,) = thread.search_messages(\"abc\", limit=1)\n            >>> message.text\n            \"Some text and abc\"\n        '''\n        pass\n\n    def _fetch_messages(self, limit, before):\n        pass\n\n    def fetch_messages(self, limit: Optional[int]) -> Iterable['_models.Message']:\n        '''Fetch messages in a thread.\n        The returned messages are ordered by last sent first.\n        Args:\n            limit: Max. number of threads to retrieve. If ``None``, all threads will be\n                retrieved.\n        Example:\n            >>> for message in thread.fetch_messages(limit=5)\n            ...     print(message.text)\n            ...\n            A message\n            Another message\n            None\n            A fourth message\n        '''\n        pass\n\n    def _fetch_images(self, limit, after):\n        pass\n\n    def fetch_images(self, limit: Optional[int]) -> Iterable['_models.Attachment']:\n        '''Fetch images/videos posted in the thread.\n        The returned images are ordered by last sent first.\n        Args:\n            limit: Max. number of images to retrieve. If ``None``, all images will be\n                retrieved.\n        Example:\n            >>> for image in thread.fetch_messages(limit=3)\n            ...     print(image.id)\n            ...\n            1234\n            2345\n        '''\n        pass\n\n    def set_nickname(self, user_id: str, nickname: str):\n        '''Change the nickname of a user in the thread.\n        Args:\n            user_id: User that will have their nickname changed\n            nickname: New nickname\n        Example:\n            >>> thread.set_nickname(\"1234\", \"A nickname\")\n        '''\n        pass\n\n    def set_color(self, color: str):\n        '''Change thread color.\n        The new color must be one of the following::\n            \"#0084ff\", \"#44bec7\", \"#ffc300\", \"#fa3c4c\", \"#d696bb\", \"#6699cc\",\n            \"#13cf13\", \"#ff7e29\", \"#e68585\", \"#7646ff\", \"#20cef5\", \"#67b868\",\n            \"#d4a88c\", \"#ff5ca1\", \"#a695c7\", \"#ff7ca8\", \"#1adb5b\", \"#f01d6a\",\n            \"#ff9c19\" or \"#0edcde\".\n        This list is subject to change in the future!\n        The default when creating a new thread is ``\"#0084ff\"``.\n        Args:\n            color: New thread color\n        Example:\n            Set the thread color to \"Coral Pink\".\n            >>> thread.set_color(\"#e68585\")\n        '''\n        pass\n\n    def set_emoji(self, emoji: Optional[str]):\n        '''Change thread emoji.\n        Args:\n            emoji: New thread emoji. If ``None``, will be set to the default \"LIKE\" icon\n        Example:\n            Set the thread emoji to \"😊\".\n            >>> thread.set_emoji(\"😊\")\n        '''\n        pass\n\n    def forward_attachment(self, attachment_id: str):\n        '''Forward an attachment.\n        Args:\n            attachment_id: Attachment ID to forward\n        Example:\n            >>> thread.forward_attachment(\"1234\")\n        '''\n        pass\n\n    def _set_typing(self, typing):\n        pass\n\n    def start_typing(self):\n        '''Set the current user to start typing in the thread.\n        Example:\n            >>> thread.start_typing()\n        '''\n        pass\n\n    def stop_typing(self):\n        '''Set the current user to stop typing in the thread.\n        Example:\n            >>> thread.stop_typing()\n        '''\n        pass\n\n    def create_plan(self, name: str, at: datetime.datetime, location_name: str=None, location_id: str=None):\n        '''Create a new plan.\n        # TODO: Arguments\n        Args:\n            name: Name of the new plan\n            at: When the plan is for\n        Example:\n            >>> thread.create_plan(...)\n        '''\n        pass\n\n    def create_poll(self, question: str, options: Mapping[str, bool]):\n        '''Create poll in a thread.\n        Args:\n            question: The question\n            options: Options and whether you want to select the option\n        Example:\n            >>> thread.create_poll(\"Test poll\", {\"Option 1\": True, \"Option 2\": False})\n        '''\n        pass\n\n    def mute(self, duration: datetime.timedelta=None):\n        '''Mute the thread.\n        Args:\n            duration: Time to mute, use ``None`` to mute forever\n        Example:\n            >>> import datetime\n            >>> thread.mute(datetime.timedelta(days=2))\n        '''\n        pass\n\n    def unmute(self):\n        '''Unmute the thread.\n        Example:\n            >>> thread.unmute()\n        '''\n        pass\n\n    def _mute_reactions(self, mode: bool):\n        pass\n\n    def mute_reactions(self):\n        '''Mute thread reactions.'''\n        pass\n\n    def unmute_reactions(self):\n        '''Unmute thread reactions.'''\n        pass\n\n    def _mute_mentions(self, mode: bool):\n        pass\n\n    def mute_mentions(self):\n        '''Mute thread mentions.'''\n        pass\n\n    def unmute_mentions(self):\n        '''Unmute thread mentions.'''\n        pass\n\n    def mark_as_spam(self):\n        '''Mark the thread as spam, and delete it.'''\n        pass\n    @staticmethod\n    def _delete_many(session, thread_ids):\n        pass\n\n    def delete(self):\n        '''Delete the thread.\n        If you want to delete multiple threads, please use `Client.delete_threads`.\n        Example:\n            >>> message.delete()\n        '''\n        pass\n\n    def _forced_fetch(self, message_id: str) -> dict:\n        pass\n    @staticmethod\n    def _parse_color(inp: Optional[str]) -> str:\n        pass\n    @staticmethod\n    def _parse_customization_info(data: Any) -> MutableMapping[str, Any]:\n        pass\n    @staticmethod\n    def _parse_participants(session, data) -> Iterable['ThreadABC']:\n        pass\nCorresponding class implementation:\n\nimport abc\nimport datetime\nimport collections\nfrom .. import _util, _exception, _session, _graphql, _models\nfrom typing import MutableMapping, Mapping, Any, Iterable, Tuple, Optional\nfrom .._common import log, attrs_default\n\nclass ThreadABC(metaclass=abc.ABCMeta):\n    \"\"\"Implemented by thread-like classes.\n\n    This is private to implement.\n    \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def session(self) -> _session.Session:\n        \"\"\"The session to use when making requests.\"\"\"\n        raise NotImplementedError\n\n    @property\n    @abc.abstractmethod\n    def id(self) -> str:\n        \"\"\"The unique identifier of the thread.\"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def _to_send_data(self) -> MutableMapping[str, str]:\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def _copy(self) -> 'ThreadABC':\n        \"\"\"It may or may not be a good idea to attach the current thread to new objects.\n\n        So for now, we use this method to create a new thread.\n\n        This should return the minimal representation of the thread (e.g. not UserData).\n        \"\"\"\n        raise NotImplementedError\n\n    def fetch(self):\n        raise NotImplementedError\n\n    def wave(self, first: bool=True) -> str:\n        \"\"\"Wave hello to the thread.\n\n        Args:\n            first: Whether to wave first or wave back\n\n        Example:\n            Wave back to the thread.\n\n            >>> thread.wave(False)\n        \"\"\"\n        data = self._to_send_data()\n        data['action_type'] = 'ma-type:user-generated-message'\n        data['lightweight_action_attachment[lwa_state]'] = 'INITIATED' if first else 'RECIPROCATED'\n        data['lightweight_action_attachment[lwa_type]'] = 'WAVE'\n        message_id, thread_id = self.session._do_send_request(data)\n        return message_id\n\n    def send_text(self, text: str, mentions: Iterable['_models.Mention']=None, files: Iterable[Tuple[str, str]]=None, reply_to_id: str=None) -> str:\n        \"\"\"Send a message to the thread.\n\n        Args:\n            text: Text to send\n            mentions: Optional mentions\n            files: Optional tuples, each containing an uploaded file's ID and mimetype.\n                See `ThreadABC.send_files` for an example.\n            reply_to_id: Optional message to reply to\n\n        Example:\n            Send a message with a mention to a thread.\n\n            >>> mention = fbchat.Mention(thread_id=\"1234\", offset=5, length=2)\n            >>> message_id = thread.send_text(\"A message\", mentions=[mention])\n\n            Reply to the message.\n\n            >>> thread.send_text(\"A reply\", reply_to_id=message_id)\n\n        Returns:\n            The sent message\n        \"\"\"\n        data = self._to_send_data()\n        data['action_type'] = 'ma-type:user-generated-message'\n        if text is not None:\n            data['body'] = text\n        for i, mention in enumerate(mentions or ()):\n            data.update(mention._to_send_data(i))\n        if files:\n            data['has_attachment'] = True\n        for i, (file_id, mimetype) in enumerate(files or ()):\n            data['{}s[{}]'.format(_util.mimetype_to_key(mimetype), i)] = file_id\n        if reply_to_id:\n            data['replied_to_message_id'] = reply_to_id\n        return self.session._do_send_request(data)\n\n    def send_emoji(self, emoji: str, size: '_models.EmojiSize') -> str:\n        \"\"\"Send an emoji to the thread.\n\n        Args:\n            emoji: The emoji to send\n            size: The size of the emoji\n\n        Example:\n            >>> thread.send_emoji(\"😀\", size=fbchat.EmojiSize.LARGE)\n\n        Returns:\n            The sent message\n        \"\"\"\n        data = self._to_send_data()\n        data['action_type'] = 'ma-type:user-generated-message'\n        data['body'] = emoji\n        data['tags[0]'] = 'hot_emoji_size:{}'.format(size.name.lower())\n        return self.session._do_send_request(data)\n\n    def send_sticker(self, sticker_id: str) -> str:\n        \"\"\"Send a sticker to the thread.\n\n        Args:\n            sticker_id: ID of the sticker to send\n\n        Example:\n            Send a sticker with the id \"1889713947839631\"\n\n            >>> thread.send_sticker(\"1889713947839631\")\n\n        Returns:\n            The sent message\n        \"\"\"\n        data = self._to_send_data()\n        data['action_type'] = 'ma-type:user-generated-message'\n        data['sticker_id'] = sticker_id\n        return self.session._do_send_request(data)\n\n    def _send_location(self, current, latitude, longitude):\n        data = self._to_send_data()\n        data['action_type'] = 'ma-type:user-generated-message'\n        data['location_attachment[coordinates][latitude]'] = latitude\n        data['location_attachment[coordinates][longitude]'] = longitude\n        data['location_attachment[is_current_location]'] = current\n        return self.session._do_send_request(data)\n\n    def send_location(self, latitude: float, longitude: float):\n        \"\"\"Send a given location to a thread as the user's current location.\n\n        Args:\n            latitude: The location latitude\n            longitude: The location longitude\n\n        Example:\n            Send a location in London, United Kingdom.\n\n            >>> thread.send_location(51.5287718, -0.2416815)\n        \"\"\"\n        self._send_location(True, latitude=latitude, longitude=longitude)\n\n    def send_pinned_location(self, latitude: float, longitude: float):\n        \"\"\"Send a given location to a thread as a pinned location.\n\n        Args:\n            latitude: The location latitude\n            longitude: The location longitude\n\n        Example:\n            Send a pinned location in Beijing, China.\n\n            >>> thread.send_pinned_location(39.9390731, 116.117273)\n        \"\"\"\n        self._send_location(False, latitude=latitude, longitude=longitude)\n\n    def send_files(self, files: Iterable[Tuple[str, str]]):\n        \"\"\"Send files from file IDs to a thread.\n\n        `files` should be a list of tuples, with a file's ID and mimetype.\n\n        Example:\n            Upload and send a video to a thread.\n\n            >>> with open(\"video.mp4\", \"rb\") as f:\n            ...     files = client.upload([(\"video.mp4\", f, \"video/mp4\")])\n            >>>\n            >>> thread.send_files(files)\n        \"\"\"\n        return self.send_text(text=None, files=files)\n\n    def _search_messages(self, query, offset, limit):\n        data = {'query': query, 'snippetOffset': offset, 'snippetLimit': limit, 'identifier': 'thread_fbid', 'thread_fbid': self.id}\n        j = self.session._payload_post('/ajax/mercury/search_snippets.php?dpr=1', data)\n        result = j['search_snippets'][query].get(self.id)\n        if not result:\n            return (0, [])\n        thread = self._copy()\n        snippets = [_models.MessageSnippet._parse(thread, snippet) for snippet in result['snippets']]\n        return (result['num_total_snippets'], snippets)\n\n    def search_messages(self, query: str, limit: int) -> Iterable[_models.MessageSnippet]:\n        \"\"\"Find and get message IDs by query.\n\n        Warning! If someone send a message to the thread that matches the query, while\n        we're searching, some snippets will get returned twice.\n\n        This is fundamentally not fixable, it's just how the endpoint is implemented.\n\n        The returned message snippets are ordered by last sent first.\n\n        Args:\n            query: Text to search for\n            limit: Max. number of message snippets to retrieve\n\n        Example:\n            Fetch the latest message in the thread that matches the query.\n\n            >>> (message,) = thread.search_messages(\"abc\", limit=1)\n            >>> message.text\n            \"Some text and abc\"\n        \"\"\"\n        offset = 0\n        for limit in _util.get_limits(limit, max_limit=50):\n            _, snippets = self._search_messages(query, offset, limit)\n            yield from snippets\n            if len(snippets) < limit:\n                return\n            offset += limit\n\n    def _fetch_messages(self, limit, before):\n        params = {'id': self.id, 'message_limit': limit, 'load_messages': True, 'load_read_receipts': True, 'before': _util.datetime_to_millis(before) if before else None}\n        j, = self.session._graphql_requests(_graphql.from_doc_id('1860982147341344', params))\n        if j.get('message_thread') is None:\n            raise _exception.ParseError('Could not fetch messages', data=j)\n        read_receipts = j['message_thread']['read_receipts']['nodes']\n        thread = self._copy()\n        return [_models.MessageData._from_graphql(thread, message, read_receipts) for message in j['message_thread']['messages']['nodes']]\n\n    def fetch_messages(self, limit: Optional[int]) -> Iterable['_models.Message']:\n        \"\"\"Fetch messages in a thread.\n\n        The returned messages are ordered by last sent first.\n\n        Args:\n            limit: Max. number of threads to retrieve. If ``None``, all threads will be\n                retrieved.\n\n        Example:\n            >>> for message in thread.fetch_messages(limit=5)\n            ...     print(message.text)\n            ...\n            A message\n            Another message\n            None\n            A fourth message\n        \"\"\"\n        MAX_BATCH_LIMIT = 100\n        before = None\n        for limit in _util.get_limits(limit, MAX_BATCH_LIMIT):\n            messages = self._fetch_messages(limit, before)\n            messages.reverse()\n            if before:\n                yield from messages[1:]\n            else:\n                yield from messages\n            if len(messages) < MAX_BATCH_LIMIT:\n                return\n            before = messages[-1].created_at\n\n    def _fetch_images(self, limit, after):\n        data = {'id': self.id, 'first': limit, 'after': after}\n        j, = self.session._graphql_requests(_graphql.from_query_id('515216185516880', data))\n        if not j[self.id]:\n            raise _exception.ParseError('Could not find images', data=j)\n        result = j[self.id]['message_shared_media']\n        rtn = []\n        for edge in result['edges']:\n            node = edge['node']\n            type_ = node['__typename']\n            if type_ == 'MessageImage':\n                rtn.append(_models.ImageAttachment._from_list(node))\n            elif type_ == 'MessageVideo':\n                rtn.append(_models.VideoAttachment._from_list(node))\n            else:\n                log.warning('Unknown image type %s, data: %s', type_, edge)\n                rtn.append(None)\n        return (result['page_info']['end_cursor'], rtn)\n\n    def fetch_images(self, limit: Optional[int]) -> Iterable['_models.Attachment']:\n        \"\"\"Fetch images/videos posted in the thread.\n\n        The returned images are ordered by last sent first.\n\n        Args:\n            limit: Max. number of images to retrieve. If ``None``, all images will be\n                retrieved.\n\n        Example:\n            >>> for image in thread.fetch_messages(limit=3)\n            ...     print(image.id)\n            ...\n            1234\n            2345\n        \"\"\"\n        cursor = None\n        for limit in _util.get_limits(limit, max_limit=1000):\n            cursor, images = self._fetch_images(limit, cursor)\n            if not images:\n                return\n            for image in images:\n                if image:\n                    yield image\n\n    def set_nickname(self, user_id: str, nickname: str):\n        \"\"\"Change the nickname of a user in the thread.\n\n        Args:\n            user_id: User that will have their nickname changed\n            nickname: New nickname\n\n        Example:\n            >>> thread.set_nickname(\"1234\", \"A nickname\")\n        \"\"\"\n        data = {'nickname': nickname, 'participant_id': user_id, 'thread_or_other_fbid': self.id}\n        j = self.session._payload_post('/messaging/save_thread_nickname/?source=thread_settings&dpr=1', data)\n\n    def set_color(self, color: str):\n        \"\"\"Change thread color.\n\n        The new color must be one of the following::\n\n            \"#0084ff\", \"#44bec7\", \"#ffc300\", \"#fa3c4c\", \"#d696bb\", \"#6699cc\",\n            \"#13cf13\", \"#ff7e29\", \"#e68585\", \"#7646ff\", \"#20cef5\", \"#67b868\",\n            \"#d4a88c\", \"#ff5ca1\", \"#a695c7\", \"#ff7ca8\", \"#1adb5b\", \"#f01d6a\",\n            \"#ff9c19\" or \"#0edcde\".\n\n        This list is subject to change in the future!\n\n        The default when creating a new thread is ``\"#0084ff\"``.\n\n        Args:\n            color: New thread color\n\n        Example:\n            Set the thread color to \"Coral Pink\".\n\n            >>> thread.set_color(\"#e68585\")\n        \"\"\"\n        if color not in SETABLE_COLORS:\n            raise ValueError('Invalid color! Please use one of: {}'.format(SETABLE_COLORS))\n        if color == DEFAULT_COLOR:\n            color = ''\n        data = {'color_choice': color, 'thread_or_other_fbid': self.id}\n        j = self.session._payload_post('/messaging/save_thread_color/?source=thread_settings&dpr=1', data)\n\n    def set_emoji(self, emoji: Optional[str]):\n        \"\"\"Change thread emoji.\n\n        Args:\n            emoji: New thread emoji. If ``None``, will be set to the default \"LIKE\" icon\n\n        Example:\n            Set the thread emoji to \"😊\".\n\n            >>> thread.set_emoji(\"😊\")\n        \"\"\"\n        data = {'emoji_choice': emoji, 'thread_or_other_fbid': self.id}\n        j = self.session._payload_post('/messaging/save_thread_emoji/?source=thread_settings&dpr=1', data)\n\n    def forward_attachment(self, attachment_id: str):\n        \"\"\"Forward an attachment.\n\n        Args:\n            attachment_id: Attachment ID to forward\n\n        Example:\n            >>> thread.forward_attachment(\"1234\")\n        \"\"\"\n        data = {'attachment_id': attachment_id, 'recipient_map[{}]'.format(_util.generate_offline_threading_id()): self.id}\n        j = self.session._payload_post('/mercury/attachments/forward/', data)\n        if not j.get('success'):\n            raise _exception.ExternalError('Failed forwarding attachment', j['error'])\n\n    def _set_typing(self, typing):\n        data = {'typ': '1' if typing else '0', 'thread': self.id, 'source': 'mercury-chat'}\n        j = self.session._payload_post('/ajax/messaging/typ.php', data)\n\n    def start_typing(self):\n        \"\"\"Set the current user to start typing in the thread.\n\n        Example:\n            >>> thread.start_typing()\n        \"\"\"\n        self._set_typing(True)\n\n    def stop_typing(self):\n        \"\"\"Set the current user to stop typing in the thread.\n\n        Example:\n            >>> thread.stop_typing()\n        \"\"\"\n        self._set_typing(False)\n\n    def create_plan(self, name: str, at: datetime.datetime, location_name: str=None, location_id: str=None):\n        \"\"\"Create a new plan.\n\n        # TODO: Arguments\n\n        Args:\n            name: Name of the new plan\n            at: When the plan is for\n\n        Example:\n            >>> thread.create_plan(...)\n        \"\"\"\n        return _models.Plan._create(self, name, at, location_name, location_id)\n\n    def create_poll(self, question: str, options: Mapping[str, bool]):\n        \"\"\"Create poll in a thread.\n\n        Args:\n            question: The question\n            options: Options and whether you want to select the option\n\n        Example:\n            >>> thread.create_poll(\"Test poll\", {\"Option 1\": True, \"Option 2\": False})\n        \"\"\"\n        data = collections.OrderedDict([('question_text', question), ('target_id', self.id)])\n        for i, (text, vote) in enumerate(options.items()):\n            data['option_text_array[{}]'.format(i)] = text\n            data['option_is_selected_array[{}]'.format(i)] = '1' if vote else '0'\n        j = self.session._payload_post('/messaging/group_polling/create_poll/?dpr=1', data)\n        if j.get('status') != 'success':\n            raise _exception.ExternalError('Failed creating poll: {}'.format(j.get('errorTitle')), j.get('errorMessage'))\n\n    def mute(self, duration: datetime.timedelta=None):\n        \"\"\"Mute the thread.\n\n        Args:\n            duration: Time to mute, use ``None`` to mute forever\n\n        Example:\n            >>> import datetime\n            >>> thread.mute(datetime.timedelta(days=2))\n        \"\"\"\n        if duration is None:\n            setting = '-1'\n        else:\n            setting = str(_util.timedelta_to_seconds(duration))\n        data = {'mute_settings': setting, 'thread_fbid': self.id}\n        j = self.session._payload_post('/ajax/mercury/change_mute_thread.php?dpr=1', data)\n\n    def unmute(self):\n        \"\"\"Unmute the thread.\n\n        Example:\n            >>> thread.unmute()\n        \"\"\"\n        return self.mute(datetime.timedelta(0))\n\n    def _mute_reactions(self, mode: bool):\n        data = {'reactions_mute_mode': '1' if mode else '0', 'thread_fbid': self.id}\n        j = self.session._payload_post('/ajax/mercury/change_reactions_mute_thread/?dpr=1', data)\n\n    def mute_reactions(self):\n        \"\"\"Mute thread reactions.\"\"\"\n        self._mute_reactions(True)\n\n    def unmute_reactions(self):\n        \"\"\"Unmute thread reactions.\"\"\"\n        self._mute_reactions(False)\n\n    def _mute_mentions(self, mode: bool):\n        data = {'mentions_mute_mode': '1' if mode else '0', 'thread_fbid': self.id}\n        j = self.session._payload_post('/ajax/mercury/change_mentions_mute_thread/?dpr=1', data)\n\n    def mute_mentions(self):\n        \"\"\"Mute thread mentions.\"\"\"\n        self._mute_mentions(True)\n\n    def unmute_mentions(self):\n        \"\"\"Unmute thread mentions.\"\"\"\n        self._mute_mentions(False)\n\n    def mark_as_spam(self):\n        \"\"\"Mark the thread as spam, and delete it.\"\"\"\n        data = {'id': self.id}\n        j = self.session._payload_post('/ajax/mercury/mark_spam.php?dpr=1', data)\n\n    @staticmethod\n    def _delete_many(session, thread_ids):\n        data = {}\n        for i, id_ in enumerate(thread_ids):\n            data['ids[{}]'.format(i)] = id_\n        j = session._payload_post('/ajax/mercury/delete_thread.php', data)\n\n    def delete(self):\n        \"\"\"Delete the thread.\n\n        If you want to delete multiple threads, please use `Client.delete_threads`.\n\n        Example:\n            >>> message.delete()\n        \"\"\"\n        self._delete_many(self.session, [self.id])\n\n    def _forced_fetch(self, message_id: str) -> dict:\n        params = {'thread_and_message_id': {'thread_id': self.id, 'message_id': message_id}}\n        j, = self.session._graphql_requests(_graphql.from_doc_id('1768656253222505', params))\n        return j\n\n    @staticmethod\n    def _parse_color(inp: Optional[str]) -> str:\n        if not inp:\n            return DEFAULT_COLOR\n        return '#{}'.format(inp[2:].lower())\n\n    @staticmethod\n    def _parse_customization_info(data: Any) -> MutableMapping[str, Any]:\n        if not data or not data.get('customization_info'):\n            return {'emoji': None, 'color': DEFAULT_COLOR}\n        info = data['customization_info']\n        rtn = {'emoji': info.get('emoji'), 'color': ThreadABC._parse_color(info.get('outgoing_bubble_color'))}\n        if data.get('thread_type') == 'GROUP' or data.get('is_group_thread') or data.get('thread_key', {}).get('thread_fbid'):\n            rtn['nicknames'] = {}\n            for k in info.get('participant_customizations', []):\n                rtn['nicknames'][k['participant_id']] = k.get('nickname')\n        elif info.get('participant_customizations'):\n            user_id = data.get('thread_key', {}).get('other_user_id') or data.get('id')\n            pc = info['participant_customizations']\n            if len(pc) > 0:\n                if pc[0].get('participant_id') == user_id:\n                    rtn['nickname'] = pc[0].get('nickname')\n                else:\n                    rtn['own_nickname'] = pc[0].get('nickname')\n            if len(pc) > 1:\n                if pc[1].get('participant_id') == user_id:\n                    rtn['nickname'] = pc[1].get('nickname')\n                else:\n                    rtn['own_nickname'] = pc[1].get('nickname')\n        return rtn\n\n    @staticmethod\n    def _parse_participants(session, data) -> Iterable['ThreadABC']:\n        from . import _user, _group, _page\n        for node in data['nodes']:\n            actor = node['messaging_actor']\n            typename = actor['__typename']\n            thread_id = actor['id']\n            if typename == 'User':\n                yield _user.User(session=session, id=thread_id)\n            elif typename == 'MessageThread':\n                yield _group.Group(session=session, id=thread_id)\n            elif typename == 'Page':\n                yield _page.Page(session=session, id=thread_id)\n            elif typename == 'Group':\n                pass\n            else:\n                log.warning('Unknown type %r in %s', typename, data)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass MessageBuilder:\n    '''增强的消息构建器'''\n    @staticmethod\n    def build_text_message(content: str) -> Dict[str, Any]:\n        '''构建文本消息'''\n        pass\n    @staticmethod\n    def build_markdown_message(content: str, markdown: Dict[str, Any]) -> Dict[str, Any]:\n        '''构建Markdown消息'''\n        pass\n    @staticmethod\n    def build_image_message(url: str) -> Dict[str, Any]:\n        '''构建图片消息'''\n        pass\n    @staticmethod\n    def build_file_message(file_info: Dict[str, Any]) -> Dict[str, Any]:\n        '''构建文件消息'''\n        pass\n    @staticmethod\n    def build_keyboard_message(content: str, keyboard: Dict[str, Any]) -> Dict[str, Any]:\n        '''构建带按钮的消息'''\n        pass\n    @staticmethod\n    def build_ark_message(ark: Dict[str, Any]) -> Dict[str, Any]:\n        '''构建ARK消息'''\n        pass"
  }
]