[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass TRCWriter(TextIOMessageWriter):\n    '''Logs CAN data to text file (.trc).\n    The measurement starts with the timestamp of the first registered message.\n    If a message has a timestamp smaller than the previous one or None,\n    it gets assigned the timestamp that was written for the last message.\n    If the first message does not have a timestamp, it is set to zero.\n    '''\n\n    def __init__(self, file: Union[StringPathLike, TextIO, TextIOWrapper], channel: int=1, **kwargs: Any) -> None:\n        '''\n        :param file: a path-like object or as file-like object to write to\n                     If this is a file-like object, is has to opened in text\n                     write mode, not binary write mode.\n        :param channel: a default channel to use when the message does not\n                        have a channel set\n        '''\n        pass\n\n    def _write_header_v1_0(self, start_time: datetime) -> None:\n        pass\n\n    def _write_header_v2_1(self, start_time: datetime) -> None:\n        pass\n\n    def _format_message_by_format(self, msg: Message, channel: int) -> str:\n        pass\n\n    def _format_message_init(self, msg: Message, channel: int) -> str:\n        pass\n\n    def write_header(self, timestamp: float) -> None:\n        pass\n\n    def log_event(self, message: str, timestamp: float) -> None:\n        pass\n\n    def on_message_received(self, msg: Message) -> None:\n        pass\nCorresponding class implementation:\n\nfrom ..message import Message\nfrom typing import Any, Callable, Optional, TextIO, Union\nfrom ..typechecking import StringPathLike\nfrom io import TextIOWrapper\nfrom datetime import datetime, timedelta, timezone\nfrom ..util import channel2int, len2dlc\nimport os\nfrom .generic import TextIOMessageReader, TextIOMessageWriter\n\nclass TRCWriter(TextIOMessageWriter):\n    \"\"\"Logs CAN data to text file (.trc).\n\n    The measurement starts with the timestamp of the first registered message.\n    If a message has a timestamp smaller than the previous one or None,\n    it gets assigned the timestamp that was written for the last message.\n    If the first message does not have a timestamp, it is set to zero.\n    \"\"\"\n    FORMAT_MESSAGE = '{msgnr:>7} {time:13.3f} DT {channel:>2} {id:>8} {dir:>2} -  {dlc:<4} {data}'\n    FORMAT_MESSAGE_V1_0 = '{msgnr:>6}) {time:7.0f} {id:>8} {dlc:<1} {data}'\n\n    def __init__(self, file: Union[StringPathLike, TextIO, TextIOWrapper], channel: int=1, **kwargs: Any) -> None:\n        \"\"\"\n        :param file: a path-like object or as file-like object to write to\n                     If this is a file-like object, is has to opened in text\n                     write mode, not binary write mode.\n        :param channel: a default channel to use when the message does not\n                        have a channel set\n        \"\"\"\n        super().__init__(file, mode='w')\n        self.channel = channel\n        if hasattr(self.file, 'reconfigure'):\n            self.file.reconfigure(newline='\\r\\n')\n        else:\n            raise TypeError('File must be opened in text mode.')\n        self.filepath = os.path.abspath(self.file.name)\n        self.header_written = False\n        self.msgnr = 0\n        self.first_timestamp: Optional[float] = None\n        self.file_version = TRCFileVersion.V2_1\n        self._msg_fmt_string = self.FORMAT_MESSAGE_V1_0\n        self._format_message = self._format_message_init\n\n    def _write_header_v1_0(self, start_time: datetime) -> None:\n        lines = [';##########################################################################', f';   {self.filepath}', ';', ';    Generated by python-can TRCWriter', f';    Start time: {start_time}', ';    PCAN-Net: N/A', ';', ';    Columns description:', ';    ~~~~~~~~~~~~~~~~~~~~~', ';    +-current number in actual sample', ';    |     +time offset of message (ms', ';    |     |        +ID of message (hex', ';    |     |        |    +data length code', ';    |     |        |    |  +data bytes (hex ...', ';    |     |        |    |  |', ';----+- ---+--- ----+--- + -+ -- -- ...']\n        self.file.writelines((line + '\\n' for line in lines))\n\n    def _write_header_v2_1(self, start_time: datetime) -> None:\n        header_time = start_time - datetime(year=1899, month=12, day=30, tzinfo=timezone.utc)\n        lines = [';$FILEVERSION=2.1', f';$STARTTIME={header_time / timedelta(days=1)}', ';$COLUMNS=N,O,T,B,I,d,R,L,D', ';', f';   {self.filepath}', ';', f';   Start time: {start_time}', ';   Generated by python-can TRCWriter', ';-------------------------------------------------------------------------------', ';   Bus   Name            Connection               Protocol', ';   N/A   N/A             N/A                      N/A', ';-------------------------------------------------------------------------------', ';   Message   Time    Type    ID     Rx/Tx', ';   Number    Offset  |  Bus  [hex]  |  Reserved', ';   |         [ms]    |  |    |      |  |  Data Length Code', ';   |         |       |  |    |      |  |  |    Data [hex] ...', ';   |         |       |  |    |      |  |  |    |', ';---+-- ------+------ +- +- --+----- +- +- +--- +- -- -- -- -- -- -- --']\n        self.file.writelines((line + '\\n' for line in lines))\n\n    def _format_message_by_format(self, msg: Message, channel: int) -> str:\n        if msg.is_extended_id:\n            arb_id = f'{msg.arbitration_id:07X}'\n        else:\n            arb_id = f'{msg.arbitration_id:04X}'\n        data = [f'{byte:02X}' for byte in msg.data]\n        if self.first_timestamp is None:\n            raise ValueError\n        serialized = self._msg_fmt_string.format(msgnr=self.msgnr, time=(msg.timestamp - self.first_timestamp) * 1000, channel=channel, id=arb_id, dir='Rx' if msg.is_rx else 'Tx', dlc=msg.dlc, data=' '.join(data))\n        return serialized\n\n    def _format_message_init(self, msg: Message, channel: int) -> str:\n        if self.file_version == TRCFileVersion.V1_0:\n            self._format_message = self._format_message_by_format\n            self._msg_fmt_string = self.FORMAT_MESSAGE_V1_0\n        elif self.file_version == TRCFileVersion.V2_1:\n            self._format_message = self._format_message_by_format\n            self._msg_fmt_string = self.FORMAT_MESSAGE\n        else:\n            raise NotImplementedError('File format is not supported')\n        return self._format_message_by_format(msg, channel)\n\n    def write_header(self, timestamp: float) -> None:\n        start_time = datetime.fromtimestamp(timestamp, timezone.utc)\n        if self.file_version == TRCFileVersion.V1_0:\n            self._write_header_v1_0(start_time)\n        elif self.file_version == TRCFileVersion.V2_1:\n            self._write_header_v2_1(start_time)\n        else:\n            raise NotImplementedError('File format is not supported')\n        self.header_written = True\n\n    def log_event(self, message: str, timestamp: float) -> None:\n        if not self.header_written:\n            self.write_header(timestamp)\n        self.file.write(message + '\\n')\n\n    def on_message_received(self, msg: Message) -> None:\n        if self.first_timestamp is None:\n            self.first_timestamp = msg.timestamp\n        if msg.is_error_frame:\n            logger.warning('TRCWriter: Logging error frames is not implemented')\n            return\n        if msg.is_remote_frame:\n            logger.warning('TRCWriter: Logging remote frames is not implemented')\n            return\n        channel = channel2int(msg.channel)\n        if channel is None:\n            channel = self.channel\n        else:\n            channel += 1\n        if msg.is_fd:\n            logger.warning('TRCWriter: Logging CAN FD is not implemented')\n            return\n        serialized = self._format_message(msg, channel)\n        self.msgnr += 1\n        self.log_event(serialized, msg.timestamp)\n\nExample skeleton:\n\n\nclass LogFile(File):\n    '''\n    A log file to configure with Python's logging module.\n    '''\n\n    def __init__(self, path=None, logger=None, loggers=[], formatter={}, format=None, *args, **kwargs):\n        pass\n\n    def prepare(self):\n        '''\n        Configure the log file.\n        '''\n        pass\n\n    def configure(self):\n        '''\n        Configure the Python logging module for this file.\n        '''\n        pass\nCorresponding class implementation:\n\nimport logging.config\nimport logging\nfrom six import string_types\n\nclass LogFile(File):\n    \"\"\"\n    A log file to configure with Python's logging module.\n    \"\"\"\n\n    def __init__(self, path=None, logger=None, loggers=[], formatter={}, format=None, *args, **kwargs):\n        super(LogFile, self).__init__(*args, path=path, **kwargs)\n        self._create = True\n        self._cleanup = True\n        self._formatter = formatter\n        self._format = format\n        if logger:\n            self._loggers = [logger]\n        else:\n            self._loggers = loggers\n\n    def prepare(self):\n        \"\"\"\n        Configure the log file.\n        \"\"\"\n        self.configure()\n\n    def configure(self):\n        \"\"\"\n        Configure the Python logging module for this file.\n        \"\"\"\n        handler = logging.FileHandler(self.path, delay=True)\n        if self._format:\n            handler.setFormatter(logging.Formatter(self._format))\n        if isinstance(self._format, string_types):\n            if self._env and self._env.config.logging.dict_config.formatters[self._formatter]:\n                d = self._env.config.logging.dict_config.formatters[self._formatter].to_dict()\n                handler.setFormatter(logging.Formatter(**d))\n        elif type(self._formatter) == dict:\n            handler.setFormatter(logging.Formatter(**self._formatter))\n        if len(self._loggers):\n            for name in self._loggers:\n                logging.getLogger(name).addHandler(handler)\n        else:\n            logging.getLogger().addHandler(handler)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\nclass PrintAndFlushSink:\n    '''A Loguru sink.\n    forcibly prints each log record and flushes immediately,\n    mimicking print(..., flush=True).\n    '''\n\n    def write(self, message: str):\n        '''Write a message to the stream and flush immediately.\n        Args:\n            message (str): The message to write.\n        '''\n        pass\n\n    def flush(self):\n        '''Flush the stream.\n        Already flushed on every write call.\n        '''\n        pass"
  }
]