[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Price:\n    '''Create a new price. Price in Stellar is represented as a fraction.\n    An example::\n        from stellar_sdk import Price\n        price_a = Price(1, 2)\n        price_b = Price.from_raw_price(\"0.5\")\n    :param n: numerator\n    :param d: denominator\n    '''\n\n    def __init__(self, n: int, d: int) -> None:\n        pass\n    @classmethod\n    def from_raw_price(cls, price: Union[str, Decimal]) -> 'Price':\n        '''Create a :class:`Price` from the given str or Decimal price.\n        :param price: the str or Decimal price. (ex. ``\"0.125\"``)\n        :return: A new :class:`Price` object from the given str or Decimal price.\n        :raises: :exc:`NoApproximationError <stellar_sdk.exceptions.NoApproximationError>`:\n            if the approximation could not not be found.\n        '''\n        pass\n\n    def to_xdr_object(self) -> stellar_xdr.Price:\n        '''Returns the xdr object for this price object.\n        :return: XDR Price object\n        '''\n        pass\n    @classmethod\n    def from_xdr_object(cls, xdr_object: stellar_xdr.Price) -> 'Price':\n        '''Create a :class:`Price` from an XDR Price object.\n        :param xdr_object: The XDR Price object.\n        :return: A new :class:`Price` object from the given XDR Price object.\n        '''\n        pass\n\n    def __lt__(self, other):\n        pass\n\n    def __le__(self, other):\n        pass\n\n    def __hash__(self):\n        pass\n\n    def __eq__(self, other):\n        pass\n\n    def __ne__(self, other):\n        pass\n\n    def __gt__(self, other):\n        pass\n\n    def __ge__(self, other):\n        pass\n\n    def __repr__(self):\n        pass\nCorresponding class implementation:\n\nfrom . import xdr as stellar_xdr\nfrom typing import Union\nfrom .utils import best_rational_approximation\nfrom decimal import Decimal\n\nclass Price:\n    \"\"\"Create a new price. Price in Stellar is represented as a fraction.\n\n    An example::\n\n        from stellar_sdk import Price\n\n        price_a = Price(1, 2)\n        price_b = Price.from_raw_price(\"0.5\")\n\n    :param n: numerator\n    :param d: denominator\n    \"\"\"\n\n    def __init__(self, n: int, d: int) -> None:\n        self.n: int = n\n        self.d: int = d\n\n    @classmethod\n    def from_raw_price(cls, price: Union[str, Decimal]) -> 'Price':\n        \"\"\"Create a :class:`Price` from the given str or Decimal price.\n\n        :param price: the str or Decimal price. (ex. ``\"0.125\"``)\n        :return: A new :class:`Price` object from the given str or Decimal price.\n        :raises: :exc:`NoApproximationError <stellar_sdk.exceptions.NoApproximationError>`:\n            if the approximation could not not be found.\n        \"\"\"\n        best_r = best_rational_approximation(str(price))\n        n = best_r['n']\n        d = best_r['d']\n        return cls(n, d)\n\n    def to_xdr_object(self) -> stellar_xdr.Price:\n        \"\"\"Returns the xdr object for this price object.\n\n        :return: XDR Price object\n        \"\"\"\n        return stellar_xdr.Price(n=stellar_xdr.Int32(self.n), d=stellar_xdr.Int32(self.d))\n\n    @classmethod\n    def from_xdr_object(cls, xdr_object: stellar_xdr.Price) -> 'Price':\n        \"\"\"Create a :class:`Price` from an XDR Price object.\n\n        :param xdr_object: The XDR Price object.\n        :return: A new :class:`Price` object from the given XDR Price object.\n        \"\"\"\n        n = xdr_object.n.int32\n        d = xdr_object.d.int32\n        return cls(n, d)\n\n    def __lt__(self, other):\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n        return self.n * other.d < other.n * self.d\n\n    def __le__(self, other):\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n        return self.n * other.d <= other.n * self.d\n\n    def __hash__(self):\n        return hash((self.n, self.d))\n\n    def __eq__(self, other):\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n        return self.n * other.d == other.n * self.d\n\n    def __ne__(self, other):\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n        return self.n * other.d != other.n * self.d\n\n    def __gt__(self, other):\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n        return self.n * other.d > other.n * self.d\n\n    def __ge__(self, other):\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n        return self.n * other.d >= other.n * self.d\n\n    def __repr__(self):\n        return f'<Price [n={self.n}, d={self.d}]>'\n\nExample skeleton:\n\n\nclass ExpressionDescriptor:\n    '''Converts a Cron Expression into a human readable string\n    '''\n\n    def __init__(self, expression: str, options: Options | None=None, **kwargs: Unpack[OptionsKwargs]) -> None:\n        '''Initializes a new instance of the ExpressionDescriptor\n        Args:\n            expression: The cron expression string\n            options: Options to control the output description\n        Raises:\n            WrongArgumentException: if kwarg is unknown\n        '''\n        pass\n\n    def translate(self, message: str) -> str:\n        pass\n\n    def get_description(self, description_type: DescriptionTypeEnum=DescriptionTypeEnum.FULL) -> str:\n        '''Generates a humanreadable string for the Cron Expression\n        Args:\n            description_type: Which part(s) of the expression to describe\n        Returns:\n            The cron expression description\n        Raises:\n            Exception:\n        '''\n        pass\n\n    def get_full_description(self) -> str:\n        '''Generates the FULL description\n        Returns:\n            The FULL description\n        Raises:\n            FormatException: if formatting fails\n        '''\n        pass\n\n    def get_time_of_day_description(self) -> str:\n        '''Generates a description for only the TIMEOFDAY portion of the expression\n        Returns:\n            The TIMEOFDAY description\n        '''\n        pass\n\n    def get_seconds_description(self) -> str:\n        '''Generates a description for only the SECONDS portion of the expression\n        Returns:\n            The SECONDS description\n        '''\n        pass\n\n        def get_description_format(s: str) -> str:\n                pass\n\n    def get_minutes_description(self) -> str:\n        '''Generates a description for only the MINUTE portion of the expression\n        Returns:\n            The MINUTE description\n        '''\n        pass\n\n        def get_description_format(s: str) -> str:\n                pass\n\n    def get_hours_description(self) -> str:\n        '''Generates a description for only the HOUR portion of the expression\n        Returns:\n            The HOUR description\n        '''\n        pass\n\n    def get_day_of_week_description(self) -> str:\n        '''Generates a description for only the DAYOFWEEK portion of the expression\n        Returns:\n            The DAYOFWEEK description\n        '''\n        pass\n\n        def get_day_name(s: str) -> str:\n                pass\n\n        def get_format(s: str) -> str:\n                pass\n\n    def get_month_description(self) -> str:\n        '''Generates a description for only the MONTH portion of the expression\n        Returns:\n            The MONTH description\n        '''\n        pass\n\n    def get_day_of_month_description(self) -> str:\n        '''Generates a description for only the DAYOFMONTH portion of the expression\n        Returns:\n            The DAYOFMONTH description\n        '''\n        pass\n\n    def get_year_description(self) -> str:\n        '''Generates a description for only the YEAR portion of the expression\n        Returns:\n            The YEAR description\n        '''\n        pass\n\n        def format_year(s: str) -> str:\n                pass\n\n    def get_segment_description(self, expression: str, all_description: str, get_single_item_description: Callable[[str], str], get_interval_description_format: Callable[[str], str], get_between_description_format: Callable[[str], str], get_description_format: Callable[[str], str], get_range_format: Callable[[str], str]) -> str:\n        '''Returns segment description\n        Args:\n            expression: Segment to descript\n            all_description: *\n            get_single_item_description: 1\n            get_interval_description_format: 1/2\n            get_between_description_format: 1-2\n            get_description_format: format get_single_item_description\n            get_range_format: function that formats range expressions depending on cron parts\n        Returns:\n            segment description\n        '''\n        pass\n\n    def generate_between_segment_description(self, between_expression: str, get_between_description_format: Callable[[str], str], get_single_item_description: Callable[[str], str]) -> str:\n        '''Generates the between segment description\n        :param between_expression:\n        :param get_between_description_format:\n        :param get_single_item_description:\n        :return: The between segment description\n        '''\n        pass\n\n    def format_time(self, hour_expression: str, minute_expression: str, second_expression: str | None=None) -> str:\n        '''Given time parts, will construct a formatted time description\n        Args:\n            hour_expression: Hours part\n            minute_expression: Minutes part\n            second_expression: Seconds part\n        Returns:\n            Formatted time description\n        '''\n        pass\n\n    def transform_verbosity(self, description: str, *, use_verbose_format: bool=False) -> str:\n        '''Transforms the verbosity of the expression description by stripping verbosity from original description\n        Args:\n            description: The description to transform\n            use_verbose_format: If True, will leave description as it, if False, will strip verbose parts\n        Returns:\n            The transformed description with proper verbosity\n        '''\n        pass\n    @staticmethod\n    def transform_case(description: str, case_type: CasingTypeEnum) -> str:\n        '''Transforms the case of the expression description, based on options\n        Args:\n            description: The description to transform\n            case_type: The casing type that controls the output casing\n        Returns:\n            The transformed description with proper casing\n        '''\n        pass\n    @staticmethod\n    def number_to_day(day_number: int) -> str:\n        '''Returns localized day name by its CRON number\n        Args:\n            day_number: Number of a day\n        Returns:\n            Day corresponding to day_number\n        Raises:\n            IndexError: When day_number is not found\n        '''\n        pass\n\n    def __str__(self) -> str:\n        pass\n\n    def __repr__(self) -> str:\n        pass\nCorresponding class implementation:\n\nfrom .Options import Options\nfrom typing import Callable, TypedDict\nfrom typing_extensions import Unpack\nfrom .Exception import FormatError, WrongArgumentError\nfrom .StringBuilder import StringBuilder\nimport re\nimport calendar\nfrom .DescriptionTypeEnum import DescriptionTypeEnum\nfrom .GetText import GetText\nimport datetime\nfrom .CasingTypeEnum import CasingTypeEnum\nfrom .ExpressionParser import ExpressionParser\n\nclass ExpressionDescriptor:\n    \"\"\"Converts a Cron Expression into a human readable string\n    \"\"\"\n    _special_characters = ('/', '-', ',', '*')\n    _expression = ''\n    _options: Options\n    _expression_parts: list[str]\n\n    def __init__(self, expression: str, options: Options | None=None, **kwargs: Unpack[OptionsKwargs]) -> None:\n        \"\"\"Initializes a new instance of the ExpressionDescriptor\n\n        Args:\n            expression: The cron expression string\n            options: Options to control the output description\n        Raises:\n            WrongArgumentException: if kwarg is unknown\n\n        \"\"\"\n        if options is None:\n            options = Options()\n        self._expression = expression\n        self._options = options\n        self._expression_parts = []\n        for kwarg, value in kwargs.items():\n            if hasattr(self._options, kwarg):\n                setattr(self._options, kwarg, value)\n            else:\n                msg = f'Unknown {kwarg} configuration argument'\n                raise WrongArgumentError(msg)\n        self.get_text = GetText(options.locale_code, options.locale_location)\n        parser = ExpressionParser(self._expression, self._options)\n        self._expression_parts = parser.parse()\n\n    def translate(self, message: str) -> str:\n        return self.get_text.trans.gettext(message)\n\n    def get_description(self, description_type: DescriptionTypeEnum=DescriptionTypeEnum.FULL) -> str:\n        \"\"\"Generates a humanreadable string for the Cron Expression\n\n        Args:\n            description_type: Which part(s) of the expression to describe\n        Returns:\n            The cron expression description\n        Raises:\n            Exception:\n\n        \"\"\"\n        choices = {DescriptionTypeEnum.FULL: self.get_full_description, DescriptionTypeEnum.TIMEOFDAY: self.get_time_of_day_description, DescriptionTypeEnum.HOURS: self.get_hours_description, DescriptionTypeEnum.MINUTES: self.get_minutes_description, DescriptionTypeEnum.SECONDS: self.get_seconds_description, DescriptionTypeEnum.DAYOFMONTH: self.get_day_of_month_description, DescriptionTypeEnum.MONTH: self.get_month_description, DescriptionTypeEnum.DAYOFWEEK: self.get_day_of_week_description, DescriptionTypeEnum.YEAR: self.get_year_description}\n        return choices.get(description_type, self.get_seconds_description)()\n\n    def get_full_description(self) -> str:\n        \"\"\"Generates the FULL description\n\n        Returns:\n            The FULL description\n        Raises:\n            FormatException: if formatting fails\n\n        \"\"\"\n        try:\n            time_segment = self.get_time_of_day_description()\n            day_of_month_desc = self.get_day_of_month_description()\n            month_desc = self.get_month_description()\n            day_of_week_desc = self.get_day_of_week_description()\n            year_desc = self.get_year_description()\n            description = f'{time_segment}{day_of_month_desc}{day_of_week_desc}{month_desc}{year_desc}'\n            description = self.transform_verbosity(description, use_verbose_format=self._options.verbose)\n            description = ExpressionDescriptor.transform_case(description, self._options.casing_type)\n        except Exception as e:\n            description = self.translate('An error occurred when generating the expression description.  Check the cron expression syntax.')\n            raise FormatError(description) from e\n        return description\n\n    def get_time_of_day_description(self) -> str:\n        \"\"\"Generates a description for only the TIMEOFDAY portion of the expression\n\n        Returns:\n            The TIMEOFDAY description\n\n        \"\"\"\n        seconds_expression = self._expression_parts[0]\n        minute_expression = self._expression_parts[1]\n        hour_expression = self._expression_parts[2]\n        description = StringBuilder()\n        if any((exp in minute_expression for exp in self._special_characters)) is False and any((exp in hour_expression for exp in self._special_characters)) is False and (any((exp in seconds_expression for exp in self._special_characters)) is False):\n            description.append(self.translate('At '))\n            description.append(self.format_time(hour_expression, minute_expression, seconds_expression))\n        elif seconds_expression == '' and '-' in minute_expression and (',' not in minute_expression) and (any((exp in hour_expression for exp in self._special_characters)) is False):\n            minute_parts = minute_expression.split('-')\n            description.append(self.translate('Every minute between {0} and {1}').format(self.format_time(hour_expression, minute_parts[0]), self.format_time(hour_expression, minute_parts[1])))\n        elif seconds_expression == '' and ',' in hour_expression and ('-' not in hour_expression) and (any((exp in minute_expression for exp in self._special_characters)) is False):\n            hour_parts = hour_expression.split(',')\n            description.append(self.translate('At'))\n            for i, hour_part in enumerate(hour_parts):\n                description.append(' ')\n                description.append(self.format_time(hour_part, minute_expression))\n                if i < len(hour_parts) - 2:\n                    description.append(',')\n                if i == len(hour_parts) - 2:\n                    description.append(self.translate(' and'))\n        else:\n            seconds_description = self.get_seconds_description()\n            minutes_description = self.get_minutes_description()\n            hours_description = self.get_hours_description()\n            description.append(seconds_description)\n            if description and minutes_description:\n                description.append(', ')\n            description.append(minutes_description)\n            if description and hours_description:\n                description.append(', ')\n            description.append(hours_description)\n        return str(description)\n\n    def get_seconds_description(self) -> str:\n        \"\"\"Generates a description for only the SECONDS portion of the expression\n\n        Returns:\n            The SECONDS description\n\n        \"\"\"\n\n        def get_description_format(s: str) -> str:\n            if s == '0':\n                return ''\n            try:\n                if int(s) < 20:\n                    return self.translate('at {0} seconds past the minute')\n                return self.translate('at {0} seconds past the minute [grThen20]') or self.translate('at {0} seconds past the minute')\n            except ValueError:\n                return self.translate('at {0} seconds past the minute')\n        return self.get_segment_description(self._expression_parts[0], self.translate('every second'), lambda s: s, lambda s: self.translate('every {0} seconds').format(s), lambda _: self.translate('seconds {0} through {1} past the minute'), get_description_format, lambda _: self.translate(', second {0} through second {1}') or self.translate(', {0} through {1}'))\n\n    def get_minutes_description(self) -> str:\n        \"\"\"Generates a description for only the MINUTE portion of the expression\n\n        Returns:\n            The MINUTE description\n\n        \"\"\"\n        seconds_expression = self._expression_parts[0]\n\n        def get_description_format(s: str) -> str:\n            if s == '0' and seconds_expression == '':\n                return ''\n            try:\n                if int(s) < 20:\n                    return self.translate('at {0} minutes past the hour')\n                return self.translate('at {0} minutes past the hour [grThen20]') or self.translate('at {0} minutes past the hour')\n            except ValueError:\n                return self.translate('at {0} minutes past the hour')\n        return self.get_segment_description(self._expression_parts[1], self.translate('every minute'), lambda s: s, lambda s: self.translate('every {0} minutes').format(s), lambda _: self.translate('minutes {0} through {1} past the hour'), get_description_format, lambda _: self.translate(', minute {0} through minute {1}') or self.translate(', {0} through {1}'))\n\n    def get_hours_description(self) -> str:\n        \"\"\"Generates a description for only the HOUR portion of the expression\n\n        Returns:\n            The HOUR description\n\n        \"\"\"\n        expression = self._expression_parts[2]\n        return self.get_segment_description(expression, self.translate('every hour'), lambda s: self.format_time(s, '0'), lambda s: self.translate('every {0} hours').format(s), lambda _: self.translate('between {0} and {1}'), lambda _: self.translate('at {0}'), lambda _: self.translate(', hour {0} through hour {1}') or self.translate(', {0} through {1}'))\n\n    def get_day_of_week_description(self) -> str:\n        \"\"\"Generates a description for only the DAYOFWEEK portion of the expression\n\n        Returns:\n            The DAYOFWEEK description\n\n        \"\"\"\n        if self._expression_parts[5] == '*':\n            return ''\n\n        def get_day_name(s: str) -> str:\n            exp = s\n            if '#' in s:\n                exp, _ = s.split('#', 2)\n            elif 'L' in s:\n                exp = exp.replace('L', '')\n            return ExpressionDescriptor.number_to_day(int(exp))\n\n        def get_format(s: str) -> str:\n            if '#' in s:\n                day_of_week_of_month = s[s.find('#') + 1:]\n                try:\n                    day_of_week_of_month_number = int(day_of_week_of_month)\n                    choices = {1: self.translate('first'), 2: self.translate('second'), 3: self.translate('third'), 4: self.translate('fourth'), 5: self.translate('fifth')}\n                    day_of_week_of_month_description = choices.get(day_of_week_of_month_number, '')\n                except ValueError:\n                    day_of_week_of_month_description = ''\n                formatted = '{}{}{}'.format(self.translate(', on the '), day_of_week_of_month_description, self.translate(' {0} of the month'))\n            elif 'L' in s:\n                formatted = self.translate(', on the last {0} of the month')\n            else:\n                formatted = self.translate(', only on {0}')\n            return formatted\n        return self.get_segment_description(self._expression_parts[5], self.translate(', every day'), lambda s: get_day_name(s), lambda s: self.translate(', every {0} days of the week').format(s), lambda _: self.translate(', {0} through {1}'), lambda s: get_format(s), lambda _: self.translate(', {0} through {1}'))\n\n    def get_month_description(self) -> str:\n        \"\"\"Generates a description for only the MONTH portion of the expression\n\n        Returns:\n            The MONTH description\n\n        \"\"\"\n        return self.get_segment_description(self._expression_parts[4], '', lambda s: datetime.date(datetime.datetime.now(tz=datetime.timezone.utc).date().year, int(s), 1).strftime('%B'), lambda s: self.translate(', every {0} months').format(s), lambda _: self.translate(', month {0} through month {1}') or self.translate(', {0} through {1}'), lambda _: self.translate(', only in {0}'), lambda _: self.translate(', month {0} through month {1}') or self.translate(', {0} through {1}'))\n\n    def get_day_of_month_description(self) -> str:\n        \"\"\"Generates a description for only the DAYOFMONTH portion of the expression\n\n        Returns:\n            The DAYOFMONTH description\n\n        \"\"\"\n        expression = self._expression_parts[3]\n        if expression == 'L':\n            description = self.translate(', on the last day of the month')\n        elif expression in ('LW', 'WL'):\n            description = self.translate(', on the last weekday of the month')\n        else:\n            regex = re.compile('(\\\\d{1,2}W)|(W\\\\d{1,2})')\n            m = regex.match(expression)\n            if m:\n                day_number = int(m.group().replace('W', ''))\n                day_string = self.translate('first weekday') if day_number == 1 else self.translate('weekday nearest day {0}').format(day_number)\n                description = self.translate(', on the {0} of the month').format(day_string)\n            elif expression == '*' and self._expression_parts[5] != '*':\n                description = ''\n            else:\n                regex = re.compile('L-(\\\\d{1,2})')\n                m = regex.match(expression)\n                if m:\n                    off_set_days = m.group(1)\n                    description = self.translate(', {0} days before the last day of the month').format(off_set_days)\n                else:\n                    description = self.get_segment_description(expression, self.translate(', every day'), lambda s: s, lambda s: self.translate(', every day') if s == '1' else self.translate(', every {0} days'), lambda _: self.translate(', between day {0} and {1} of the month'), lambda _: self.translate(', on day {0} of the month'), lambda _: self.translate(', {0} through {1}'))\n        return description\n\n    def get_year_description(self) -> str:\n        \"\"\"Generates a description for only the YEAR portion of the expression\n\n        Returns:\n            The YEAR description\n\n        \"\"\"\n\n        def format_year(s: str) -> str:\n            regex = re.compile('^\\\\d+$')\n            if regex.match(s):\n                year_int = int(s)\n                if year_int < 1900:\n                    return str(year_int)\n                return datetime.date(year_int, 1, 1).strftime('%Y')\n            return s\n        return self.get_segment_description(self._expression_parts[6], '', lambda s: format_year(s), lambda s: self.translate(', every {0} years').format(s), lambda _: self.translate(', year {0} through year {1}') or self.translate(', {0} through {1}'), lambda _: self.translate(', only in {0}'), lambda _: self.translate(', year {0} through year {1}') or self.translate(', {0} through {1}'))\n\n    def get_segment_description(self, expression: str, all_description: str, get_single_item_description: Callable[[str], str], get_interval_description_format: Callable[[str], str], get_between_description_format: Callable[[str], str], get_description_format: Callable[[str], str], get_range_format: Callable[[str], str]) -> str:\n        \"\"\"Returns segment description\n        Args:\n            expression: Segment to descript\n            all_description: *\n            get_single_item_description: 1\n            get_interval_description_format: 1/2\n            get_between_description_format: 1-2\n            get_description_format: format get_single_item_description\n            get_range_format: function that formats range expressions depending on cron parts\n        Returns:\n            segment description\n\n        \"\"\"\n        if not expression:\n            return ''\n        if expression == '*':\n            return all_description\n        if not any((ext in expression for ext in ['/', '-', ','])):\n            return get_description_format(expression).format(get_single_item_description(expression))\n        if '/' in expression:\n            segments = expression.split('/')\n            description = get_interval_description_format(segments[1]).format(segments[1])\n            if '-' in segments[0]:\n                between_segment_description = self.generate_between_segment_description(segments[0], get_between_description_format, get_single_item_description)\n                if not between_segment_description.startswith(', '):\n                    description += ', '\n                description += between_segment_description\n            elif not any((ext in segments[0] for ext in ['*', ','])):\n                range_item_description = get_description_format(segments[0]).format(get_single_item_description(segments[0]))\n                range_item_description = range_item_description.replace(', ', '')\n                description += self.translate(', starting {0}').format(range_item_description)\n            return description\n        if ',' in expression:\n            segments = expression.split(',')\n            description_content = ''\n            for i, segment in enumerate(segments):\n                if i > 0 and len(segments) > 2:\n                    description_content += ','\n                    if i < len(segments) - 1:\n                        description_content += ' '\n                if i > 0 and len(segments) > 1 and (i == len(segments) - 1 or len(segments) == 2):\n                    description_content += self.translate(' and ')\n                if '-' in segment:\n                    between_segment_description = self.generate_between_segment_description(segment, get_range_format, get_single_item_description)\n                    between_segment_description = between_segment_description.replace(', ', '')\n                    description_content += between_segment_description\n                else:\n                    description_content += get_single_item_description(segment)\n            return get_description_format(expression).format(description_content)\n        if '-' in expression:\n            return self.generate_between_segment_description(expression, get_between_description_format, get_single_item_description)\n        return '?'\n\n    def generate_between_segment_description(self, between_expression: str, get_between_description_format: Callable[[str], str], get_single_item_description: Callable[[str], str]) -> str:\n        \"\"\"Generates the between segment description\n        :param between_expression:\n        :param get_between_description_format:\n        :param get_single_item_description:\n        :return: The between segment description\n        \"\"\"\n        description = ''\n        between_segments = between_expression.split('-')\n        between_segment_1_description = get_single_item_description(between_segments[0])\n        between_segment_2_description = get_single_item_description(between_segments[1])\n        between_segment_2_description = between_segment_2_description.replace(':00', ':59')\n        between_description_format = get_between_description_format(between_expression)\n        description += between_description_format.format(between_segment_1_description, between_segment_2_description)\n        return description\n\n    def format_time(self, hour_expression: str, minute_expression: str, second_expression: str | None=None) -> str:\n        \"\"\"Given time parts, will construct a formatted time description\n        Args:\n            hour_expression: Hours part\n            minute_expression: Minutes part\n            second_expression: Seconds part\n        Returns:\n            Formatted time description\n\n        \"\"\"\n        hour = int(hour_expression)\n        period = ''\n        if self._options.use_24hour_time_format is False:\n            period = self.translate('PM') if hour >= 12 else self.translate('AM')\n            if period:\n                period = ' ' + period\n            if hour > 12:\n                hour -= 12\n            if hour == 0:\n                hour = 12\n        minute = str(int(minute_expression))\n        second = ''\n        if second_expression is not None and second_expression:\n            second = '{}{}'.format(':', str(int(second_expression)).zfill(2))\n        return f'{str(hour).zfill(2)}:{minute.zfill(2)}{second}{period}'\n\n    def transform_verbosity(self, description: str, *, use_verbose_format: bool=False) -> str:\n        \"\"\"Transforms the verbosity of the expression description by stripping verbosity from original description\n        Args:\n            description: The description to transform\n            use_verbose_format: If True, will leave description as it, if False, will strip verbose parts\n        Returns:\n            The transformed description with proper verbosity\n\n        \"\"\"\n        if not use_verbose_format:\n            description = description.replace(self.translate(', every minute'), '')\n            description = description.replace(self.translate(', every hour'), '')\n            description = description.replace(self.translate(', every day'), '')\n            description = re.sub(', ?$', '', description)\n        return description\n\n    @staticmethod\n    def transform_case(description: str, case_type: CasingTypeEnum) -> str:\n        \"\"\"Transforms the case of the expression description, based on options\n        Args:\n            description: The description to transform\n            case_type: The casing type that controls the output casing\n        Returns:\n            The transformed description with proper casing\n        \"\"\"\n        if case_type == CasingTypeEnum.Sentence:\n            description = f'{description[0].upper()}{description[1:]}'\n        elif case_type == CasingTypeEnum.Title:\n            description = description.title()\n        else:\n            description = description.lower()\n        return description\n\n    @staticmethod\n    def number_to_day(day_number: int) -> str:\n        \"\"\"Returns localized day name by its CRON number\n\n        Args:\n            day_number: Number of a day\n        Returns:\n            Day corresponding to day_number\n        Raises:\n            IndexError: When day_number is not found\n\n        \"\"\"\n        try:\n            return [calendar.day_name[6], calendar.day_name[0], calendar.day_name[1], calendar.day_name[2], calendar.day_name[3], calendar.day_name[4], calendar.day_name[5]][day_number]\n        except IndexError as e:\n            msg = f'Day {day_number} is out of range!'\n            raise IndexError(msg) from e\n\n    def __str__(self) -> str:\n        return self.get_description()\n\n    def __repr__(self) -> str:\n        return self.get_description()\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass PriceFormatter:\n    '''Utility class for formatting prices and quantities consistently.'''\n    @staticmethod\n    def format_price_for_display(price: Union[float, int, None]) -> str:\n        '''\n        Format price for user display (UI, console output).\n        Args:\n            price: Price value to format\n        Returns:\n            Formatted price string with currency symbol\n        '''\n        pass\n    @staticmethod\n    def format_price_for_logging(price: Union[float, int, None]) -> str:\n        '''\n        Format price for logging (more precision, with currency symbol).\n        Args:\n            price: Price value to format\n        Returns:\n            Formatted price string for logging\n        '''\n        pass\n    @staticmethod\n    def format_quantity(quantity: Union[float, int, None]) -> str:\n        '''\n        Format quantity for display.\n        Args:\n            quantity: Quantity value to format\n        Returns:\n            Formatted quantity string\n        '''\n        pass\n    @staticmethod\n    def format_percentage(percentage: Union[float, int, None]) -> str:\n        '''\n        Format percentage for display.\n        Args:\n            percentage: Percentage value to format (as decimal, e.g., 0.05 for 5%)\n        Returns:\n            Formatted percentage string\n        '''\n        pass\n    @staticmethod\n    def format_price_for_display(price: Union[float, int, None]) -> str:\n        '''\n        Format price without currency symbol, preserving precision.\n        Args:\n            price: Price value to format\n            force_precision: Optional forced decimal places\n        Returns:\n            Formatted price string without currency symbol\n        '''\n        pass\n    @staticmethod\n    def format_currency(price: Union[float, int, None], currency: str='USD') -> str:\n        '''\n        Format price with currency symbol.\n        Args:\n            price: Price value to format\n            currency: Currency code (USD, EUR, BTC, etc.)\n        Returns:\n            Formatted price string with currency symbol\n        '''\n        pass"
  }
]