[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass UserSource(Source):\n    '''\n    UserSource\n    '''\n\n    class Config:\n        '''Pydantic configuration'''\n\n    def to_str(self) -> str:\n        '''Returns the string representation of the model using alias'''\n        pass\n\n    def to_json(self) -> str:\n        '''Returns the JSON representation of the model using alias'''\n        pass\n    @classmethod\n    def from_json(cls, json_str: str) -> UserSource:\n        '''Create an instance of UserSource from a JSON string'''\n        pass\n\n    def to_dict(self):\n        '''Returns the dictionary representation of the model using alias'''\n        pass\n    @classmethod\n    def from_dict(cls, obj: dict) -> UserSource:\n        '''Create an instance of UserSource from a dict'''\n        pass\nCorresponding class implementation:\n\nfrom pydantic.v1 import Field, StrictStr\nimport pprint\nfrom typing import Optional\nimport json\nfrom linebot.v3.webhooks.models.source import Source\n\nclass UserSource(Source):\n    \"\"\"\n    UserSource\n    \"\"\"\n    user_id: Optional[StrictStr] = Field(None, alias='userId', description='ID of the source user')\n    type: str = 'user'\n    __properties = ['type', 'userId']\n\n    class Config:\n        \"\"\"Pydantic configuration\"\"\"\n        allow_population_by_field_name = True\n        validate_assignment = True\n\n    def to_str(self) -> str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.dict(by_alias=True))\n\n    def to_json(self) -> str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -> UserSource:\n        \"\"\"Create an instance of UserSource from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self):\n        \"\"\"Returns the dictionary representation of the model using alias\"\"\"\n        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict) -> UserSource:\n        \"\"\"Create an instance of UserSource from a dict\"\"\"\n        if obj is None:\n            return None\n        if not isinstance(obj, dict):\n            return UserSource.parse_obj(obj)\n        _obj = UserSource.parse_obj({'type': obj.get('type'), 'user_id': obj.get('userId')})\n        return _obj\n\nExample skeleton:\n\n\nclass ActivatedEvent(Event):\n    '''\n    This event indicates that the module channel has been switched to Active Channel by calling the Acquire Control API. Sent to the webhook URL server of the module channel.\n    '''\n\n    class Config:\n        '''Pydantic configuration'''\n\n    def to_str(self) -> str:\n        '''Returns the string representation of the model using alias'''\n        pass\n\n    def to_json(self) -> str:\n        '''Returns the JSON representation of the model using alias'''\n        pass\n    @classmethod\n    def from_json(cls, json_str: str) -> ActivatedEvent:\n        '''Create an instance of ActivatedEvent from a JSON string'''\n        pass\n\n    def to_dict(self):\n        '''Returns the dictionary representation of the model using alias'''\n        pass\n    @classmethod\n    def from_dict(cls, obj: dict) -> ActivatedEvent:\n        '''Create an instance of ActivatedEvent from a dict'''\n        pass\nCorresponding class implementation:\n\nfrom linebot.v3.webhooks.models.source import Source\nfrom linebot.v3.webhooks.models.chat_control import ChatControl\nfrom linebot.v3.webhooks.models.delivery_context import DeliveryContext\nimport pprint\nfrom linebot.v3.webhooks.models.event import Event\nfrom pydantic.v1 import Field\nimport json\n\nclass ActivatedEvent(Event):\n    \"\"\"\n    This event indicates that the module channel has been switched to Active Channel by calling the Acquire Control API. Sent to the webhook URL server of the module channel.\n    \"\"\"\n    chat_control: ChatControl = Field(..., alias='chatControl')\n    type: str = 'activated'\n    __properties = ['type', 'source', 'timestamp', 'mode', 'webhookEventId', 'deliveryContext', 'chatControl']\n\n    class Config:\n        \"\"\"Pydantic configuration\"\"\"\n        allow_population_by_field_name = True\n        validate_assignment = True\n\n    def to_str(self) -> str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.dict(by_alias=True))\n\n    def to_json(self) -> str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -> ActivatedEvent:\n        \"\"\"Create an instance of ActivatedEvent from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self):\n        \"\"\"Returns the dictionary representation of the model using alias\"\"\"\n        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)\n        if self.source:\n            _dict['source'] = self.source.to_dict()\n        if self.delivery_context:\n            _dict['deliveryContext'] = self.delivery_context.to_dict()\n        if self.chat_control:\n            _dict['chatControl'] = self.chat_control.to_dict()\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict) -> ActivatedEvent:\n        \"\"\"Create an instance of ActivatedEvent from a dict\"\"\"\n        if obj is None:\n            return None\n        if not isinstance(obj, dict):\n            return ActivatedEvent.parse_obj(obj)\n        _obj = ActivatedEvent.parse_obj({'type': obj.get('type'), 'source': Source.from_dict(obj.get('source')) if obj.get('source') is not None else None, 'timestamp': obj.get('timestamp'), 'mode': obj.get('mode'), 'webhook_event_id': obj.get('webhookEventId'), 'delivery_context': DeliveryContext.from_dict(obj.get('deliveryContext')) if obj.get('deliveryContext') is not None else None, 'chat_control': ChatControl.from_dict(obj.get('chatControl')) if obj.get('chatControl') is not None else None})\n        return _obj\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n@dataclass\nclass SmartDefaultsConfig:\n    '''Configuration for Smart Defaults system'''\n    @classmethod\n    def from_env(cls) -> 'SmartDefaultsConfig':\n        '''Create configuration from environment variables'''\n        pass\n    @classmethod\n    def from_file(cls, config_path: Path) -> 'SmartDefaultsConfig':\n        '''Load configuration from JSON file'''\n        pass\n\n    def to_file(self, config_path: Path):\n        '''Save configuration to JSON file'''\n        pass\n\n    def validate(self) -> List[str]:\n        '''Validate configuration and return list of issues'''\n        pass\n\n    def get_environment_defaults(self, environment: str) -> Dict[str, Any]:\n        '''Get defaults for a specific environment'''\n        pass\n\n    def should_learn_from_field(self, field_name: str) -> bool:\n        '''Check if learning should be enabled for a field'''\n        pass\n\n    def should_learn_from_context(self, context: str) -> bool:\n        '''Check if learning should be enabled for a context'''\n        pass"
  }
]