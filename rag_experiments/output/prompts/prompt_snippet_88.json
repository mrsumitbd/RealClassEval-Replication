[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass RandomGrayscale(torch.nn.Module):\n    '''Randomly convert image to grayscale with a probability of p (default 0.1).\n    If the image is torch Tensor, it is expected\n    to have [..., 3, H, W] shape, where ... means an arbitrary number of leading dimensions\n    Args:\n        p (float): probability that image should be converted to grayscale.\n    Returns:\n        PIL Image or Tensor: Grayscale version of the input image with probability p and unchanged\n        with probability (1-p).\n        - If input image is 1 channel: grayscale version is 1 channel\n        - If input image is 3 channel: grayscale version is 3 channel with r == g == b\n    '''\n\n    def __init__(self, p=0.1):\n        pass\n\n    def forward(self, img):\n        '''\n        Args:\n            img (PIL Image or Tensor): Image to be converted to grayscale.\n        Returns:\n            PIL Image or Tensor: Randomly grayscaled image.\n        '''\n        pass\n\n    def __repr__(self) -> str:\n        pass\nCorresponding class implementation:\n\nfrom ..utils import _log_api_usage_once\nfrom . import functional as F\nimport torch\n\nclass RandomGrayscale(torch.nn.Module):\n    \"\"\"Randomly convert image to grayscale with a probability of p (default 0.1).\n    If the image is torch Tensor, it is expected\n    to have [..., 3, H, W] shape, where ... means an arbitrary number of leading dimensions\n\n    Args:\n        p (float): probability that image should be converted to grayscale.\n\n    Returns:\n        PIL Image or Tensor: Grayscale version of the input image with probability p and unchanged\n        with probability (1-p).\n        - If input image is 1 channel: grayscale version is 1 channel\n        - If input image is 3 channel: grayscale version is 3 channel with r == g == b\n\n    \"\"\"\n\n    def __init__(self, p=0.1):\n        super().__init__()\n        _log_api_usage_once(self)\n        self.p = p\n\n    def forward(self, img):\n        \"\"\"\n        Args:\n            img (PIL Image or Tensor): Image to be converted to grayscale.\n\n        Returns:\n            PIL Image or Tensor: Randomly grayscaled image.\n        \"\"\"\n        num_output_channels, _, _ = F.get_dimensions(img)\n        if torch.rand(1) < self.p:\n            return F.rgb_to_grayscale(img, num_output_channels=num_output_channels)\n        return img\n\n    def __repr__(self) -> str:\n        return f'{self.__class__.__name__}(p={self.p})'\n\nExample skeleton:\n\n\nclass VAO:\n    '''\n    Represents a vertex array object.\n    This is a wrapper class over ``moderngl.VertexArray`` to provide helper method.\n    The main purpose is to provide render methods taking a program as parameter.\n    The class will auto detect the programs attributes and add padding when needed\n    to match the vertex object.\n    A new vertexbuffer object is created and stored internally for each unique\n    shader program used.\n    A secondary purpose is to provide an alternate way to build vertexbuffers\n    This can be practical when loading or creating various geometry.\n    There is no requirements to use this class, but most methods in the\n    system creating vertexbuffers will return this type. You can obtain\n    a single vertexbuffer instance by calling :py:meth:`VAO.instance`\n    method if you prefer to work directly on moderngl instances.\n    '''\n\n    def __init__(self, name='', mode=moderngl.TRIANGLES):\n        '''\n        Create and empty VAO\n        Keyword Args:\n            name (str): The name for debug purposes\n            mode (int): Default draw mode\n        '''\n        pass\n\n    def render(self, program: moderngl.Program, mode=None, vertices=-1, first=0, instances=1):\n        '''\n        Render the VAO.\n        Args:\n            program: The ``moderngl.Program``\n        Keyword Args:\n            mode: Override the draw mode (``TRIANGLES`` etc)\n            vertices (int): The number of vertices to transform\n            first (int): The index of the first vertex to start with\n            instances (int): The number of instances\n        '''\n        pass\n\n    def render_indirect(self, program: moderngl.Program, buffer, mode=None, count=-1, *, first=0):\n        '''\n        The render primitive (mode) must be the same as the input primitive of the GeometryShader.\n        The draw commands are 5 integers: (count, instanceCount, firstIndex, baseVertex, baseInstance).\n        Args:\n            program: The ``moderngl.Program``\n            buffer: The ``moderngl.Buffer`` containing indirect draw commands\n        Keyword Args:\n            mode (int): By default :py:data:`TRIANGLES` will be used.\n            count (int): The number of draws.\n            first (int): The index of the first indirect draw command.\n        '''\n        pass\n\n    def transform(self, program: moderngl.Program, buffer: moderngl.Buffer, mode=None, vertices=-1, first=0, instances=1):\n        '''\n        Transform vertices. Stores the output in a single buffer.\n        Args:\n            program: The ``moderngl.Program``\n            buffer: The ``moderngl.buffer`` to store the output\n        Keyword Args:\n            mode: Draw mode (for example ``moderngl.POINTS``)\n            vertices (int): The number of vertices to transform\n            first (int): The index of the first vertex to start with\n            instances (int): The number of instances\n        '''\n        pass\n\n    def buffer(self, buffer, buffer_format: str, attribute_names, per_instance=False):\n        '''\n        Register a buffer/vbo for the VAO. This can be called multiple times.\n        adding multiple buffers (interleaved or not)\n        Args:\n            buffer: The buffer data. Can be ``numpy.array``, ``moderngl.Buffer`` or ``bytes``.\n            buffer_format (str): The format of the buffer. (eg. ``3f 3f`` for interleaved positions and normals).\n            attribute_names: A list of attribute names this buffer should map to.\n        Keyword Args:\n            per_instance (bool): Is this buffer per instance data for instanced rendering?\n        Returns:\n            The ``moderngl.Buffer`` instance object. This is handy when providing ``bytes`` and ``numpy.array``.\n        '''\n        pass\n\n    def index_buffer(self, buffer, index_element_size=4):\n        '''\n        Set the index buffer for this VAO\n        Args:\n            buffer: ``moderngl.Buffer``, ``numpy.array`` or ``bytes``\n        Keyword Args:\n            index_element_size (int): Byte size of each element. 1, 2 or 4\n        '''\n        pass\n\n    def instance(self, program: moderngl.Program) -> moderngl.VertexArray:\n        '''\n        Obtain the ``moderngl.VertexArray`` instance for the program.\n        The instance is only created once and cached internally.\n        Returns: ``moderngl.VertexArray`` instance\n        '''\n        pass\n\n    def release(self, buffer=True):\n        '''\n        Destroy the vao object\n        Keyword Args:\n            buffers (bool): also release buffers\n        '''\n        pass\nCorresponding class implementation:\n\nimport numpy\nimport moderngl\nfrom demosys import context\n\nclass VAO:\n    \"\"\"\n    Represents a vertex array object.\n    This is a wrapper class over ``moderngl.VertexArray`` to provide helper method.\n\n    The main purpose is to provide render methods taking a program as parameter.\n    The class will auto detect the programs attributes and add padding when needed\n    to match the vertex object.\n    A new vertexbuffer object is created and stored internally for each unique\n    shader program used.\n\n    A secondary purpose is to provide an alternate way to build vertexbuffers\n    This can be practical when loading or creating various geometry.\n\n    There is no requirements to use this class, but most methods in the\n    system creating vertexbuffers will return this type. You can obtain\n    a single vertexbuffer instance by calling :py:meth:`VAO.instance`\n    method if you prefer to work directly on moderngl instances.\n    \"\"\"\n\n    def __init__(self, name='', mode=moderngl.TRIANGLES):\n        \"\"\"\n        Create and empty VAO\n\n        Keyword Args:\n            name (str): The name for debug purposes\n            mode (int): Default draw mode\n        \"\"\"\n        self.ctx = context.ctx()\n        self.name = name\n        self.mode = mode\n        try:\n            DRAW_MODES[self.mode]\n        except KeyError:\n            raise VAOError('Invalid draw mode. Options are {}'.format(DRAW_MODES.values()))\n        self.buffers = []\n        self._index_buffer = None\n        self._index_element_size = None\n        self.vertex_count = 0\n        self.vaos = {}\n\n    def render(self, program: moderngl.Program, mode=None, vertices=-1, first=0, instances=1):\n        \"\"\"\n        Render the VAO.\n\n        Args:\n            program: The ``moderngl.Program``\n\n        Keyword Args:\n            mode: Override the draw mode (``TRIANGLES`` etc)\n            vertices (int): The number of vertices to transform\n            first (int): The index of the first vertex to start with\n            instances (int): The number of instances\n        \"\"\"\n        vao = self.instance(program)\n        if mode is None:\n            mode = self.mode\n        vao.render(mode, vertices=vertices, first=first, instances=instances)\n\n    def render_indirect(self, program: moderngl.Program, buffer, mode=None, count=-1, *, first=0):\n        \"\"\"\n        The render primitive (mode) must be the same as the input primitive of the GeometryShader.\n        The draw commands are 5 integers: (count, instanceCount, firstIndex, baseVertex, baseInstance).\n\n        Args:\n            program: The ``moderngl.Program``\n            buffer: The ``moderngl.Buffer`` containing indirect draw commands\n\n        Keyword Args:\n            mode (int): By default :py:data:`TRIANGLES` will be used.\n            count (int): The number of draws.\n            first (int): The index of the first indirect draw command.\n        \"\"\"\n        vao = self.instance(program)\n        if mode is None:\n            mode = self.mode\n        vao.render_indirect(buffer, mode=mode, count=count, first=first)\n\n    def transform(self, program: moderngl.Program, buffer: moderngl.Buffer, mode=None, vertices=-1, first=0, instances=1):\n        \"\"\"\n        Transform vertices. Stores the output in a single buffer.\n\n        Args:\n            program: The ``moderngl.Program``\n            buffer: The ``moderngl.buffer`` to store the output\n\n        Keyword Args:\n            mode: Draw mode (for example ``moderngl.POINTS``)\n            vertices (int): The number of vertices to transform\n            first (int): The index of the first vertex to start with\n            instances (int): The number of instances\n        \"\"\"\n        vao = self.instance(program)\n        if mode is None:\n            mode = self.mode\n        vao.transform(buffer, mode=mode, vertices=vertices, first=first, instances=instances)\n\n    def buffer(self, buffer, buffer_format: str, attribute_names, per_instance=False):\n        \"\"\"\n        Register a buffer/vbo for the VAO. This can be called multiple times.\n        adding multiple buffers (interleaved or not)\n\n        Args:\n            buffer: The buffer data. Can be ``numpy.array``, ``moderngl.Buffer`` or ``bytes``.\n            buffer_format (str): The format of the buffer. (eg. ``3f 3f`` for interleaved positions and normals).\n            attribute_names: A list of attribute names this buffer should map to.\n\n        Keyword Args:\n            per_instance (bool): Is this buffer per instance data for instanced rendering?\n\n        Returns:\n            The ``moderngl.Buffer`` instance object. This is handy when providing ``bytes`` and ``numpy.array``.\n        \"\"\"\n        if not isinstance(attribute_names, list):\n            attribute_names = [attribute_names]\n        if not type(buffer) in [moderngl.Buffer, numpy.ndarray, bytes]:\n            raise VAOError('buffer parameter must be a moderngl.Buffer, numpy.ndarray or bytes instance(not {})'.format(type(buffer)))\n        if isinstance(buffer, numpy.ndarray):\n            buffer = self.ctx.buffer(buffer.tobytes())\n        if isinstance(buffer, bytes):\n            buffer = self.ctx.buffer(data=buffer)\n        formats = buffer_format.split()\n        if len(formats) != len(attribute_names):\n            raise VAOError(\"Format '{}' does not describe attributes {}\".format(buffer_format, attribute_names))\n        self.buffers.append(BufferInfo(buffer, buffer_format, attribute_names, per_instance=per_instance))\n        self.vertex_count = self.buffers[-1].vertices\n        return buffer\n\n    def index_buffer(self, buffer, index_element_size=4):\n        \"\"\"\n        Set the index buffer for this VAO\n\n        Args:\n            buffer: ``moderngl.Buffer``, ``numpy.array`` or ``bytes``\n\n        Keyword Args:\n            index_element_size (int): Byte size of each element. 1, 2 or 4\n        \"\"\"\n        if not type(buffer) in [moderngl.Buffer, numpy.ndarray, bytes]:\n            raise VAOError('buffer parameter must be a moderngl.Buffer, numpy.ndarray or bytes instance')\n        if isinstance(buffer, numpy.ndarray):\n            buffer = self.ctx.buffer(buffer.tobytes())\n        if isinstance(buffer, bytes):\n            buffer = self.ctx.buffer(data=buffer)\n        self._index_buffer = buffer\n        self._index_element_size = index_element_size\n\n    def instance(self, program: moderngl.Program) -> moderngl.VertexArray:\n        \"\"\"\n        Obtain the ``moderngl.VertexArray`` instance for the program.\n        The instance is only created once and cached internally.\n\n        Returns: ``moderngl.VertexArray`` instance\n        \"\"\"\n        vao = self.vaos.get(program.glo)\n        if vao:\n            return vao\n        program_attributes = [name for name, attr in program._members.items() if isinstance(attr, moderngl.Attribute)]\n        for attrib_name in program_attributes:\n            if attrib_name.startswith('gl_'):\n                continue\n            if not sum((buffer.has_attribute(attrib_name) for buffer in self.buffers)):\n                raise VAOError(\"VAO {} doesn't have attribute {} for program {}\".format(self.name, attrib_name, program.name))\n        vao_content = []\n        for buffer in self.buffers:\n            content = buffer.content(program_attributes)\n            if content:\n                vao_content.append(content)\n        if program_attributes:\n            for attrib_name in program_attributes:\n                if attrib_name.startswith('gl_'):\n                    continue\n                raise VAOError('Did not find a buffer mapping for {}'.format([n for n in program_attributes]))\n        if self._index_buffer:\n            vao = context.ctx().vertex_array(program, vao_content, self._index_buffer, self._index_element_size)\n        else:\n            vao = context.ctx().vertex_array(program, vao_content)\n        self.vaos[program.glo] = vao\n        return vao\n\n    def release(self, buffer=True):\n        \"\"\"\n        Destroy the vao object\n\n        Keyword Args:\n            buffers (bool): also release buffers\n        \"\"\"\n        for key, vao in self.vaos:\n            vao.release()\n        if buffer:\n            for buff in self.buffers:\n                buff.buffer.release()\n            if self._index_buffer:\n                self._index_buffer.release()\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass ToTensor:\n    '''\n    Converts an image from a numpy array to a PyTorch tensor.\n    This class is designed to be part of a transformation pipeline, e.g., T.Compose([LetterBox(size), ToTensor()]).\n    Attributes:\n        half (bool): If True, converts the image to half precision (float16).\n    Methods:\n        __call__: Applies the tensor conversion to an input image.\n    Examples:\n        >>> transform = ToTensor(half=True)\n        >>> img = np.random.randint(0, 255, (640, 640, 3), dtype=np.uint8)\n        >>> tensor_img = transform(img)\n        >>> print(tensor_img.shape, tensor_img.dtype)\n        torch.Size([3, 640, 640]) torch.float16\n    Notes:\n        The input image is expected to be in BGR format with shape (H, W, C).\n        The output tensor will be in RGB format with shape (C, H, W), normalized to [0, 1].\n    '''\n\n    def __init__(self, half=False):\n        '''\n        Initializes the ToTensor object for converting images to PyTorch tensors.\n        This class is designed to be used as part of a transformation pipeline for image preprocessing in the\n        Ultralytics YOLO framework. It converts numpy arrays or PIL Images to PyTorch tensors, with an option\n        for half-precision (float16) conversion.\n        Args:\n            half (bool): If True, converts the tensor to half precision (float16). Default is False.\n        Examples:\n            >>> transform = ToTensor(half=True)\n            >>> img = np.random.rand(640, 640, 3)\n            >>> tensor_img = transform(img)\n            >>> print(tensor_img.dtype)\n            torch.float16\n        '''\n        pass\n\n    def __call__(self, im):\n        '''\n        Transforms an image from a numpy array to a PyTorch tensor.\n        This method converts the input image from a numpy array to a PyTorch tensor, applying optional\n        half-precision conversion and normalization. The image is transposed from HWC to CHW format and\n        the color channels are reversed from BGR to RGB.\n        Args:\n            im (numpy.ndarray): Input image as a numpy array with shape (H, W, C) in BGR order.\n        Returns:\n            (torch.Tensor): The transformed image as a PyTorch tensor in float32 or float16, normalized\n                to [0, 1] with shape (C, H, W) in RGB order.\n        Examples:\n            >>> transform = ToTensor(half=True)\n            >>> img = np.random.randint(0, 255, (640, 640, 3), dtype=np.uint8)\n            >>> tensor_img = transform(img)\n            >>> print(tensor_img.shape, tensor_img.dtype)\n            torch.Size([3, 640, 640]) torch.float16\n        '''\n        pass"
  }
]