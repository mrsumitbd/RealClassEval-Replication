[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass CSFileSystem(file_system.FileSystem):\n    '''File system that uses pyfvde.'''\n\n    def __init__(self, resolver_context, path_spec):\n        '''Initializes a file system.\n        Args:\n          resolver_context (Context): resolver context.\n          path_spec (PathSpec): a path specification.\n        '''\n        pass\n\n    def _Close(self):\n        '''Closes the file system.\n        Raises:\n          IOError: if the close failed.\n        '''\n        pass\n\n    def _Open(self, mode='rb'):\n        '''Opens the file system defined by path specification.\n        Args:\n          mode (Optional[str]): file access mode. The default is 'rb'\n              read-only binary.\n        Raises:\n          AccessError: if the access to open the file was denied.\n          IOError: if the file system could not be opened.\n          PathSpecError: if the path specification is incorrect.\n          ValueError: if the path specification is invalid.\n        '''\n        pass\n\n    def FileEntryExistsByPathSpec(self, path_spec):\n        '''Determines if a file entry for a path specification exists.\n        Args:\n          path_spec (PathSpec): path specification.\n        Returns:\n          bool: True if the file entry exists.\n        '''\n        pass\n\n    def GetFileEntryByPathSpec(self, path_spec):\n        '''Retrieves a file entry for a path specification.\n        Args:\n          path_spec (PathSpec): path specification.\n        Returns:\n          CSFileEntry: a file entry or None if not available.\n        '''\n        pass\n\n    def GetFVDELogicalVolumeByPathSpec(self, path_spec):\n        '''Retrieves a Core Storage logical volume for a path specification.\n        Args:\n          path_spec (PathSpec): path specification.\n        Returns:\n          pyfvde.logical_volume: a Core Storage logical volume or None if not\n              available.\n        '''\n        pass\n\n    def GetFVDEVolumeGroup(self):\n        '''Retrieves the Core Storage volume group.\n        Returns:\n          pyfvde.volume_group: a Core Storage volume group.\n        '''\n        pass\n\n    def GetRootFileEntry(self):\n        '''Retrieves the root file entry.\n        Returns:\n          CSFileEntry: root file entry or None if not available.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom dfvfs.lib import errors\nfrom dfvfs.lib import definitions\nimport pyfvde\nfrom dfvfs.path import cs_path_spec\nfrom dfvfs.resolver import resolver\nfrom dfvfs.vfs import cs_file_entry\nfrom dfvfs.lib import cs_helper\nfrom dfvfs.vfs import file_system\n\nclass CSFileSystem(file_system.FileSystem):\n    \"\"\"File system that uses pyfvde.\"\"\"\n    TYPE_INDICATOR = definitions.TYPE_INDICATOR_CS\n\n    def __init__(self, resolver_context, path_spec):\n        \"\"\"Initializes a file system.\n\n        Args:\n          resolver_context (Context): resolver context.\n          path_spec (PathSpec): a path specification.\n        \"\"\"\n        super(CSFileSystem, self).__init__(resolver_context, path_spec)\n        self._fvde_volume = None\n        self._fvde_volume_group = None\n        self._file_object = None\n\n    def _Close(self):\n        \"\"\"Closes the file system.\n\n        Raises:\n          IOError: if the close failed.\n        \"\"\"\n        self._fvde_volume_group = None\n        self._fvde_volume.close()\n        self._fvde_volume = None\n        self._file_object = None\n\n    def _Open(self, mode='rb'):\n        \"\"\"Opens the file system defined by path specification.\n\n        Args:\n          mode (Optional[str]): file access mode. The default is 'rb'\n              read-only binary.\n\n        Raises:\n          AccessError: if the access to open the file was denied.\n          IOError: if the file system could not be opened.\n          PathSpecError: if the path specification is incorrect.\n          ValueError: if the path specification is invalid.\n        \"\"\"\n        if not self._path_spec.HasParent():\n            raise errors.PathSpecError('Unsupported path specification without parent.')\n        resolver.Resolver.key_chain.ExtractCredentialsFromPathSpec(self._path_spec)\n        file_object = resolver.Resolver.OpenFileObject(self._path_spec.parent, resolver_context=self._resolver_context)\n        fvde_volume = pyfvde.volume()\n        encrypted_root_plist = resolver.Resolver.key_chain.GetCredential(self._path_spec, 'encrypted_root_plist')\n        if encrypted_root_plist:\n            fvde_volume.read_encrypted_root_plist(encrypted_root_plist)\n        fvde_volume.open_file_object(file_object)\n        fvde_volume.open_physical_volume_files_as_file_objects([file_object])\n        fvde_volume_group = fvde_volume.get_volume_group()\n        self._file_object = file_object\n        self._fvde_volume = fvde_volume\n        self._fvde_volume_group = fvde_volume_group\n\n    def FileEntryExistsByPathSpec(self, path_spec):\n        \"\"\"Determines if a file entry for a path specification exists.\n\n        Args:\n          path_spec (PathSpec): path specification.\n\n        Returns:\n          bool: True if the file entry exists.\n        \"\"\"\n        volume_index = cs_helper.CSPathSpecGetVolumeIndex(path_spec)\n        if volume_index is None:\n            location = getattr(path_spec, 'location', None)\n            return location is not None and location == self.LOCATION_ROOT\n        return 0 <= volume_index < self._fvde_volume_group.number_of_logical_volumes\n\n    def GetFileEntryByPathSpec(self, path_spec):\n        \"\"\"Retrieves a file entry for a path specification.\n\n        Args:\n          path_spec (PathSpec): path specification.\n\n        Returns:\n          CSFileEntry: a file entry or None if not available.\n        \"\"\"\n        volume_index = cs_helper.CSPathSpecGetVolumeIndex(path_spec)\n        if volume_index is None:\n            location = getattr(path_spec, 'location', None)\n            if location is None or location != self.LOCATION_ROOT:\n                return None\n            return cs_file_entry.CSFileEntry(self._resolver_context, self, path_spec, is_root=True, is_virtual=True)\n        if volume_index < 0 or volume_index >= self._fvde_volume_group.number_of_logical_volumes:\n            return None\n        return cs_file_entry.CSFileEntry(self._resolver_context, self, path_spec)\n\n    def GetFVDELogicalVolumeByPathSpec(self, path_spec):\n        \"\"\"Retrieves a Core Storage logical volume for a path specification.\n\n        Args:\n          path_spec (PathSpec): path specification.\n\n        Returns:\n          pyfvde.logical_volume: a Core Storage logical volume or None if not\n              available.\n        \"\"\"\n        volume_index = cs_helper.CSPathSpecGetVolumeIndex(path_spec)\n        if volume_index is None:\n            return None\n        return self._fvde_volume_group.get_logical_volume(volume_index)\n\n    def GetFVDEVolumeGroup(self):\n        \"\"\"Retrieves the Core Storage volume group.\n\n        Returns:\n          pyfvde.volume_group: a Core Storage volume group.\n        \"\"\"\n        return self._fvde_volume_group\n\n    def GetRootFileEntry(self):\n        \"\"\"Retrieves the root file entry.\n\n        Returns:\n          CSFileEntry: root file entry or None if not available.\n        \"\"\"\n        path_spec = cs_path_spec.CSPathSpec(location=self.LOCATION_ROOT, parent=self._path_spec.parent)\n        return self.GetFileEntryByPathSpec(path_spec)\n\nExample skeleton:\n\n\nclass Job(AbstractJob):\n\n    def __init__(self, model: AbstractPriorModel, simulate_cls: Callable, perturb_model: AbstractPriorModel, simulate_instance: ModelInstance, base_instance: ModelInstance, base_fit_cls: Callable, perturb_fit_cls: Callable, paths: AbstractPaths, number: int):\n        '''\n        Job to run non-linear searches comparing how well a model and a model with a perturbation fit the image.\n        Parameters\n        ----------\n        model\n            A base model that fits the image without a perturbation\n        perturb_model\n            A model of the perturbation which has been added to the underlying image\n        base_fit_cls\n            A class which defines the function which fits the base model to each simulated dataset of the sensitivity\n            map.\n        perturb_fit_cls\n            A class which defines the function which fits the perturbed model to each simulated dataset of the\n            sensitivity map.\n        paths\n            The paths defining the output directory structure of the sensitivity mapping.\n        '''\n        pass\n    @property\n    def base_paths(self):\n        pass\n    @property\n    def perturb_paths(self):\n        pass\n    @property\n    def is_complete(self) -> bool:\n        '''\n        Returns True if the job has been completed, False otherwise.\n        '''\n        pass\n\n    def perform(self) -> JobResult:\n        '''\n        - Create one model with a perturbation and another without\n        - Fit each model against the perturbed image\n        Returns\n        -------\n        An object comprising the results of the two fits\n        '''\n        pass\nCorresponding class implementation:\n\nfrom copy import copy\nfrom itertools import count\nfrom autofit.mapper.prior_model.abstract import AbstractPriorModel\nfrom typing import Callable, Optional\nfrom autofit.non_linear.paths.abstract import AbstractPaths\nfrom autofit.mapper.model import ModelInstance\nfrom autofit.non_linear.parallel import AbstractJob, AbstractJobResult\n\nclass Job(AbstractJob):\n    _number = count()\n\n    def __init__(self, model: AbstractPriorModel, simulate_cls: Callable, perturb_model: AbstractPriorModel, simulate_instance: ModelInstance, base_instance: ModelInstance, base_fit_cls: Callable, perturb_fit_cls: Callable, paths: AbstractPaths, number: int):\n        \"\"\"\n        Job to run non-linear searches comparing how well a model and a model with a perturbation fit the image.\n\n        Parameters\n        ----------\n        model\n            A base model that fits the image without a perturbation\n        perturb_model\n            A model of the perturbation which has been added to the underlying image\n        base_fit_cls\n            A class which defines the function which fits the base model to each simulated dataset of the sensitivity\n            map.\n        perturb_fit_cls\n            A class which defines the function which fits the perturbed model to each simulated dataset of the\n            sensitivity map.\n        paths\n            The paths defining the output directory structure of the sensitivity mapping.\n        \"\"\"\n        super().__init__(number=number)\n        self.model = model\n        self.simulate_cls = simulate_cls\n        self.perturb_model = perturb_model\n        self.simulate_instance = simulate_instance\n        self.base_instance = base_instance\n        self.base_fit_cls = base_fit_cls\n        self.perturb_fit_cls = perturb_fit_cls\n        self.paths = paths\n\n    @property\n    def base_paths(self):\n        return self.paths.for_sub_analysis('[base]')\n\n    @property\n    def perturb_paths(self):\n        return self.paths.for_sub_analysis('[perturb]')\n\n    @property\n    def is_complete(self) -> bool:\n        \"\"\"\n        Returns True if the job has been completed, False otherwise.\n        \"\"\"\n        return self.base_paths.is_complete and self.perturb_paths.is_complete or ((self.paths.output_path / '[base].zip').exists() and (self.paths.output_path / '[perturb].zip').exists())\n\n    def perform(self) -> JobResult:\n        \"\"\"\n        - Create one model with a perturbation and another without\n        - Fit each model against the perturbed image\n\n        Returns\n        -------\n        An object comprising the results of the two fits\n        \"\"\"\n        if self.is_complete:\n            dataset = None\n        else:\n            dataset = self.simulate_cls(instance=self.simulate_instance, simulate_path=self.paths.image_path.with_name('simulate'))\n        result = self.base_fit_cls(model=self.model, dataset=dataset, paths=self.base_paths, instance=self.simulate_instance)\n        perturb_model = copy(self.model)\n        perturb_model.perturb = self.perturb_model\n        perturb_result = self.perturb_fit_cls(model=perturb_model, dataset=dataset, paths=self.perturb_paths, instance=self.simulate_instance)\n        return JobResult(number=self.number, result=result, perturb_result=perturb_result)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass PSDConeProjection:\n    '''\n    Initial implementation of psd_cone_projection task.\n    This will be evolved by OpenEvolve to improve performance and correctness.\n    '''\n\n    def __init__(self):\n        '''Initialize the PSDConeProjection.'''\n        pass\n\n    def solve(self, problem):\n        '''\n        Solve the psd_cone_projection problem.\n        Args:\n            problem: Dictionary containing problem data specific to psd_cone_projection\n        Returns:\n            The solution in the format expected by the task\n        '''\n        pass\n\n    def is_solution(self, problem, solution):\n        '''\n        Check if the provided solution is valid.\n        Args:\n            problem: The original problem\n            solution: The proposed solution\n        Returns:\n            True if the solution is valid, False otherwise\n        '''\n        pass"
  }
]