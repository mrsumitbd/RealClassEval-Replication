[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass GeopediaWmsRequest(GeopediaRequest):\n    '''Web Map Service request class for Geopedia\n    Creates an instance of Geopedia's WMS (Web Map Service) GetMap request, which provides access to WMS layers in\n    Geopedia.\n    '''\n\n    def __init__(self, layer: str | int, theme: str, bbox: BBox, *, width: int | None=None, height: int | None=None, **kwargs: Any):\n        '''\n        :param layer: Geopedia layer which contains requested data\n        :param theme: Geopedia's theme endpoint string for which the layer is defined.\n        :param bbox: Bounding box of the requested data\n        :param width: width (number of columns) of the returned image (array)\n        :param height: height (number of rows) of the returned image (array)\n        :param image_format: Format of the returned image by the Sentinel Hub's WMS getMap service. Default is\n            ``constants.MimeType.PNG``.\n        :param data_folder: Location of the directory where the fetched data will be saved.\n        :param config: A custom instance of config class to override parameters from the saved configuration.\n        '''\n        pass\n\n    def create_request(self) -> None:\n        '''Set download requests\n        Create a list of DownloadRequests for all Sentinel-2 acquisitions within request's time interval and\n        acceptable cloud coverage.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom ..geometry import BBox\nfrom ..constants import CRS, MimeType, ServiceType\nfrom .core import GeopediaFeatureIterator, GeopediaImageService, GeopediaSession, GeopediaWmsService\nfrom typing import Any\n\nclass GeopediaWmsRequest(GeopediaRequest):\n    \"\"\"Web Map Service request class for Geopedia\n\n    Creates an instance of Geopedia's WMS (Web Map Service) GetMap request, which provides access to WMS layers in\n    Geopedia.\n    \"\"\"\n\n    def __init__(self, layer: str | int, theme: str, bbox: BBox, *, width: int | None=None, height: int | None=None, **kwargs: Any):\n        \"\"\"\n        :param layer: Geopedia layer which contains requested data\n        :param theme: Geopedia's theme endpoint string for which the layer is defined.\n        :param bbox: Bounding box of the requested data\n        :param width: width (number of columns) of the returned image (array)\n        :param height: height (number of rows) of the returned image (array)\n        :param image_format: Format of the returned image by the Sentinel Hub's WMS getMap service. Default is\n            ``constants.MimeType.PNG``.\n        :param data_folder: Location of the directory where the fetched data will be saved.\n        :param config: A custom instance of config class to override parameters from the saved configuration.\n        \"\"\"\n        self.size_x = width\n        self.size_y = height\n        super().__init__(layer=layer, theme=theme, bbox=bbox, service_type=ServiceType.WMS, **kwargs)\n\n    def create_request(self) -> None:\n        \"\"\"Set download requests\n\n        Create a list of DownloadRequests for all Sentinel-2 acquisitions within request's time interval and\n        acceptable cloud coverage.\n        \"\"\"\n        gpd_service = GeopediaWmsService(config=self.config)\n        self.download_list = gpd_service.get_request(self)\n\nExample skeleton:\n\n@utils.registerPlexObject\nclass MediaPart(PlexObject):\n    ''' Represents a single media part (often a single file) for the media this belongs to.\n        Attributes:\n            TAG (str): 'Part'\n            accessible (bool): True if the file is accessible.\n                Requires reloading the media with ``checkFiles=True``.\n                Refer to :func:`~plexapi.base.PlexObject.reload`.\n            audioProfile (str): The audio profile of the file.\n            container (str): The container type of the file (ex: avi).\n            decision (str): Unknown.\n            deepAnalysisVersion (int): The Plex deep analysis version for the file.\n            duration (int): The duration of the file in milliseconds.\n            exists (bool): True if the file exists.\n                Requires reloading the media with ``checkFiles=True``.\n                Refer to :func:`~plexapi.base.PlexObject.reload`.\n            file (str): The path to this file on disk (ex: /media/Movies/Cars (2006)/Cars (2006).mkv)\n            has64bitOffsets (bool): True if the file has 64 bit offsets.\n            hasThumbnail (bool): True if the file (track) has an embedded thumbnail.\n            id (int): The unique ID for this media part on the server.\n            indexes (str, None): sd if the file has generated preview (BIF) thumbnails.\n            key (str): API URL (ex: /library/parts/46618/1389985872/file.mkv).\n            optimizedForStreaming (bool): True if the file is optimized for streaming.\n            packetLength (int): The packet length of the file.\n            requiredBandwidths (str): The required bandwidths to stream the file.\n            selected (bool): True if this media part is selected.\n            size (int): The size of the file in bytes (ex: 733884416).\n            streams (List<:class:`~plexapi.media.MediaPartStream`>): List of stream objects.\n            syncItemId (int): The unique ID for this media part if it is synced.\n            syncState (str): The sync state for this media part.\n            videoProfile (str): The video profile of the file.\n    '''\n\n    def _loadData(self, data):\n        ''' Load attribute values from Plex XML response. '''\n        pass\n\n    def _buildStreams(self, data):\n        ''' Returns a list of :class:`~plexapi.media.MediaPartStream` objects in this MediaPart. '''\n        pass\n    @property\n    def hasPreviewThumbnails(self):\n        ''' Returns True if the media part has generated preview (BIF) thumbnails. '''\n        pass\n\n    def videoStreams(self):\n        ''' Returns a list of :class:`~plexapi.media.VideoStream` objects in this MediaPart. '''\n        pass\n\n    def audioStreams(self):\n        ''' Returns a list of :class:`~plexapi.media.AudioStream` objects in this MediaPart. '''\n        pass\n\n    def subtitleStreams(self):\n        ''' Returns a list of :class:`~plexapi.media.SubtitleStream` objects in this MediaPart. '''\n        pass\n\n    def lyricStreams(self):\n        ''' Returns a list of :class:`~plexapi.media.LyricStream` objects in this MediaPart. '''\n        pass\n\n    def setSelectedAudioStream(self, stream):\n        ''' Set the selected :class:`~plexapi.media.AudioStream` for this MediaPart.\n            Parameters:\n                stream (:class:`~plexapi.media.AudioStream`): Audio stream to set as selected\n        '''\n        pass\n\n    def setSelectedSubtitleStream(self, stream):\n        ''' Set the selected :class:`~plexapi.media.SubtitleStream` for this MediaPart.\n            Parameters:\n                stream (:class:`~plexapi.media.SubtitleStream`): Subtitle stream to set as selected.\n        '''\n        pass\n\n    def resetSelectedSubtitleStream(self):\n        ''' Set the selected subtitle of this MediaPart to 'None'. '''\n        pass\n    @deprecated('Use \"setSelectedAudioStream\" instead.')\n    def setDefaultAudioStream(self, stream):\n        pass\n    @deprecated('Use \"setSelectedSubtitleStream\" instead.')\n    def setDefaultSubtitleStream(self, stream):\n        pass\n    @deprecated('Use \"resetSelectedSubtitleStream\" instead.')\n    def resetDefaultSubtitleStream(self):\n        pass\nCorresponding class implementation:\n\nfrom plexapi.utils import deprecated\nfrom plexapi.base import PlexObject, cached_data_property\nfrom plexapi import log, settings, utils\n\n@utils.registerPlexObject\nclass MediaPart(PlexObject):\n    \"\"\" Represents a single media part (often a single file) for the media this belongs to.\n\n        Attributes:\n            TAG (str): 'Part'\n            accessible (bool): True if the file is accessible.\n                Requires reloading the media with ``checkFiles=True``.\n                Refer to :func:`~plexapi.base.PlexObject.reload`.\n            audioProfile (str): The audio profile of the file.\n            container (str): The container type of the file (ex: avi).\n            decision (str): Unknown.\n            deepAnalysisVersion (int): The Plex deep analysis version for the file.\n            duration (int): The duration of the file in milliseconds.\n            exists (bool): True if the file exists.\n                Requires reloading the media with ``checkFiles=True``.\n                Refer to :func:`~plexapi.base.PlexObject.reload`.\n            file (str): The path to this file on disk (ex: /media/Movies/Cars (2006)/Cars (2006).mkv)\n            has64bitOffsets (bool): True if the file has 64 bit offsets.\n            hasThumbnail (bool): True if the file (track) has an embedded thumbnail.\n            id (int): The unique ID for this media part on the server.\n            indexes (str, None): sd if the file has generated preview (BIF) thumbnails.\n            key (str): API URL (ex: /library/parts/46618/1389985872/file.mkv).\n            optimizedForStreaming (bool): True if the file is optimized for streaming.\n            packetLength (int): The packet length of the file.\n            requiredBandwidths (str): The required bandwidths to stream the file.\n            selected (bool): True if this media part is selected.\n            size (int): The size of the file in bytes (ex: 733884416).\n            streams (List<:class:`~plexapi.media.MediaPartStream`>): List of stream objects.\n            syncItemId (int): The unique ID for this media part if it is synced.\n            syncState (str): The sync state for this media part.\n            videoProfile (str): The video profile of the file.\n    \"\"\"\n    TAG = 'Part'\n\n    def _loadData(self, data):\n        \"\"\" Load attribute values from Plex XML response. \"\"\"\n        self.accessible = utils.cast(bool, data.attrib.get('accessible'))\n        self.audioProfile = data.attrib.get('audioProfile')\n        self.container = data.attrib.get('container')\n        self.decision = data.attrib.get('decision')\n        self.deepAnalysisVersion = utils.cast(int, data.attrib.get('deepAnalysisVersion'))\n        self.duration = utils.cast(int, data.attrib.get('duration'))\n        self.exists = utils.cast(bool, data.attrib.get('exists'))\n        self.file = data.attrib.get('file')\n        self.has64bitOffsets = utils.cast(bool, data.attrib.get('has64bitOffsets'))\n        self.hasThumbnail = utils.cast(bool, data.attrib.get('hasThumbnail'))\n        self.id = utils.cast(int, data.attrib.get('id'))\n        self.indexes = data.attrib.get('indexes')\n        self.key = data.attrib.get('key')\n        self.optimizedForStreaming = utils.cast(bool, data.attrib.get('optimizedForStreaming'))\n        self.packetLength = utils.cast(int, data.attrib.get('packetLength'))\n        self.protocol = data.attrib.get('protocol')\n        self.requiredBandwidths = data.attrib.get('requiredBandwidths')\n        self.selected = utils.cast(bool, data.attrib.get('selected'))\n        self.size = utils.cast(int, data.attrib.get('size'))\n        self.streams = self._buildStreams(data)\n        self.syncItemId = utils.cast(int, data.attrib.get('syncItemId'))\n        self.syncState = data.attrib.get('syncState')\n        self.videoProfile = data.attrib.get('videoProfile')\n\n    def _buildStreams(self, data):\n        \"\"\" Returns a list of :class:`~plexapi.media.MediaPartStream` objects in this MediaPart. \"\"\"\n        return self.findItems(data)\n\n    @property\n    def hasPreviewThumbnails(self):\n        \"\"\" Returns True if the media part has generated preview (BIF) thumbnails. \"\"\"\n        return self.indexes == 'sd'\n\n    def videoStreams(self):\n        \"\"\" Returns a list of :class:`~plexapi.media.VideoStream` objects in this MediaPart. \"\"\"\n        return [stream for stream in self.streams if isinstance(stream, VideoStream)]\n\n    def audioStreams(self):\n        \"\"\" Returns a list of :class:`~plexapi.media.AudioStream` objects in this MediaPart. \"\"\"\n        return [stream for stream in self.streams if isinstance(stream, AudioStream)]\n\n    def subtitleStreams(self):\n        \"\"\" Returns a list of :class:`~plexapi.media.SubtitleStream` objects in this MediaPart. \"\"\"\n        return [stream for stream in self.streams if isinstance(stream, SubtitleStream)]\n\n    def lyricStreams(self):\n        \"\"\" Returns a list of :class:`~plexapi.media.LyricStream` objects in this MediaPart. \"\"\"\n        return [stream for stream in self.streams if isinstance(stream, LyricStream)]\n\n    def setSelectedAudioStream(self, stream):\n        \"\"\" Set the selected :class:`~plexapi.media.AudioStream` for this MediaPart.\n\n            Parameters:\n                stream (:class:`~plexapi.media.AudioStream`): Audio stream to set as selected\n        \"\"\"\n        key = f'/library/parts/{self.id}'\n        params = {'allParts': 1}\n        if isinstance(stream, AudioStream):\n            params['audioStreamID'] = stream.id\n        else:\n            params['audioStreamID'] = stream\n        self._server.query(key, method=self._server._session.put, params=params)\n        return self\n\n    def setSelectedSubtitleStream(self, stream):\n        \"\"\" Set the selected :class:`~plexapi.media.SubtitleStream` for this MediaPart.\n\n            Parameters:\n                stream (:class:`~plexapi.media.SubtitleStream`): Subtitle stream to set as selected.\n        \"\"\"\n        key = f'/library/parts/{self.id}'\n        params = {'allParts': 1}\n        if isinstance(stream, SubtitleStream):\n            params['subtitleStreamID'] = stream.id\n        else:\n            params['subtitleStreamID'] = stream\n        self._server.query(key, method=self._server._session.put, params=params)\n        return self\n\n    def resetSelectedSubtitleStream(self):\n        \"\"\" Set the selected subtitle of this MediaPart to 'None'. \"\"\"\n        key = f'/library/parts/{self.id}'\n        params = {'subtitleStreamID': 0, 'allParts': 1}\n        self._server.query(key, method=self._server._session.put, params=params)\n        return self\n\n    @deprecated('Use \"setSelectedAudioStream\" instead.')\n    def setDefaultAudioStream(self, stream):\n        return self.setSelectedAudioStream(stream)\n\n    @deprecated('Use \"setSelectedSubtitleStream\" instead.')\n    def setDefaultSubtitleStream(self, stream):\n        return self.setSelectedSubtitleStream(stream)\n\n    @deprecated('Use \"resetSelectedSubtitleStream\" instead.')\n    def resetDefaultSubtitleStream(self):\n        return self.resetSelectedSubtitleStream()\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass ParkingPtsSelection:\n    '''\n    A class for selecting and managing parking zone points on images using a Tkinter-based UI.\n    This class provides functionality to upload an image, select points to define parking zones, and save the\n    selected points to a JSON file. It uses Tkinter for the graphical user interface.\n    Attributes:\n        tk (module): The Tkinter module for GUI operations.\n        filedialog (module): Tkinter's filedialog module for file selection operations.\n        messagebox (module): Tkinter's messagebox module for displaying message boxes.\n        master (tk.Tk): The main Tkinter window.\n        canvas (tk.Canvas): The canvas widget for displaying the image and drawing bounding boxes.\n        image (PIL.Image.Image): The uploaded image.\n        canvas_image (ImageTk.PhotoImage): The image displayed on the canvas.\n        rg_data (List[List[Tuple[int, int]]]): List of bounding boxes, each defined by 4 points.\n        current_box (List[Tuple[int, int]]): Temporary storage for the points of the current bounding box.\n        imgw (int): Original width of the uploaded image.\n        imgh (int): Original height of the uploaded image.\n        canvas_max_width (int): Maximum width of the canvas.\n        canvas_max_height (int): Maximum height of the canvas.\n    Methods:\n        initialize_properties: Initializes the necessary properties.\n        upload_image: Uploads an image, resizes it to fit the canvas, and displays it.\n        on_canvas_click: Handles mouse clicks to add points for bounding boxes.\n        draw_box: Draws a bounding box on the canvas.\n        remove_last_bounding_box: Removes the last bounding box and redraws the canvas.\n        redraw_canvas: Redraws the canvas with the image and all bounding boxes.\n        save_to_json: Saves the bounding boxes to a JSON file.\n    Examples:\n        >>> parking_selector = ParkingPtsSelection()\n        >>> # Use the GUI to upload an image, select parking zones, and save the data\n    '''\n\n    def __init__(self):\n        '''Initializes the ParkingPtsSelection class, setting up UI and properties for parking zone point selection.'''\n        pass\n\n    def initialize_properties(self):\n        '''Initialize properties for image, canvas, bounding boxes, and dimensions.'''\n        pass\n\n    def upload_image(self):\n        '''Uploads and displays an image on the canvas, resizing it to fit within specified dimensions.'''\n        pass\n\n    def on_canvas_click(self, event):\n        '''Handles mouse clicks to add points for bounding boxes on the canvas.'''\n        pass\n\n    def draw_box(self, box):\n        '''Draws a bounding box on the canvas using the provided coordinates.'''\n        pass\n\n    def remove_last_bounding_box(self):\n        '''Removes the last bounding box from the list and redraws the canvas.'''\n        pass\n\n    def redraw_canvas(self):\n        '''Redraws the canvas with the image and all bounding boxes.'''\n        pass\n\n    def save_to_json(self):\n        '''Saves the selected parking zone points to a JSON file with scaled coordinates.'''\n        pass"
  }
]