[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass SearchSettingsConversationalSearch:\n    '''\n    Configuration settings for conversational search.\n    :param bool enabled: Whether to enable conversational search.\n    :param SearchSettingsConversationalSearchResponseLength response_length:\n          (optional)\n    :param SearchSettingsConversationalSearchSearchConfidence search_confidence:\n          (optional)\n    '''\n\n    def __init__(self, enabled: bool, *, response_length: Optional['SearchSettingsConversationalSearchResponseLength']=None, search_confidence: Optional['SearchSettingsConversationalSearchSearchConfidence']=None) -> None:\n        '''\n        Initialize a SearchSettingsConversationalSearch object.\n        :param bool enabled: Whether to enable conversational search.\n        :param SearchSettingsConversationalSearchResponseLength response_length:\n               (optional)\n        :param SearchSettingsConversationalSearchSearchConfidence\n               search_confidence: (optional)\n        '''\n        pass\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'SearchSettingsConversationalSearch':\n        '''Initialize a SearchSettingsConversationalSearch object from a json dictionary.'''\n        pass\n    @classmethod\n    def _from_dict(cls, _dict):\n        '''Initialize a SearchSettingsConversationalSearch object from a json dictionary.'''\n        pass\n\n    def to_dict(self) -> Dict:\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def _to_dict(self):\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Return a `str` version of this SearchSettingsConversationalSearch object.'''\n        pass\n\n    def __eq__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        '''Return `true` when self and other are equal, false otherwise.'''\n        pass\n\n    def __ne__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        '''Return `true` when self and other are not equal, false otherwise.'''\n        pass\nCorresponding class implementation:\n\nimport json\nfrom typing import BinaryIO, Dict, List, Optional\n\nclass SearchSettingsConversationalSearch:\n    \"\"\"\n    Configuration settings for conversational search.\n\n    :param bool enabled: Whether to enable conversational search.\n    :param SearchSettingsConversationalSearchResponseLength response_length:\n          (optional)\n    :param SearchSettingsConversationalSearchSearchConfidence search_confidence:\n          (optional)\n    \"\"\"\n\n    def __init__(self, enabled: bool, *, response_length: Optional['SearchSettingsConversationalSearchResponseLength']=None, search_confidence: Optional['SearchSettingsConversationalSearchSearchConfidence']=None) -> None:\n        \"\"\"\n        Initialize a SearchSettingsConversationalSearch object.\n\n        :param bool enabled: Whether to enable conversational search.\n        :param SearchSettingsConversationalSearchResponseLength response_length:\n               (optional)\n        :param SearchSettingsConversationalSearchSearchConfidence\n               search_confidence: (optional)\n        \"\"\"\n        self.enabled = enabled\n        self.response_length = response_length\n        self.search_confidence = search_confidence\n\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'SearchSettingsConversationalSearch':\n        \"\"\"Initialize a SearchSettingsConversationalSearch object from a json dictionary.\"\"\"\n        args = {}\n        if (enabled := _dict.get('enabled')) is not None:\n            args['enabled'] = enabled\n        else:\n            raise ValueError(\"Required property 'enabled' not present in SearchSettingsConversationalSearch JSON\")\n        if (response_length := _dict.get('response_length')) is not None:\n            args['response_length'] = SearchSettingsConversationalSearchResponseLength.from_dict(response_length)\n        if (search_confidence := _dict.get('search_confidence')) is not None:\n            args['search_confidence'] = SearchSettingsConversationalSearchSearchConfidence.from_dict(search_confidence)\n        return cls(**args)\n\n    @classmethod\n    def _from_dict(cls, _dict):\n        \"\"\"Initialize a SearchSettingsConversationalSearch object from a json dictionary.\"\"\"\n        return cls.from_dict(_dict)\n\n    def to_dict(self) -> Dict:\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        _dict = {}\n        if hasattr(self, 'enabled') and self.enabled is not None:\n            _dict['enabled'] = self.enabled\n        if hasattr(self, 'response_length') and self.response_length is not None:\n            if isinstance(self.response_length, dict):\n                _dict['response_length'] = self.response_length\n            else:\n                _dict['response_length'] = self.response_length.to_dict()\n        if hasattr(self, 'search_confidence') and self.search_confidence is not None:\n            if isinstance(self.search_confidence, dict):\n                _dict['search_confidence'] = self.search_confidence\n            else:\n                _dict['search_confidence'] = self.search_confidence.to_dict()\n        return _dict\n\n    def _to_dict(self):\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        return self.to_dict()\n\n    def __str__(self) -> str:\n        \"\"\"Return a `str` version of this SearchSettingsConversationalSearch object.\"\"\"\n        return json.dumps(self.to_dict(), indent=2)\n\n    def __eq__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        \"\"\"Return `true` when self and other are equal, false otherwise.\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        \"\"\"Return `true` when self and other are not equal, false otherwise.\"\"\"\n        return not self == other\n\nExample skeleton:\n\nclass AnalyzersManager(object):\n    '''Class that implements the analyzers manager.'''\n    @classmethod\n    def DeregisterAnalyzer(cls, analyzer_class):\n        '''Deregisters a analyzer class.\n        The analyzer classes are identified based on their lower case name.\n        Args:\n          analyzer_class (type): class object of the analyzer.\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzersInformation(cls):\n        '''Retrieves the analyzers information.\n        Returns:\n          list[tuple]: containing:\n            str: analyzer name.\n            str: analyzer description.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzerInstance(cls, analyzer_name):\n        '''Retrieves an instance of a specific analyzer.\n        Args:\n          analyzer_name (str): name of the analyzer to retrieve.\n        Returns:\n          BaseAnalyzer: analyzer instance.\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzerInstances(cls, analyzer_names):\n        '''Retrieves instances for all the specified analyzers.\n        Args:\n          analyzer_names (list[str]): names of the analyzers to retrieve.\n        Returns:\n          list[BaseAnalyzer]: analyzer instances.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzerNames(cls):\n        '''Retrieves the names of all loaded analyzers.\n        Returns:\n          list[str]: of analyzer names.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzersInformation(cls):\n        '''Retrieves the registered analyzers.\n        Yields:\n          tuple: containing:\n            str: the uniquely identifying name of the analyzer\n            type: the analyzer class.\n        '''\n        pass\n    @classmethod\n    def RegisterAnalyzer(cls, analyzer_class):\n        '''Registers a analyzer class.\n        The analyzer classes are identified by their lower case name.\n        Args:\n          analyzer_class (type): the analyzer class to register.\n        Raises:\n          KeyError: if analyzer class is already set for the corresponding name.\n        '''\n        pass\nCorresponding class implementation:\n\nclass AnalyzersManager(object):\n    \"\"\"Class that implements the analyzers manager.\"\"\"\n    _analyzer_classes = {}\n\n    @classmethod\n    def DeregisterAnalyzer(cls, analyzer_class):\n        \"\"\"Deregisters a analyzer class.\n\n        The analyzer classes are identified based on their lower case name.\n\n        Args:\n          analyzer_class (type): class object of the analyzer.\n\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        \"\"\"\n        analyzer_name = analyzer_class.NAME.lower()\n        if analyzer_name not in cls._analyzer_classes:\n            raise KeyError(f'analyzer class not set for name: {analyzer_class.NAME:s}')\n        del cls._analyzer_classes[analyzer_name]\n\n    @classmethod\n    def GetAnalyzersInformation(cls):\n        \"\"\"Retrieves the analyzers information.\n\n        Returns:\n          list[tuple]: containing:\n\n            str: analyzer name.\n            str: analyzer description.\n        \"\"\"\n        analyzer_information = []\n        for _, analyzer_class in cls.GetAnalyzers():\n            description = getattr(analyzer_class, 'DESCRIPTION', '')\n            analyzer_information.append((analyzer_class.NAME, description))\n        return analyzer_information\n\n    @classmethod\n    def GetAnalyzerInstance(cls, analyzer_name):\n        \"\"\"Retrieves an instance of a specific analyzer.\n\n        Args:\n          analyzer_name (str): name of the analyzer to retrieve.\n\n        Returns:\n          BaseAnalyzer: analyzer instance.\n\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        \"\"\"\n        analyzer_name = analyzer_name.lower()\n        if analyzer_name not in cls._analyzer_classes:\n            raise KeyError(f'analyzer class not set for name: {analyzer_name:s}.')\n        analyzer_class = cls._analyzer_classes[analyzer_name]\n        return analyzer_class()\n\n    @classmethod\n    def GetAnalyzerInstances(cls, analyzer_names):\n        \"\"\"Retrieves instances for all the specified analyzers.\n\n        Args:\n          analyzer_names (list[str]): names of the analyzers to retrieve.\n\n        Returns:\n          list[BaseAnalyzer]: analyzer instances.\n        \"\"\"\n        analyzer_instances = []\n        for analyzer_name, analyzer_class in cls.GetAnalyzers():\n            if analyzer_name in analyzer_names:\n                analyzer_instances.append(analyzer_class())\n        return analyzer_instances\n\n    @classmethod\n    def GetAnalyzerNames(cls):\n        \"\"\"Retrieves the names of all loaded analyzers.\n\n        Returns:\n          list[str]: of analyzer names.\n        \"\"\"\n        return cls._analyzer_classes.keys()\n\n    @classmethod\n    def GetAnalyzers(cls):\n        \"\"\"Retrieves the registered analyzers.\n\n        Yields:\n          tuple: containing:\n\n            str: the uniquely identifying name of the analyzer\n            type: the analyzer class.\n        \"\"\"\n        for analyzer_name, analyzer_class in cls._analyzer_classes.items():\n            yield (analyzer_name, analyzer_class)\n\n    @classmethod\n    def RegisterAnalyzer(cls, analyzer_class):\n        \"\"\"Registers a analyzer class.\n\n        The analyzer classes are identified by their lower case name.\n\n        Args:\n          analyzer_class (type): the analyzer class to register.\n\n        Raises:\n          KeyError: if analyzer class is already set for the corresponding name.\n        \"\"\"\n        analyzer_name = analyzer_class.NAME.lower()\n        if analyzer_name in cls._analyzer_classes:\n            raise KeyError(f'analyzer class already set for name: {analyzer_class.NAME:s}.')\n        cls._analyzer_classes[analyzer_name] = analyzer_class\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass CheckConfigRegistry:\n    '''\n    Registry for check configuration classes.\n    Maps unique check names (e.g., 'null-check') to their corresponding configuration classes.\n    Used to resolve configuration classes dynamically during check instantiation.\n        '''\n    @classmethod\n    def register(cls, name: str, config_cls: Type[BaseCheckConfig]) -> None:\n        '''\n        Registers a configuration class under a given name.\n        Args:\n            name (str): Unique name for the check configuration (e.g., 'null-check').\n            config_cls (Type[BaseCheckConfig]): The configuration class to register.\n        Raises:\n            ValueError: If the given name is already registered.\n        '''\n        pass\n    @classmethod\n    def get(cls, name: str) -> Type[BaseCheckConfig]:\n        '''\n        Retrieves a registered configuration class by its check name.\n        Args:\n            name (str): The name of the check configuration.\n        Returns:\n            Type[BaseCheckConfig]: The corresponding configuration class.\n        Raises:\n            KeyError: If no configuration class is registered under the given name.\n        '''\n        pass\n    @classmethod\n    def list_registered(cls) -> Dict[str, Type[BaseCheckConfig]]:\n        '''\n        Returns all registered check configurations.\n        Returns:\n            Dict[str, Type[BaseCheckConfig]]: Mapping of check names to configuration classes.\n        '''\n        pass"
  }
]