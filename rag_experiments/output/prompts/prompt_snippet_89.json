[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass DatasetFolder(VisionDataset):\n    '''A generic data loader.\n    This default directory structure can be customized by overriding the\n    :meth:`find_classes` method.\n    Args:\n        root (str or ``pathlib.Path``): Root directory path.\n        loader (callable): A function to load a sample given its path.\n        extensions (tuple[string]): A list of allowed extensions.\n            both extensions and is_valid_file should not be passed.\n        transform (callable, optional): A function/transform that takes in\n            a sample and returns a transformed version.\n            E.g, ``transforms.RandomCrop`` for images.\n        target_transform (callable, optional): A function/transform that takes\n            in the target and transforms it.\n        is_valid_file (callable, optional): A function that takes path of a file\n            and check if the file is a valid file (used to check of corrupt files)\n            both extensions and is_valid_file should not be passed.\n        allow_empty(bool, optional): If True, empty folders are considered to be valid classes.\n            An error is raised on empty folders if False (default).\n     Attributes:\n        classes (list): List of the class names sorted alphabetically.\n        class_to_idx (dict): Dict with items (class_name, class_index).\n        samples (list): List of (sample path, class_index) tuples\n        targets (list): The class_index value for each image in the dataset\n            '''\n\n    def __init__(self, root: Union[str, Path], loader: Callable[[str], Any], extensions: Optional[tuple[str, ...]]=None, transform: Optional[Callable]=None, target_transform: Optional[Callable]=None, is_valid_file: Optional[Callable[[str], bool]]=None, allow_empty: bool=False) -> None:\n        pass\n    @staticmethod\n    def make_dataset(directory: Union[str, Path], class_to_idx: dict[str, int], extensions: Optional[tuple[str, ...]]=None, is_valid_file: Optional[Callable[[str], bool]]=None, allow_empty: bool=False) -> list[tuple[str, int]]:\n        '''Generates a list of samples of a form (path_to_sample, class).\n        This can be overridden to e.g. read files from a compressed zip file instead of from the disk.\n        Args:\n            directory (str): root dataset directory, corresponding to ``self.root``.\n            class_to_idx (Dict[str, int]): Dictionary mapping class name to class index.\n            extensions (optional): A list of allowed extensions.\n                Either extensions or is_valid_file should be passed. Defaults to None.\n            is_valid_file (optional): A function that takes path of a file\n                and checks if the file is a valid file\n                (used to check of corrupt files) both extensions and\n                is_valid_file should not be passed. Defaults to None.\n            allow_empty(bool, optional): If True, empty folders are considered to be valid classes.\n                An error is raised on empty folders if False (default).\n        Raises:\n            ValueError: In case ``class_to_idx`` is empty.\n            ValueError: In case ``extensions`` and ``is_valid_file`` are None or both are not None.\n            FileNotFoundError: In case no valid file was found for any class.\n        Returns:\n            List[Tuple[str, int]]: samples of a form (path_to_sample, class)\n                        '''\n                        pass\n\n    def find_classes(self, directory: Union[str, Path]) -> tuple[list[str], dict[str, int]]:\n        '''Find the class folders in a dataset structured as follows::\n            directory/\n            ├── class_x\n            │   ├── xxx.ext\n            │   ├── xxy.ext\n            │   └── ...\n            │       └── xxz.ext\n            └── class_y\n                ├── 123.ext\n                ├── nsdf3.ext\n                └── ...\n                └── asd932_.ext\n        This method can be overridden to only consider\n        a subset of classes, or to adapt to a different dataset directory structure.\n        Args:\n            directory(str): Root directory path, corresponding to ``self.root``\n        Raises:\n            FileNotFoundError: If ``dir`` has no class folders.\n        Returns:\n            (Tuple[List[str], Dict[str, int]]): List of all classes and dictionary mapping each class to an index.\n        '''\n        pass\n\n    def __getitem__(self, index: int) -> tuple[Any, Any]:\n        '''\n        Args:\n            index (int): Index\n        Returns:\n            tuple: (sample, target) where target is class_index of the target class.\n        '''\n        pass\n\n    def __len__(self) -> int:\n        pass\nCorresponding class implementation:\n\nfrom .vision import VisionDataset\nfrom typing import Any, Callable, cast, Optional, Union\nfrom pathlib import Path\n\nclass DatasetFolder(VisionDataset):\n    \"\"\"A generic data loader.\n\n    This default directory structure can be customized by overriding the\n    :meth:`find_classes` method.\n\n    Args:\n        root (str or ``pathlib.Path``): Root directory path.\n        loader (callable): A function to load a sample given its path.\n        extensions (tuple[string]): A list of allowed extensions.\n            both extensions and is_valid_file should not be passed.\n        transform (callable, optional): A function/transform that takes in\n            a sample and returns a transformed version.\n            E.g, ``transforms.RandomCrop`` for images.\n        target_transform (callable, optional): A function/transform that takes\n            in the target and transforms it.\n        is_valid_file (callable, optional): A function that takes path of a file\n            and check if the file is a valid file (used to check of corrupt files)\n            both extensions and is_valid_file should not be passed.\n        allow_empty(bool, optional): If True, empty folders are considered to be valid classes.\n            An error is raised on empty folders if False (default).\n\n     Attributes:\n        classes (list): List of the class names sorted alphabetically.\n        class_to_idx (dict): Dict with items (class_name, class_index).\n        samples (list): List of (sample path, class_index) tuples\n        targets (list): The class_index value for each image in the dataset\n    \"\"\"\n\n    def __init__(self, root: Union[str, Path], loader: Callable[[str], Any], extensions: Optional[tuple[str, ...]]=None, transform: Optional[Callable]=None, target_transform: Optional[Callable]=None, is_valid_file: Optional[Callable[[str], bool]]=None, allow_empty: bool=False) -> None:\n        super().__init__(root, transform=transform, target_transform=target_transform)\n        classes, class_to_idx = self.find_classes(self.root)\n        samples = self.make_dataset(self.root, class_to_idx=class_to_idx, extensions=extensions, is_valid_file=is_valid_file, allow_empty=allow_empty)\n        self.loader = loader\n        self.extensions = extensions\n        self.classes = classes\n        self.class_to_idx = class_to_idx\n        self.samples = samples\n        self.targets = [s[1] for s in samples]\n\n    @staticmethod\n    def make_dataset(directory: Union[str, Path], class_to_idx: dict[str, int], extensions: Optional[tuple[str, ...]]=None, is_valid_file: Optional[Callable[[str], bool]]=None, allow_empty: bool=False) -> list[tuple[str, int]]:\n        \"\"\"Generates a list of samples of a form (path_to_sample, class).\n\n        This can be overridden to e.g. read files from a compressed zip file instead of from the disk.\n\n        Args:\n            directory (str): root dataset directory, corresponding to ``self.root``.\n            class_to_idx (Dict[str, int]): Dictionary mapping class name to class index.\n            extensions (optional): A list of allowed extensions.\n                Either extensions or is_valid_file should be passed. Defaults to None.\n            is_valid_file (optional): A function that takes path of a file\n                and checks if the file is a valid file\n                (used to check of corrupt files) both extensions and\n                is_valid_file should not be passed. Defaults to None.\n            allow_empty(bool, optional): If True, empty folders are considered to be valid classes.\n                An error is raised on empty folders if False (default).\n\n        Raises:\n            ValueError: In case ``class_to_idx`` is empty.\n            ValueError: In case ``extensions`` and ``is_valid_file`` are None or both are not None.\n            FileNotFoundError: In case no valid file was found for any class.\n\n        Returns:\n            List[Tuple[str, int]]: samples of a form (path_to_sample, class)\n        \"\"\"\n        if class_to_idx is None:\n            raise ValueError('The class_to_idx parameter cannot be None.')\n        return make_dataset(directory, class_to_idx, extensions=extensions, is_valid_file=is_valid_file, allow_empty=allow_empty)\n\n    def find_classes(self, directory: Union[str, Path]) -> tuple[list[str], dict[str, int]]:\n        \"\"\"Find the class folders in a dataset structured as follows::\n\n            directory/\n            ├── class_x\n            │   ├── xxx.ext\n            │   ├── xxy.ext\n            │   └── ...\n            │       └── xxz.ext\n            └── class_y\n                ├── 123.ext\n                ├── nsdf3.ext\n                └── ...\n                └── asd932_.ext\n\n        This method can be overridden to only consider\n        a subset of classes, or to adapt to a different dataset directory structure.\n\n        Args:\n            directory(str): Root directory path, corresponding to ``self.root``\n\n        Raises:\n            FileNotFoundError: If ``dir`` has no class folders.\n\n        Returns:\n            (Tuple[List[str], Dict[str, int]]): List of all classes and dictionary mapping each class to an index.\n        \"\"\"\n        return find_classes(directory)\n\n    def __getitem__(self, index: int) -> tuple[Any, Any]:\n        \"\"\"\n        Args:\n            index (int): Index\n\n        Returns:\n            tuple: (sample, target) where target is class_index of the target class.\n        \"\"\"\n        path, target = self.samples[index]\n        sample = self.loader(path)\n        if self.transform is not None:\n            sample = self.transform(sample)\n        if self.target_transform is not None:\n            target = self.target_transform(target)\n        return (sample, target)\n\n    def __len__(self) -> int:\n        return len(self.samples)\n\nExample skeleton:\n\n@utils.registerPlexObject\nclass MediaPart(PlexObject):\n    ''' Represents a single media part (often a single file) for the media this belongs to.\n        Attributes:\n            TAG (str): 'Part'\n            accessible (bool): True if the file is accessible.\n                Requires reloading the media with ``checkFiles=True``.\n                Refer to :func:`~plexapi.base.PlexObject.reload`.\n            audioProfile (str): The audio profile of the file.\n            container (str): The container type of the file (ex: avi).\n            decision (str): Unknown.\n            deepAnalysisVersion (int): The Plex deep analysis version for the file.\n            duration (int): The duration of the file in milliseconds.\n            exists (bool): True if the file exists.\n                Requires reloading the media with ``checkFiles=True``.\n                Refer to :func:`~plexapi.base.PlexObject.reload`.\n            file (str): The path to this file on disk (ex: /media/Movies/Cars (2006)/Cars (2006).mkv)\n            has64bitOffsets (bool): True if the file has 64 bit offsets.\n            hasThumbnail (bool): True if the file (track) has an embedded thumbnail.\n            id (int): The unique ID for this media part on the server.\n            indexes (str, None): sd if the file has generated preview (BIF) thumbnails.\n            key (str): API URL (ex: /library/parts/46618/1389985872/file.mkv).\n            optimizedForStreaming (bool): True if the file is optimized for streaming.\n            packetLength (int): The packet length of the file.\n            requiredBandwidths (str): The required bandwidths to stream the file.\n            selected (bool): True if this media part is selected.\n            size (int): The size of the file in bytes (ex: 733884416).\n            streams (List<:class:`~plexapi.media.MediaPartStream`>): List of stream objects.\n            syncItemId (int): The unique ID for this media part if it is synced.\n            syncState (str): The sync state for this media part.\n            videoProfile (str): The video profile of the file.\n    '''\n\n    def _loadData(self, data):\n        ''' Load attribute values from Plex XML response. '''\n        pass\n\n    def _buildStreams(self, data):\n        ''' Returns a list of :class:`~plexapi.media.MediaPartStream` objects in this MediaPart. '''\n        pass\n    @property\n    def hasPreviewThumbnails(self):\n        ''' Returns True if the media part has generated preview (BIF) thumbnails. '''\n        pass\n\n    def videoStreams(self):\n        ''' Returns a list of :class:`~plexapi.media.VideoStream` objects in this MediaPart. '''\n        pass\n\n    def audioStreams(self):\n        ''' Returns a list of :class:`~plexapi.media.AudioStream` objects in this MediaPart. '''\n        pass\n\n    def subtitleStreams(self):\n        ''' Returns a list of :class:`~plexapi.media.SubtitleStream` objects in this MediaPart. '''\n        pass\n\n    def lyricStreams(self):\n        ''' Returns a list of :class:`~plexapi.media.LyricStream` objects in this MediaPart. '''\n        pass\n\n    def setSelectedAudioStream(self, stream):\n        ''' Set the selected :class:`~plexapi.media.AudioStream` for this MediaPart.\n            Parameters:\n                stream (:class:`~plexapi.media.AudioStream`): Audio stream to set as selected\n        '''\n        pass\n\n    def setSelectedSubtitleStream(self, stream):\n        ''' Set the selected :class:`~plexapi.media.SubtitleStream` for this MediaPart.\n            Parameters:\n                stream (:class:`~plexapi.media.SubtitleStream`): Subtitle stream to set as selected.\n        '''\n        pass\n\n    def resetSelectedSubtitleStream(self):\n        ''' Set the selected subtitle of this MediaPart to 'None'. '''\n        pass\n    @deprecated('Use \"setSelectedAudioStream\" instead.')\n    def setDefaultAudioStream(self, stream):\n        pass\n    @deprecated('Use \"setSelectedSubtitleStream\" instead.')\n    def setDefaultSubtitleStream(self, stream):\n        pass\n    @deprecated('Use \"resetSelectedSubtitleStream\" instead.')\n    def resetDefaultSubtitleStream(self):\n        pass\nCorresponding class implementation:\n\nfrom plexapi.utils import deprecated\nfrom plexapi.base import PlexObject, cached_data_property\nfrom plexapi import log, settings, utils\n\n@utils.registerPlexObject\nclass MediaPart(PlexObject):\n    \"\"\" Represents a single media part (often a single file) for the media this belongs to.\n\n        Attributes:\n            TAG (str): 'Part'\n            accessible (bool): True if the file is accessible.\n                Requires reloading the media with ``checkFiles=True``.\n                Refer to :func:`~plexapi.base.PlexObject.reload`.\n            audioProfile (str): The audio profile of the file.\n            container (str): The container type of the file (ex: avi).\n            decision (str): Unknown.\n            deepAnalysisVersion (int): The Plex deep analysis version for the file.\n            duration (int): The duration of the file in milliseconds.\n            exists (bool): True if the file exists.\n                Requires reloading the media with ``checkFiles=True``.\n                Refer to :func:`~plexapi.base.PlexObject.reload`.\n            file (str): The path to this file on disk (ex: /media/Movies/Cars (2006)/Cars (2006).mkv)\n            has64bitOffsets (bool): True if the file has 64 bit offsets.\n            hasThumbnail (bool): True if the file (track) has an embedded thumbnail.\n            id (int): The unique ID for this media part on the server.\n            indexes (str, None): sd if the file has generated preview (BIF) thumbnails.\n            key (str): API URL (ex: /library/parts/46618/1389985872/file.mkv).\n            optimizedForStreaming (bool): True if the file is optimized for streaming.\n            packetLength (int): The packet length of the file.\n            requiredBandwidths (str): The required bandwidths to stream the file.\n            selected (bool): True if this media part is selected.\n            size (int): The size of the file in bytes (ex: 733884416).\n            streams (List<:class:`~plexapi.media.MediaPartStream`>): List of stream objects.\n            syncItemId (int): The unique ID for this media part if it is synced.\n            syncState (str): The sync state for this media part.\n            videoProfile (str): The video profile of the file.\n    \"\"\"\n    TAG = 'Part'\n\n    def _loadData(self, data):\n        \"\"\" Load attribute values from Plex XML response. \"\"\"\n        self.accessible = utils.cast(bool, data.attrib.get('accessible'))\n        self.audioProfile = data.attrib.get('audioProfile')\n        self.container = data.attrib.get('container')\n        self.decision = data.attrib.get('decision')\n        self.deepAnalysisVersion = utils.cast(int, data.attrib.get('deepAnalysisVersion'))\n        self.duration = utils.cast(int, data.attrib.get('duration'))\n        self.exists = utils.cast(bool, data.attrib.get('exists'))\n        self.file = data.attrib.get('file')\n        self.has64bitOffsets = utils.cast(bool, data.attrib.get('has64bitOffsets'))\n        self.hasThumbnail = utils.cast(bool, data.attrib.get('hasThumbnail'))\n        self.id = utils.cast(int, data.attrib.get('id'))\n        self.indexes = data.attrib.get('indexes')\n        self.key = data.attrib.get('key')\n        self.optimizedForStreaming = utils.cast(bool, data.attrib.get('optimizedForStreaming'))\n        self.packetLength = utils.cast(int, data.attrib.get('packetLength'))\n        self.protocol = data.attrib.get('protocol')\n        self.requiredBandwidths = data.attrib.get('requiredBandwidths')\n        self.selected = utils.cast(bool, data.attrib.get('selected'))\n        self.size = utils.cast(int, data.attrib.get('size'))\n        self.streams = self._buildStreams(data)\n        self.syncItemId = utils.cast(int, data.attrib.get('syncItemId'))\n        self.syncState = data.attrib.get('syncState')\n        self.videoProfile = data.attrib.get('videoProfile')\n\n    def _buildStreams(self, data):\n        \"\"\" Returns a list of :class:`~plexapi.media.MediaPartStream` objects in this MediaPart. \"\"\"\n        return self.findItems(data)\n\n    @property\n    def hasPreviewThumbnails(self):\n        \"\"\" Returns True if the media part has generated preview (BIF) thumbnails. \"\"\"\n        return self.indexes == 'sd'\n\n    def videoStreams(self):\n        \"\"\" Returns a list of :class:`~plexapi.media.VideoStream` objects in this MediaPart. \"\"\"\n        return [stream for stream in self.streams if isinstance(stream, VideoStream)]\n\n    def audioStreams(self):\n        \"\"\" Returns a list of :class:`~plexapi.media.AudioStream` objects in this MediaPart. \"\"\"\n        return [stream for stream in self.streams if isinstance(stream, AudioStream)]\n\n    def subtitleStreams(self):\n        \"\"\" Returns a list of :class:`~plexapi.media.SubtitleStream` objects in this MediaPart. \"\"\"\n        return [stream for stream in self.streams if isinstance(stream, SubtitleStream)]\n\n    def lyricStreams(self):\n        \"\"\" Returns a list of :class:`~plexapi.media.LyricStream` objects in this MediaPart. \"\"\"\n        return [stream for stream in self.streams if isinstance(stream, LyricStream)]\n\n    def setSelectedAudioStream(self, stream):\n        \"\"\" Set the selected :class:`~plexapi.media.AudioStream` for this MediaPart.\n\n            Parameters:\n                stream (:class:`~plexapi.media.AudioStream`): Audio stream to set as selected\n        \"\"\"\n        key = f'/library/parts/{self.id}'\n        params = {'allParts': 1}\n        if isinstance(stream, AudioStream):\n            params['audioStreamID'] = stream.id\n        else:\n            params['audioStreamID'] = stream\n        self._server.query(key, method=self._server._session.put, params=params)\n        return self\n\n    def setSelectedSubtitleStream(self, stream):\n        \"\"\" Set the selected :class:`~plexapi.media.SubtitleStream` for this MediaPart.\n\n            Parameters:\n                stream (:class:`~plexapi.media.SubtitleStream`): Subtitle stream to set as selected.\n        \"\"\"\n        key = f'/library/parts/{self.id}'\n        params = {'allParts': 1}\n        if isinstance(stream, SubtitleStream):\n            params['subtitleStreamID'] = stream.id\n        else:\n            params['subtitleStreamID'] = stream\n        self._server.query(key, method=self._server._session.put, params=params)\n        return self\n\n    def resetSelectedSubtitleStream(self):\n        \"\"\" Set the selected subtitle of this MediaPart to 'None'. \"\"\"\n        key = f'/library/parts/{self.id}'\n        params = {'subtitleStreamID': 0, 'allParts': 1}\n        self._server.query(key, method=self._server._session.put, params=params)\n        return self\n\n    @deprecated('Use \"setSelectedAudioStream\" instead.')\n    def setDefaultAudioStream(self, stream):\n        return self.setSelectedAudioStream(stream)\n\n    @deprecated('Use \"setSelectedSubtitleStream\" instead.')\n    def setDefaultSubtitleStream(self, stream):\n        return self.setSelectedSubtitleStream(stream)\n\n    @deprecated('Use \"resetSelectedSubtitleStream\" instead.')\n    def resetDefaultSubtitleStream(self):\n        return self.resetSelectedSubtitleStream()\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass LoadImagesAndVideos:\n    '''\n    A class for loading and processing images and videos for YOLO object detection.\n    This class manages the loading and pre-processing of image and video data from various sources, including\n    single image files, video files, and lists of image and video paths.\n    Attributes:\n        files (List[str]): List of image and video file paths.\n        nf (int): Total number of files (images and videos).\n        video_flag (List[bool]): Flags indicating whether a file is a video (True) or an image (False).\n        mode (str): Current mode, 'image' or 'video'.\n        vid_stride (int): Stride for video frame-rate.\n        bs (int): Batch size.\n        cap (cv2.VideoCapture): Video capture object for OpenCV.\n        frame (int): Frame counter for video.\n        frames (int): Total number of frames in the video.\n        count (int): Counter for iteration, initialized at 0 during __iter__().\n        ni (int): Number of images.\n    Methods:\n        __init__: Initialize the LoadImagesAndVideos object.\n        __iter__: Returns an iterator object for VideoStream or ImageFolder.\n        __next__: Returns the next batch of images or video frames along with their paths and metadata.\n        _new_video: Creates a new video capture object for the given path.\n        __len__: Returns the number of batches in the object.\n    Examples:\n        >>> loader = LoadImagesAndVideos(\"path/to/data\", batch=32, vid_stride=1)\n        >>> for paths, imgs, info in loader:\n        ...     # Process batch of images or video frames\n        ...     pass\n    Notes:\n        - Supports various image formats including HEIC.\n        - Handles both local files and directories.\n        - Can read from a text file containing paths to images and videos.\n    '''\n\n    def __init__(self, path, batch=1, vid_stride=1):\n        '''Initialize dataloader for images and videos, supporting various input formats.'''\n        pass\n\n    def __iter__(self):\n        '''Iterates through image/video files, yielding source paths, images, and metadata.'''\n        pass\n\n    def __next__(self):\n        '''Returns the next batch of images or video frames with their paths and metadata.'''\n        pass\n\n    def _new_video(self, path):\n        '''Creates a new video capture object for the given path and initializes video-related attributes.'''\n        pass\n\n    def __len__(self):\n        '''Returns the number of files (images and videos) in the dataset.'''\n        pass"
  }
]