[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass ActivatedEvent(Event):\n    '''\n    This event indicates that the module channel has been switched to Active Channel by calling the Acquire Control API. Sent to the webhook URL server of the module channel.\n    '''\n\n    class Config:\n        '''Pydantic configuration'''\n\n    def to_str(self) -> str:\n        '''Returns the string representation of the model using alias'''\n        pass\n\n    def to_json(self) -> str:\n        '''Returns the JSON representation of the model using alias'''\n        pass\n    @classmethod\n    def from_json(cls, json_str: str) -> ActivatedEvent:\n        '''Create an instance of ActivatedEvent from a JSON string'''\n        pass\n\n    def to_dict(self):\n        '''Returns the dictionary representation of the model using alias'''\n        pass\n    @classmethod\n    def from_dict(cls, obj: dict) -> ActivatedEvent:\n        '''Create an instance of ActivatedEvent from a dict'''\n        pass\nCorresponding class implementation:\n\nfrom linebot.v3.webhooks.models.source import Source\nfrom linebot.v3.webhooks.models.chat_control import ChatControl\nfrom linebot.v3.webhooks.models.delivery_context import DeliveryContext\nimport pprint\nfrom linebot.v3.webhooks.models.event import Event\nfrom pydantic.v1 import Field\nimport json\n\nclass ActivatedEvent(Event):\n    \"\"\"\n    This event indicates that the module channel has been switched to Active Channel by calling the Acquire Control API. Sent to the webhook URL server of the module channel.\n    \"\"\"\n    chat_control: ChatControl = Field(..., alias='chatControl')\n    type: str = 'activated'\n    __properties = ['type', 'source', 'timestamp', 'mode', 'webhookEventId', 'deliveryContext', 'chatControl']\n\n    class Config:\n        \"\"\"Pydantic configuration\"\"\"\n        allow_population_by_field_name = True\n        validate_assignment = True\n\n    def to_str(self) -> str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.dict(by_alias=True))\n\n    def to_json(self) -> str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -> ActivatedEvent:\n        \"\"\"Create an instance of ActivatedEvent from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self):\n        \"\"\"Returns the dictionary representation of the model using alias\"\"\"\n        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)\n        if self.source:\n            _dict['source'] = self.source.to_dict()\n        if self.delivery_context:\n            _dict['deliveryContext'] = self.delivery_context.to_dict()\n        if self.chat_control:\n            _dict['chatControl'] = self.chat_control.to_dict()\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict) -> ActivatedEvent:\n        \"\"\"Create an instance of ActivatedEvent from a dict\"\"\"\n        if obj is None:\n            return None\n        if not isinstance(obj, dict):\n            return ActivatedEvent.parse_obj(obj)\n        _obj = ActivatedEvent.parse_obj({'type': obj.get('type'), 'source': Source.from_dict(obj.get('source')) if obj.get('source') is not None else None, 'timestamp': obj.get('timestamp'), 'mode': obj.get('mode'), 'webhook_event_id': obj.get('webhookEventId'), 'delivery_context': DeliveryContext.from_dict(obj.get('deliveryContext')) if obj.get('deliveryContext') is not None else None, 'chat_control': ChatControl.from_dict(obj.get('chatControl')) if obj.get('chatControl') is not None else None})\n        return _obj\n\nExample skeleton:\n\n\nclass QuickReplyItem(BaseModel):\n    '''\n    QuickReplyItem\n    https://developers.line.biz/en/reference/messaging-api/#items-object\n    '''\n\n    class Config:\n        '''Pydantic configuration'''\n\n    def to_str(self) -> str:\n        '''Returns the string representation of the model using alias'''\n        pass\n\n    def to_json(self) -> str:\n        '''Returns the JSON representation of the model using alias'''\n        pass\n    @classmethod\n    def from_json(cls, json_str: str) -> QuickReplyItem:\n        '''Create an instance of QuickReplyItem from a JSON string'''\n        pass\n\n    def to_dict(self):\n        '''Returns the dictionary representation of the model using alias'''\n        pass\n    @classmethod\n    def from_dict(cls, obj: dict) -> QuickReplyItem:\n        '''Create an instance of QuickReplyItem from a dict'''\n        pass\nCorresponding class implementation:\n\nfrom pydantic.v1 import BaseModel, Field, StrictStr, constr\nimport pprint\nimport json\nfrom typing import Optional\nfrom linebot.v3.messaging.models.action import Action\n\nclass QuickReplyItem(BaseModel):\n    \"\"\"\n    QuickReplyItem\n    https://developers.line.biz/en/reference/messaging-api/#items-object\n    \"\"\"\n    image_url: Optional[constr(strict=True, max_length=2000)] = Field(None, alias='imageUrl', description='URL of the icon that is displayed at the beginning of the button')\n    action: Optional[Action] = None\n    type: Optional[StrictStr] = Field('action', description='`action`')\n    __properties = ['imageUrl', 'action', 'type']\n\n    class Config:\n        \"\"\"Pydantic configuration\"\"\"\n        allow_population_by_field_name = True\n        validate_assignment = True\n\n    def to_str(self) -> str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.dict(by_alias=True))\n\n    def to_json(self) -> str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -> QuickReplyItem:\n        \"\"\"Create an instance of QuickReplyItem from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self):\n        \"\"\"Returns the dictionary representation of the model using alias\"\"\"\n        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)\n        if self.action:\n            _dict['action'] = self.action.to_dict()\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict) -> QuickReplyItem:\n        \"\"\"Create an instance of QuickReplyItem from a dict\"\"\"\n        if obj is None:\n            return None\n        if not isinstance(obj, dict):\n            return QuickReplyItem.parse_obj(obj)\n        _obj = QuickReplyItem.parse_obj({'image_url': obj.get('imageUrl'), 'action': Action.from_dict(obj.get('action')) if obj.get('action') is not None else None, 'type': obj.get('type') if obj.get('type') is not None else 'action'})\n        return _obj\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n@dataclass\nclass StatusBioDTO:\n    '''Status biography data transfer object'''\n    @classmethod\n    def from_model(cls, model: 'StatusBiography') -> 'StatusBioDTO':\n        '''Create DTO from database model\n        Args:\n            model (StatusBiography): database model object\n        Returns:\n            StatusBioDTO: data transfer object\n        '''\n        pass\n\n    def to_dict(self) -> dict:\n        '''Convert to dictionary format\n        Returns:\n            dict: dictionary format data\n        '''\n        pass"
  }
]