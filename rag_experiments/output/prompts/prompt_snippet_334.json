[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass CatalogueFunctionRegistry(dict):\n    '''\n    A collection of methods/functions working on catalogues.\n    The registry also holds information about the type of the input arguments\n    '''\n\n    def check_config(self, config, fields_spec):\n        '''\n        Check that `config` has each field in `fields_spec` if a default\n        has not been provided.\n        '''\n        pass\n\n    def set_defaults(self, config, fields_spec):\n        '''\n        Set default values got from `fields_spec` into the `config`\n        dictionary\n        '''\n        pass\n\n    def add(self, method_name, completeness=False, **fields):\n        '''\n        Class decorator.\n        Decorate `method_name` by adding a call to `set_defaults` and\n        `check_config`. Then, save into the registry a callable\n        function with the same signature of the original method.\n        :param str method_name:\n            the method to decorate\n        :param bool completeness:\n            True if the method accepts in input an optional parameter\n            for the completeness table\n        :param fields:\n            a dictionary of field spec corresponding to the\n            keys expected to be present in the config dictionary\n            for the decorated method, e.g.\n            time_bin=float,\n            b_value=1E-6\n        '''\n        pass\n\n        def class_decorator(class_obj):\n                pass\n\n            def caller(fn, obj, catalogue, config=None, *args, **kwargs):\n                        pass\n\n    def add_function(self, completeness=False, **fields):\n        '''\n        Function decorator.\n        Decorate a function by adding a call to `set_defaults` and\n        `check_config`. Then, save into the registry a callable\n        function with the same signature of the original method\n        :param fields:\n            a dictionary of field spec, e.g.\n            time_bin=float,\n            b_value=1E-6\n        '''\n        pass\n\n        def dec(fn):\n                pass\n\n                def fn_with_config_and_c(catalogue, config, completeness_table=None):\n                                pass\n\n                def fn_with_config_without_c(catalogue, config):\n                                pass\nCorresponding class implementation:\n\nimport sys\nfrom decorator import decorator\nimport functools\n\nclass CatalogueFunctionRegistry(dict):\n    \"\"\"\n    A collection of methods/functions working on catalogues.\n\n    The registry also holds information about the type of the input arguments\n    \"\"\"\n\n    def check_config(self, config, fields_spec):\n        \"\"\"\n        Check that `config` has each field in `fields_spec` if a default\n        has not been provided.\n        \"\"\"\n        for field, type_info in fields_spec.items():\n            has_default = not isinstance(type_info, type)\n            if field not in config and (not has_default):\n                raise RuntimeError('Configuration not complete. %s missing' % field)\n\n    def set_defaults(self, config, fields_spec):\n        \"\"\"\n        Set default values got from `fields_spec` into the `config`\n        dictionary\n        \"\"\"\n        defaults = dict([(f, d) for f, d in fields_spec.items() if not isinstance(d, type)])\n        for field, default_value in defaults.items():\n            if field not in config:\n                config[field] = default_value\n\n    def add(self, method_name, completeness=False, **fields):\n        \"\"\"\n        Class decorator.\n\n        Decorate `method_name` by adding a call to `set_defaults` and\n        `check_config`. Then, save into the registry a callable\n        function with the same signature of the original method.\n\n        :param str method_name:\n            the method to decorate\n        :param bool completeness:\n            True if the method accepts in input an optional parameter\n            for the completeness table\n        :param fields:\n            a dictionary of field spec corresponding to the\n            keys expected to be present in the config dictionary\n            for the decorated method, e.g.\n            time_bin=float,\n            b_value=1E-6\n        \"\"\"\n\n        def class_decorator(class_obj):\n            original_method = getattr(class_obj, method_name)\n            if sys.version[0] == '2':\n                original_method = original_method.im_func\n\n            def caller(fn, obj, catalogue, config=None, *args, **kwargs):\n                config = config or {}\n                self.set_defaults(config, fields)\n                self.check_config(config, fields)\n                return fn(obj, catalogue, config, *args, **kwargs)\n            new_method = decorator(caller, original_method)\n            setattr(class_obj, method_name, new_method)\n            instance = class_obj()\n            func = functools.partial(new_method, instance)\n            func.fields = fields\n            func.model = instance\n            func.completeness = completeness\n            functools.update_wrapper(func, new_method)\n            self[class_obj.__name__] = func\n            return class_obj\n        return class_decorator\n\n    def add_function(self, completeness=False, **fields):\n        \"\"\"\n        Function decorator.\n\n        Decorate a function by adding a call to `set_defaults` and\n        `check_config`. Then, save into the registry a callable\n        function with the same signature of the original method\n\n        :param fields:\n            a dictionary of field spec, e.g.\n            time_bin=float,\n            b_value=1E-6\n        \"\"\"\n\n        def dec(fn):\n            if completeness:\n\n                def fn_with_config_and_c(catalogue, config, completeness_table=None):\n                    return fn(catalogue, completeness_table, **config)\n                fn_with_config = fn_with_config_and_c\n            else:\n\n                def fn_with_config_without_c(catalogue, config):\n                    return fn(catalogue, **config)\n                fn_with_config = fn_with_config_without_c\n            fn_with_config.fields = fields\n            fn_with_config.completeness = completeness\n            fn.fields = fields\n            self[fn.__name__] = fn_with_config\n            return fn\n        return dec\n\nExample skeleton:\n\n\nclass EOWorkflowVisualization:\n    '''Class handling EOWorkflow visualization'''\n\n    def __init__(self, nodes: Sequence[EONode]):\n        '''\n        :param nodes: A sequence of topologically ordered workflow nodes\n        '''\n        pass\n\n    def dependency_graph(self, filename: str | None=None) -> Digraph:\n        '''Visualize the computational graph.\n        :param filename: Filename of the output image together with file extension. Supported formats: `png`, `jpg`,\n            `pdf`, ... . Check `graphviz` Python package for more options\n        :return: The DOT representation of the computational graph, with some more formatting\n        '''\n        pass\n\n    def get_dot(self) -> Digraph:\n        '''Generates the DOT description of the underlying computational graph.\n        :return: The DOT representation of the computational graph\n        '''\n        pass\n    @staticmethod\n    def _get_node_uid_to_dot_name_mapping(nodes: Sequence[EONode]) -> dict[str, str]:\n        '''Creates mapping between EONode classes and names used in DOT graph. To do that, it has to collect nodes with\n        the same name and assign them different indices.'''\n        pass\nCorresponding class implementation:\n\nfrom typing import Sequence\nfrom graphviz import Digraph\nfrom eolearn.core import EONode\n\nclass EOWorkflowVisualization:\n    \"\"\"Class handling EOWorkflow visualization\"\"\"\n\n    def __init__(self, nodes: Sequence[EONode]):\n        \"\"\"\n        :param nodes: A sequence of topologically ordered workflow nodes\n        \"\"\"\n        self.nodes = nodes\n\n    def dependency_graph(self, filename: str | None=None) -> Digraph:\n        \"\"\"Visualize the computational graph.\n\n        :param filename: Filename of the output image together with file extension. Supported formats: `png`, `jpg`,\n            `pdf`, ... . Check `graphviz` Python package for more options\n        :return: The DOT representation of the computational graph, with some more formatting\n        \"\"\"\n        dot = self.get_dot()\n        dot.attr(rankdir='LR')\n        if filename is not None:\n            file_name, file_format = filename.rsplit('.', 1)\n            dot.render(filename=file_name, format=file_format, cleanup=True)\n        return dot\n\n    def get_dot(self) -> Digraph:\n        \"\"\"Generates the DOT description of the underlying computational graph.\n\n        :return: The DOT representation of the computational graph\n        \"\"\"\n        dot = Digraph(format='png')\n        node_uid_to_dot_name = self._get_node_uid_to_dot_name_mapping(self.nodes)\n        for node in self.nodes:\n            for input_node in node.inputs:\n                dot.edge(node_uid_to_dot_name[input_node.uid], node_uid_to_dot_name[node.uid])\n        return dot\n\n    @staticmethod\n    def _get_node_uid_to_dot_name_mapping(nodes: Sequence[EONode]) -> dict[str, str]:\n        \"\"\"Creates mapping between EONode classes and names used in DOT graph. To do that, it has to collect nodes with\n        the same name and assign them different indices.\"\"\"\n        dot_name_to_nodes: dict[str, list[EONode]] = {}\n        for node in nodes:\n            dot_name_to_nodes[node.get_name()] = dot_name_to_nodes.get(node.get_name(), [])\n            dot_name_to_nodes[node.get_name()].append(node)\n        node_to_dot_name = {}\n        for same_name_nodes in dot_name_to_nodes.values():\n            if len(same_name_nodes) == 1:\n                node = same_name_nodes[0]\n                node_to_dot_name[node.uid] = node.get_name()\n            else:\n                for idx, node in enumerate(same_name_nodes):\n                    node_to_dot_name[node.uid] = node.get_name(idx + 1)\n        return node_to_dot_name\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass GraphProcessing:\n    '''\n    Class that performs graph clustering and visualization\n    '''\n    @classmethod\n    def cluster_graph(cls, graph: nx.Graph, max_community_size: int=1) -> pd.DataFrame:\n        '''\n        Method to perform hierarchical clustering of given graph,\n        until the resulting final communities each have a maximum of\n        `max_community_size` number of nodes.\n        Args:\n            graph (nx.Graph): graph to be clustered\n            max_community_size (int, optional): maximum number of nodes to be present\n            in a cluster/community. Defaults to 1.\n        Returns:\n            pd.DataFrame: Clustered communities in a DataFrame format.\n            Columns are - level, cluster_id, parent_cluster_id, nodes\n        '''\n        pass\n    @classmethod\n    def add_node_labels(cls, cluster_communities: pd.DataFrame, graph: nx.Graph):\n        '''\n        Method to add community name and community level\n        to the graph nodes\n        Args:\n            cluster_communities (pd.DataFrame): cluster info dataframe\n            graph (nx.Graph): networkx graph\n        Returns:\n            nx.Graph: updated graph with community and community level labels\n        '''\n        pass\n    @classmethod\n    def visualize_graph(cls, graph_path: str, graph_save_path: str, max_community_size: Union[int, None]=None, community_level: Union[int, None]=None, figsize: tuple[float, float]=(36.0, 20.0), default_node_sizes:\n        '''\n        Method to perform graph clustering, if specified,\n        and visualize the resulting graph using the GraphDisplay class.\n        Args:\n            graph_path (str): path to the graphml file\n            graph_save_path (str): path where the resulting graph visualization is to be saved\n            max_community_size (Union[int, None], optional): maximum number of nodes to be present\n            in a cluster/community. If set as None, clustering is skipped. Defaults to None.\n            community_level (Union[int, None], optional): Level of the community to retain.\n            Nodes of this community level are retained and then visualized.\n            If set to `-1` highest community level nodes are retained. Defaults to None.\n        '''\n        pass"
  }
]