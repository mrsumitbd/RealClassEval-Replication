[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass ImageSet(BaseModel):\n    '''\n    ImageSet\n    '''\n\n    class Config:\n        '''Pydantic configuration'''\n\n    def to_str(self) -> str:\n        '''Returns the string representation of the model using alias'''\n        pass\n\n    def to_json(self) -> str:\n        '''Returns the JSON representation of the model using alias'''\n        pass\n    @classmethod\n    def from_json(cls, json_str: str) -> ImageSet:\n        '''Create an instance of ImageSet from a JSON string'''\n        pass\n\n    def to_dict(self):\n        '''Returns the dictionary representation of the model using alias'''\n        pass\n    @classmethod\n    def from_dict(cls, obj: dict) -> ImageSet:\n        '''Create an instance of ImageSet from a dict'''\n        pass\nCorresponding class implementation:\n\nfrom typing import Optional\nimport json\nfrom pydantic.v1 import BaseModel, Field, StrictInt, StrictStr\nimport pprint\n\nclass ImageSet(BaseModel):\n    \"\"\"\n    ImageSet\n    \"\"\"\n    id: StrictStr = Field(..., description='Image set ID. Only included when multiple images are sent simultaneously.')\n    index: Optional[StrictInt] = Field(None, description=\"An index starting from 1, indicating the image number in a set of images sent simultaneously. Only included when multiple images are sent simultaneously. However, it won't be included if the sender is using LINE 11.15 or earlier for Android.\")\n    total: Optional[StrictInt] = Field(None, description='The total number of images sent simultaneously.')\n    __properties = ['id', 'index', 'total']\n\n    class Config:\n        \"\"\"Pydantic configuration\"\"\"\n        allow_population_by_field_name = True\n        validate_assignment = True\n\n    def to_str(self) -> str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.dict(by_alias=True))\n\n    def to_json(self) -> str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -> ImageSet:\n        \"\"\"Create an instance of ImageSet from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self):\n        \"\"\"Returns the dictionary representation of the model using alias\"\"\"\n        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict) -> ImageSet:\n        \"\"\"Create an instance of ImageSet from a dict\"\"\"\n        if obj is None:\n            return None\n        if not isinstance(obj, dict):\n            return ImageSet.parse_obj(obj)\n        _obj = ImageSet.parse_obj({'id': obj.get('id'), 'index': obj.get('index'), 'total': obj.get('total')})\n        return _obj\n\nExample skeleton:\n\n\nclass QuickReplyItem(BaseModel):\n    '''\n    QuickReplyItem\n    https://developers.line.biz/en/reference/messaging-api/#items-object\n    '''\n\n    class Config:\n        '''Pydantic configuration'''\n\n    def to_str(self) -> str:\n        '''Returns the string representation of the model using alias'''\n        pass\n\n    def to_json(self) -> str:\n        '''Returns the JSON representation of the model using alias'''\n        pass\n    @classmethod\n    def from_json(cls, json_str: str) -> QuickReplyItem:\n        '''Create an instance of QuickReplyItem from a JSON string'''\n        pass\n\n    def to_dict(self):\n        '''Returns the dictionary representation of the model using alias'''\n        pass\n    @classmethod\n    def from_dict(cls, obj: dict) -> QuickReplyItem:\n        '''Create an instance of QuickReplyItem from a dict'''\n        pass\nCorresponding class implementation:\n\nfrom pydantic.v1 import BaseModel, Field, StrictStr, constr\nimport pprint\nimport json\nfrom typing import Optional\nfrom linebot.v3.messaging.models.action import Action\n\nclass QuickReplyItem(BaseModel):\n    \"\"\"\n    QuickReplyItem\n    https://developers.line.biz/en/reference/messaging-api/#items-object\n    \"\"\"\n    image_url: Optional[constr(strict=True, max_length=2000)] = Field(None, alias='imageUrl', description='URL of the icon that is displayed at the beginning of the button')\n    action: Optional[Action] = None\n    type: Optional[StrictStr] = Field('action', description='`action`')\n    __properties = ['imageUrl', 'action', 'type']\n\n    class Config:\n        \"\"\"Pydantic configuration\"\"\"\n        allow_population_by_field_name = True\n        validate_assignment = True\n\n    def to_str(self) -> str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.dict(by_alias=True))\n\n    def to_json(self) -> str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -> QuickReplyItem:\n        \"\"\"Create an instance of QuickReplyItem from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self):\n        \"\"\"Returns the dictionary representation of the model using alias\"\"\"\n        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)\n        if self.action:\n            _dict['action'] = self.action.to_dict()\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict) -> QuickReplyItem:\n        \"\"\"Create an instance of QuickReplyItem from a dict\"\"\"\n        if obj is None:\n            return None\n        if not isinstance(obj, dict):\n            return QuickReplyItem.parse_obj(obj)\n        _obj = QuickReplyItem.parse_obj({'image_url': obj.get('imageUrl'), 'action': Action.from_dict(obj.get('action')) if obj.get('action') is not None else None, 'type': obj.get('type') if obj.get('type') is not None else 'action'})\n        return _obj\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass URLExtractor:\n    '''URL提取器'''\n    @staticmethod\n    def convert_arxiv_url(url: str) -> str:\n        '''将arXiv网页链接转换为PDF下载链接'''\n        pass\n    @classmethod\n    def extract_urls(cls, text: str) -> List[str]:\n        '''从文本中提取URL'''\n        pass\n    @staticmethod\n    def infer_filename_from_url(url: str) -> str:\n        '''从URL推断文件名'''\n        pass"
  }
]