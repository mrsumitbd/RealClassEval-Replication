[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass TestInputsConfig:\n    '''Test TcEx Inputs Config.'''\n    @staticmethod\n    def test_config_kwarg():\n        '''Test config file input method of TcEx'''\n        pass\n    @staticmethod\n    def test_config_file_kwarg(playbook_app: Callable[..., MockApp]):\n        '''Test config file input method of TcEx'''\n        pass\n    @staticmethod\n    def test_input_token(tcex: TcEx):\n        '''Test default values (e.g., token) are in args.'''\n        pass\nCorresponding class implementation:\n\nfrom tcex.registry import registry\nimport json\nfrom pathlib import Path\nfrom uuid import uuid4\nfrom tcex import TcEx\nimport os\nfrom collections.abc import Callable\nfrom tests.mock_app import MockApp\n\nclass TestInputsConfig:\n    \"\"\"Test TcEx Inputs Config.\"\"\"\n\n    @staticmethod\n    def test_config_kwarg():\n        \"\"\"Test config file input method of TcEx\"\"\"\n        registry._reset()\n        config_data = {'api_default_org': 'TCI', 'tc_api_access_id': os.getenv('TC_API_ACCESS_ID'), 'tc_api_path': os.getenv('TC_API_PATH'), 'tc_api_secret_key': os.getenv('TC_API_SECRET_KEY'), 'tc_log_path': os.getcwd(), 'tc_token': None, 'tc_expires': None, 'tc_verify': True, 'external_config_item': 'some-custom-value'}\n        tcex = TcEx(config=config_data)\n        assert tcex.inputs.model.external_config_item == config_data.get('external_config_item')\n\n    @staticmethod\n    def test_config_file_kwarg(playbook_app: Callable[..., MockApp]):\n        \"\"\"Test config file input method of TcEx\"\"\"\n        _ = playbook_app()\n        registry._reset()\n        config_file = Path('app_config.json')\n        config_data = {'api_default_org': 'TCI', 'tc_playbook_kvstore_context': str(uuid4()), 'tc_api_access_id': os.getenv('TC_API_ACCESS_ID'), 'tc_api_path': os.getenv('TC_API_PATH'), 'tc_api_secret_key': os.getenv('TC_API_SECRET_KEY'), 'tc_log_path': os.getcwd(), 'tc_token': None, 'tc_expires': None, 'tc_verify': True, 'external_config_item': 'some-custom-value'}\n        with config_file.open(mode='w') as fh:\n            json.dump(config_data, fh)\n        tcex = TcEx(config_file=config_file)\n        assert tcex.inputs.model.external_config_item == config_data.get('external_config_item')\n        config_file.unlink()\n\n    @staticmethod\n    def test_input_token(tcex: TcEx):\n        \"\"\"Test default values (e.g., token) are in args.\"\"\"\n        assert tcex.inputs.model.tc_token\n        assert tcex.inputs.model.tc_token_expires\n        assert tcex.inputs.model.api_default_org == 'TCI'\n\nExample skeleton:\n\n\nclass ActivatedEvent(Event):\n    '''\n    This event indicates that the module channel has been switched to Active Channel by calling the Acquire Control API. Sent to the webhook URL server of the module channel.\n    '''\n\n    class Config:\n        '''Pydantic configuration'''\n\n    def to_str(self) -> str:\n        '''Returns the string representation of the model using alias'''\n        pass\n\n    def to_json(self) -> str:\n        '''Returns the JSON representation of the model using alias'''\n        pass\n    @classmethod\n    def from_json(cls, json_str: str) -> ActivatedEvent:\n        '''Create an instance of ActivatedEvent from a JSON string'''\n        pass\n\n    def to_dict(self):\n        '''Returns the dictionary representation of the model using alias'''\n        pass\n    @classmethod\n    def from_dict(cls, obj: dict) -> ActivatedEvent:\n        '''Create an instance of ActivatedEvent from a dict'''\n        pass\nCorresponding class implementation:\n\nfrom linebot.v3.webhooks.models.source import Source\nfrom linebot.v3.webhooks.models.chat_control import ChatControl\nfrom linebot.v3.webhooks.models.delivery_context import DeliveryContext\nimport pprint\nfrom linebot.v3.webhooks.models.event import Event\nfrom pydantic.v1 import Field\nimport json\n\nclass ActivatedEvent(Event):\n    \"\"\"\n    This event indicates that the module channel has been switched to Active Channel by calling the Acquire Control API. Sent to the webhook URL server of the module channel.\n    \"\"\"\n    chat_control: ChatControl = Field(..., alias='chatControl')\n    type: str = 'activated'\n    __properties = ['type', 'source', 'timestamp', 'mode', 'webhookEventId', 'deliveryContext', 'chatControl']\n\n    class Config:\n        \"\"\"Pydantic configuration\"\"\"\n        allow_population_by_field_name = True\n        validate_assignment = True\n\n    def to_str(self) -> str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.dict(by_alias=True))\n\n    def to_json(self) -> str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -> ActivatedEvent:\n        \"\"\"Create an instance of ActivatedEvent from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self):\n        \"\"\"Returns the dictionary representation of the model using alias\"\"\"\n        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)\n        if self.source:\n            _dict['source'] = self.source.to_dict()\n        if self.delivery_context:\n            _dict['deliveryContext'] = self.delivery_context.to_dict()\n        if self.chat_control:\n            _dict['chatControl'] = self.chat_control.to_dict()\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict) -> ActivatedEvent:\n        \"\"\"Create an instance of ActivatedEvent from a dict\"\"\"\n        if obj is None:\n            return None\n        if not isinstance(obj, dict):\n            return ActivatedEvent.parse_obj(obj)\n        _obj = ActivatedEvent.parse_obj({'type': obj.get('type'), 'source': Source.from_dict(obj.get('source')) if obj.get('source') is not None else None, 'timestamp': obj.get('timestamp'), 'mode': obj.get('mode'), 'webhook_event_id': obj.get('webhookEventId'), 'delivery_context': DeliveryContext.from_dict(obj.get('deliveryContext')) if obj.get('deliveryContext') is not None else None, 'chat_control': ChatControl.from_dict(obj.get('chatControl')) if obj.get('chatControl') is not None else None})\n        return _obj\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass FewShotFormat:\n    '''Handler for different few-shot example formats'''\n    @staticmethod\n    def convert(examples: List[Dict[str, Any]]) -> List[Dict[str, str]]:\n        '''Convert any supported format to input-output format'''\n        pass\n    @staticmethod\n    def validate(examples: List[Dict[str, Any]]) -> bool:\n        '''Validate that examples are in input-output format'''\n        pass"
  }
]