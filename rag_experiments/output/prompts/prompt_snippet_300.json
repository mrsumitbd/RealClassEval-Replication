[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass AuthProvider(metaclass=abc.ABCMeta):\n    '''Authentication provider for a specific kind of credential.'''\n\n    def authenticate(self, environ):\n        '''Produce an opaque auth token from a WSGI request environment.\n        Args:\n          environ: A WSGI environment `dict`; see PEP 3333.\n        Returns:\n          A Python object representing an auth token. The representation\n          and semantics depend on the particular `AuthProvider`\n          implementation.\n        Raises:\n          Exception: Any error, usually `tensorboard.errors.PublicError`\n            subclasses (like `PermissionDenied`) but also possibly a\n            custom error type that should propagate to a WSGI middleware\n            for effecting a redirect-driven auth flow.\n        '''\n        pass\nCorresponding class implementation:\n\nimport abc\n\nclass AuthProvider(metaclass=abc.ABCMeta):\n    \"\"\"Authentication provider for a specific kind of credential.\"\"\"\n\n    def authenticate(self, environ):\n        \"\"\"Produce an opaque auth token from a WSGI request environment.\n\n        Args:\n          environ: A WSGI environment `dict`; see PEP 3333.\n\n        Returns:\n          A Python object representing an auth token. The representation\n          and semantics depend on the particular `AuthProvider`\n          implementation.\n\n        Raises:\n          Exception: Any error, usually `tensorboard.errors.PublicError`\n            subclasses (like `PermissionDenied`) but also possibly a\n            custom error type that should propagate to a WSGI middleware\n            for effecting a redirect-driven auth flow.\n        \"\"\"\n        pass\n\nExample skeleton:\n\n\nclass UploadMixin(_RestObjectBase):\n\n    def _get_upload_path(self) -> str:\n        '''Formats _upload_path with object attributes.\n        Returns:\n            The upload path\n        '''\n        pass\n    @cli.register_custom_action(cls_names=('Project', 'ProjectWiki'), required=('filename', 'filepath'))\n    @exc.on_http_error(exc.GitlabUploadError)\n    def upload(self, filename: str, filedata: bytes | None=None, filepath: str | None=None, **kwargs: Any) -> dict[str, Any]:\n        '''Upload the specified file.\n        .. note::\n            Either ``filedata`` or ``filepath`` *MUST* be specified.\n        Args:\n            filename: The name of the file being uploaded\n            filedata: The raw data of the file being uploaded\n            filepath: The path to a local file to upload (optional)\n        Raises:\n            GitlabAuthenticationError: If authentication is not correct\n            GitlabUploadError: If the file upload fails\n            GitlabUploadError: If ``filedata`` and ``filepath`` are not\n                specified\n            GitlabUploadError: If both ``filedata`` and ``filepath`` are\n                specified\n        Returns:\n            A ``dict`` with info on the uploaded file\n        '''\n        pass\nCorresponding class implementation:\n\nfrom types import ModuleType\nfrom gitlab import base, cli\nfrom gitlab import exceptions as exc\nfrom typing import Any, Callable, Literal, overload, TYPE_CHECKING\n\nclass UploadMixin(_RestObjectBase):\n    _id_attr: str | None\n    _attrs: dict[str, Any]\n    _module: ModuleType\n    _parent_attrs: dict[str, Any]\n    _updated_attrs: dict[str, Any]\n    _upload_path: str\n    manager: base.RESTManager[Any]\n\n    def _get_upload_path(self) -> str:\n        \"\"\"Formats _upload_path with object attributes.\n\n        Returns:\n            The upload path\n        \"\"\"\n        if TYPE_CHECKING:\n            assert isinstance(self._upload_path, str)\n        data = self.attributes\n        return self._upload_path.format(**data)\n\n    @cli.register_custom_action(cls_names=('Project', 'ProjectWiki'), required=('filename', 'filepath'))\n    @exc.on_http_error(exc.GitlabUploadError)\n    def upload(self, filename: str, filedata: bytes | None=None, filepath: str | None=None, **kwargs: Any) -> dict[str, Any]:\n        \"\"\"Upload the specified file.\n\n        .. note::\n\n            Either ``filedata`` or ``filepath`` *MUST* be specified.\n\n        Args:\n            filename: The name of the file being uploaded\n            filedata: The raw data of the file being uploaded\n            filepath: The path to a local file to upload (optional)\n\n        Raises:\n            GitlabAuthenticationError: If authentication is not correct\n            GitlabUploadError: If the file upload fails\n            GitlabUploadError: If ``filedata`` and ``filepath`` are not\n                specified\n            GitlabUploadError: If both ``filedata`` and ``filepath`` are\n                specified\n\n        Returns:\n            A ``dict`` with info on the uploaded file\n        \"\"\"\n        if filepath is None and filedata is None:\n            raise exc.GitlabUploadError('No file contents or path specified')\n        if filedata is not None and filepath is not None:\n            raise exc.GitlabUploadError('File contents and file path specified')\n        if filepath is not None:\n            with open(filepath, 'rb') as f:\n                filedata = f.read()\n        file_info = {'file': (filename, filedata)}\n        path = self._get_upload_path()\n        server_data = self.manager.gitlab.http_post(path, files=file_info, **kwargs)\n        if TYPE_CHECKING:\n            assert isinstance(server_data, dict)\n        return server_data\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass KafkaExceptionHandlerMixin:\n    '''Mixin class to handle Kafka exceptions in a consistent way.'''\n    @classmethod\n    def _handle_kafka_exception(cls, exception: Exception, operation: str) -> None:\n        '''Handle Kafka exceptions and map them to appropriate application errors.\n        Args:\n            exception: The original exception\n            operation: The name of the operation that failed\n        Raises:\n            Various application-specific errors based on the exception type/content\n        '''\n        pass\n    @classmethod\n    def _handle_producer_exception(cls, exception: Exception, operation: str) -> None:\n        '''Handle producer-specific exceptions.\n        Args:\n            exception: The original exception\n            operation: The name of the operation that failed\n        Raises:\n            ResourceExhaustedError: If the producer queue is full\n            Various other errors from _handle_kafka_exception\n        '''\n        pass"
  }
]