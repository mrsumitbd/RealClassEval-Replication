[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass MapItem:\n\n    def __init__(self, buff: bytes, cm: ClassManager) -> None:\n        '''\n        Implementation of a map_item, which occours in a map_list\n        https://source.android.com/devices/tech/dalvik/dex-format#map-item\n        '''\n        pass\n\n    def get_off(self) -> int:\n        '''Gets the offset of the map item itself inside the DEX file'''\n        pass\n\n    def get_offset(self) -> int:\n        '''Gets the offset of the item of the map item'''\n        pass\n\n    def get_type(self) -> TypeMapItem:\n        pass\n\n    def get_size(self) -> int:\n        '''\n        Returns the number of items found at the location indicated by\n        [get_offset][androguard.core.dex.MapItem.get_offset].\n        :returns: number of items\n        '''\n        pass\n\n    def parse(self) -> None:\n        '''parse this map_item by parsing its potential [TypeMapItem][androguard.core.dex.dex_types.TypeMapItem] type and cast it appropriately.'''\n        pass\n\n    def show(self) -> None:\n        pass\n\n    def get_obj(self) -> object:\n        '''\n        Return the associated item itself.\n        Might return `None`, if [parse][androguard.core.dex.MapItem.parse] was not called yet.\n        This method is the same as `item`.\n        :returns: item object\n        '''\n        pass\n\n    def get_raw(self) -> bytes:\n        pass\n\n    def get_length(self) -> int:\n        pass\n\n    def set_item(self, item: object) -> None:\n        pass\nCorresponding class implementation:\n\nimport time\nfrom androguard.core import apk, bytecode, mutf8\nfrom struct import calcsize, pack, unpack\nfrom loguru import logger\nfrom .dex_types import ACCESS_FLAGS, TYPE_DESCRIPTOR, Kind, Operand, TypeMapItem\n\nclass MapItem:\n\n    def __init__(self, buff: bytes, cm: ClassManager) -> None:\n        \"\"\"\n        Implementation of a map_item, which occours in a map_list\n\n        https://source.android.com/devices/tech/dalvik/dex-format#map-item\n        \"\"\"\n        self.CM = cm\n        self.buff = buff\n        self.off = buff.tell()\n        self.type = TypeMapItem(cm.packer['H'].unpack(buff.read(2))[0])\n        self.unused, self.size, self.offset = cm.packer['H2I'].unpack(buff.read(10))\n        self.item = None\n\n    def get_off(self) -> int:\n        \"\"\"Gets the offset of the map item itself inside the DEX file\"\"\"\n        return self.off\n\n    def get_offset(self) -> int:\n        \"\"\"Gets the offset of the item of the map item\"\"\"\n        return self.offset\n\n    def get_type(self) -> TypeMapItem:\n        return self.type\n\n    def get_size(self) -> int:\n        \"\"\"\n        Returns the number of items found at the location indicated by\n        [get_offset][androguard.core.dex.MapItem.get_offset].\n\n        :returns: number of items\n        \"\"\"\n        return self.size\n\n    def parse(self) -> None:\n        \"\"\"parse this map_item by parsing its potential [TypeMapItem][androguard.core.dex.dex_types.TypeMapItem] type and cast it appropriately.\"\"\"\n        logger.debug(\"Starting parsing map_item '{}'\".format(self.type.name))\n        started_at = time.time()\n        buff = self.buff\n        cm = self.CM\n        if TypeMapItem.STRING_ID_ITEM == self.type:\n            buff.seek(self.offset)\n            self.item = [StringIdItem(buff, cm) for _ in range(self.size)]\n        elif TypeMapItem.CODE_ITEM == self.type:\n            buff.seek(self.offset + self.offset % 4)\n            self.item = CodeItem(self.size, buff, cm)\n        elif TypeMapItem.TYPE_ID_ITEM == self.type:\n            buff.seek(self.offset + self.offset % 4)\n            self.item = TypeHIdItem(self.size, buff, cm)\n        elif TypeMapItem.PROTO_ID_ITEM == self.type:\n            buff.seek(self.offset + self.offset % 4)\n            self.item = ProtoHIdItem(self.size, buff, cm)\n        elif TypeMapItem.FIELD_ID_ITEM == self.type:\n            buff.seek(self.offset + self.offset % 4)\n            self.item = FieldHIdItem(self.size, buff, cm)\n        elif TypeMapItem.METHOD_ID_ITEM == self.type:\n            buff.seek(self.offset + self.offset % 4)\n            self.item = MethodHIdItem(self.size, buff, cm)\n        elif TypeMapItem.CLASS_DEF_ITEM == self.type:\n            buff.seek(self.offset + self.offset % 4)\n            self.item = ClassHDefItem(self.size, buff, cm)\n        elif TypeMapItem.HEADER_ITEM == self.type:\n            buff.seek(self.offset + self.offset % 4)\n            self.item = HeaderItem(self.size, buff, cm)\n        elif TypeMapItem.ANNOTATION_ITEM == self.type:\n            buff.seek(self.offset)\n            self.item = [AnnotationItem(buff, cm) for _ in range(self.size)]\n        elif TypeMapItem.ANNOTATION_SET_ITEM == self.type:\n            buff.seek(self.offset + self.offset % 4)\n            self.item = [AnnotationSetItem(buff, cm) for _ in range(self.size)]\n        elif TypeMapItem.ANNOTATIONS_DIRECTORY_ITEM == self.type:\n            buff.seek(self.offset + self.offset % 4)\n            self.item = [AnnotationsDirectoryItem(buff, cm) for _ in range(self.size)]\n        elif TypeMapItem.HIDDENAPI_CLASS_DATA_ITEM == self.type:\n            buff.seek(self.offset)\n            self.item = HiddenApiClassDataItem(buff, cm)\n        elif TypeMapItem.ANNOTATION_SET_REF_LIST == self.type:\n            buff.seek(self.offset + self.offset % 4)\n            self.item = [AnnotationSetRefList(buff, cm) for _ in range(self.size)]\n        elif TypeMapItem.TYPE_LIST == self.type:\n            buff.seek(self.offset + self.offset % 4)\n            self.item = [TypeList(buff, cm) for _ in range(self.size)]\n        elif TypeMapItem.STRING_DATA_ITEM == self.type:\n            buff.seek(self.offset)\n            self.item = [StringDataItem(buff, cm) for _ in range(self.size)]\n        elif TypeMapItem.DEBUG_INFO_ITEM == self.type:\n            buff.seek(self.offset)\n            self.item = DebugInfoItemEmpty(buff, cm)\n        elif TypeMapItem.ENCODED_ARRAY_ITEM == self.type:\n            buff.seek(self.offset)\n            self.item = [EncodedArrayItem(buff, cm) for _ in range(self.size)]\n        elif TypeMapItem.CLASS_DATA_ITEM == self.type:\n            buff.seek(self.offset)\n            self.item = [ClassDataItem(buff, cm) for _ in range(self.size)]\n        elif TypeMapItem.MAP_LIST == self.type:\n            buff.seek(self.offset + self.offset % 4)\n            pass\n        else:\n            logger.warning(\"Map item with id '{type}' offset: 0x{off:x} ({off}) size: {size} is unknown. Is this a newer DEX format?\".format(type=self.type, off=buff.tell(), size=self.size))\n        diff = time.time() - started_at\n        minutes, seconds = (diff // 60, diff % 60)\n        logger.debug(\"End of parsing map_item '{}'. Required time {:.0f}:{:07.4f}\".format(self.type.name, minutes, seconds))\n\n    def show(self) -> None:\n        bytecode._Print('\\tMAP_TYPE_ITEM', self.type.name)\n        if self.item is not None:\n            if isinstance(self.item, list):\n                for i in self.item:\n                    i.show()\n            else:\n                self.item.show()\n\n    def get_obj(self) -> object:\n        \"\"\"\n        Return the associated item itself.\n        Might return `None`, if [parse][androguard.core.dex.MapItem.parse] was not called yet.\n\n        This method is the same as `item`.\n\n        :returns: item object\n        \"\"\"\n        return self.item\n    get_item = get_obj\n\n    def get_raw(self) -> bytes:\n        if isinstance(self.item, list):\n            self.offset = self.item[0].get_off()\n        else:\n            self.offset = self.item.get_off()\n        return self.CM.packer['2H2I'].pack(self.type, self.unused, self.size, self.offset)\n\n    def get_length(self) -> int:\n        return calcsize('HHII')\n\n    def set_item(self, item: object) -> None:\n        self.item = item\n\nExample skeleton:\n\n\nclass ActivatedEvent(Event):\n    '''\n    This event indicates that the module channel has been switched to Active Channel by calling the Acquire Control API. Sent to the webhook URL server of the module channel.\n    '''\n\n    class Config:\n        '''Pydantic configuration'''\n\n    def to_str(self) -> str:\n        '''Returns the string representation of the model using alias'''\n        pass\n\n    def to_json(self) -> str:\n        '''Returns the JSON representation of the model using alias'''\n        pass\n    @classmethod\n    def from_json(cls, json_str: str) -> ActivatedEvent:\n        '''Create an instance of ActivatedEvent from a JSON string'''\n        pass\n\n    def to_dict(self):\n        '''Returns the dictionary representation of the model using alias'''\n        pass\n    @classmethod\n    def from_dict(cls, obj: dict) -> ActivatedEvent:\n        '''Create an instance of ActivatedEvent from a dict'''\n        pass\nCorresponding class implementation:\n\nfrom linebot.v3.webhooks.models.source import Source\nfrom linebot.v3.webhooks.models.chat_control import ChatControl\nfrom linebot.v3.webhooks.models.delivery_context import DeliveryContext\nimport pprint\nfrom linebot.v3.webhooks.models.event import Event\nfrom pydantic.v1 import Field\nimport json\n\nclass ActivatedEvent(Event):\n    \"\"\"\n    This event indicates that the module channel has been switched to Active Channel by calling the Acquire Control API. Sent to the webhook URL server of the module channel.\n    \"\"\"\n    chat_control: ChatControl = Field(..., alias='chatControl')\n    type: str = 'activated'\n    __properties = ['type', 'source', 'timestamp', 'mode', 'webhookEventId', 'deliveryContext', 'chatControl']\n\n    class Config:\n        \"\"\"Pydantic configuration\"\"\"\n        allow_population_by_field_name = True\n        validate_assignment = True\n\n    def to_str(self) -> str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.dict(by_alias=True))\n\n    def to_json(self) -> str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -> ActivatedEvent:\n        \"\"\"Create an instance of ActivatedEvent from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self):\n        \"\"\"Returns the dictionary representation of the model using alias\"\"\"\n        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)\n        if self.source:\n            _dict['source'] = self.source.to_dict()\n        if self.delivery_context:\n            _dict['deliveryContext'] = self.delivery_context.to_dict()\n        if self.chat_control:\n            _dict['chatControl'] = self.chat_control.to_dict()\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict) -> ActivatedEvent:\n        \"\"\"Create an instance of ActivatedEvent from a dict\"\"\"\n        if obj is None:\n            return None\n        if not isinstance(obj, dict):\n            return ActivatedEvent.parse_obj(obj)\n        _obj = ActivatedEvent.parse_obj({'type': obj.get('type'), 'source': Source.from_dict(obj.get('source')) if obj.get('source') is not None else None, 'timestamp': obj.get('timestamp'), 'mode': obj.get('mode'), 'webhook_event_id': obj.get('webhookEventId'), 'delivery_context': DeliveryContext.from_dict(obj.get('deliveryContext')) if obj.get('deliveryContext') is not None else None, 'chat_control': ChatControl.from_dict(obj.get('chatControl')) if obj.get('chatControl') is not None else None})\n        return _obj\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n@dataclass\nclass EvaluationResult:\n    '''\n    Result of program evaluation containing both metrics and optional artifacts\n    This maintains backward compatibility with the existing dict[str, float] contract\n    while adding a side-channel for arbitrary artifacts (text or binary data).\n    IMPORTANT: For custom MAP-Elites features, metrics values must be raw continuous\n    scores (e.g., actual counts, percentages, continuous measurements), NOT pre-computed\n    bin indices. The database handles all binning internally using min-max scaling.\n    Examples:\n        ✅ Correct: {\"combined_score\": 0.85, \"prompt_length\": 1247, \"execution_time\": 0.234}\n        ❌ Wrong:   {\"combined_score\": 0.85, \"prompt_length\": 7, \"execution_time\": 3}\n    '''\n    @classmethod\n    def from_dict(cls, metrics: Dict[str, float]) -> 'EvaluationResult':\n        '''Auto-wrap dict returns for backward compatibility'''\n        pass\n\n    def to_dict(self) -> Dict[str, float]:\n        '''Backward compatibility - return just metrics'''\n        pass\n\n    def has_artifacts(self) -> bool:\n        '''Check if this result contains any artifacts'''\n        pass\n\n    def get_artifact_keys(self) -> list:\n        '''Get list of artifact keys'''\n        pass\n\n    def get_artifact_size(self, key: str) -> int:\n        '''Get size of a specific artifact in bytes'''\n        pass\n\n    def get_total_artifact_size(self) -> int:\n        '''Get total size of all artifacts in bytes'''\n        pass"
  }
]