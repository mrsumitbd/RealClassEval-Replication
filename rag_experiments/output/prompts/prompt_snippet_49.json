[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Job(AbstractJob):\n\n    def __init__(self, model: AbstractPriorModel, simulate_cls: Callable, perturb_model: AbstractPriorModel, simulate_instance: ModelInstance, base_instance: ModelInstance, base_fit_cls: Callable, perturb_fit_cls: Callable, paths: AbstractPaths, number: int):\n        '''\n        Job to run non-linear searches comparing how well a model and a model with a perturbation fit the image.\n        Parameters\n        ----------\n        model\n            A base model that fits the image without a perturbation\n        perturb_model\n            A model of the perturbation which has been added to the underlying image\n        base_fit_cls\n            A class which defines the function which fits the base model to each simulated dataset of the sensitivity\n            map.\n        perturb_fit_cls\n            A class which defines the function which fits the perturbed model to each simulated dataset of the\n            sensitivity map.\n        paths\n            The paths defining the output directory structure of the sensitivity mapping.\n        '''\n        pass\n    @property\n    def base_paths(self):\n        pass\n    @property\n    def perturb_paths(self):\n        pass\n    @property\n    def is_complete(self) -> bool:\n        '''\n        Returns True if the job has been completed, False otherwise.\n        '''\n        pass\n\n    def perform(self) -> JobResult:\n        '''\n        - Create one model with a perturbation and another without\n        - Fit each model against the perturbed image\n        Returns\n        -------\n        An object comprising the results of the two fits\n        '''\n        pass\nCorresponding class implementation:\n\nfrom copy import copy\nfrom itertools import count\nfrom autofit.mapper.prior_model.abstract import AbstractPriorModel\nfrom typing import Callable, Optional\nfrom autofit.non_linear.paths.abstract import AbstractPaths\nfrom autofit.mapper.model import ModelInstance\nfrom autofit.non_linear.parallel import AbstractJob, AbstractJobResult\n\nclass Job(AbstractJob):\n    _number = count()\n\n    def __init__(self, model: AbstractPriorModel, simulate_cls: Callable, perturb_model: AbstractPriorModel, simulate_instance: ModelInstance, base_instance: ModelInstance, base_fit_cls: Callable, perturb_fit_cls: Callable, paths: AbstractPaths, number: int):\n        \"\"\"\n        Job to run non-linear searches comparing how well a model and a model with a perturbation fit the image.\n\n        Parameters\n        ----------\n        model\n            A base model that fits the image without a perturbation\n        perturb_model\n            A model of the perturbation which has been added to the underlying image\n        base_fit_cls\n            A class which defines the function which fits the base model to each simulated dataset of the sensitivity\n            map.\n        perturb_fit_cls\n            A class which defines the function which fits the perturbed model to each simulated dataset of the\n            sensitivity map.\n        paths\n            The paths defining the output directory structure of the sensitivity mapping.\n        \"\"\"\n        super().__init__(number=number)\n        self.model = model\n        self.simulate_cls = simulate_cls\n        self.perturb_model = perturb_model\n        self.simulate_instance = simulate_instance\n        self.base_instance = base_instance\n        self.base_fit_cls = base_fit_cls\n        self.perturb_fit_cls = perturb_fit_cls\n        self.paths = paths\n\n    @property\n    def base_paths(self):\n        return self.paths.for_sub_analysis('[base]')\n\n    @property\n    def perturb_paths(self):\n        return self.paths.for_sub_analysis('[perturb]')\n\n    @property\n    def is_complete(self) -> bool:\n        \"\"\"\n        Returns True if the job has been completed, False otherwise.\n        \"\"\"\n        return self.base_paths.is_complete and self.perturb_paths.is_complete or ((self.paths.output_path / '[base].zip').exists() and (self.paths.output_path / '[perturb].zip').exists())\n\n    def perform(self) -> JobResult:\n        \"\"\"\n        - Create one model with a perturbation and another without\n        - Fit each model against the perturbed image\n\n        Returns\n        -------\n        An object comprising the results of the two fits\n        \"\"\"\n        if self.is_complete:\n            dataset = None\n        else:\n            dataset = self.simulate_cls(instance=self.simulate_instance, simulate_path=self.paths.image_path.with_name('simulate'))\n        result = self.base_fit_cls(model=self.model, dataset=dataset, paths=self.base_paths, instance=self.simulate_instance)\n        perturb_model = copy(self.model)\n        perturb_model.perturb = self.perturb_model\n        perturb_result = self.perturb_fit_cls(model=perturb_model, dataset=dataset, paths=self.perturb_paths, instance=self.simulate_instance)\n        return JobResult(number=self.number, result=result, perturb_result=perturb_result)\n\nExample skeleton:\n\n\nclass BrotherQLRaster(object):\n    '''\n    This class facilitates the creation of a complete set\n    of raster instructions by adding them one after the other\n    using the methods of the class. Each method call is adding\n    instructions to the member variable :py:attr:`data`.\n    Instatiate the class by providing the printer\n    model as argument.\n    :param str model: Choose from the list of available models.\n    :ivar bytes data: The resulting bytecode with all instructions.\n    :ivar bool exception_on_warning: If set to True, an exception is raised if trying to add instruction which are not supported on the selected model. If set to False, the instruction is simply ignored and a warning sent to logging/stderr.\n    '''\n\n    def __init__(self, model='QL-500'):\n        pass\n\n    def _warn(self, problem, kind=BrotherQLRasterError):\n        '''\n        Logs the warning message `problem` or raises a\n        `BrotherQLRasterError` exception (changeable via `kind`)\n        if `self.exception_on_warning` is set to True.\n        :raises BrotherQLRasterError: Or other exception             set via the `kind` keyword argument.\n        '''\n        pass\n\n    def _unsupported(self, problem):\n        '''\n        Raises BrotherQLUnsupportedCmd if\n        exception_on_warning is set to True.\n        Issues a logger warning otherwise.\n        :raises BrotherQLUnsupportedCmd:\n        '''\n        pass\n    @property\n    def two_color_support(self):\n        pass\n\n    def add_initialize(self):\n        pass\n\n    def add_status_information(self):\n        ''' Status Information Request '''\n        pass\n\n    def add_switch_mode(self):\n        '''\n        Switch dynamic command mode\n        Switch to the raster mode on the printers that support\n        the mode change (others are in raster mode already).\n        '''\n        pass\n\n    def add_invalidate(self):\n        ''' clear command buffer '''\n        pass\n    @property\n    def mtype(self):\n        pass\n    @property\n    def mwidth(self):\n        pass\n    @property\n    def mlength(self):\n        pass\n    @property\n    def pquality(self):\n        pass\n    @mtype.setter\n    def mtype(self):\n        pass\n    @mwidth.setter\n    def mwidth(self):\n        pass\n    @mlength.setter\n    def mlength(self):\n        pass\n    @pquality.setter\n    def pquality(self):\n        pass\n\n    def add_media_and_quality(self, rnumber):\n        pass\n\n    def add_autocut(self, autocut=False):\n        pass\n\n    def add_cut_every(self, n=1):\n        pass\n\n    def add_expanded_mode(self):\n        pass\n\n    def add_margins(self, dots=35):\n        pass\n\n    def add_compression(self, compression=True):\n        '''\n        Add an instruction enabling or disabling compression for the transmitted raster image lines.\n        Not all models support compression. If the specific model doesn't support it but this method\n        is called trying to enable it, either a warning is set or an exception is raised depending on\n        the value of :py:attr:`exception_on_warning`\n        :param bool compression: Whether compression should be on or off\n        '''\n        pass\n\n    def get_pixel_width(self):\n        pass\n\n    def add_raster_data(self, image, second_image=None):\n        '''\n        Add the image data to the instructions.\n        The provided image has to be binary (every pixel\n        is either black or white).\n        :param PIL.Image.Image image: The image to be converted and added to the raster instructions\n        :param PIL.Image.Image second_image: A second image with a separate color layer (red layer for the QL-800 series)\n        '''\n        pass\n\n    def add_print(self, last_page=True):\n        pass\nCorresponding class implementation:\n\nimport struct\nimport packbits\nfrom builtins import bytes\nfrom .devicedependent import models, min_max_feed, min_max_length_dots, number_bytes_per_row, compressionsupport, cuttingsupport, expandedmode, two_color_support, modesetting\nfrom PIL import Image\nfrom . import BrotherQLError, BrotherQLUnsupportedCmd, BrotherQLUnknownModel, BrotherQLRasterError\n\nclass BrotherQLRaster(object):\n    \"\"\"\n    This class facilitates the creation of a complete set\n    of raster instructions by adding them one after the other\n    using the methods of the class. Each method call is adding\n    instructions to the member variable :py:attr:`data`.\n\n    Instatiate the class by providing the printer\n    model as argument.\n\n    :param str model: Choose from the list of available models.\n\n    :ivar bytes data: The resulting bytecode with all instructions.\n    :ivar bool exception_on_warning: If set to True, an exception is raised if trying to add instruction which are not supported on the selected model. If set to False, the instruction is simply ignored and a warning sent to logging/stderr.\n    \"\"\"\n\n    def __init__(self, model='QL-500'):\n        if model not in models:\n            raise BrotherQLUnknownModel()\n        self.model = model\n        self.data = b''\n        self._pquality = True\n        self.page_number = 0\n        self.cut_at_end = True\n        self.dpi_600 = False\n        self.two_color_printing = False\n        self._compression = False\n        self.exception_on_warning = False\n\n    def _warn(self, problem, kind=BrotherQLRasterError):\n        \"\"\"\n        Logs the warning message `problem` or raises a\n        `BrotherQLRasterError` exception (changeable via `kind`)\n        if `self.exception_on_warning` is set to True.\n\n        :raises BrotherQLRasterError: Or other exception             set via the `kind` keyword argument.\n        \"\"\"\n        if self.exception_on_warning:\n            raise kind(problem)\n        else:\n            logger.warning(problem)\n\n    def _unsupported(self, problem):\n        \"\"\"\n        Raises BrotherQLUnsupportedCmd if\n        exception_on_warning is set to True.\n        Issues a logger warning otherwise.\n\n        :raises BrotherQLUnsupportedCmd:\n        \"\"\"\n        self._warn(problem, kind=BrotherQLUnsupportedCmd)\n\n    @property\n    def two_color_support(self):\n        return self.model in two_color_support\n\n    def add_initialize(self):\n        self.page_number = 0\n        self.data += b'\\x1b@'\n\n    def add_status_information(self):\n        \"\"\" Status Information Request \"\"\"\n        self.data += b'\\x1biS'\n\n    def add_switch_mode(self):\n        \"\"\"\n        Switch dynamic command mode\n        Switch to the raster mode on the printers that support\n        the mode change (others are in raster mode already).\n        \"\"\"\n        if self.model not in modesetting:\n            self._unsupported(\"Trying to switch the operating mode on a printer that doesn't support the command.\")\n            return\n        self.data += b'\\x1bia\\x01'\n\n    def add_invalidate(self):\n        \"\"\" clear command buffer \"\"\"\n        self.data += b'\\x00' * 200\n\n    @property\n    def mtype(self):\n        return self._mtype\n\n    @property\n    def mwidth(self):\n        return self._mwidth\n\n    @property\n    def mlength(self):\n        return self._mlength\n\n    @property\n    def pquality(self):\n        return self._pquality\n\n    @mtype.setter\n    def mtype(self, value):\n        self._mtype = bytes([value & 255])\n\n    @mwidth.setter\n    def mwidth(self, value):\n        self._mwidth = bytes([value & 255])\n\n    @mlength.setter\n    def mlength(self, value):\n        self._mlength = bytes([value & 255])\n\n    @pquality.setter\n    def pquality(self, value):\n        self._pquality = bool(value)\n\n    def add_media_and_quality(self, rnumber):\n        self.data += b'\\x1biz'\n        valid_flags = 128\n        valid_flags |= (self._mtype is not None) << 1\n        valid_flags |= (self._mwidth is not None) << 2\n        valid_flags |= (self._mlength is not None) << 3\n        valid_flags |= self._pquality << 6\n        self.data += bytes([valid_flags])\n        vals = [self._mtype, self._mwidth, self._mlength]\n        self.data += b''.join((b'\\x00' if val is None else val for val in vals))\n        self.data += struct.pack('<L', rnumber)\n        self.data += bytes([0 if self.page_number == 0 else 1])\n        self.data += b'\\x00'\n\n    def add_autocut(self, autocut=False):\n        if self.model not in cuttingsupport:\n            self._unsupported(\"Trying to call add_autocut with a printer that doesn't support it\")\n            return\n        self.data += b'\\x1biM'\n        self.data += bytes([autocut << 6])\n\n    def add_cut_every(self, n=1):\n        if self.model not in cuttingsupport:\n            self._unsupported(\"Trying to call add_cut_every with a printer that doesn't support it\")\n            return\n        self.data += b'\\x1biA'\n        self.data += bytes([n & 255])\n\n    def add_expanded_mode(self):\n        if self.model not in expandedmode:\n            self._unsupported(\"Trying to set expanded mode (dpi/cutting at end) on a printer that doesn't support it\")\n            return\n        if self.two_color_printing and (not self.two_color_support):\n            self._unsupported(\"Trying to set two_color_printing in expanded mode on a printer that doesn't support it.\")\n            return\n        self.data += b'\\x1biK'\n        flags = 0\n        flags |= self.cut_at_end << 3\n        flags |= self.dpi_600 << 6\n        flags |= self.two_color_printing << 0\n        self.data += bytes([flags])\n\n    def add_margins(self, dots=35):\n        self.data += b'\\x1bid'\n        self.data += struct.pack('<H', dots)\n\n    def add_compression(self, compression=True):\n        \"\"\"\n        Add an instruction enabling or disabling compression for the transmitted raster image lines.\n        Not all models support compression. If the specific model doesn't support it but this method\n        is called trying to enable it, either a warning is set or an exception is raised depending on\n        the value of :py:attr:`exception_on_warning`\n\n        :param bool compression: Whether compression should be on or off\n        \"\"\"\n        if self.model not in compressionsupport:\n            self._unsupported(\"Trying to set compression on a printer that doesn't support it\")\n            return\n        self._compression = compression\n        self.data += b'M'\n        self.data += bytes([compression << 1])\n\n    def get_pixel_width(self):\n        try:\n            nbpr = number_bytes_per_row[self.model]\n        except:\n            nbpr = number_bytes_per_row['default']\n        return nbpr * 8\n\n    def add_raster_data(self, image, second_image=None):\n        \"\"\"\n        Add the image data to the instructions.\n        The provided image has to be binary (every pixel\n        is either black or white).\n\n        :param PIL.Image.Image image: The image to be converted and added to the raster instructions\n        :param PIL.Image.Image second_image: A second image with a separate color layer (red layer for the QL-800 series)\n        \"\"\"\n        logger.debug('raster_image_size: {0}x{1}'.format(*image.size))\n        if image.size[0] != self.get_pixel_width():\n            fmt = 'Wrong pixel width: {}, expected {}'\n            raise BrotherQLRasterError(fmt.format(image.size[0], self.get_pixel_width()))\n        images = [image]\n        if second_image:\n            if image.size != second_image.size:\n                fmt = \"First and second image don't have the same dimesions: {} vs {}.\"\n                raise BrotherQLRasterError(fmt.format(image.size, second_image.size))\n            images.append(second_image)\n        frames = []\n        for image in images:\n            image = image.transpose(Image.FLIP_LEFT_RIGHT)\n            image = image.convert('1')\n            frames.append(bytes(image.tobytes(encoder_name='raw')))\n        frame_len = len(frames[0])\n        row_len = images[0].size[0] // 8\n        start = 0\n        file_str = BytesIO()\n        while start + row_len <= frame_len:\n            for i, frame in enumerate(frames):\n                row = frame[start:start + row_len]\n                if self._compression:\n                    row = packbits.encode(row)\n                translen = len(row)\n                if self.model.startswith('PT'):\n                    file_str.write(b'G')\n                    file_str.write(bytes([translen % 256, translen // 256]))\n                else:\n                    if second_image:\n                        file_str.write(b'w\\x01' if i == 0 else b'w\\x02')\n                    else:\n                        file_str.write(b'g\\x00')\n                    file_str.write(bytes([translen]))\n                file_str.write(row)\n            start += row_len\n        self.data += file_str.getvalue()\n\n    def add_print(self, last_page=True):\n        if last_page:\n            self.data += b'\\x1a'\n        else:\n            self.data += b'\\x0c'\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass FFTComplexScipyFFTpack:\n    '''\n    Initial implementation of fft_cmplx_scipy_fftpack task.\n    This will be evolved by OpenEvolve to improve performance and correctness.\n    '''\n    @staticmethod\n    def solve(problem):\n        '''\n        Solve the fft_cmplx_scipy_fftpack problem.\n        Args:\n            problem: Dictionary containing problem data specific to fft_cmplx_scipy_fftpack\n        Returns:\n            The solution in the format expected by the task\n        '''\n        pass\n    @staticmethod\n    def is_solution(problem, solution):\n        '''\n        Check if the provided solution is valid.\n        Args:\n            problem: The original problem\n            solution: The proposed solution\n        Returns:\n            True if the solution is valid, False otherwise\n        '''\n        pass"
  }
]