[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass UnrootedLayout(BaseLayout):\n    '''Layout for unrooted tree projection: \"unrooted\", \"u1\", \"u2\"\n    '''\n\n    def run(self):\n        '''Fills the .coords array with x, y values.'''\n        pass\n\n    def style_overwrite(self):\n        '''Overwrite styles that are not allowed in unrooted layout\n        of which should have different defaults.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom toytree.layout import BaseLayout, get_tip_labels_angles\n\nclass UnrootedLayout(BaseLayout):\n    \"\"\"Layout for unrooted tree projection: \"unrooted\", \"u1\", \"u2\"\n    \"\"\"\n\n    def run(self):\n        \"\"\"Fills the .coords array with x, y values.\"\"\"\n        self.coords = equal_daylight_algorithm(tree=self.tree, max_iter=50, use_edge_lengths=self.style.use_edge_lengths)\n        self.tcoords = self.coords[:self.tree.ntips, :].copy()\n        self.angles = get_tip_labels_angles(self.tree, self.coords)\n        self.style_overwrite()\n\n    def style_overwrite(self):\n        \"\"\"Overwrite styles that are not allowed in unrooted layout\n        of which should have different defaults.\n        \"\"\"\n        self.style.tip_labels_align = False\n        self.style.edge_type = 'c'\n\nExample skeleton:\n\n\nclass ColorRange(ColorList):\n\n    def __init__(self, h=(0.0, 1.0), s=(0.0, 1.0), b=(0.0, 1.0), a=(1.0, 1.0), grayscale=False, name='', length=100):\n        '''A stateless list of colors whose HSB values are confined to a range.\n        Hue, saturation and brightness are confined to a (min, max) tuple,\n        or a list of (min, max) tuples for discontinuous ranges, or to a single value.\n        This way you can describe concepts such as \"light\", \"dark\", etc.\n        With stateless we mean that you are never sure which colors are\n        in the ColorRange, different colors that fall within the ranges\n        are returned each time when calling color() or colors().\n        ColorRange has all the ColorList transformations (such as darken()),\n        these return ColorList objects. It's like a snapshot of the original\n        stateless ColorRange.\n        '''\n        pass\n\n    def constrain_hue(self, min, max=None):\n        pass\n\n    def constrain_saturation(self, min, max=None):\n        pass\n\n    def constrain_brightness(self, min, max=None):\n        pass\n\n    def constrain_alpha(self, min, max=None):\n        pass\n\n    def copy(self, clr=None, d=0.0):\n        '''Returns a copy of the range.\n        Optionally, supply a color to get a range copy limited to the\n        hue of that color.\n        '''\n        pass\n\n    def color(self, clr=None, d=0.035):\n        '''Returns a color with random values in the defined h, s b, a ranges.\n        If a color is given, use that color's hue and alpha,\n        and generate its saturation and brightness from the shade.\n        The hue is varied with the given d.\n        In this way you could have a \"warm\" color range\n        that returns all kinds of warm colors.\n        When a red color is given as parameter it would generate\n        all kinds of warm red colors.\n        '''\n        pass\n\n    def colors(self, clr=None, n=10, d=0.035):\n        pass\n\n    def contains(self, clr):\n        '''Returns True if the given color is part of this color range.\n        Check whether each h, s, b, a component of the color\n        falls within the defined range for that component.\n        If the given color is grayscale,\n        checks against the definitions for black and white.\n        '''\n        pass\n\n    def __add__(self, colorrange):\n        '''Combines two ColorRange objects into one.\n        For example, if you merge a dark green range and a light red\n        range, you get a range returning dark and light variations of\n        green and red.\n        '''\n        pass\n\n    def __iadd__(self, colorrange):\n        pass\n\n    def __contains__(self, clr):\n        pass\n\n    def __len__(self):\n        pass\n\n    def __getitem__(self, i):\n        pass\n\n    def __getslice__(self, i, j):\n        pass\n\n    def __iter__(self):\n        pass\n\n    def __call__(self, clr=None, d=0.035, n=1):\n        pass\n\n    def __str__(self):\n        pass\n\n    def __repr__(self):\n        pass\nCorresponding class implementation:\n\nfrom shoebot.graphics import Color as BaseColor\nfrom random import random, choice\nfrom copy import deepcopy\n\nclass ColorRange(ColorList):\n\n    def __init__(self, h=(0.0, 1.0), s=(0.0, 1.0), b=(0.0, 1.0), a=(1.0, 1.0), grayscale=False, name='', length=100):\n        \"\"\"A stateless list of colors whose HSB values are confined to a range.\n\n        Hue, saturation and brightness are confined to a (min, max) tuple,\n        or a list of (min, max) tuples for discontinuous ranges, or to a single value.\n        This way you can describe concepts such as \"light\", \"dark\", etc.\n\n        With stateless we mean that you are never sure which colors are\n        in the ColorRange, different colors that fall within the ranges\n        are returned each time when calling color() or colors().\n\n        ColorRange has all the ColorList transformations (such as darken()),\n        these return ColorList objects. It's like a snapshot of the original\n        stateless ColorRange.\n        \"\"\"\n        ColorList.__init__(self)\n        self.name = name\n        self.h = h\n        self.s = s\n        self.b = b\n        self.a = a\n        self.grayscale = grayscale\n        if not grayscale:\n            self.black = ColorRange((0, 1), 0, 0, 1, True, name)\n            self.white = ColorRange((0, 1), 0, 1, 1, True, name)\n        self.length = length\n\n    def constrain_hue(self, min, max=None):\n        if max is None:\n            max = min\n        self.h = (min, max)\n\n    def constrain_saturation(self, min, max=None):\n        if max is None:\n            max = min\n        self.s = (min, max)\n\n    def constrain_brightness(self, min, max=None):\n        if max is None:\n            max = min\n        self.b = (min, max)\n\n    def constrain_alpha(self, min, max=None):\n        if max is None:\n            max = min\n        self.a = (min, max)\n\n    def copy(self, clr=None, d=0.0):\n        \"\"\"Returns a copy of the range.\n\n        Optionally, supply a color to get a range copy limited to the\n        hue of that color.\n        \"\"\"\n        cr = ColorRange()\n        cr.name = self.name\n        cr.h = deepcopy(self.h)\n        cr.s = deepcopy(self.s)\n        cr.b = deepcopy(self.b)\n        cr.a = deepcopy(self.a)\n        cr.grayscale = self.grayscale\n        if not self.grayscale:\n            cr.black = self.black.copy()\n            cr.white = self.white.copy()\n        if clr != None:\n            cr.h, cr.a = (clr.h + d * (random() * 2 - 1), clr.a)\n        return cr\n\n    def color(self, clr=None, d=0.035):\n        \"\"\"Returns a color with random values in the defined h, s b, a ranges.\n\n        If a color is given, use that color's hue and alpha,\n        and generate its saturation and brightness from the shade.\n        The hue is varied with the given d.\n\n        In this way you could have a \"warm\" color range\n        that returns all kinds of warm colors.\n        When a red color is given as parameter it would generate\n        all kinds of warm red colors.\n        \"\"\"\n        if clr != None and (not isinstance(clr, Color)):\n            clr = color(clr)\n        if clr != None and (not self.grayscale):\n            if clr.is_black:\n                return self.black.color(clr, d)\n            if clr.is_white:\n                return self.white.color(clr, d)\n            if clr.is_grey:\n                return choice((self.black.color(clr, d), self.white.color(clr, d)))\n        h, s, b, a = (self.h, self.s, self.b, self.a)\n        if clr != None:\n            h, a = (clr.h + d * (random() * 2 - 1), clr.a)\n        hsba = []\n        for v in [h, s, b, a]:\n            if isinstance(v, _list):\n                min, max = choice(v)\n            elif isinstance(v, tuple):\n                min, max = v\n            else:\n                min, max = (v, v)\n            hsba.append(min + (max - min) * random())\n        h, s, b, a = hsba\n        return color(h, s, b, a, mode='hsb')\n\n    def colors(self, clr=None, n=10, d=0.035):\n        return colorlist([self.color(clr, d) for i in _range(n)])\n    colorlist = colors\n\n    def contains(self, clr):\n        \"\"\"Returns True if the given color is part of this color range.\n\n        Check whether each h, s, b, a component of the color\n        falls within the defined range for that component.\n\n        If the given color is grayscale,\n        checks against the definitions for black and white.\n        \"\"\"\n        if not isinstance(clr, Color):\n            return False\n        if not isinstance(clr, _list):\n            clr = [clr]\n        for clr in clr:\n            if clr.is_grey and (not self.grayscale):\n                return self.black.contains(clr) or self.white.contains(clr)\n            for r, v in [(self.h, clr.h), (self.s, clr.s), (self.b, clr.brightness), (self.a, clr.a)]:\n                if isinstance(r, _list):\n                    pass\n                elif isinstance(r, tuple):\n                    r = [r]\n                else:\n                    r = [(r, r)]\n                for min, max in r:\n                    if not min <= v <= max:\n                        return False\n        return True\n\n    def __add__(self, colorrange):\n        \"\"\"Combines two ColorRange objects into one.\n\n        For example, if you merge a dark green range and a light red\n        range, you get a range returning dark and light variations of\n        green and red.\n        \"\"\"\n        if isinstance(colorrange, Color):\n            colorrange = ColorList(colorrange)\n        if isinstance(colorrange, ColorList) and (not isinstance(colorrange, ColorRange)):\n            colorrange = ColorRange([(clr.h, clr.h) for clr in colorrange], [], [])\n        hsba = [[], [], [], []]\n        for r in [self, colorrange]:\n            for i in _range(4):\n                v = [r.h, r.s, r.b, r.a][i]\n                if isinstance(v, _list):\n                    hsba[i].extend(v)\n                elif isinstance(v, tuple):\n                    hsba[i].append(v)\n                else:\n                    hsba[i].append((v, v))\n        r = ColorRange(*hsba)\n        return r\n\n    def __iadd__(self, colorrange):\n        return self.__add__(colorrange)\n\n    def __contains__(self, clr):\n        return self.contains(clr)\n\n    def __len__(self):\n        return self.length\n\n    def __getitem__(self, i):\n        return self.color()\n\n    def __getslice__(self, i, j):\n        j = min(len(self), j)\n        n = min(len(self), j - i)\n        return colorlist([self.color() for i in _range(n)])\n\n    def __iter__(self):\n        colors = [self.color() for i in _range(len(self))]\n        return iter(colors)\n\n    def __call__(self, clr=None, d=0.035, n=1):\n        if isinstance(clr, _list):\n            return colorlist([self.color(clr, d) for clr in clr])\n        elif n > 1:\n            return colorlist([self.color(clr, d) for i in _range(n)])\n        else:\n            return self.color(clr, d)\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return self.name\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass Text_border:\n    '''文本描边的参数'''\n\n    def __init__(self, *, alpha: float=1.0, color: Tuple[float, float, float]=(0.0, 0.0, 0.0), width:\n        '''\n        Args:\n            alpha (`float`, optional): 描边不透明度, 取值范围[0, 1], 默认为1.0\n            color (`Tuple[float, float, float]`, optional): 描边颜色, RGB三元组, 取值范围为[0, 1], 默认为黑色\n            width (`float`, optional): 描边宽度, 与剪映中一致, 取值范围为[0, 100], 默认为40.0\n        '''\n        pass\n\n    def export_json(self) -> Dict[str, Any]:\n        '''导出JSON数据, 放置在素材content的styles中'''\n        pass"
  }
]