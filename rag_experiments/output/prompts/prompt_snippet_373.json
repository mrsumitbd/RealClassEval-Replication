[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass ScatterPlot(PluginInterface):\n    '''A Scatter Plot Plugin for Feature Sets.'''\n\n    def __init__(self, show_axes: bool=True):\n        '''Initialize the Scatter Plot Plugin\n        Args:\n            show_axes (bool): Whether to show the axes and grid. Default is True.\n        '''\n        pass\n\n    def create_component(self, component_id: str) -> html.Div:\n        '''Create a Dash Graph Component without any data.\n        Args:\n            component_id (str): The ID of the web component.\n        Returns:\n            html.Div: A Dash Div Component containing the graph and dropdowns.\n        '''\n        pass\n\n    def update_properties(self, input_data: pd.DataFrame, **kwargs) -> list:\n        '''Update the property values for the plugin component.\n        Args:\n            input_data (pd.DataFrame): The input data object.\n            **kwargs: Additional keyword arguments (plugins can define their own arguments).\n                      Note: The current kwargs processed are:\n                            - x: The default x-axis column\n                            - y: The default y-axis column\n                            - color: The default color column\n                            - dropdown_columns: The columns to use for the x and y options\n                            - hover_columns: The columns to show when hovering over a point\n                            - suppress_hover_display: Suppress hover display (default: False)\n                            - custom_data: Custom data that get passed to hoverData callbacks\n        Returns:\n            list: A list of updated property values (figure, x options, y options, color options,\n                                                    label options, x default, y default,\n                                                    color default).\n        '''\n        pass\n\n    def create_scatter_plot(self, df: pd.DataFrame, x_col: str, y_col: str, color_col: str, label_col: str, regression_line: bool=False, marker_size: int=15) -> go.Figure:\n        '''Create a Plotly Scatter Plot figure.\n        Args:\n            df (pd.DataFrame): The dataframe containing the data.\n            x_col (str): The column to use for the x-axis.\n            y_col (str): The column to use for the y-axis.\n            color_col (str): The column to use for the color scale.\n            label_col (str): The column to use for point labels.\n            regression_line (bool): Whether to include a regression line.\n            marker_size (int): Size of the markers. Default is 15.\n        Returns:\n            go.Figure: A Plotly Figure object.\n        '''\n        pass\n\n        def generate_hover_text(row):\n                pass\n\n    def register_internal_callbacks(self):\n        '''Register any internal callbacks for the plugin.'''\n        pass\n        @callback(Output(f'{self.component_id}-graph', 'figure', allow_duplicate=True), [Input(f'{self.component_id}-x-dropdown', 'value'), Input(f'{self.component_id}-y-dropdown', 'value'), Input(f'{self.component_id}-color-dropdown', 'value'), Input(f'{self.component_id}-label-dropdown', 'value'), Input(f'{self.component_id}-regression-line', 'value')], prevent_initial_call=True)\n        def _update_scatter_plot(x_value, y_value, color_value, label_value, regression_line):\n                '''Update the Scatter Plot Graph based on the dropdown values.'''\n                pass\n        @callback(Output(f'{self.component_id}-overlay', 'show'), Output(f'{self.component_id}-overlay', 'bbox'), Output(f'{self.component_id}-overlay', 'children'), Input(f'{self.component_id}-graph', 'hoverData'))\n        def _scatter_overlay(hover_data):\n                pass\nCorresponding class implementation:\n\nfrom workbench.utils.theme_manager import ThemeManager\nfrom dash import dcc, html, callback, Input, Output, no_update\nimport plotly.express as px\nimport base64\nimport pandas as pd\nfrom dash.exceptions import PreventUpdate\nfrom workbench.utils.plot_utils import prediction_intervals\nimport plotly.graph_objects as go\nfrom workbench.web_interface.components.plugin_interface import PluginInterface, PluginPage, PluginInputType\n\nclass ScatterPlot(PluginInterface):\n    \"\"\"A Scatter Plot Plugin for Feature Sets.\"\"\"\n    auto_load_page = PluginPage.NONE\n    plugin_input_type = PluginInputType.DATAFRAME\n\n    def __init__(self, show_axes: bool=True):\n        \"\"\"Initialize the Scatter Plot Plugin\n\n        Args:\n            show_axes (bool): Whether to show the axes and grid. Default is True.\n        \"\"\"\n        self.component_id = None\n        self.hover_columns = []\n        self.df = None\n        self.show_axes = show_axes\n        self.theme_manager = ThemeManager()\n        self.colorscale = self.theme_manager.colorscale()\n        super().__init__()\n\n    def create_component(self, component_id: str) -> html.Div:\n        \"\"\"Create a Dash Graph Component without any data.\n\n        Args:\n            component_id (str): The ID of the web component.\n\n        Returns:\n            html.Div: A Dash Div Component containing the graph and dropdowns.\n        \"\"\"\n        self.component_id = component_id\n        self.properties = [(f'{component_id}-graph', 'figure'), (f'{component_id}-x-dropdown', 'options'), (f'{component_id}-y-dropdown', 'options'), (f'{component_id}-color-dropdown', 'options'), (f'{component_id}-label-dropdown', 'options'), (f'{component_id}-x-dropdown', 'value'), (f'{component_id}-y-dropdown', 'value'), (f'{component_id}-color-dropdown', 'value')]\n        self.signals = [(f'{component_id}-graph', 'hoverData'), (f'{component_id}-graph', 'clickData')]\n        return html.Div(children=[dcc.Graph(id=f'{component_id}-graph', figure=self.display_text('Waiting for Data...'), config={'scrollZoom': True}, style={'height': '100%'}, clear_on_unhover=True), html.Div([html.Label('X', style={'marginLeft': '40px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-x-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, clearable=False), html.Label('Y', style={'marginLeft': '30px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-y-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, clearable=False), html.Label('Color', style={'marginLeft': '30px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-color-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, clearable=False), html.Label('Label', style={'marginLeft': '30px', 'marginRight': '5px', 'fontWeight': 'bold'}), dcc.Dropdown(id=f'{component_id}-label-dropdown', className='dropdown', style={'min-width': '50px', 'flex': 1}, options=[{'label': 'None', 'value': 'none'}], value='none', clearable=False), dcc.Checklist(id=f'{component_id}-regression-line', options=[{'label': ' Diagonal', 'value': 'show'}], value=[], style={'margin': '10px'})], style={'padding': '0px 0px 10px 0px', 'display': 'flex', 'gap': '10px'}), dcc.Tooltip(id=f'{component_id}-overlay', background_color='rgba(0,0,0,0)', border_color='rgba(0,0,0,0)', direction='bottom', loading_text='')], style={'height': '100%', 'display': 'flex', 'flexDirection': 'column'})\n\n    def update_properties(self, input_data: pd.DataFrame, **kwargs) -> list:\n        \"\"\"Update the property values for the plugin component.\n\n        Args:\n            input_data (pd.DataFrame): The input data object.\n            **kwargs: Additional keyword arguments (plugins can define their own arguments).\n                      Note: The current kwargs processed are:\n                            - x: The default x-axis column\n                            - y: The default y-axis column\n                            - color: The default color column\n                            - dropdown_columns: The columns to use for the x and y options\n                            - hover_columns: The columns to show when hovering over a point\n                            - suppress_hover_display: Suppress hover display (default: False)\n                            - custom_data: Custom data that get passed to hoverData callbacks\n\n        Returns:\n            list: A list of updated property values (figure, x options, y options, color options,\n                                                    label options, x default, y default,\n                                                    color default).\n        \"\"\"\n        limit = kwargs.get('limit', 20000)\n        if isinstance(input_data, pd.DataFrame):\n            self.df = input_data.sample(n=limit) if len(input_data) > limit else input_data\n        else:\n            raise ValueError('The input data must be a Pandas DataFrame.')\n        aws_cols = ['write_time', 'api_invocation_time', 'is_deleted', 'event_time']\n        self.df = self.df.drop(columns=aws_cols, errors='ignore')\n        self.hover_columns = kwargs.get('hover_columns', self.df.columns.tolist()[:10])\n        self.suppress_hover_display = kwargs.get('suppress_hover_display', False)\n        self.custom_data = kwargs.get('custom_data', [])\n        numeric_columns = self.df.select_dtypes(include='number').columns.tolist()\n        if len(numeric_columns) < 3:\n            raise ValueError('At least three numeric columns are required for x, y, and color.')\n        x_default = kwargs.get('x', numeric_columns[0])\n        y_default = kwargs.get('y', numeric_columns[1])\n        color_default = kwargs.get('color', numeric_columns[2])\n        regression_line = kwargs.get('regression_line', False)\n        figure = self.create_scatter_plot(self.df, x_default, y_default, color_default, 'none', regression_line)\n        dropdown_columns = kwargs.get('dropdown_columns', numeric_columns)\n        x_options = [{'label': col, 'value': col} for col in dropdown_columns]\n        y_options = x_options.copy()\n        cat_columns = self.df.select_dtypes(include=['object', 'string', 'category']).columns.tolist()\n        cat_columns = [col for col in cat_columns if self.df[col].astype(str).nunique() < 20]\n        color_columns = numeric_columns + cat_columns\n        color_options = [{'label': col, 'value': col} for col in color_columns]\n        label_options = [{'label': 'None', 'value': 'none'}]\n        label_options.extend([{'label': col, 'value': col} for col in self.df.columns])\n        return [figure, x_options, y_options, color_options, label_options, x_default, y_default, color_default]\n\n    def create_scatter_plot(self, df: pd.DataFrame, x_col: str, y_col: str, color_col: str, label_col: str, regression_line: bool=False, marker_size: int=15) -> go.Figure:\n        \"\"\"Create a Plotly Scatter Plot figure.\n\n        Args:\n            df (pd.DataFrame): The dataframe containing the data.\n            x_col (str): The column to use for the x-axis.\n            y_col (str): The column to use for the y-axis.\n            color_col (str): The column to use for the color scale.\n            label_col (str): The column to use for point labels.\n            regression_line (bool): Whether to include a regression line.\n            marker_size (int): Size of the markers. Default is 15.\n\n        Returns:\n            go.Figure: A Plotly Figure object.\n        \"\"\"\n        show_labels = label_col != 'none' and len(df) < 1000\n\n        def generate_hover_text(row):\n            return '<br>'.join([f'{col}: {row[col]}' for col in self.hover_columns])\n        hovertext = df.apply(generate_hover_text, axis=1)\n        hovertemplate = '%{hovertext}<extra></extra>'\n        hoverinfo = 'none' if self.suppress_hover_display else None\n        if pd.api.types.is_numeric_dtype(df[color_col]):\n            marker_color = df[color_col]\n            colorbar = dict(title=color_col, thickness=10)\n            data = [go.Scattergl(x=df[x_col], y=df[y_col], mode='markers', text=df[label_col].astype(str) if show_labels else None, textposition='top center', hoverinfo=hoverinfo, hovertext=hovertext, hovertemplate=hovertemplate, customdata=df[self.custom_data], marker=dict(size=marker_size, color=marker_color, colorscale=self.colorscale, colorbar=colorbar, opacity=0.8, line=dict(color='rgba(0,0,0,0.25)', width=1)))]\n            showlegend = False\n        else:\n            categories = sorted(df[color_col].astype(str).unique())\n            discrete_colors = px.colors.qualitative.Plotly\n            data = []\n            for i, cat in enumerate(categories):\n                sub_df = df[df[color_col] == cat]\n                sub_hovertext = hovertext.loc[sub_df.index]\n                trace = go.Scattergl(x=sub_df[x_col], y=sub_df[y_col], mode='markers', text=sub_df[label_col] if show_labels else None, textposition='top center', name=cat, hoverinfo=hoverinfo, hovertext=sub_hovertext, hovertemplate=hovertemplate, customdata=sub_df[self.custom_data], marker=dict(size=marker_size, color=discrete_colors[i % len(discrete_colors)], opacity=0.8, line=dict(color='rgba(0,0,0,0.25)', width=1)))\n                data.append(trace)\n            showlegend = True\n        figure = go.Figure()\n        if y_col == 'prediction' or x_col == 'prediction':\n            figure = prediction_intervals(df, figure, x_col)\n        if regression_line:\n            axis_min = min(df[x_col].min(), df[y_col].min())\n            axis_max = max(df[x_col].max(), df[y_col].max())\n            figure.add_shape(type='line', line=dict(width=4, color='rgba(128, 128, 128, 1.0)'), x0=axis_min, x1=axis_max, y0=axis_min, y1=axis_max)\n        figure.add_traces(data)\n        if self.show_axes:\n            xaxis = dict(title=dict(text=x_col, font=dict(size=16), standoff=15), tickformat='.2f', tickfont=dict(size=10))\n            yaxis = dict(title=dict(text=y_col, font=dict(size=16), standoff=25), tickformat='.2f', tickfont=dict(size=10))\n        else:\n            xaxis = dict(visible=False)\n            yaxis = dict(visible=False)\n        figure.update_layout(margin={'t': 20, 'b': 55, 'r': 0, 'l': 35, 'pad': 0}, xaxis=xaxis, yaxis=yaxis, showlegend=showlegend, dragmode='pan', modebar={'bgcolor': 'rgba(0, 0, 0, 0)'}, uirevision='constant')\n        return figure\n\n    def register_internal_callbacks(self):\n        \"\"\"Register any internal callbacks for the plugin.\"\"\"\n\n        @callback(Output(f'{self.component_id}-graph', 'figure', allow_duplicate=True), [Input(f'{self.component_id}-x-dropdown', 'value'), Input(f'{self.component_id}-y-dropdown', 'value'), Input(f'{self.component_id}-color-dropdown', 'value'), Input(f'{self.component_id}-label-dropdown', 'value'), Input(f'{self.component_id}-regression-line', 'value')], prevent_initial_call=True)\n        def _update_scatter_plot(x_value, y_value, color_value, label_value, regression_line):\n            \"\"\"Update the Scatter Plot Graph based on the dropdown values.\"\"\"\n            if not self.df.empty and x_value and y_value and color_value:\n                figure = self.create_scatter_plot(self.df, x_value, y_value, color_value, label_value, regression_line)\n                return figure\n            raise PreventUpdate\n\n        @callback(Output(f'{self.component_id}-overlay', 'show'), Output(f'{self.component_id}-overlay', 'bbox'), Output(f'{self.component_id}-overlay', 'children'), Input(f'{self.component_id}-graph', 'hoverData'))\n        def _scatter_overlay(hover_data):\n            if hover_data is None:\n                return (False, no_update, no_update)\n            bbox = hover_data['points'][0]['bbox']\n            svg = '\\n            <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\" style=\"overflow: visible;\">\\n                <!-- Circle for the node -->\\n                <circle cx=\"50\" cy=\"50\" r=\"10\" stroke=\"rgba(255, 255, 255, 1)\" stroke-width=\"3\" fill=\"none\" />\\n            </svg>\\n            '\n            encoded_svg = base64.b64encode(svg.encode('utf-8')).decode('utf-8')\n            data_uri = f'data:image/svg+xml;base64,{encoded_svg}'\n            svg_image = html.Img(src=data_uri, style={'width': '100px', 'height': '100px'})\n            center_x = (bbox['x0'] + bbox['x1']) / 2\n            center_y = (bbox['y0'] + bbox['y1']) / 2\n            adjusted_bbox = {'x0': center_x - 50, 'x1': center_x + 50, 'y0': center_y - 162, 'y1': center_y - 62}\n            return (True, adjusted_bbox, [svg_image])\n\nExample skeleton:\n\n\nclass DataTable(BaseModel):\n    '''\n    Data table class. Prepares and holds data and configuration\n    for either a table or a violin plot.\n    '''\n\n    def is_empty(self) -> bool:\n        '''\n        Check if the table is empty.\n        '''\n        pass\n    @staticmethod\n    def create(data: Dict[SectionKey, SectionT], table_id: str, table_anchor: Anchor, pconfig: TableConfig, headers: Dict[SectionKey, Dict[ColumnKey, ColumnDict]]) -> 'DataTable':\n        '''Prepare data for use in a table or plot'''\n        pass\n\n    def get_headers_in_order(self, keep_hidden: bool=True) -> List[Tuple[int, ColumnKey, ColumnMeta]]:\n        '''\n        Gets the headers in the order they want to be displayed.\n        Returns a list of triplets: (bucket_idx, key, header_info)\n        '''\n        pass\n\n    def merge(self, new_dt: 'DataTable'):\n        '''\n        Extend the existing DataTable with new data.\n        Sections are matched by their column keys rather than their position in the list.\n        This allows for merging sections even if they appear in different order.\n        New samples and columns are added at the end, while existing sample/column combinations\n        are overwritten with new data.\n        '''\n        pass\n\n    def _rebuild_headers_in_order(self) -> None:\n        '''\n        Rebuild the headers_in_order dictionary based on current sections and columns.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom multiqc.types import Anchor, ColumnKey, SampleGroup, SampleName, SectionKey\nfrom typing import Any, Callable, Dict, List, Mapping, NewType, Optional, Sequence, Set, Tuple, TypedDict, Union, cast\nfrom pydantic import BaseModel, Field\nfrom collections import defaultdict\nfrom multiqc import config, report\n\nclass DataTable(BaseModel):\n    \"\"\"\n    Data table class. Prepares and holds data and configuration\n    for either a table or a violin plot.\n    \"\"\"\n    id: str\n    anchor: Anchor\n    pconfig: TableConfig\n    section_by_id: Dict[SectionKey, TableSection]\n    headers_in_order: Dict[float, List[Tuple[int, ColumnKey]]]\n\n    def is_empty(self) -> bool:\n        \"\"\"\n        Check if the table is empty.\n        \"\"\"\n        return not self.section_by_id or not any((section.rows_by_sgroup.values() for section in self.section_by_id.values()))\n\n    @staticmethod\n    def create(data: Dict[SectionKey, SectionT], table_id: str, table_anchor: Anchor, pconfig: TableConfig, headers: Dict[SectionKey, Dict[ColumnKey, ColumnDict]]) -> 'DataTable':\n        \"\"\"Prepare data for use in a table or plot\"\"\"\n        if table_anchor in config.custom_plot_config:\n            for k, v in config.custom_plot_config[table_anchor].items():\n                if isinstance(k, str) and k in pconfig.__dict__:\n                    setattr(pconfig, k, v)\n        input_section_key: SectionKey\n        input_section: SectionT\n        input_group: GroupT\n        unified_sections__with_nulls: Dict[SectionKey, Dict[SampleGroup, List[InputRow]]] = {}\n        for input_section_key, input_section in data.items():\n            rows_by_group: Dict[SampleGroup, List[InputRow]] = {}\n            for g_name, input_group in input_section.items():\n                g_name = SampleGroup(str(g_name))\n                if isinstance(input_group, dict):\n                    rows_by_group[g_name] = [InputRow(sample=SampleName(g_name), data=input_group)]\n                elif isinstance(input_group, list):\n                    rows_by_group[g_name] = input_group\n                else:\n                    assert isinstance(input_group, InputRow)\n                    rows_by_group[g_name] = [input_group]\n            unified_sections__with_nulls[input_section_key] = rows_by_group\n        del data\n        sections: Dict[SectionKey, TableSection] = {}\n        for sec_idx, (section_key, rows_by_sname__with_nulls) in enumerate(unified_sections__with_nulls.items()):\n            header_by_key: Union[Dict[ColumnKey, ColumnDict], Dict[str, ColumnDict]] = headers.get(SectionKey(section_key)) or dict()\n            if not header_by_key:\n                pconfig.only_defined_headers = False\n            column_by_key: Dict[ColumnKey, ColumnMeta] = dict()\n            col_dict_by_key_copy: Dict[ColumnKey, ColumnDict] = _get_or_create_headers(rows_by_sname__with_nulls, header_by_key, pconfig)\n            for col_key, col_dict in col_dict_by_key_copy.items():\n                column_by_key[col_key] = ColumnMeta.create(col_dict=col_dict, col_key=col_key, sec_idx=sec_idx, pconfig=pconfig, table_anchor=table_anchor)\n            section = TableSection(column_by_key=column_by_key)\n            for g_name, group_rows__with_nulls in rows_by_sname__with_nulls.items():\n                for input_row in group_rows__with_nulls:\n                    row = Row(sample=input_row.sample)\n                    for col_key, optional_val in input_row.data.items():\n                        if col_key not in column_by_key:\n                            continue\n                        if optional_val is None or str(optional_val).strip() == '':\n                            continue\n                        val_obj = _process_and_format_value(optional_val, column_by_key[col_key], parse_numeric=pconfig.parse_numeric)\n                        row.data[col_key] = val_obj\n                    if row.data:\n                        section.rows_by_sgroup[g_name].append(row)\n            section.rows_by_sgroup = {sname: rows for sname, rows in section.rows_by_sgroup.items() if rows}\n            for col_key, column in column_by_key.items():\n                _determine_dmin_and_dmax(column, col_key, section.rows_by_sgroup)\n            sections[section_key] = section\n        del unified_sections__with_nulls\n        shared_keys: Dict[str, Dict[str, Union[int, float]]] = _collect_shared_keys(sections)\n        headers_in_order: Dict[float, List[Tuple[int, ColumnKey]]] = defaultdict(list)\n        for sec_idx, section in enumerate(sections.values()):\n            for col_key, column in section.column_by_key.items():\n                if column.shared_key is not None:\n                    column.dmax = shared_keys[column.shared_key].get('dmax')\n                    column.dmin = shared_keys[column.shared_key].get('dmin')\n                headers_in_order[column.placement].append((sec_idx, col_key))\n        for section in sections.values():\n            for column in section.column_by_key.values():\n                column.modify = None\n                if not isinstance(column.format, str):\n                    column.format = None\n        return DataTable(id=table_id, anchor=table_anchor, section_by_id=sections, headers_in_order=headers_in_order, pconfig=pconfig)\n\n    def get_headers_in_order(self, keep_hidden: bool=True) -> List[Tuple[int, ColumnKey, ColumnMeta]]:\n        \"\"\"\n        Gets the headers in the order they want to be displayed.\n        Returns a list of triplets: (bucket_idx, key, header_info)\n        \"\"\"\n        res: List[Tuple[int, ColumnKey, ColumnMeta]] = list()\n        placement: float\n        for placement in sorted(self.headers_in_order.keys()):\n            for section_idx, col_key in self.headers_in_order[placement]:\n                if keep_hidden or not list(self.section_by_id.values())[section_idx].column_by_key[col_key].hidden:\n                    res.append((section_idx, col_key, list(self.section_by_id.values())[section_idx].column_by_key[col_key]))\n        return res\n\n    def merge(self, new_dt: 'DataTable'):\n        \"\"\"\n        Extend the existing DataTable with new data.\n\n        Sections are matched by their column keys rather than their position in the list.\n        This allows for merging sections even if they appear in different order.\n\n        New samples and columns are added at the end, while existing sample/column combinations\n        are overwritten with new data.\n        \"\"\"\n        for section_id, new_section in new_dt.section_by_id.items():\n            if section_id in self.section_by_id:\n                section = self.section_by_id[section_id]\n                for col_key, new_col_meta in new_section.column_by_key.items():\n                    if col_key in section.column_by_key:\n                        existing_col = section.column_by_key[col_key]\n                        for field_name, field_value in new_col_meta.model_dump().items():\n                            setattr(existing_col, field_name, field_value)\n                    else:\n                        section.column_by_key[col_key] = new_col_meta\n                for group_name, new_rows in new_section.rows_by_sgroup.items():\n                    existing_rows = section.rows_by_sgroup.get(group_name, [])\n                    existing_samples = {row.sample for row in existing_rows}\n                    for new_row in new_rows:\n                        if new_row.sample in existing_samples:\n                            for i, row in enumerate(existing_rows):\n                                if row.sample == new_row.sample:\n                                    row.data.update(new_row.data)\n                                    existing_rows[i] = row\n                                    break\n                        else:\n                            existing_rows.append(new_row)\n                    section.rows_by_sgroup[group_name] = existing_rows\n                for col_key, column in section.column_by_key.items():\n                    _determine_dmin_and_dmax(column, col_key, section.rows_by_sgroup)\n            else:\n                self.section_by_id[section_id] = new_section\n        self._rebuild_headers_in_order()\n\n    def _rebuild_headers_in_order(self) -> None:\n        \"\"\"\n        Rebuild the headers_in_order dictionary based on current sections and columns.\n        \"\"\"\n        self.headers_in_order = defaultdict(list)\n        for sec_idx, section in enumerate(self.section_by_id.values()):\n            for col_key, column in section.column_by_key.items():\n                self.headers_in_order[column.placement].append((sec_idx, col_key))\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass _TPCDataGenerator:\n    '''\n    Base class for TPC data generation. PLEASE DO NOT INSTANTIATE THIS CLASS DIRECTLY. Use the TPCHDataGenerator and TPCDSDataGenerator\n    subclasses instead.\n        '''\n\n    def __init__(self, scale_factor: int, target_mount_folder_path: str=None, target_row_group_size_mb: int=128):\n        '''\n        Initialize the TPC data generator with a scale factor.\n        :param scale_factor: The scale factor for the data generation.\n        '''\n        pass\n\n    def run(self):\n        '''\n        This method uses DuckDB to generate in-memory tables based on the specified \n        scale factor and writes them to Parquet files. It estimates the average row \n        size in MB using a sample of the data since DuckDB only supports specifying \n        the number of rows per row group. The generated tables are written to the \n        specified target folder with optimized row group sizes.\n        Parameters\n        ----------\n        None\n        Notes\n        -----\n        - The method creates a sample Parquet file for each table to estimate row sizes.\n        - The full table is then written as Parquet files with optimized row group sizes.\n        - Temporary files and in-memory tables are cleaned up after processing.\n        '''\n        pass"
  }
]