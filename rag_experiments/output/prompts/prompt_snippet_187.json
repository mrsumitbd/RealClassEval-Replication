[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass DialogSuggestionValue:\n    '''\n    An object defining the message input to be sent to the assistant if the user selects\n    the corresponding disambiguation option.\n     **Note:** This entire message input object must be included in the request body of\n    the next message sent to the assistant. Do not modify or remove any of the included\n    properties.\n    :param MessageInput input: (optional) An input object that includes the input\n          text.\n    '''\n\n    def __init__(self, *, input: Optional['MessageInput']=None) -> None:\n        '''\n        Initialize a DialogSuggestionValue object.\n        :param MessageInput input: (optional) An input object that includes the\n               input text.\n        '''\n        pass\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'DialogSuggestionValue':\n        '''Initialize a DialogSuggestionValue object from a json dictionary.'''\n        pass\n    @classmethod\n    def _from_dict(cls, _dict):\n        '''Initialize a DialogSuggestionValue object from a json dictionary.'''\n        pass\n\n    def to_dict(self) -> Dict:\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def _to_dict(self):\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Return a `str` version of this DialogSuggestionValue object.'''\n        pass\n\n    def __eq__(self, other: 'DialogSuggestionValue') -> bool:\n        '''Return `true` when self and other are equal, false otherwise.'''\n        pass\n\n    def __ne__(self, other: 'DialogSuggestionValue') -> bool:\n        '''Return `true` when self and other are not equal, false otherwise.'''\n        pass\nCorresponding class implementation:\n\nfrom typing import BinaryIO, Dict, List, Optional\nimport json\n\nclass DialogSuggestionValue:\n    \"\"\"\n    An object defining the message input to be sent to the assistant if the user selects\n    the corresponding disambiguation option.\n     **Note:** This entire message input object must be included in the request body of\n    the next message sent to the assistant. Do not modify or remove any of the included\n    properties.\n\n    :param MessageInput input: (optional) An input object that includes the input\n          text.\n    \"\"\"\n\n    def __init__(self, *, input: Optional['MessageInput']=None) -> None:\n        \"\"\"\n        Initialize a DialogSuggestionValue object.\n\n        :param MessageInput input: (optional) An input object that includes the\n               input text.\n        \"\"\"\n        self.input = input\n\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'DialogSuggestionValue':\n        \"\"\"Initialize a DialogSuggestionValue object from a json dictionary.\"\"\"\n        args = {}\n        if (input := _dict.get('input')) is not None:\n            args['input'] = MessageInput.from_dict(input)\n        return cls(**args)\n\n    @classmethod\n    def _from_dict(cls, _dict):\n        \"\"\"Initialize a DialogSuggestionValue object from a json dictionary.\"\"\"\n        return cls.from_dict(_dict)\n\n    def to_dict(self) -> Dict:\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        _dict = {}\n        if hasattr(self, 'input') and self.input is not None:\n            if isinstance(self.input, dict):\n                _dict['input'] = self.input\n            else:\n                _dict['input'] = self.input.to_dict()\n        return _dict\n\n    def _to_dict(self):\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        return self.to_dict()\n\n    def __str__(self) -> str:\n        \"\"\"Return a `str` version of this DialogSuggestionValue object.\"\"\"\n        return json.dumps(self.to_dict(), indent=2)\n\n    def __eq__(self, other: 'DialogSuggestionValue') -> bool:\n        \"\"\"Return `true` when self and other are equal, false otherwise.\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other: 'DialogSuggestionValue') -> bool:\n        \"\"\"Return `true` when self and other are not equal, false otherwise.\"\"\"\n        return not self == other\n\nExample skeleton:\n\n\nclass RawMetricsOperator(BaseOperator):\n    '''Raw Metrics Operator.'''\n\n    def __init__(self, config: WilyConfig, targets: Iterable[str]):\n        '''\n        Instantiate a new raw operator.\n        :param config: The wily configuration.\n        :param targets: An iterable of paths from which to harvest metrics.\n        '''\n        pass\n\n    def run(self, module: str, options: Dict[str, Any]) -> Dict[Any, Any]:\n        '''\n        Run the operator.\n        :param module: The target module path.\n        :param options: Any runtime options.\n        :return: The operator results.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom wily.lang import _\nfrom wily.operators import BaseOperator, Metric, MetricType\nfrom typing import Any, Dict, Iterable\nfrom wily.config.types import WilyConfig\nfrom radon.cli import Config\nfrom wily import logger\nimport radon.cli.harvest as harvesters\n\nclass RawMetricsOperator(BaseOperator):\n    \"\"\"Raw Metrics Operator.\"\"\"\n    name = 'raw'\n    defaults = {'exclude': None, 'ignore': None, 'summary': False, 'include_ipynb': True, 'ipynb_cells': True}\n    metrics = (Metric('loc', _('Lines of Code'), int, MetricType.Informational, sum), Metric('lloc', _('L Lines of Code'), int, MetricType.AimLow, sum), Metric('sloc', _('S Lines of Code'), int, MetricType.AimLow, sum), Metric('comments', _('Multi-line comments'), int, MetricType.AimHigh, sum), Metric('multi', _('Multi lines'), int, MetricType.Informational, sum), Metric('blank', _('blank lines'), int, MetricType.Informational, sum), Metric('single_comments', _('Single comment lines'), int, MetricType.Informational, sum))\n    default_metric_index = 0\n\n    def __init__(self, config: WilyConfig, targets: Iterable[str]):\n        \"\"\"\n        Instantiate a new raw operator.\n\n        :param config: The wily configuration.\n        :param targets: An iterable of paths from which to harvest metrics.\n        \"\"\"\n        logger.debug('Using %s with %s for Raw metrics', targets, self.defaults)\n        self.harvester = harvesters.RawHarvester(targets, config=Config(**self.defaults))\n\n    def run(self, module: str, options: Dict[str, Any]) -> Dict[Any, Any]:\n        \"\"\"\n        Run the operator.\n\n        :param module: The target module path.\n        :param options: Any runtime options.\n        :return: The operator results.\n        \"\"\"\n        logger.debug('Running raw harvester')\n        results = {}\n        for filename, metrics in dict(self.harvester.results).items():\n            results[filename] = {'total': metrics}\n        return results\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass DataLoaderFactory:\n    '''Factory for creating data loaders and loading data.'''\n    @staticmethod\n    def load_data_for_task(task: str, dataset_config: DatasetConfig) -> Union[List[str], List[Tuple[str, Any]]]:\n        '''Load data for a specific task.\n        Args:\n            task: Task name in format \"input-to-output\"\n            dataset_config: Dataset configuration\n        Returns:\n            Loaded data for the task\n        '''\n        pass\n    @staticmethod\n    def _load_text_data(dataset_config: DatasetConfig, output_modality: str) -> List[str]:\n        '''Load text data.'''\n        pass\n    @staticmethod\n    def _load_image_data(dataset_config: DatasetConfig) -> List[Tuple[str, Any]]:\n        '''Load image data.'''\n        pass"
  }
]