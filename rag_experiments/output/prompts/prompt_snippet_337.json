[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass State:\n    '''State class that allows the reading and writing of state to a given\n    path. Input and output state transformations can be supplied in read_fn and\n    write_fn respectively. The input state transformation takes in a string\n    while the output transformation outputs a string. If run inside a GitHub\n    Action, the saved state file could be committed to GitHub so that on next\n    run the state is available in the repository.\n    Args:\n        path (str): Path to save state file\n        read_fn (Callable[[str], Any]): Input state transformation. Defaults to lambda x: x.\n        write_fn: Callable[[Any], str]: Output state transformation. Defaults to lambda x: x.\n    '''\n\n    def __init__(self, path: str, read_fn: Callable[[str], Any]=lambda x: x, write_fn: Callable[[Any], str]=lambda x: x) -> None:\n        pass\n\n    def __enter__(self) -> 'State':\n        '''Allow usage of with.\n        Returns:\n            State: SavedState object\n        '''\n        pass\n\n    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None:\n        '''Allow usage of with.\n        Args:\n            exc_type (Any): Exception type\n            exc_value (Any): Exception value\n            traceback (Any): Traceback\n        Returns:\n            None\n        '''\n        pass\n\n    def read(self) -> Any:\n        '''Read state from file\n        Returns:\n            Any: State\n        '''\n        pass\n\n    def write(self) -> None:\n        '''Write state to file\n        Returns:\n            None\n        '''\n        pass\n\n    def get(self) -> Any:\n        '''Get the state\n        Returns:\n            Any: State\n        '''\n        pass\n\n    def set(self, state: Any):\n        '''Set the state\n        Args:\n            state (Any): State\n        Returns:\n            None\n        '''\n        pass\n    @staticmethod\n    def dates_str_to_country_date_dict(dates_str: str) -> Dict:\n        '''Convert a comma separated string of key=date string pairs eg.\n        \"default=2017-01-01,afg=2019-01-01\" to a dictionary of key date\n        mappings eg.\n        {\"default\": 2017-01-01 as datetime, \"afg\": 2019-01-01 as datetime}\n        Args:\n            dates_str (str): Comma separated string of key=date string pairs\n        Returns:\n            Dict: Dictionary of key date mappings\n        '''\n        pass\n    @staticmethod\n    def country_date_dict_to_dates_str(country_date_dict: Dict) -> str:\n        '''Convert a dictionary of key date mappings eg.\n        {\"default\": 2017-01-01 as datetime, \"afg\": 2019-01-01 as datetime}\n        to a comma separated string of key=date string pairs eg.\n        \"default=2017-01-01,afg=2019-01-01\"\n        Args:\n            country_date_dict (Dict): Dictionary of key date mappings\n        Returns:\n            str: Comma separated string of key=date string pairs\n        '''\n        pass\nCorresponding class implementation:\n\nfrom typing import Any, Callable, Dict\nfrom hdx.utilities.loader import load_text\nfrom hdx.utilities.dateparse import iso_string_from_datetime, parse_date\nfrom hdx.utilities.saver import save_text\n\nclass State:\n    \"\"\"State class that allows the reading and writing of state to a given\n    path. Input and output state transformations can be supplied in read_fn and\n    write_fn respectively. The input state transformation takes in a string\n    while the output transformation outputs a string. If run inside a GitHub\n    Action, the saved state file could be committed to GitHub so that on next\n    run the state is available in the repository.\n\n    Args:\n        path (str): Path to save state file\n        read_fn (Callable[[str], Any]): Input state transformation. Defaults to lambda x: x.\n        write_fn: Callable[[Any], str]: Output state transformation. Defaults to lambda x: x.\n    \"\"\"\n\n    def __init__(self, path: str, read_fn: Callable[[str], Any]=lambda x: x, write_fn: Callable[[Any], str]=lambda x: x) -> None:\n        self.path = path\n        self.read_fn = read_fn\n        self.write_fn = write_fn\n        self.state = self.read()\n\n    def __enter__(self) -> 'State':\n        \"\"\"Allow usage of with.\n\n        Returns:\n            State: SavedState object\n        \"\"\"\n        return self\n\n    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None:\n        \"\"\"Allow usage of with.\n\n        Args:\n            exc_type (Any): Exception type\n            exc_value (Any): Exception value\n            traceback (Any): Traceback\n\n        Returns:\n            None\n        \"\"\"\n        self.write()\n\n    def read(self) -> Any:\n        \"\"\"Read state from file\n\n        Returns:\n            Any: State\n        \"\"\"\n        value = self.read_fn(load_text(self.path))\n        logger.info(f'State read from {self.path} = {value}')\n        return value\n\n    def write(self) -> None:\n        \"\"\"Write state to file\n\n        Returns:\n            None\n        \"\"\"\n        logger.info(f'State written to {self.path} = {self.state}')\n        save_text(self.write_fn(self.state), self.path)\n\n    def get(self) -> Any:\n        \"\"\"Get the state\n\n        Returns:\n            Any: State\n        \"\"\"\n        return self.state\n\n    def set(self, state: Any):\n        \"\"\"Set the state\n\n        Args:\n            state (Any): State\n\n        Returns:\n            None\n        \"\"\"\n        self.state = state\n\n    @staticmethod\n    def dates_str_to_country_date_dict(dates_str: str) -> Dict:\n        \"\"\"Convert a comma separated string of key=date string pairs eg.\n        \"default=2017-01-01,afg=2019-01-01\" to a dictionary of key date\n        mappings eg.\n        {\"default\": 2017-01-01 as datetime, \"afg\": 2019-01-01 as datetime}\n\n        Args:\n            dates_str (str): Comma separated string of key=date string pairs\n\n        Returns:\n            Dict: Dictionary of key date mappings\n        \"\"\"\n        result = {}\n        for keyvalue in dates_str.split(','):\n            key, value = keyvalue.split('=')\n            result[key] = parse_date(value)\n        return result\n\n    @staticmethod\n    def country_date_dict_to_dates_str(country_date_dict: Dict) -> str:\n        \"\"\"Convert a dictionary of key date mappings eg.\n        {\"default\": 2017-01-01 as datetime, \"afg\": 2019-01-01 as datetime}\n        to a comma separated string of key=date string pairs eg.\n        \"default=2017-01-01,afg=2019-01-01\"\n\n        Args:\n            country_date_dict (Dict): Dictionary of key date mappings\n\n        Returns:\n            str: Comma separated string of key=date string pairs\n        \"\"\"\n        strlist = []\n        for key, value in country_date_dict.items():\n            valstr = iso_string_from_datetime(value)\n            strlist.append(f'{key}={valstr}')\n        return ','.join(strlist)\n\nExample skeleton:\n\n\nclass WinLnkParser(interface.FileObjectParser):\n    '''Windows Shortcut (LNK) file parser.'''\n\n    def __init__(self):\n        '''Initializes a Windows Shortcut (LNK) file parser.'''\n        pass\n\n    def _GetDateTime(self, filetime):\n        '''Retrieves the date and time from a FILETIME timestamp.\n        Args:\n          filetime (int): FILETIME timestamp.\n        Returns:\n          dfdatetime.DateTimeValues: date and time or None if not set.\n        '''\n        pass\n\n    def _GetSanitizedPathString(self, path):\n        '''Retrieves a sanitize path string.\n        Args:\n          path (str): path.\n        Returns:\n          str: sanitized path string.\n        '''\n        pass\n    @classmethod\n    def GetFormatSpecification(cls):\n        '''Retrieves the format specification.\n        Returns:\n          FormatSpecification: format specification.\n        '''\n        pass\n\n    def _ParseDistributedTrackingIdentifier(self, parser_mediator, uuid_string, origin):\n        '''Extracts data from a Distributed Tracking identifier.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          uuid_string (str): UUID string of the Distributed Tracking identifier.\n          origin (str): origin of the event (event source).\n        '''\n        pass\n\n    def ParseFileObject(self, parser_mediator, file_object):\n        '''Parses a Windows Shortcut (LNK) file-like object.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): file-like object.\n        '''\n        pass\n\n    def ParseFileLNKFile(self, parser_mediator, file_object, display_name):\n        '''Parses a Windows Shortcut (LNK) file-like object.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): file-like object.\n          display_name (str): display name.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom plaso.lib import specification\nfrom dfdatetime import filetime as dfdatetime_filetime\nfrom plaso.containers import windows_events\nimport uuid\nfrom plaso.parsers.shared import shell_items\nfrom plaso.parsers import interface\nfrom plaso.lib import definitions\nimport pylnk\n\nclass WinLnkParser(interface.FileObjectParser):\n    \"\"\"Windows Shortcut (LNK) file parser.\"\"\"\n    _INITIAL_FILE_OFFSET = None\n    _PATH_ESCAPE_CHARACTERS = {'\\\\': '\\\\\\\\'}\n    _PATH_ESCAPE_CHARACTERS.update(definitions.NON_PRINTABLE_CHARACTERS)\n    NAME = 'lnk'\n    DATA_FORMAT = 'Windows Shortcut (LNK) file'\n\n    def __init__(self):\n        \"\"\"Initializes a Windows Shortcut (LNK) file parser.\"\"\"\n        super(WinLnkParser, self).__init__()\n        self._path_escape_characters = str.maketrans(self._PATH_ESCAPE_CHARACTERS)\n\n    def _GetDateTime(self, filetime):\n        \"\"\"Retrieves the date and time from a FILETIME timestamp.\n\n        Args:\n          filetime (int): FILETIME timestamp.\n\n        Returns:\n          dfdatetime.DateTimeValues: date and time or None if not set.\n        \"\"\"\n        if not filetime:\n            return None\n        return dfdatetime_filetime.Filetime(timestamp=filetime)\n\n    def _GetSanitizedPathString(self, path):\n        \"\"\"Retrieves a sanitize path string.\n\n        Args:\n          path (str): path.\n\n        Returns:\n          str: sanitized path string.\n        \"\"\"\n        if not path:\n            return None\n        return path.translate(self._path_escape_characters)\n\n    @classmethod\n    def GetFormatSpecification(cls):\n        \"\"\"Retrieves the format specification.\n\n        Returns:\n          FormatSpecification: format specification.\n        \"\"\"\n        format_specification = specification.FormatSpecification(cls.NAME)\n        format_specification.AddNewSignature(b'\\x01\\x14\\x02\\x00\\x00\\x00\\x00\\x00\\xc0\\x00\\x00\\x00\\x00\\x00\\x00F', offset=4)\n        return format_specification\n\n    def _ParseDistributedTrackingIdentifier(self, parser_mediator, uuid_string, origin):\n        \"\"\"Extracts data from a Distributed Tracking identifier.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          uuid_string (str): UUID string of the Distributed Tracking identifier.\n          origin (str): origin of the event (event source).\n        \"\"\"\n        uuid_object = uuid.UUID(uuid_string)\n        if uuid_object.version == 1:\n            event_data = windows_events.WindowsDistributedLinkTrackingEventData(uuid_object, origin)\n            parser_mediator.ProduceEventData(event_data)\n\n    def ParseFileObject(self, parser_mediator, file_object):\n        \"\"\"Parses a Windows Shortcut (LNK) file-like object.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): file-like object.\n        \"\"\"\n        display_name = parser_mediator.GetDisplayName()\n        self.ParseFileLNKFile(parser_mediator, file_object, display_name)\n\n    def ParseFileLNKFile(self, parser_mediator, file_object, display_name):\n        \"\"\"Parses a Windows Shortcut (LNK) file-like object.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): file-like object.\n          display_name (str): display name.\n        \"\"\"\n        code_page = parser_mediator.GetCodePage()\n        lnk_file = pylnk.file()\n        lnk_file.set_ascii_codepage(code_page)\n        try:\n            lnk_file.open_file_object(file_object)\n        except IOError as exception:\n            parser_mediator.ProduceExtractionWarning('unable to open file with error: {0!s}'.format(exception))\n            return\n        link_target = None\n        if lnk_file.link_target_identifier_data:\n            display_name = parser_mediator.GetFilename()\n            shell_items_parser = shell_items.ShellItemsParser(display_name)\n            shell_items_parser.ParseByteStream(parser_mediator, lnk_file.link_target_identifier_data, codepage=code_page)\n            link_target = shell_items_parser.CopyToPath()\n        access_time = lnk_file.get_file_access_time_as_integer()\n        creation_time = lnk_file.get_file_creation_time_as_integer()\n        modification_time = lnk_file.get_file_modification_time_as_integer()\n        event_data = WinLnkLinkEventData()\n        event_data.access_time = self._GetDateTime(access_time)\n        event_data.birth_droid_file_identifier = lnk_file.birth_droid_file_identifier\n        event_data.birth_droid_volume_identifier = lnk_file.birth_droid_volume_identifier\n        event_data.command_line_arguments = self._GetSanitizedPathString(lnk_file.command_line_arguments)\n        event_data.creation_time = self._GetDateTime(creation_time)\n        event_data.description = self._GetSanitizedPathString(lnk_file.description)\n        event_data.drive_serial_number = lnk_file.drive_serial_number\n        event_data.drive_type = lnk_file.drive_type\n        event_data.droid_file_identifier = lnk_file.droid_file_identifier\n        event_data.droid_volume_identifier = lnk_file.droid_volume_identifier\n        event_data.env_var_location = self._GetSanitizedPathString(lnk_file.environment_variables_location)\n        event_data.file_attribute_flags = lnk_file.file_attribute_flags\n        event_data.file_size = lnk_file.file_size\n        event_data.icon_location = self._GetSanitizedPathString(lnk_file.icon_location)\n        event_data.link_target = link_target\n        event_data.local_path = self._GetSanitizedPathString(lnk_file.local_path)\n        event_data.modification_time = self._GetDateTime(modification_time)\n        event_data.network_path = self._GetSanitizedPathString(lnk_file.network_path)\n        event_data.relative_path = self._GetSanitizedPathString(lnk_file.relative_path)\n        event_data.volume_label = lnk_file.volume_label\n        event_data.working_directory = self._GetSanitizedPathString(lnk_file.working_directory)\n        parser_mediator.ProduceEventData(event_data)\n        if lnk_file.droid_file_identifier:\n            try:\n                self._ParseDistributedTrackingIdentifier(parser_mediator, lnk_file.droid_file_identifier, display_name)\n            except (TypeError, ValueError) as exception:\n                parser_mediator.ProduceExtractionWarning('unable to read droid file identifier with error: {0!s}.'.format(exception))\n        if lnk_file.birth_droid_file_identifier and lnk_file.birth_droid_file_identifier != lnk_file.droid_file_identifier:\n            try:\n                self._ParseDistributedTrackingIdentifier(parser_mediator, lnk_file.birth_droid_file_identifier, display_name)\n            except (TypeError, ValueError) as exception:\n                parser_mediator.ProduceExtractionWarning('unable to read birth droid file identifier with error: {0!s}.'.format(exception))\n        lnk_file.close()\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass DiffGenerator:\n    '''Generates diff reports comparing two evaluation runs.'''\n\n    def generate_diff(self, baseline_report: ReportV1, target_report: ReportV1, output_path: Path | None=None) -> ReportDiffV1:\n        '''Generate a diff report comparing baseline and target runs.\n        Args:\n            baseline_report: Baseline report\n            target_report: Target report\n            output_path: Optional path to save the diff JSON\n        Returns:\n            ReportDiffV1 instance\n        '''\n        pass\n\n    def generate_diff_from_files(self, baseline_path: Path, target_path: Path, output_path: Path | None=None) -> ReportDiffV1:\n        '''Generate a diff report from two report JSON files.\n        Args:\n            baseline_path: Path to baseline report JSON\n            target_path: Path to target report JSON\n            output_path: Optional path to save the diff JSON\n        Returns:\n            ReportDiffV1 instance\n        '''\n        pass\n\n    def _generate_functional_tests_diff(self, baseline_ft, target_ft) -> FunctionalTestsDiff:\n        '''Generate functional tests diff section.'''\n        pass\n\n    def _find_test_changes(self, baseline_cases, target_cases) -> tuple[list[str], list[str]]:\n        '''Find test regressions and fixes between baseline and target.'''\n        pass\n\n    def _generate_benchmarks_diff(self, baseline_benchmarks, target_benchmarks) -> list[BenchmarkDiff]:\n        '''Generate benchmarks diff section.'''\n        pass\n\n    def _generate_subset_metrics_diff(self, baseline_benchmark, target_benchmark, metric_name: str) -> dict[str, NumberTriplet] | None:\n        '''Generate subset metrics diff for a benchmark.'''\n        pass"
  }
]