[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass CfnginConfig(BaseConfig[CfnginConfigDefinitionModel]):\n    '''Python representation of a CFNgin config file.\n    This is used internally by CFNgin to parse and validate a YAML formatted\n    CFNgin configuration file, but can also be used in scripts to generate a\n    CFNgin config file before handing it off to CFNgin to deploy/destroy.\n    Example::\n        from runway.cfngin.config import dump, Config, Stack\n        vpc = Stack({\n            \"name\": \"vpc\",\n            \"class_path\": \"blueprints.VPC\"})\n        config = Config()\n        config.namespace = \"prod\"\n        config.stacks = [vpc]\n        print dump(config)\n    '''\n\n    def __init__(self, data: CfnginConfigDefinitionModel, *, path: Path | None=None, work_dir: Path | None=None) -> None:\n        '''Instantiate class.\n        Args:\n            data: The data model of the config file.\n            path: Path to the config file.\n            work_dir: Working directory.\n        '''\n        pass\n\n    def load(self) -> None:\n        '''Load config options into the current environment/session.'''\n        pass\n    @classmethod\n    def find_config_file(cls, path: Path | None=None, *, exclude: list[str] | None=None) -> list[Path]:\n        '''Find a config file in the provided path.\n        Args:\n            path: The path to search for a config file.\n            exclude: List of file names to exclude. This list is appended to\n                the global exclude list.\n        Raises:\n            ConfigNotFound: Could not find a config file in the provided path.\n            ValueError: More than one config file found in the provided path.\n        '''\n        pass\n    @classmethod\n    def parse_file(cls, *, path: Path | None=None, file_path: Path | None=None, parameters: MutableMapping[str, Any] | None=None, work_dir: Path | None=None, **kwargs: Any) -> CfnginConfig:\n        '''Parse a YAML file to create a config object.\n        Args:\n            path: The path to search for a config file.\n            file_path: Exact path to a file to parse.\n            parameters: Values to use when resolving a raw config.\n            work_dir: Explicit working directory.\n            **kwargs: Arbitrary keyword arguments.\n        Raises:\n            ConfigNotFound: Provided config file was not found.\n        '''\n        pass\n    @classmethod\n    def parse_obj(cls, obj: Any, *, path: Path | None=None, work_dir: Path | None=None) -> CfnginConfig:\n        '''Parse a python object.\n        Args:\n            obj: A python object to parse as a CFNgin config.\n            path: The path to the config file that was parsed into the object.\n            work_dir: Working directory.\n        '''\n        pass\n    @classmethod\n    def parse_raw(cls, data: str, *, parameters: MutableMapping[str, Any] | None=None, path: Path | None=None, skip_package_sources: bool=False, work_dir: Path | None=None) -> CfnginConfig:\n        '''Parse raw data.\n        Args:\n            data: The raw data to parse.\n            parameters: Values to use when resolving a raw config.\n            path: The path to search for a config file.\n            skip_package_sources: Skip processing package sources.\n            work_dir: Explicit working directory.\n        '''\n        pass\n    @classmethod\n    def process_package_sources(cls, raw_data: str, *, parameters: MutableMapping[str, Any] | None=None, work_dir: Path | None=None) -> str:\n        '''Process the package sources defined in a rendered config.\n        Args:\n            raw_data: Raw configuration data.\n            cache_dir: Directory to use when caching remote sources.\n            parameters: Values to use when resolving a raw config.\n            work_dir: Explicit working directory.\n        '''\n        pass\n    @staticmethod\n    def resolve_raw_data(raw_data: str, *, parameters: MutableMapping[str, Any] | None=None) -> str:\n        '''Resolve raw data.\n        Args:\n            raw_data: Raw configuration data.\n            parameters: Values to use when resolving a raw config.\n        Raises:\n            MissingEnvironment: A value required by the config was not provided\n                in parameters.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom string import Template\nfrom ..cfngin.utils import SourceProcessor\nimport re\nfrom ..utils import merge_dicts\nfrom ..exceptions import ConfigNotFound\nimport sys\nfrom typing import TYPE_CHECKING, Any, ClassVar, Generic, TypeVar, cast\nimport yaml\nfrom pathlib import Path\nfrom .models.cfngin import CfnginConfigDefinitionModel, CfnginHookDefinitionModel, CfnginPackageSourcesDefinitionModel, CfnginStackDefinitionModel\nfrom ..cfngin import exceptions\nfrom ..cfngin.lookups.registry import register_lookup_handler\n\nclass CfnginConfig(BaseConfig[CfnginConfigDefinitionModel]):\n    \"\"\"Python representation of a CFNgin config file.\n\n    This is used internally by CFNgin to parse and validate a YAML formatted\n    CFNgin configuration file, but can also be used in scripts to generate a\n    CFNgin config file before handing it off to CFNgin to deploy/destroy.\n\n    Example::\n\n        from runway.cfngin.config import dump, Config, Stack\n\n        vpc = Stack({\n            \"name\": \"vpc\",\n            \"class_path\": \"blueprints.VPC\"})\n\n        config = Config()\n        config.namespace = \"prod\"\n        config.stacks = [vpc]\n\n        print dump(config)\n\n    \"\"\"\n    EXCLUDE_REGEX: ClassVar[str] = '(?x)^(bitbucket-pipelines|buildspec|docker-compose|runway)(\\\\..*)?\\\\.(yml|yaml)'\n    'Regex for file names to exclude when looking for config files.'\n    EXCLUDE_LIST: ClassVar[list[str]] = []\n    'Explicit files names to ignore when looking for config files.'\n    cfngin_bucket: str | None\n    'Bucket to use for CFNgin resources. (e.g. CloudFormation templates).\\n    May be an empty string.\\n    '\n    cfngin_bucket_region: str | None\n    'Explicit region to use for :attr:`CfnginConfig.cfngin_bucket`'\n    cfngin_cache_dir: Path\n    'Local directory to use for caching.'\n    log_formats: dict[str, str]\n    'Custom formatting for log messages.'\n    lookups: dict[str, str]\n    'Register custom lookups.'\n    mappings: dict[str, dict[str, dict[str, Any]]]\n    'Mappings that will be added to all stacks.'\n    namespace: str\n    'Namespace to prepend to everything.'\n    namespace_delimiter: str\n    'Character used to separate :attr:`CfnginConfig.namespace` and anything it prepends.'\n    package_sources: CfnginPackageSourcesDefinitionModel\n    'Remote source locations.'\n    persistent_graph_key: str | None = None\n    'S3 object key were the persistent graph is stored.'\n    post_deploy: list[CfnginHookDefinitionModel]\n    'Hooks to run after a deploy action.'\n    post_destroy: list[CfnginHookDefinitionModel]\n    'Hooks to run after a destroy action.'\n    pre_deploy: list[CfnginHookDefinitionModel]\n    'Hooks to run before a deploy action.'\n    pre_destroy: list[CfnginHookDefinitionModel]\n    'Hooks to run before a destroy action.'\n    service_role: str | None\n    'IAM role for CloudFormation to use.'\n    stacks: list[CfnginStackDefinitionModel]\n    'Stacks to be processed.'\n    sys_path: Path | None\n    'Relative or absolute path to use as the work directory.'\n    tags: dict[str, str] | None\n    'Tags to apply to all resources.'\n    template_indent: int\n    'Spaces to use per-indent level when outputting a template to json.'\n\n    def __init__(self, data: CfnginConfigDefinitionModel, *, path: Path | None=None, work_dir: Path | None=None) -> None:\n        \"\"\"Instantiate class.\n\n        Args:\n            data: The data model of the config file.\n            path: Path to the config file.\n            work_dir: Working directory.\n\n        \"\"\"\n        super().__init__(data, path=path)\n        self.cfngin_bucket = self._data.cfngin_bucket\n        self.cfngin_bucket_region = self._data.cfngin_bucket_region\n        if self._data.cfngin_cache_dir:\n            self.cfngin_cache_dir = self._data.cfngin_cache_dir\n        elif work_dir:\n            self.cfngin_cache_dir = work_dir / 'cache'\n        elif path:\n            self.cfngin_cache_dir = path.parent / '.runway' / 'cache'\n        else:\n            self.cfngin_cache_dir = Path().cwd() / '.runway' / 'cache'\n        self.log_formats = self._data.log_formats\n        self.lookups = self._data.lookups\n        self.mappings = self._data.mappings\n        self.namespace = self._data.namespace\n        self.namespace_delimiter = self._data.namespace_delimiter\n        self.package_sources = self._data.package_sources\n        self.persistent_graph_key = self._data.persistent_graph_key\n        self.post_deploy = cast('list[CfnginHookDefinitionModel]', self._data.post_deploy)\n        self.post_destroy = cast('list[CfnginHookDefinitionModel]', self._data.post_destroy)\n        self.pre_deploy = cast('list[CfnginHookDefinitionModel]', self._data.pre_deploy)\n        self.pre_destroy = cast('list[CfnginHookDefinitionModel]', self._data.pre_destroy)\n        self.service_role = self._data.service_role\n        self.stacks = cast('list[CfnginStackDefinitionModel]', self._data.stacks)\n        self.sys_path = self._data.sys_path\n        self.tags = self._data.tags\n        self.template_indent = self._data.template_indent\n\n    def load(self) -> None:\n        \"\"\"Load config options into the current environment/session.\"\"\"\n        if self.sys_path:\n            LOGGER.debug('appending to sys.path: %s', self.sys_path)\n            sys.path.append(str(self.sys_path))\n            LOGGER.debug('sys.path: %s', sys.path)\n        if self.lookups:\n            for key, handler in self.lookups.items():\n                register_lookup_handler(key, handler)\n\n    @classmethod\n    def find_config_file(cls, path: Path | None=None, *, exclude: list[str] | None=None) -> list[Path]:\n        \"\"\"Find a config file in the provided path.\n\n        Args:\n            path: The path to search for a config file.\n            exclude: List of file names to exclude. This list is appended to\n                the global exclude list.\n\n        Raises:\n            ConfigNotFound: Could not find a config file in the provided path.\n            ValueError: More than one config file found in the provided path.\n\n        \"\"\"\n        if not path:\n            path = Path.cwd()\n        elif path.is_file():\n            return [path]\n        exclude = exclude or []\n        result: list[Path] = []\n        exclude.extend(cls.EXCLUDE_LIST)\n        yml_files = list(path.glob('*.yml'))\n        yml_files.extend(list(path.glob('*.yaml')))\n        for f in yml_files:\n            if re.match(cls.EXCLUDE_REGEX, f.name) or f.name in exclude or f.name.startswith('.'):\n                continue\n            result.append(f)\n        result.sort()\n        return result\n\n    @classmethod\n    def parse_file(cls, *, path: Path | None=None, file_path: Path | None=None, parameters: MutableMapping[str, Any] | None=None, work_dir: Path | None=None, **kwargs: Any) -> CfnginConfig:\n        \"\"\"Parse a YAML file to create a config object.\n\n        Args:\n            path: The path to search for a config file.\n            file_path: Exact path to a file to parse.\n            parameters: Values to use when resolving a raw config.\n            work_dir: Explicit working directory.\n            **kwargs: Arbitrary keyword arguments.\n\n        Raises:\n            ConfigNotFound: Provided config file was not found.\n\n        \"\"\"\n        if file_path:\n            if not file_path.is_file():\n                raise ConfigNotFound(path=file_path)\n            return cls.parse_raw(file_path.read_text(), path=file_path, parameters=parameters or {}, work_dir=work_dir, **kwargs)\n        if path:\n            found = cls.find_config_file(path)\n            if len(found) > 1:\n                raise ValueError(f'more than one config files found: {found}')\n            return cls.parse_file(file_path=found[0], parameters=parameters or {}, work_dir=work_dir, **kwargs)\n        raise ValueError('must provide path or file_path')\n\n    @classmethod\n    def parse_obj(cls, obj: Any, *, path: Path | None=None, work_dir: Path | None=None) -> CfnginConfig:\n        \"\"\"Parse a python object.\n\n        Args:\n            obj: A python object to parse as a CFNgin config.\n            path: The path to the config file that was parsed into the object.\n            work_dir: Working directory.\n\n        \"\"\"\n        return cls(CfnginConfigDefinitionModel.model_validate(obj), path=path, work_dir=work_dir)\n\n    @classmethod\n    def parse_raw(cls, data: str, *, parameters: MutableMapping[str, Any] | None=None, path: Path | None=None, skip_package_sources: bool=False, work_dir: Path | None=None) -> CfnginConfig:\n        \"\"\"Parse raw data.\n\n        Args:\n            data: The raw data to parse.\n            parameters: Values to use when resolving a raw config.\n            path: The path to search for a config file.\n            skip_package_sources: Skip processing package sources.\n            work_dir: Explicit working directory.\n\n        \"\"\"\n        if not parameters:\n            parameters = {}\n        pre_rendered = cls.resolve_raw_data(data, parameters=parameters)\n        if skip_package_sources:\n            return cls.parse_obj(yaml.safe_load(pre_rendered))\n        config_dict = yaml.safe_load(cls.process_package_sources(pre_rendered, parameters=parameters, work_dir=work_dir))\n        return cls.parse_obj(config_dict, path=path)\n\n    @classmethod\n    def process_package_sources(cls, raw_data: str, *, parameters: MutableMapping[str, Any] | None=None, work_dir: Path | None=None) -> str:\n        \"\"\"Process the package sources defined in a rendered config.\n\n        Args:\n            raw_data: Raw configuration data.\n            cache_dir: Directory to use when caching remote sources.\n            parameters: Values to use when resolving a raw config.\n            work_dir: Explicit working directory.\n\n        \"\"\"\n        config: dict[str, Any] = yaml.safe_load(raw_data) or {}\n        processor = SourceProcessor(sources=CfnginPackageSourcesDefinitionModel.model_validate(config.get('package_sources', {})), cache_dir=Path(config.get('cfngin_cache_dir', (work_dir or Path().cwd() / '.runway') / 'cache')))\n        processor.get_package_sources()\n        if processor.configs_to_merge:\n            for i in processor.configs_to_merge:\n                LOGGER.debug('merging in remote config: %s', i)\n                with i.open('rb') as opened_file:\n                    config = merge_dicts(yaml.safe_load(opened_file), config)\n            return cls.resolve_raw_data(yaml.dump(config), parameters=parameters or {})\n        return raw_data\n\n    @staticmethod\n    def resolve_raw_data(raw_data: str, *, parameters: MutableMapping[str, Any] | None=None) -> str:\n        \"\"\"Resolve raw data.\n\n        Args:\n            raw_data: Raw configuration data.\n            parameters: Values to use when resolving a raw config.\n\n        Raises:\n            MissingEnvironment: A value required by the config was not provided\n                in parameters.\n\n        \"\"\"\n        if not parameters:\n            parameters = {}\n        template = Template(raw_data)\n        try:\n            rendered = template.substitute(**parameters)\n        except KeyError as err:\n            raise exceptions.MissingEnvironment(err.args[0]) from None\n        except ValueError:\n            rendered = template.safe_substitute(**parameters)\n        return rendered\n\nExample skeleton:\n\n\nclass JSONLinesSerializer(SimpleBaseSerializer):\n    '''Serialize data to a JSON Lines formatted string.'''\n\n    def __init__(self, content_type='application/jsonlines'):\n        '''Initialize a ``JSONLinesSerializer`` instance.\n        Args:\n            content_type (str): The MIME type to signal to the inference endpoint when sending\n                request data (default: \"application/jsonlines\").\n        '''\n        pass\n\n    def serialize(self, data):\n        '''Serialize data of various formats to a JSON Lines formatted string.\n        Args:\n            data (object): Data to be serialized. The data can be a string,\n                iterable of JSON serializable objects, or a file-like object.\n        Returns:\n            str: The data serialized as a string containing newline-separated\n                JSON values.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom collections.abc import Iterable\nimport json\n\nclass JSONLinesSerializer(SimpleBaseSerializer):\n    \"\"\"Serialize data to a JSON Lines formatted string.\"\"\"\n\n    def __init__(self, content_type='application/jsonlines'):\n        \"\"\"Initialize a ``JSONLinesSerializer`` instance.\n\n        Args:\n            content_type (str): The MIME type to signal to the inference endpoint when sending\n                request data (default: \"application/jsonlines\").\n        \"\"\"\n        super(JSONLinesSerializer, self).__init__(content_type=content_type)\n\n    def serialize(self, data):\n        \"\"\"Serialize data of various formats to a JSON Lines formatted string.\n\n        Args:\n            data (object): Data to be serialized. The data can be a string,\n                iterable of JSON serializable objects, or a file-like object.\n\n        Returns:\n            str: The data serialized as a string containing newline-separated\n                JSON values.\n        \"\"\"\n        if isinstance(data, str):\n            return data\n        if hasattr(data, 'read'):\n            return data.read()\n        if isinstance(data, Iterable):\n            return '\\n'.join((json.dumps(element) for element in data))\n        raise ValueError('Object of type %s is not JSON Lines serializable.' % type(data))\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass TelemetryConfig:\n    '''This configuration class sets up OpenTelemetry tracing.\n      - Export spans to a Jaeger collector using gRPC.\n      - Write spans to a file.\n      - Save spans in a SQLite database.\n    Only exporters with a non-None configuration will be activated.\n    '''\n\n    def __init__(self, service_name: str, jaeger_endpoint: str | None=None, jaeger_transport: str='grpc', local_logging_dir: str | None=None, file_export_name: str | None=None, sqlite_db_name: str | None=None, enable_jaeger: bool=True, enable_file: bool=True, enable_sql: bool=True, enable_otlp: bool=True, otlp_protocol: str='grpc', otlp_endpoint: str='http://localhost:4317', batch_processor_options: dict | None=None):\n        ''':param service_name: Name of your service.\n        :param jaeger_endpoint: The Jaeger collector gRPC endpoint (e.g., \"localhost:14250\").\n        :param file_export_path: If provided, spans will be written to this file.\n        :param sqlite_db_path: If provided, spans will be stored in this SQLite DB.\n        :param batch_processor_options: Dict of options for BatchSpanProcessor (e.g., {\"max_export_batch_size\": 10}).\n        '''\n        pass\n\n    def setup_tracing(self):\n        '''Set up OpenTelemetry tracing with the specified exporters.'''\n        pass\n\n    def log_exception_to_otel(self, exc_type, exc_value, exc_traceback):\n        '''Log unhandled exceptions to OpenTelemetry.'''\n        pass"
  }
]