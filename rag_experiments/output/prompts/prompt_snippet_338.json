[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass TimeBasedCache(FastStore):\n    '''A Cache which expires based on time.'''\n\n    def __init__(self, max_size=10, max_age=600):\n        '''Constructor.\n        This cache will refresh the age of the cached object as long as they are\n        accessed within the allowed age. The age refers to the time since it was\n        last touched.\n        Args:\n          max_size: The maximum number of objects held in cache.\n          max_age: The maximum length of time an object is considered alive.\n        '''\n        pass\n\n        def HouseKeeper():\n                '''A housekeeper thread which expunges old objects.'''\n                pass\n    @Synchronized\n    def Get(self, key):\n        pass\n\n    def Put(self, key, obj):\n        pass\nCorresponding class implementation:\n\nimport weakref\nimport time\n\nclass TimeBasedCache(FastStore):\n    \"\"\"A Cache which expires based on time.\"\"\"\n    active_caches = None\n    house_keeper_thread = None\n\n    def __init__(self, max_size=10, max_age=600):\n        \"\"\"Constructor.\n\n        This cache will refresh the age of the cached object as long as they are\n        accessed within the allowed age. The age refers to the time since it was\n        last touched.\n\n        Args:\n          max_size: The maximum number of objects held in cache.\n          max_age: The maximum length of time an object is considered alive.\n        \"\"\"\n        super().__init__(max_size)\n        self.max_age = max_age\n\n        def HouseKeeper():\n            \"\"\"A housekeeper thread which expunges old objects.\"\"\"\n            if not time:\n                return\n            now = time.time()\n            for cache in TimeBasedCache.active_caches:\n                with cache.lock:\n                    for node in list(cache._hash.values()):\n                        if node.data.timestamp + cache.max_age < now:\n                            cache.KillObject(node.data)\n                            cache._age.Unlink(node)\n                            cache._hash.pop(node.key, None)\n        if not TimeBasedCache.house_keeper_thread:\n            TimeBasedCache.active_caches = weakref.WeakSet()\n            TimeBasedCache.house_keeper_thread = InterruptableThread(name='HouseKeeperThread', target=HouseKeeper)\n            TimeBasedCache.house_keeper_thread.start()\n        TimeBasedCache.active_caches.add(self)\n\n    @Synchronized\n    def Get(self, key):\n        now = time.time()\n        stored = super().Get(key)\n        if stored.timestamp + self.max_age < now:\n            raise KeyError('Expired')\n        stored.timestamp = now\n        return stored.value\n\n    def Put(self, key, obj):\n        super().Put(key, TimeBasedCacheEntry(time.time(), obj))\n\nExample skeleton:\n\n\nclass FileOperation(metaclass=abc.ABCMeta):\n    '''Base wrapper class for file operations.'''\n    @classmethod\n    @abc.abstractmethod\n    def RunningState(cls) -> int:\n        pass\n    @classmethod\n    @abc.abstractmethod\n    def FinishedState(cls) -> int:\n        pass\n\n    def __init__(self, client_id: str, operation_id: str, target_file: 'FileBase', context: api_context.GrrApiContext):\n        pass\n    @abc.abstractmethod\n    def GetState(self) -> int:\n        pass\n\n    def WaitUntilDone(self, timeout: Optional[int]=None) -> 'FileOperation':\n        '''Wait until the operation is done.\n        Args:\n          timeout: timeout in seconds. None means default timeout (1 hour). 0 means\n            no timeout (wait forever).\n        Returns:\n          Operation object with refreshed target_file.\n        Raises:\n          PollTimeoutError: if timeout is reached.\n        '''\n        pass\nCorresponding class implementation:\n\nimport abc\nfrom typing import Optional\nfrom grr_api_client import utils\nfrom grr_api_client import context as api_context\n\nclass FileOperation(metaclass=abc.ABCMeta):\n    \"\"\"Base wrapper class for file operations.\"\"\"\n\n    @classmethod\n    @abc.abstractmethod\n    def RunningState(cls) -> int:\n        raise NotImplementedError()\n\n    @classmethod\n    @abc.abstractmethod\n    def FinishedState(cls) -> int:\n        raise NotImplementedError()\n\n    def __init__(self, client_id: str, operation_id: str, target_file: 'FileBase', context: api_context.GrrApiContext):\n        super().__init__()\n        if not client_id:\n            raise ValueError(\"client_id can't be empty\")\n        if not operation_id:\n            raise ValueError(\"operation_id can't be empty\")\n        if not target_file:\n            raise ValueError(\"target_file can't be empty\")\n        self.client_id: str = client_id\n        self.operation_id: str = operation_id\n        self.target_file: FileBase = target_file\n        self._context: api_context.GrrApiContext = context\n\n    @abc.abstractmethod\n    def GetState(self) -> int:\n        raise NotImplementedError()\n\n    def WaitUntilDone(self, timeout: Optional[int]=None) -> 'FileOperation':\n        \"\"\"Wait until the operation is done.\n\n        Args:\n          timeout: timeout in seconds. None means default timeout (1 hour). 0 means\n            no timeout (wait forever).\n\n        Returns:\n          Operation object with refreshed target_file.\n        Raises:\n          PollTimeoutError: if timeout is reached.\n        \"\"\"\n        utils.Poll(generator=self.GetState, condition=lambda s: s != self.__class__.RunningState(), timeout=timeout)\n        self.target_file = self.target_file.Get()\n        return self\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass RateLimiter:\n    '''Simple rate limiter to ensure we don't exceed API rate limits.'''\n\n    def __init__(self, max_calls: int=3, period: float=1.0):\n        '''\n        Initialize the rate limiter.\n        Args:\n            max_calls: Maximum number of calls allowed in the period\n            period: Time period in seconds\n        '''\n        pass\n\n    def wait(self):\n        '''\n        Wait if necessary to respect the rate limit.\n        '''\n        pass"
  }
]