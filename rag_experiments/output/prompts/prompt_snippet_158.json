[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass ApiGatewayV2Authorizer:\n\n    def __init__(self, api_logical_id=None, name=None, authorization_scopes=None, jwt_configuration=None, id_source=None, function_arn=None, function_invoke_role=None, identity=None, authorizer_payload_format_version=None, enable_simple_responses=None, is_aws_iam_authorizer=False, enable_function_default_permissions=None):\n        '''\n        Creates an authorizer for use in V2 Http Apis\n        '''\n        pass\n\n    def _get_auth_type(self) -> str:\n        pass\n\n    def _validate_input_parameters(self) -> None:\n        pass\n\n    def _validate_jwt_authorizer(self) -> None:\n        pass\n\n    def _validate_lambda_authorizer(self) -> None:\n        pass\n\n    def generate_openapi(self) -> Dict[str, Any]:\n        '''\n        Generates OAS for the securitySchemes section\n        '''\n        pass\n\n    def _get_function_invoke_role(self) -> Optional[PassThrough]:\n        pass\n\n    def _get_identity_source(self, auth_identity: Dict[str, Any]) -> List[str]:\n        '''\n        Generate the list of identitySource using authorizer's Identity config by flatting them.\n        For the format of identitySource, see:\n        https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions-authorizer.html\n        It will add API GW prefix to each item:\n        - prefix \"$request.header.\" to all values in \"Headers\"\n        - prefix \"$request.querystring.\" to all values in \"QueryStrings\"\n        - prefix \"$stageVariables.\" to all values in \"StageVariables\"\n        - prefix \"$context.\" to all values in \"Context\"\n        '''\n        pass\n    @staticmethod\n    def _get_jwt_configuration(props: Optional[Dict[str, Union[str, List[str]]]], api_logical_id: str) -> Optional[JwtConfiguration]:\n        '''Make sure that JWT configuration dict keys are lower case.\n        ApiGatewayV2Authorizer doesn't create `AWS::ApiGatewayV2::Authorizer` but generates\n        Open Api which will be appended to the API's Open Api definition body.\n        For Open Api JWT configuration keys should be in lower case.\n        But for `AWS::ApiGatewayV2::Authorizer` the same keys are capitalized,\n        the way it's usually done in CloudFormation resources.\n        Users get often confused when passing capitalized key to `AWS::Serverless::HttpApi` doesn't work.\n        There exist a comment about that in the documentation\n        https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-property-httpapi-oauth2authorizer.html#sam-httpapi-oauth2authorizer-jwtconfiguration\n        but the comment doesn't prevent users from making the error.\n        Parameters\n        ----------\n        props: jwt configuration dict with the keys either lower case or capitalized\n        api_logical_id: logical id of the Serverless Api resource with the jwt configuration\n        Returns\n        -------\n            jwt configuration dict with low case keys\n        '''\n        pass\nCorresponding class implementation:\n\nfrom samtranslator.translator.arn_generator import ArnGenerator\nfrom samtranslator.validator.value_validator import sam_expect\nfrom typing import Any, Dict, List, Optional, Union\nfrom samtranslator.model.intrinsics import fnSub, ref\nfrom samtranslator.model.types import PassThrough\nfrom samtranslator.model.exceptions import ExpectedType, InvalidResourceException\n\nclass ApiGatewayV2Authorizer:\n\n    def __init__(self, api_logical_id=None, name=None, authorization_scopes=None, jwt_configuration=None, id_source=None, function_arn=None, function_invoke_role=None, identity=None, authorizer_payload_format_version=None, enable_simple_responses=None, is_aws_iam_authorizer=False, enable_function_default_permissions=None):\n        \"\"\"\n        Creates an authorizer for use in V2 Http Apis\n        \"\"\"\n        self.api_logical_id = api_logical_id\n        self.name = name\n        self.authorization_scopes = authorization_scopes\n        self.jwt_configuration: Optional[JwtConfiguration] = self._get_jwt_configuration(jwt_configuration, api_logical_id)\n        self.id_source = id_source\n        self.function_arn = function_arn\n        self.function_invoke_role = function_invoke_role\n        self.identity = identity\n        self.authorizer_payload_format_version = authorizer_payload_format_version\n        self.enable_simple_responses = enable_simple_responses\n        self.is_aws_iam_authorizer = is_aws_iam_authorizer\n        self.enable_function_default_permissions = enable_function_default_permissions\n        self._validate_input_parameters()\n        authorizer_type = self._get_auth_type()\n        if authorizer_type == 'JWT':\n            self._validate_jwt_authorizer()\n        if authorizer_type == 'REQUEST':\n            self._validate_lambda_authorizer()\n        if enable_function_default_permissions is not None:\n            sam_expect(enable_function_default_permissions, api_logical_id, f'Authorizers.{name}.EnableFunctionDefaultPermissions').to_be_a_bool()\n\n    def _get_auth_type(self) -> str:\n        if self.is_aws_iam_authorizer:\n            return 'AWS_IAM'\n        if self.jwt_configuration:\n            return 'JWT'\n        return 'REQUEST'\n\n    def _validate_input_parameters(self) -> None:\n        authorizer_type = self._get_auth_type()\n        if self.authorization_scopes is not None and (not isinstance(self.authorization_scopes, list)):\n            raise InvalidResourceException(self.api_logical_id, 'AuthorizationScopes must be a list.')\n        if self.authorization_scopes is not None and (not authorizer_type == 'JWT'):\n            raise InvalidResourceException(self.api_logical_id, 'AuthorizationScopes must be defined only for OAuth2 Authorizer.')\n        if self.jwt_configuration is not None and (not authorizer_type == 'JWT'):\n            raise InvalidResourceException(self.api_logical_id, 'JwtConfiguration must be defined only for OAuth2 Authorizer.')\n        if self.id_source is not None and (not authorizer_type == 'JWT'):\n            raise InvalidResourceException(self.api_logical_id, 'IdentitySource must be defined only for OAuth2 Authorizer.')\n        if self.function_arn is not None and (not authorizer_type == 'REQUEST'):\n            raise InvalidResourceException(self.api_logical_id, 'FunctionArn must be defined only for Lambda Authorizer.')\n        if self.function_invoke_role is not None and (not authorizer_type == 'REQUEST'):\n            raise InvalidResourceException(self.api_logical_id, 'FunctionInvokeRole must be defined only for Lambda Authorizer.')\n        if self.identity is not None and (not authorizer_type == 'REQUEST'):\n            raise InvalidResourceException(self.api_logical_id, 'Identity must be defined only for Lambda Authorizer.')\n        if self.authorizer_payload_format_version is not None and (not authorizer_type == 'REQUEST'):\n            raise InvalidResourceException(self.api_logical_id, 'AuthorizerPayloadFormatVersion must be defined only for Lambda Authorizer.')\n        if self.enable_simple_responses is not None and (not authorizer_type == 'REQUEST'):\n            raise InvalidResourceException(self.api_logical_id, 'EnableSimpleResponses must be defined only for Lambda Authorizer.')\n        if self.enable_function_default_permissions is not None and authorizer_type != 'REQUEST':\n            raise InvalidResourceException(self.api_logical_id, 'EnableFunctionDefaultPermissions must be defined only for Lambda Authorizer.')\n\n    def _validate_jwt_authorizer(self) -> None:\n        if not self.jwt_configuration:\n            raise InvalidResourceException(self.api_logical_id, f\"{self.name} OAuth2 Authorizer must define 'JwtConfiguration'.\")\n        if not self.id_source:\n            raise InvalidResourceException(self.api_logical_id, f\"{self.name} OAuth2 Authorizer must define 'IdentitySource'.\")\n\n    def _validate_lambda_authorizer(self) -> None:\n        if not self.function_arn:\n            raise InvalidResourceException(self.api_logical_id, f\"{self.name} Lambda Authorizer must define 'FunctionArn'.\")\n        if not self.authorizer_payload_format_version:\n            raise InvalidResourceException(self.api_logical_id, f\"{self.name} Lambda Authorizer must define 'AuthorizerPayloadFormatVersion'.\")\n\n    def generate_openapi(self) -> Dict[str, Any]:\n        \"\"\"\n        Generates OAS for the securitySchemes section\n        \"\"\"\n        authorizer_type = self._get_auth_type()\n        openapi: Dict[str, Any]\n        if authorizer_type == 'AWS_IAM':\n            openapi = {'type': 'apiKey', 'name': 'Authorization', 'in': 'header', 'x-amazon-apigateway-authtype': 'awsSigv4'}\n        elif authorizer_type == 'JWT':\n            openapi = {'type': 'oauth2', APIGATEWAY_AUTHORIZER_KEY: {'jwtConfiguration': self.jwt_configuration, 'identitySource': self.id_source, 'type': 'jwt'}}\n        elif authorizer_type == 'REQUEST':\n            openapi = {'type': 'apiKey', 'name': 'Unused', 'in': 'header', APIGATEWAY_AUTHORIZER_KEY: {'type': 'request'}}\n            partition = ArnGenerator.get_partition_name()\n            resource = 'lambda:path/2015-03-31/functions/${__FunctionArn__}/invocations'\n            authorizer_uri = fnSub(ArnGenerator.generate_arn(partition=partition, service='apigateway', resource=resource, include_account_id=False), {'__FunctionArn__': self.function_arn})\n            openapi[APIGATEWAY_AUTHORIZER_KEY]['authorizerUri'] = authorizer_uri\n            function_invoke_role = self._get_function_invoke_role()\n            if function_invoke_role:\n                openapi[APIGATEWAY_AUTHORIZER_KEY]['authorizerCredentials'] = function_invoke_role\n            if self.identity:\n                sam_expect(self.identity, self.api_logical_id, f'Auth.Authorizers.{self.name}.Identity').to_be_a_map()\n                reauthorize_every = self.identity.get('ReauthorizeEvery')\n                if reauthorize_every is not None:\n                    openapi[APIGATEWAY_AUTHORIZER_KEY]['authorizerResultTtlInSeconds'] = reauthorize_every\n                openapi[APIGATEWAY_AUTHORIZER_KEY]['identitySource'] = self._get_identity_source(self.identity)\n            openapi[APIGATEWAY_AUTHORIZER_KEY]['authorizerPayloadFormatVersion'] = self.authorizer_payload_format_version\n            if self.enable_simple_responses:\n                openapi[APIGATEWAY_AUTHORIZER_KEY]['enableSimpleResponses'] = self.enable_simple_responses\n        else:\n            raise ValueError(f'Unexpected authorizer_type: {authorizer_type}')\n        return openapi\n\n    def _get_function_invoke_role(self) -> Optional[PassThrough]:\n        if not self.function_invoke_role or self.function_invoke_role == 'NONE':\n            return None\n        return self.function_invoke_role\n\n    def _get_identity_source(self, auth_identity: Dict[str, Any]) -> List[str]:\n        \"\"\"\n        Generate the list of identitySource using authorizer's Identity config by flatting them.\n        For the format of identitySource, see:\n        https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions-authorizer.html\n\n        It will add API GW prefix to each item:\n        - prefix \"$request.header.\" to all values in \"Headers\"\n        - prefix \"$request.querystring.\" to all values in \"QueryStrings\"\n        - prefix \"$stageVariables.\" to all values in \"StageVariables\"\n        - prefix \"$context.\" to all values in \"Context\"\n        \"\"\"\n        identity_source: List[str] = []\n        identity_property_path = f'Authorizers.{self.name}.Identity'\n        for prefix, property_name in [('$request.header.', 'Headers'), ('$request.querystring.', 'QueryStrings'), ('$stageVariables.', 'StageVariables'), ('$context.', 'Context')]:\n            property_values = auth_identity.get(property_name)\n            if property_values:\n                sam_expect(property_values, self.api_logical_id, f'{identity_property_path}.{property_name}').to_be_a_list_of(ExpectedType.STRING)\n                identity_source += [prefix + value for value in property_values]\n        return identity_source\n\n    @staticmethod\n    def _get_jwt_configuration(props: Optional[Dict[str, Union[str, List[str]]]], api_logical_id: str) -> Optional[JwtConfiguration]:\n        \"\"\"Make sure that JWT configuration dict keys are lower case.\n\n        ApiGatewayV2Authorizer doesn't create `AWS::ApiGatewayV2::Authorizer` but generates\n        Open Api which will be appended to the API's Open Api definition body.\n        For Open Api JWT configuration keys should be in lower case.\n        But for `AWS::ApiGatewayV2::Authorizer` the same keys are capitalized,\n        the way it's usually done in CloudFormation resources.\n        Users get often confused when passing capitalized key to `AWS::Serverless::HttpApi` doesn't work.\n        There exist a comment about that in the documentation\n        https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-property-httpapi-oauth2authorizer.html#sam-httpapi-oauth2authorizer-jwtconfiguration\n        but the comment doesn't prevent users from making the error.\n\n        Parameters\n        ----------\n        props: jwt configuration dict with the keys either lower case or capitalized\n        api_logical_id: logical id of the Serverless Api resource with the jwt configuration\n\n        Returns\n        -------\n            jwt configuration dict with low case keys\n        \"\"\"\n        if not props:\n            return None\n        sam_expect(props, api_logical_id, 'JwtConfiguration').to_be_a_map()\n        return {k.lower(): v for k, v in props.items()}\n\nExample skeleton:\n\n\nclass Category(caching.Memoizable):\n    ''' Wrapper for category information '''\n    @staticmethod\n    @utils.stash\n    def load(path: str):\n        ''' Get a category wrapper object\n        path -- the path to the category\n        '''\n        pass\n\n    def __init__(self, create_key, path: str):\n        ''' Initialize a category wrapper '''\n        pass\n\n    def _key(self):\n        pass\n    @cached_property\n    def link(self) -> typing.Callable[..., str]:\n        ''' Returns a link to the category.\n        Takes optional view arguments, as well as the following optional arguments:\n        template -- which template to generate the link against\n        '''\n        pass\n\n        def _link(template='', absolute=False, **kwargs) -> str:\n                pass\n    @cached_property\n    def subcats(self) -> typing.Callable[..., str]:\n        ''' Returns a list of subcategories.\n        Takes the following arguments:\n        recurse -- whether to include their subcategories as well (default: False)\n        '''\n        pass\n\n        def _get_subcats(recurse=False) -> typing.List['Category']:\n            ''' Get the subcategories of this category\n            recurse -- whether to include their subcategories as well\n                '''\n                pass\n    @cached_property\n    def first(self) -> typing.Callable[..., typing.Optional[entry.Entry]]:\n        ''' Returns the first entry in the category.\n        Takes optional view arguments.\n        '''\n        pass\n\n        def _first(**spec) -> typing.Optional[entry.Entry]:\n                ''' Get the earliest entry in this category, optionally including subcategories '''\n                pass\n    @cached_property\n    def last(self) -> typing.Callable[..., typing.Optional[entry.Entry]]:\n        ''' Returns the last entry in the category.\n        Takes optional view arguments.\n        '''\n        pass\n\n        def _last(**spec) -> typing.Optional[entry.Entry]:\n                ''' Get the latest entry in this category, optionally including subcategories '''\n                pass\n    @cached_property\n    def _meta(self) -> typing.Optional[email.message.Message]:\n        pass\n    @cached_property\n    def name(self) -> typing.Callable[..., str]:\n        ''' Get the display name of the category. Accepts the following arguments:\n        markup -- If True, convert it from Markdown to HTML; otherwise, strip\n            all markup (default: True)\n        no_smartquotes -- if True, preserve quotes and other characters as originally\n            presented\n        markdown_extensions -- a list of markdown extensions to use\n        '''\n        pass\n\n        def _name(markup=True, no_smartquotes=False, markdown_extensions=None) -> str:\n                pass\n    @cached_property\n    def description(self) -> typing.Callable[..., str]:\n        ''' Get the textual description of the category '''\n        pass\n\n        def _description(**kwargs) -> str:\n                pass\n    @cached_property\n    def search_path(self) -> str:\n        ''' Get the file search path for this category '''\n        pass\n    @cached_property\n    def breadcrumb(self) -> typing.List['Category']:\n        ''' Get the category hierarchy leading up to this category, including\n        root and self.\n        For example, path/to/long/category will return a list containing\n        Category.load('path'), Category.load('path/to'), and Category.load('path/to/long').\n        '''\n        pass\n    @cached_property\n    def sort_name(self) -> str:\n        ''' Get the sorting name of this category '''\n        pass\n    @cached_property\n    def tags(self) -> typing.Callable[..., typing.List[TagCount]]:\n        ''' Get the list of tags associated with this category's entries.\n        Takes optional view arguments (including recurse)\n        Returns a list of category.TagCount tuples like `(tag='foo', count=5)`\n        '''\n        pass\n\n        def _tags(**spec) -> typing.List[TagCount]:\n                pass\n\n    def __getattr__(self, name):\n        ''' Proxy undefined properties to the meta file '''\n        pass\n\n    def get(self, name, default=None):\n        ''' Get a single metadata value '''\n        pass\n\n    def get_all(self, name):\n        ''' Get all matching metadata values '''\n        pass\n\n    def __str__(self):\n        pass\n\n    def __eq__(self, other):\n        pass\n\n    def __lt__(self, other):\n        pass\n    @cached_property\n    def parent(self) -> typing.Optional['Category']:\n        ''' Get the parent category '''\n        pass\n    @cached_property\n    def root(self):\n        ''' Get the root category object. Equivalent to `breadcrumb[0]` but faster/easier. '''\n        pass\n\n    def _entries(self, spec):\n        ''' Return a model query to get our entry records '''\n        pass\n    @cached_property\n    def index_template(self) -> str:\n        ''' Get the name of the index template for this category '''\n        pass\n\n    def image(self, filename):\n        ''' Retrieve an image using our search path as the context '''\n        pass\nCorresponding class implementation:\n\nfrom pony import orm\nimport markupsafe\nfrom . import entry\nfrom werkzeug.utils import cached_property\nimport os\nimport email\nfrom flask import url_for\nimport typing\nfrom . import caching, image, markdown, model, queries, utils\n\nclass Category(caching.Memoizable):\n    \"\"\" Wrapper for category information \"\"\"\n    __hash__ = caching.Memoizable.__hash__\n\n    @staticmethod\n    @utils.stash\n    def load(path: str):\n        \"\"\" Get a category wrapper object\n\n        path -- the path to the category\n        \"\"\"\n        return Category(Category.load.__name__, path)\n\n    def __init__(self, create_key, path: str):\n        \"\"\" Initialize a category wrapper \"\"\"\n        assert create_key == Category.load.__name__, 'Category must be created with Category.load()'\n        if path is None:\n            path = ''\n        self.path = path\n        self.basename = os.path.basename(path)\n        subcat_query = orm.select((e.category for e in model.Entry if e.visible))\n        if path:\n            subcat_query = orm.select((c for c in subcat_query if c.startswith(path + '/')))\n        else:\n            subcat_query = orm.select((c for c in subcat_query if c != ''))\n        self._subcats_recursive = subcat_query\n        self._record = model.Category.get(category=path)\n\n    def _key(self):\n        return self.path\n\n    @cached_property\n    def link(self) -> typing.Callable[..., str]:\n        \"\"\" Returns a link to the category.\n\n        Takes optional view arguments, as well as the following optional arguments:\n\n        template -- which template to generate the link against\n\n        \"\"\"\n\n        def _link(template='', absolute=False, **kwargs) -> str:\n            return url_for('category', category=self.path, template=template if str(template) != self.index_template else '', _external=absolute, **kwargs)\n        return utils.CallableProxy(_link)\n\n    @cached_property\n    def subcats(self) -> typing.Callable[..., str]:\n        \"\"\" Returns a list of subcategories.\n\n        Takes the following arguments:\n\n        recurse -- whether to include their subcategories as well (default: False)\n\n        \"\"\"\n\n        def _get_subcats(recurse=False) -> typing.List['Category']:\n            \"\"\" Get the subcategories of this category\n\n            recurse -- whether to include their subcategories as well\n            \"\"\"\n            if recurse:\n                return sorted([Category.load(e) for e in self._subcats_recursive], key=lambda cat: tuple((crumb.sort_name for crumb in cat.breadcrumb)))\n            parts = len(self.path.split('/')) + 1 if self.path else 1\n            subcats = {'/'.join(c.split('/', parts)[:parts]) for c in self._subcats_recursive}\n            return sorted([Category.load(c) for c in subcats], key=lambda c: c.sort_name)\n        return utils.CallableProxy(_get_subcats)\n\n    @cached_property\n    def first(self) -> typing.Callable[..., typing.Optional[entry.Entry]]:\n        \"\"\" Returns the first entry in the category.\n\n        Takes optional view arguments.\n        \"\"\"\n\n        def _first(**spec) -> typing.Optional[entry.Entry]:\n            \"\"\" Get the earliest entry in this category, optionally including subcategories \"\"\"\n            for record in self._entries(spec).order_by(model.Entry.local_date, model.Entry.id)[:1]:\n                return entry.Entry.load(record)\n            return None\n        return utils.CallableProxy(_first)\n\n    @cached_property\n    def last(self) -> typing.Callable[..., typing.Optional[entry.Entry]]:\n        \"\"\" Returns the last entry in the category.\n\n        Takes optional view arguments.\n        \"\"\"\n\n        def _last(**spec) -> typing.Optional[entry.Entry]:\n            \"\"\" Get the latest entry in this category, optionally including subcategories \"\"\"\n            for record in self._entries(spec).order_by(orm.desc(model.Entry.local_date), orm.desc(model.Entry.id))[:1]:\n                return entry.Entry.load(record)\n            return None\n        return utils.CallableProxy(_last)\n\n    @cached_property\n    def _meta(self) -> typing.Optional[email.message.Message]:\n        if self._record and self._record.file_path:\n            return load_metafile(self._record.file_path)\n        return None\n\n    @cached_property\n    def name(self) -> typing.Callable[..., str]:\n        \"\"\" Get the display name of the category. Accepts the following arguments:\n\n        markup -- If True, convert it from Markdown to HTML; otherwise, strip\n            all markup (default: True)\n        no_smartquotes -- if True, preserve quotes and other characters as originally\n            presented\n        markdown_extensions -- a list of markdown extensions to use\n        \"\"\"\n        if self._meta and self._meta.get('name'):\n            name = self._meta.get('name')\n        else:\n            name = self.basename.replace('_', ' ').title()\n\n        def _name(markup=True, no_smartquotes=False, markdown_extensions=None) -> str:\n            return markdown.render_title(name, markup, no_smartquotes, markdown_extensions)\n        return utils.CallableProxy(_name)\n\n    @cached_property\n    def description(self) -> typing.Callable[..., str]:\n        \"\"\" Get the textual description of the category \"\"\"\n\n        def _description(**kwargs) -> str:\n            if self._meta:\n                return markupsafe.Markup(markdown.to_html(self._meta.get_payload(), args=kwargs, search_path=self.search_path, counter=markdown.ItemCounter()))\n            return ''\n        if self._meta and self._meta.get_payload():\n            return utils.TrueCallableProxy(_description)\n        return utils.CallableValue('')\n\n    @cached_property\n    def search_path(self) -> str:\n        \"\"\" Get the file search path for this category \"\"\"\n        return search_path(self.path)\n\n    @cached_property\n    def breadcrumb(self) -> typing.List['Category']:\n        \"\"\" Get the category hierarchy leading up to this category, including\n        root and self.\n\n        For example, path/to/long/category will return a list containing\n        Category.load('path'), Category.load('path/to'), and Category.load('path/to/long').\n        \"\"\"\n        ret = []\n        here: typing.Optional[Category] = self\n        while here:\n            ret.append(here)\n            here = here.parent\n        return list(reversed(ret))\n\n    @cached_property\n    def sort_name(self) -> str:\n        \"\"\" Get the sorting name of this category \"\"\"\n        if self._record and self._record.sort_name:\n            return self._record.sort_name\n        return self.name(markup=False)\n\n    @cached_property\n    def tags(self) -> typing.Callable[..., typing.List[TagCount]]:\n        \"\"\" Get the list of tags associated with this category's entries.\n\n        Takes optional view arguments (including recurse)\n\n        Returns a list of category.TagCount tuples like `(tag='foo', count=5)`\n        \"\"\"\n\n        def _tags(**spec) -> typing.List[TagCount]:\n            entries = self._entries(spec)\n            etags = orm.select(((tag.tag, orm.count(tag.tag, distinct=False)) for e in entries for tag in e.tags if not tag.hidden))\n            return [TagCount(tag.name, count) for tag, count in etags]\n        return utils.CallableProxy(_tags)\n\n    def __getattr__(self, name):\n        \"\"\" Proxy undefined properties to the meta file \"\"\"\n        if self._meta:\n            return self._meta.get(name)\n        return None\n\n    def get(self, name, default=None):\n        \"\"\" Get a single metadata value \"\"\"\n        if self._meta:\n            return self._meta.get(name, default)\n        return default\n\n    def get_all(self, name):\n        \"\"\" Get all matching metadata values \"\"\"\n        if self._meta:\n            return self._meta.get_all(name) or []\n        return None\n\n    def __str__(self):\n        return self.path\n\n    def __eq__(self, other):\n        return str(other) == str(self)\n\n    def __lt__(self, other):\n        return self.path < other.path\n\n    @cached_property\n    def parent(self) -> typing.Optional['Category']:\n        \"\"\" Get the parent category \"\"\"\n        if self.path:\n            return Category.load(os.path.dirname(self.path))\n        return None\n\n    @cached_property\n    def root(self):\n        \"\"\" Get the root category object. Equivalent to `breadcrumb[0]` but faster/easier. \"\"\"\n        if self.path:\n            return Category.load(None)\n        return self\n\n    def _entries(self, spec):\n        \"\"\" Return a model query to get our entry records \"\"\"\n        return queries.build_query({**spec, 'category': self})\n\n    @cached_property\n    def index_template(self) -> str:\n        \"\"\" Get the name of the index template for this category \"\"\"\n        return self.get('Index-Template', 'index')\n\n    def image(self, filename):\n        \"\"\" Retrieve an image using our search path as the context \"\"\"\n        return image.get_image(filename, (self.search_path,))\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass AWSComponentRegistry:\n    '''\n    Class responsible for discovering and managing AWS components from the diagrams package.\n    Encapsulates the component discovery, caching and lookup functionality.\n    '''\n\n    def __init__(self):\n        '''Initialize the registry with discovered components and aliases'''\n        pass\n\n    def _discover_categories(self) -> List[str]:\n        '''Dynamically discover all AWS categories from the diagrams package'''\n        pass\n\n    def _discover_components(self) -> Dict[str, List[str]]:\n        '''Dynamically discover all available AWS components by category'''\n        pass\n\n    def _build_aliases(self) -> Dict[str, str]:\n        '''Build aliases dictionary by analyzing available components'''\n        pass\n\n    def get_node(self, node_type: str) -> Any:\n        '''Get AWS component class using dynamic discovery with caching'''\n        pass\n\n    def list_available_components(self, category: str=None) -> Dict[str, List[str]]:\n        '''List all available AWS components and their aliases'''\n        pass"
  }
]