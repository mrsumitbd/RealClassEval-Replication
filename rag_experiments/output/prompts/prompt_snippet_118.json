[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass CatalogueFunctionRegistry(dict):\n    '''\n    A collection of methods/functions working on catalogues.\n    The registry also holds information about the type of the input arguments\n    '''\n\n    def check_config(self, config, fields_spec):\n        '''\n        Check that `config` has each field in `fields_spec` if a default\n        has not been provided.\n        '''\n        pass\n\n    def set_defaults(self, config, fields_spec):\n        '''\n        Set default values got from `fields_spec` into the `config`\n        dictionary\n        '''\n        pass\n\n    def add(self, method_name, completeness=False, **fields):\n        '''\n        Class decorator.\n        Decorate `method_name` by adding a call to `set_defaults` and\n        `check_config`. Then, save into the registry a callable\n        function with the same signature of the original method.\n        :param str method_name:\n            the method to decorate\n        :param bool completeness:\n            True if the method accepts in input an optional parameter\n            for the completeness table\n        :param fields:\n            a dictionary of field spec corresponding to the\n            keys expected to be present in the config dictionary\n            for the decorated method, e.g.\n            time_bin=float,\n            b_value=1E-6\n        '''\n        pass\n\n        def class_decorator(class_obj):\n                pass\n\n            def caller(fn, obj, catalogue, config=None, *args, **kwargs):\n                        pass\n\n    def add_function(self, completeness=False, **fields):\n        '''\n        Function decorator.\n        Decorate a function by adding a call to `set_defaults` and\n        `check_config`. Then, save into the registry a callable\n        function with the same signature of the original method\n        :param fields:\n            a dictionary of field spec, e.g.\n            time_bin=float,\n            b_value=1E-6\n        '''\n        pass\n\n        def dec(fn):\n                pass\n\n                def fn_with_config_and_c(catalogue, config, completeness_table=None):\n                                pass\n\n                def fn_with_config_without_c(catalogue, config):\n                                pass\nCorresponding class implementation:\n\nimport sys\nfrom decorator import decorator\nimport functools\n\nclass CatalogueFunctionRegistry(dict):\n    \"\"\"\n    A collection of methods/functions working on catalogues.\n\n    The registry also holds information about the type of the input arguments\n    \"\"\"\n\n    def check_config(self, config, fields_spec):\n        \"\"\"\n        Check that `config` has each field in `fields_spec` if a default\n        has not been provided.\n        \"\"\"\n        for field, type_info in fields_spec.items():\n            has_default = not isinstance(type_info, type)\n            if field not in config and (not has_default):\n                raise RuntimeError('Configuration not complete. %s missing' % field)\n\n    def set_defaults(self, config, fields_spec):\n        \"\"\"\n        Set default values got from `fields_spec` into the `config`\n        dictionary\n        \"\"\"\n        defaults = dict([(f, d) for f, d in fields_spec.items() if not isinstance(d, type)])\n        for field, default_value in defaults.items():\n            if field not in config:\n                config[field] = default_value\n\n    def add(self, method_name, completeness=False, **fields):\n        \"\"\"\n        Class decorator.\n\n        Decorate `method_name` by adding a call to `set_defaults` and\n        `check_config`. Then, save into the registry a callable\n        function with the same signature of the original method.\n\n        :param str method_name:\n            the method to decorate\n        :param bool completeness:\n            True if the method accepts in input an optional parameter\n            for the completeness table\n        :param fields:\n            a dictionary of field spec corresponding to the\n            keys expected to be present in the config dictionary\n            for the decorated method, e.g.\n            time_bin=float,\n            b_value=1E-6\n        \"\"\"\n\n        def class_decorator(class_obj):\n            original_method = getattr(class_obj, method_name)\n            if sys.version[0] == '2':\n                original_method = original_method.im_func\n\n            def caller(fn, obj, catalogue, config=None, *args, **kwargs):\n                config = config or {}\n                self.set_defaults(config, fields)\n                self.check_config(config, fields)\n                return fn(obj, catalogue, config, *args, **kwargs)\n            new_method = decorator(caller, original_method)\n            setattr(class_obj, method_name, new_method)\n            instance = class_obj()\n            func = functools.partial(new_method, instance)\n            func.fields = fields\n            func.model = instance\n            func.completeness = completeness\n            functools.update_wrapper(func, new_method)\n            self[class_obj.__name__] = func\n            return class_obj\n        return class_decorator\n\n    def add_function(self, completeness=False, **fields):\n        \"\"\"\n        Function decorator.\n\n        Decorate a function by adding a call to `set_defaults` and\n        `check_config`. Then, save into the registry a callable\n        function with the same signature of the original method\n\n        :param fields:\n            a dictionary of field spec, e.g.\n            time_bin=float,\n            b_value=1E-6\n        \"\"\"\n\n        def dec(fn):\n            if completeness:\n\n                def fn_with_config_and_c(catalogue, config, completeness_table=None):\n                    return fn(catalogue, completeness_table, **config)\n                fn_with_config = fn_with_config_and_c\n            else:\n\n                def fn_with_config_without_c(catalogue, config):\n                    return fn(catalogue, **config)\n                fn_with_config = fn_with_config_without_c\n            fn_with_config.fields = fields\n            fn_with_config.completeness = completeness\n            fn.fields = fields\n            self[fn.__name__] = fn_with_config\n            return fn\n        return dec\n\nExample skeleton:\n\n\nclass Job(AbstractJob):\n\n    def __init__(self, model: AbstractPriorModel, simulate_cls: Callable, perturb_model: AbstractPriorModel, simulate_instance: ModelInstance, base_instance: ModelInstance, base_fit_cls: Callable, perturb_fit_cls: Callable, paths: AbstractPaths, number: int):\n        '''\n        Job to run non-linear searches comparing how well a model and a model with a perturbation fit the image.\n        Parameters\n        ----------\n        model\n            A base model that fits the image without a perturbation\n        perturb_model\n            A model of the perturbation which has been added to the underlying image\n        base_fit_cls\n            A class which defines the function which fits the base model to each simulated dataset of the sensitivity\n            map.\n        perturb_fit_cls\n            A class which defines the function which fits the perturbed model to each simulated dataset of the\n            sensitivity map.\n        paths\n            The paths defining the output directory structure of the sensitivity mapping.\n        '''\n        pass\n    @property\n    def base_paths(self):\n        pass\n    @property\n    def perturb_paths(self):\n        pass\n    @property\n    def is_complete(self) -> bool:\n        '''\n        Returns True if the job has been completed, False otherwise.\n        '''\n        pass\n\n    def perform(self) -> JobResult:\n        '''\n        - Create one model with a perturbation and another without\n        - Fit each model against the perturbed image\n        Returns\n        -------\n        An object comprising the results of the two fits\n        '''\n        pass\nCorresponding class implementation:\n\nfrom copy import copy\nfrom itertools import count\nfrom autofit.mapper.prior_model.abstract import AbstractPriorModel\nfrom typing import Callable, Optional\nfrom autofit.non_linear.paths.abstract import AbstractPaths\nfrom autofit.mapper.model import ModelInstance\nfrom autofit.non_linear.parallel import AbstractJob, AbstractJobResult\n\nclass Job(AbstractJob):\n    _number = count()\n\n    def __init__(self, model: AbstractPriorModel, simulate_cls: Callable, perturb_model: AbstractPriorModel, simulate_instance: ModelInstance, base_instance: ModelInstance, base_fit_cls: Callable, perturb_fit_cls: Callable, paths: AbstractPaths, number: int):\n        \"\"\"\n        Job to run non-linear searches comparing how well a model and a model with a perturbation fit the image.\n\n        Parameters\n        ----------\n        model\n            A base model that fits the image without a perturbation\n        perturb_model\n            A model of the perturbation which has been added to the underlying image\n        base_fit_cls\n            A class which defines the function which fits the base model to each simulated dataset of the sensitivity\n            map.\n        perturb_fit_cls\n            A class which defines the function which fits the perturbed model to each simulated dataset of the\n            sensitivity map.\n        paths\n            The paths defining the output directory structure of the sensitivity mapping.\n        \"\"\"\n        super().__init__(number=number)\n        self.model = model\n        self.simulate_cls = simulate_cls\n        self.perturb_model = perturb_model\n        self.simulate_instance = simulate_instance\n        self.base_instance = base_instance\n        self.base_fit_cls = base_fit_cls\n        self.perturb_fit_cls = perturb_fit_cls\n        self.paths = paths\n\n    @property\n    def base_paths(self):\n        return self.paths.for_sub_analysis('[base]')\n\n    @property\n    def perturb_paths(self):\n        return self.paths.for_sub_analysis('[perturb]')\n\n    @property\n    def is_complete(self) -> bool:\n        \"\"\"\n        Returns True if the job has been completed, False otherwise.\n        \"\"\"\n        return self.base_paths.is_complete and self.perturb_paths.is_complete or ((self.paths.output_path / '[base].zip').exists() and (self.paths.output_path / '[perturb].zip').exists())\n\n    def perform(self) -> JobResult:\n        \"\"\"\n        - Create one model with a perturbation and another without\n        - Fit each model against the perturbed image\n\n        Returns\n        -------\n        An object comprising the results of the two fits\n        \"\"\"\n        if self.is_complete:\n            dataset = None\n        else:\n            dataset = self.simulate_cls(instance=self.simulate_instance, simulate_path=self.paths.image_path.with_name('simulate'))\n        result = self.base_fit_cls(model=self.model, dataset=dataset, paths=self.base_paths, instance=self.simulate_instance)\n        perturb_model = copy(self.model)\n        perturb_model.perturb = self.perturb_model\n        perturb_result = self.perturb_fit_cls(model=perturb_model, dataset=dataset, paths=self.perturb_paths, instance=self.simulate_instance)\n        return JobResult(number=self.number, result=result, perturb_result=perturb_result)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass NunchakuModelMerger:\n    '''\n    Node for merging a Nunchaku FLUX.1 model folder into a single safetensors file.\n    This node scans available model folders, merges the selected folder using\n    `nunchaku.merge_safetensors.merge_safetensors`, and saves the result as a safetensors file.\n    Attributes\n    ----------\n    RETURN_TYPES : tuple of str\n        The return types of the node (\"STRING\",).\n    RETURN_NAMES : tuple of str\n        The names of the returned values (\"status\",).\n    FUNCTION : str\n        The function to execute (\"run\").\n    CATEGORY : str\n        The node category (\"Nunchaku\").\n    TITLE : str\n        The display title of the node.\n    '''\n    @classmethod\n    def INPUT_TYPES(s):\n        '''\n        Returns the input types required for the node.\n        Returns\n        -------\n        dict\n            Dictionary specifying required inputs: model_folder and save_name.\n        '''\n        pass\n\n    def run(self, model_folder: str, save_name: str):\n        '''\n        Merge the specified Nunchaku model folder and save as a safetensors file.\n        Parameters\n        ----------\n        model_folder : str\n            Name of the Nunchaku FLUX.1 model folder to merge.\n        save_name : str\n            Filename to save the merged model as.\n        Returns\n        -------\n        tuple of str\n            Status message indicating the result of the merge operation.\n        '''\n        pass"
  }
]