[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass LLDSMAT(LLDAlgoABC):\n    '''Simple moving average threshold.'''\n\n    def __init__(self, samples: int=10, thresh: float=-15) -> None:\n        '''Init.'''\n        pass\n\n    def name(self) -> str:\n        '''Name of this algorithm.'''\n        pass\n\n    def reset(self) -> None:\n        '''Reset simulator between runs.'''\n        pass\n    @staticmethod\n    def _tick_one_sensor(pressure: float, samples_n: int, running_samples: List[float]) -> Tuple[float, List[float]]:\n        '''ticks one sensor returns the new current average and running_samples.'''\n        pass\n\n    def tick(self, pressures: Tuple[float, float]) -> Tuple[bool, Tuple[float, float]]:\n        '''Simulate firmware motor interrupt tick.'''\n        pass\nCorresponding class implementation:\n\nfrom typing import List, Optional, Tuple, Any, Dict\n\nclass LLDSMAT(LLDAlgoABC):\n    \"\"\"Simple moving average threshold.\"\"\"\n    samples_n_smat: int\n    running_samples_smat_p: List[float]\n    running_samples_smat_s: List[float]\n    threshold_smat: float\n\n    def __init__(self, samples: int=10, thresh: float=-15) -> None:\n        \"\"\"Init.\"\"\"\n        self.samples_n_smat = samples\n        self.threshold_smat = thresh\n        self.reset()\n\n    def name(self) -> str:\n        \"\"\"Name of this algorithm.\"\"\"\n        return '{:<40}'.format(f'simple moving avg thresh {self.samples_n_smat} {self.threshold_smat}')\n\n    def reset(self) -> None:\n        \"\"\"Reset simulator between runs.\"\"\"\n        self.running_samples_smat_p = [impossible_pressure] * self.samples_n_smat\n        self.running_samples_smat_s = [impossible_pressure] * self.samples_n_smat\n\n    @staticmethod\n    def _tick_one_sensor(pressure: float, samples_n: int, running_samples: List[float]) -> Tuple[float, List[float]]:\n        \"\"\"ticks one sensor returns the new current average and running_samples.\"\"\"\n        try:\n            next_ind = running_samples.index(impossible_pressure)\n            running_samples[next_ind] = pressure\n            return (impossible_pressure, running_samples)\n        except ValueError:\n            pass\n        for i in range(samples_n - 1):\n            running_samples[i] = running_samples[i + 1]\n        running_samples[samples_n - 1] = pressure\n        new_running_avg = sum(running_samples) / samples_n\n        return (new_running_avg, running_samples)\n\n    def tick(self, pressures: Tuple[float, float]) -> Tuple[bool, Tuple[float, float]]:\n        \"\"\"Simulate firmware motor interrupt tick.\"\"\"\n        new_avg_p, self.running_samples_smad_p = LLDSMAT._tick_one_sensor(pressures[0], self.samples_n_smat, self.running_samples_smat_p)\n        new_avg_s, self.running_samples_smad_s = LLDSMAT._tick_one_sensor(pressures[1], self.samples_n_smat, self.running_samples_smat_s)\n        if abs(new_avg_p) == impossible_pressure or abs(new_avg_s) == impossible_pressure:\n            return (False, (new_avg_p, new_avg_s))\n        return (abs(new_avg_p) > self.threshold_smat or abs(new_avg_s) > self.threshold_smat, (new_avg_p, new_avg_s))\n\nExample skeleton:\n\n\nclass DriftModel(NIDMObject):\n    '''Object representing a DriftModel entity.'''\n\n    def __init__(self, drift_type, parameter, label=None, oid=None):\n        pass\n    @classmethod\n    def get_query(klass, oid=None):\n        pass\n\n    def export(self, nidm_version, export_dir):\n        '''Create prov entities and activities.'''\n        pass\nCorresponding class implementation:\n\nfrom nidmresults.objects.generic import Image, NIDMFile, NIDMObject\nfrom nidmresults.objects.constants import DC, DCT, FSL_DRIFT_CUTOFF_PERIOD, FSL_GAUSSIAN_RUNNING_LINE_DRIFT_MODEL, NFO, NIDM_DATA, NIDM_DATA_SCALING, NIDM_DEPENDENCE_SPATIAL_MODEL, NIDM_DESIGN_MATRIX, NIDM_ERROR_MODEL, NIDM_ERROR_VARIANCE_HOMOGENEOUS, NIDM_GRAND_MEAN_MAP, NIDM_GRAND_MEAN_SCALING, NIDM_GROUP_NAME, NIDM_HAS_DRIFT_MODEL, NIDM_HAS_ERROR_DEPENDENCE, NIDM_HAS_ERROR_DISTRIBUTION, NIDM_HAS_FMRI_DESIGN, NIDM_HAS_HRF_BASIS, NIDM_HAS_MRI_PROTOCOL, NIDM_IN_COORDINATE_SPACE, NIDM_IS_USER_DEFINED, NIDM_MASK_MAP, NIDM_MASKED_MEDIAN, NIDM_MODEL_PARAMETERS_ESTIMATION, NIDM_NUMBER_OF_SUBJECTS, NIDM_PARAMETER_ESTIMATE_MAP, NIDM_REGRESSOR_NAMES, NIDM_RESELS_PER_VOXEL_MAP, NIDM_RESIDUAL_MEAN_SQUARES_MAP, NIDM_TARGET_INTENSITY, NIDM_VARIANCE_SPATIAL_MODEL, NIDM_WITH_ESTIMATION_METHOD, NIF_EEG, NIF_MEG, NIF_MRI, NIF_PET, NIF_SPECT, NLX_FMRI_PROTOCOL, NLX_IMAGING_INSTRUMENT, PROV, SPM_DCT_DRIFT_MODEL, SPM_SPMS_DRIFT_CUT_OFF_PERIOD, STATO_GROUP\n\nclass DriftModel(NIDMObject):\n    \"\"\"Object representing a DriftModel entity.\"\"\"\n\n    def __init__(self, drift_type, parameter, label=None, oid=None):\n        super().__init__(oid=oid)\n        self.drift_type = drift_type\n        self.parameter = parameter\n        self.type = drift_type\n        self.prov_type = PROV['Entity']\n        if not label:\n            if self.drift_type == FSL_GAUSSIAN_RUNNING_LINE_DRIFT_MODEL:\n                self.label = \"FSL's Gaussian Running Line Drift Model\"\n        else:\n            self.label = label\n\n    @classmethod\n    def get_query(klass, oid=None):\n        if oid is None:\n            oid_var = '?oid'\n        else:\n            oid_var = '<' + str(oid) + '>'\n        query = '\\nprefix nidm_DesignMatrix: <http://purl.org/nidash/nidm#NIDM_0000019>\\nprefix spm_SPMsDriftCutoffPeriod: <http://purl.org/nidash/spm#SPM_0000001>\\nprefix fsl_driftCutoffPeriod: <http://purl.org/nidash/fsl#FSL_0000004>\\n\\nSELECT DISTINCT * WHERE {\\n    [] a nidm_DesignMatrix: ;\\n        nidm_hasDriftModel: ' + oid_var + ' .\\n\\n    ' + oid_var + ' a ?drift_type ;\\n        rdfs:label ?label .\\n\\n    {' + oid_var + ' spm_SPMsDriftCutoffPeriod: ?parameter .} UNION\\n    {' + oid_var + ' fsl_driftCutoffPeriod: ?parameter .} .\\n\\n    FILTER ( ?drift_type NOT IN (prov:Entity) )\\n}\\n        '\n        return query\n\n    def export(self, nidm_version, export_dir):\n        \"\"\"Create prov entities and activities.\"\"\"\n        attributes = [(PROV['type'], self.drift_type), (PROV['label'], self.label)]\n        if self.drift_type == FSL_GAUSSIAN_RUNNING_LINE_DRIFT_MODEL:\n            attributes.append((FSL_DRIFT_CUTOFF_PERIOD, self.parameter))\n        if self.drift_type == SPM_DCT_DRIFT_MODEL:\n            attributes.append((SPM_SPMS_DRIFT_CUT_OFF_PERIOD, self.parameter))\n        self.add_attributes(attributes)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass GSNet:\n    '''This class is used to grasp an object from a point cloud.'''\n\n    def __init__(self):\n        '''This function is used to initialize the configuration.'''\n        pass\n\n    def inference(self, cloud_masked, max_grasps=200):\n        '''This function is used to infer the grasp from the point cloud.'''\n        pass\n\n    def visualize(self, cloud, gg: GraspGroup=None, g: Grasp=None, image_only=False):\n        '''This function is used to visualize the grasp group or grasp.'''\n        pass"
  }
]