[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass CSFileSystem(file_system.FileSystem):\n    '''File system that uses pyfvde.'''\n\n    def __init__(self, resolver_context, path_spec):\n        '''Initializes a file system.\n        Args:\n          resolver_context (Context): resolver context.\n          path_spec (PathSpec): a path specification.\n        '''\n        pass\n\n    def _Close(self):\n        '''Closes the file system.\n        Raises:\n          IOError: if the close failed.\n        '''\n        pass\n\n    def _Open(self, mode='rb'):\n        '''Opens the file system defined by path specification.\n        Args:\n          mode (Optional[str]): file access mode. The default is 'rb'\n              read-only binary.\n        Raises:\n          AccessError: if the access to open the file was denied.\n          IOError: if the file system could not be opened.\n          PathSpecError: if the path specification is incorrect.\n          ValueError: if the path specification is invalid.\n        '''\n        pass\n\n    def FileEntryExistsByPathSpec(self, path_spec):\n        '''Determines if a file entry for a path specification exists.\n        Args:\n          path_spec (PathSpec): path specification.\n        Returns:\n          bool: True if the file entry exists.\n        '''\n        pass\n\n    def GetFileEntryByPathSpec(self, path_spec):\n        '''Retrieves a file entry for a path specification.\n        Args:\n          path_spec (PathSpec): path specification.\n        Returns:\n          CSFileEntry: a file entry or None if not available.\n        '''\n        pass\n\n    def GetFVDELogicalVolumeByPathSpec(self, path_spec):\n        '''Retrieves a Core Storage logical volume for a path specification.\n        Args:\n          path_spec (PathSpec): path specification.\n        Returns:\n          pyfvde.logical_volume: a Core Storage logical volume or None if not\n              available.\n        '''\n        pass\n\n    def GetFVDEVolumeGroup(self):\n        '''Retrieves the Core Storage volume group.\n        Returns:\n          pyfvde.volume_group: a Core Storage volume group.\n        '''\n        pass\n\n    def GetRootFileEntry(self):\n        '''Retrieves the root file entry.\n        Returns:\n          CSFileEntry: root file entry or None if not available.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom dfvfs.lib import errors\nfrom dfvfs.lib import definitions\nimport pyfvde\nfrom dfvfs.path import cs_path_spec\nfrom dfvfs.resolver import resolver\nfrom dfvfs.vfs import cs_file_entry\nfrom dfvfs.lib import cs_helper\nfrom dfvfs.vfs import file_system\n\nclass CSFileSystem(file_system.FileSystem):\n    \"\"\"File system that uses pyfvde.\"\"\"\n    TYPE_INDICATOR = definitions.TYPE_INDICATOR_CS\n\n    def __init__(self, resolver_context, path_spec):\n        \"\"\"Initializes a file system.\n\n        Args:\n          resolver_context (Context): resolver context.\n          path_spec (PathSpec): a path specification.\n        \"\"\"\n        super(CSFileSystem, self).__init__(resolver_context, path_spec)\n        self._fvde_volume = None\n        self._fvde_volume_group = None\n        self._file_object = None\n\n    def _Close(self):\n        \"\"\"Closes the file system.\n\n        Raises:\n          IOError: if the close failed.\n        \"\"\"\n        self._fvde_volume_group = None\n        self._fvde_volume.close()\n        self._fvde_volume = None\n        self._file_object = None\n\n    def _Open(self, mode='rb'):\n        \"\"\"Opens the file system defined by path specification.\n\n        Args:\n          mode (Optional[str]): file access mode. The default is 'rb'\n              read-only binary.\n\n        Raises:\n          AccessError: if the access to open the file was denied.\n          IOError: if the file system could not be opened.\n          PathSpecError: if the path specification is incorrect.\n          ValueError: if the path specification is invalid.\n        \"\"\"\n        if not self._path_spec.HasParent():\n            raise errors.PathSpecError('Unsupported path specification without parent.')\n        resolver.Resolver.key_chain.ExtractCredentialsFromPathSpec(self._path_spec)\n        file_object = resolver.Resolver.OpenFileObject(self._path_spec.parent, resolver_context=self._resolver_context)\n        fvde_volume = pyfvde.volume()\n        encrypted_root_plist = resolver.Resolver.key_chain.GetCredential(self._path_spec, 'encrypted_root_plist')\n        if encrypted_root_plist:\n            fvde_volume.read_encrypted_root_plist(encrypted_root_plist)\n        fvde_volume.open_file_object(file_object)\n        fvde_volume.open_physical_volume_files_as_file_objects([file_object])\n        fvde_volume_group = fvde_volume.get_volume_group()\n        self._file_object = file_object\n        self._fvde_volume = fvde_volume\n        self._fvde_volume_group = fvde_volume_group\n\n    def FileEntryExistsByPathSpec(self, path_spec):\n        \"\"\"Determines if a file entry for a path specification exists.\n\n        Args:\n          path_spec (PathSpec): path specification.\n\n        Returns:\n          bool: True if the file entry exists.\n        \"\"\"\n        volume_index = cs_helper.CSPathSpecGetVolumeIndex(path_spec)\n        if volume_index is None:\n            location = getattr(path_spec, 'location', None)\n            return location is not None and location == self.LOCATION_ROOT\n        return 0 <= volume_index < self._fvde_volume_group.number_of_logical_volumes\n\n    def GetFileEntryByPathSpec(self, path_spec):\n        \"\"\"Retrieves a file entry for a path specification.\n\n        Args:\n          path_spec (PathSpec): path specification.\n\n        Returns:\n          CSFileEntry: a file entry or None if not available.\n        \"\"\"\n        volume_index = cs_helper.CSPathSpecGetVolumeIndex(path_spec)\n        if volume_index is None:\n            location = getattr(path_spec, 'location', None)\n            if location is None or location != self.LOCATION_ROOT:\n                return None\n            return cs_file_entry.CSFileEntry(self._resolver_context, self, path_spec, is_root=True, is_virtual=True)\n        if volume_index < 0 or volume_index >= self._fvde_volume_group.number_of_logical_volumes:\n            return None\n        return cs_file_entry.CSFileEntry(self._resolver_context, self, path_spec)\n\n    def GetFVDELogicalVolumeByPathSpec(self, path_spec):\n        \"\"\"Retrieves a Core Storage logical volume for a path specification.\n\n        Args:\n          path_spec (PathSpec): path specification.\n\n        Returns:\n          pyfvde.logical_volume: a Core Storage logical volume or None if not\n              available.\n        \"\"\"\n        volume_index = cs_helper.CSPathSpecGetVolumeIndex(path_spec)\n        if volume_index is None:\n            return None\n        return self._fvde_volume_group.get_logical_volume(volume_index)\n\n    def GetFVDEVolumeGroup(self):\n        \"\"\"Retrieves the Core Storage volume group.\n\n        Returns:\n          pyfvde.volume_group: a Core Storage volume group.\n        \"\"\"\n        return self._fvde_volume_group\n\n    def GetRootFileEntry(self):\n        \"\"\"Retrieves the root file entry.\n\n        Returns:\n          CSFileEntry: root file entry or None if not available.\n        \"\"\"\n        path_spec = cs_path_spec.CSPathSpec(location=self.LOCATION_ROOT, parent=self._path_spec.parent)\n        return self.GetFileEntryByPathSpec(path_spec)\n\nExample skeleton:\n\n\nclass FastRCNNLossComputation(object):\n    '''\n    Computes the loss for Faster R-CNN.\n    Also supports FPN\n    '''\n\n    def __init__(self, proposal_matcher, fg_bg_sampler, box_coder, cls_agnostic_bbox_reg=False):\n        '''\n        Arguments:\n            proposal_matcher (Matcher)\n            fg_bg_sampler (BalancedPositiveNegativeSampler)\n            box_coder (BoxCoder)\n        '''\n        pass\n\n    def match_targets_to_proposals(self, proposal, target):\n        pass\n\n    def prepare_targets(self, proposals, targets):\n        pass\n\n    def subsample(self, proposals, targets):\n        '''\n        This method performs the positive/negative sampling, and return\n        the sampled proposals.\n        Note: this function keeps a state.\n        Arguments:\n            proposals (list[BoxList])\n            targets (list[BoxList])\n        '''\n        pass\n\n    def __call__(self, class_logits, box_regression):\n        '''\n        Computes the loss for Faster R-CNN.\n        This requires that the subsample method has been called beforehand.\n        Arguments:\n            class_logits (list[Tensor])\n            box_regression (list[Tensor])\n        Returns:\n            classification_loss (Tensor)\n            box_loss (Tensor)\n                        '''\n                        pass\nCorresponding class implementation:\n\nfrom maskrcnn_benchmark.modeling.utils import cat\nfrom maskrcnn_benchmark.layers import smooth_l1_loss\nfrom torch.nn import functional as F\nfrom maskrcnn_benchmark.modeling.matcher import Matcher\nfrom maskrcnn_benchmark.structures.boxlist_ops import boxlist_iou\nimport torch\n\nclass FastRCNNLossComputation(object):\n    \"\"\"\n    Computes the loss for Faster R-CNN.\n    Also supports FPN\n    \"\"\"\n\n    def __init__(self, proposal_matcher, fg_bg_sampler, box_coder, cls_agnostic_bbox_reg=False):\n        \"\"\"\n        Arguments:\n            proposal_matcher (Matcher)\n            fg_bg_sampler (BalancedPositiveNegativeSampler)\n            box_coder (BoxCoder)\n        \"\"\"\n        self.proposal_matcher = proposal_matcher\n        self.fg_bg_sampler = fg_bg_sampler\n        self.box_coder = box_coder\n        self.cls_agnostic_bbox_reg = cls_agnostic_bbox_reg\n\n    def match_targets_to_proposals(self, proposal, target):\n        match_quality_matrix = boxlist_iou(target, proposal)\n        matched_idxs = self.proposal_matcher(match_quality_matrix)\n        target = target.copy_with_fields('labels')\n        matched_targets = target[matched_idxs.clamp(min=0)]\n        matched_targets.add_field('matched_idxs', matched_idxs)\n        return matched_targets\n\n    def prepare_targets(self, proposals, targets):\n        labels = []\n        regression_targets = []\n        for proposals_per_image, targets_per_image in zip(proposals, targets):\n            matched_targets = self.match_targets_to_proposals(proposals_per_image, targets_per_image)\n            matched_idxs = matched_targets.get_field('matched_idxs')\n            labels_per_image = matched_targets.get_field('labels')\n            labels_per_image = labels_per_image.to(dtype=torch.int64)\n            bg_inds = matched_idxs == Matcher.BELOW_LOW_THRESHOLD\n            labels_per_image[bg_inds] = 0\n            ignore_inds = matched_idxs == Matcher.BETWEEN_THRESHOLDS\n            labels_per_image[ignore_inds] = -1\n            regression_targets_per_image = self.box_coder.encode(matched_targets.bbox, proposals_per_image.bbox)\n            labels.append(labels_per_image)\n            regression_targets.append(regression_targets_per_image)\n        return (labels, regression_targets)\n\n    def subsample(self, proposals, targets):\n        \"\"\"\n        This method performs the positive/negative sampling, and return\n        the sampled proposals.\n        Note: this function keeps a state.\n\n        Arguments:\n            proposals (list[BoxList])\n            targets (list[BoxList])\n        \"\"\"\n        labels, regression_targets = self.prepare_targets(proposals, targets)\n        sampled_pos_inds, sampled_neg_inds = self.fg_bg_sampler(labels)\n        proposals = list(proposals)\n        for labels_per_image, regression_targets_per_image, proposals_per_image in zip(labels, regression_targets, proposals):\n            proposals_per_image.add_field('labels', labels_per_image)\n            proposals_per_image.add_field('regression_targets', regression_targets_per_image)\n        for img_idx, (pos_inds_img, neg_inds_img) in enumerate(zip(sampled_pos_inds, sampled_neg_inds)):\n            img_sampled_inds = torch.nonzero(pos_inds_img | neg_inds_img).squeeze(1)\n            proposals_per_image = proposals[img_idx][img_sampled_inds]\n            proposals[img_idx] = proposals_per_image\n        self._proposals = proposals\n        return proposals\n\n    def __call__(self, class_logits, box_regression):\n        \"\"\"\n        Computes the loss for Faster R-CNN.\n        This requires that the subsample method has been called beforehand.\n\n        Arguments:\n            class_logits (list[Tensor])\n            box_regression (list[Tensor])\n\n        Returns:\n            classification_loss (Tensor)\n            box_loss (Tensor)\n        \"\"\"\n        class_logits = cat(class_logits, dim=0)\n        box_regression = cat(box_regression, dim=0)\n        device = class_logits.device\n        if not hasattr(self, '_proposals'):\n            raise RuntimeError('subsample needs to be called before')\n        proposals = self._proposals\n        labels = cat([proposal.get_field('labels') for proposal in proposals], dim=0)\n        regression_targets = cat([proposal.get_field('regression_targets') for proposal in proposals], dim=0)\n        classification_loss = F.cross_entropy(class_logits, labels)\n        sampled_pos_inds_subset = torch.nonzero(labels > 0).squeeze(1)\n        labels_pos = labels[sampled_pos_inds_subset]\n        if self.cls_agnostic_bbox_reg:\n            map_inds = torch.tensor([4, 5, 6, 7], device=device)\n        else:\n            map_inds = 4 * labels_pos[:, None] + torch.tensor([0, 1, 2, 3], device=device)\n        box_loss = smooth_l1_loss(box_regression[sampled_pos_inds_subset[:, None], map_inds], regression_targets[sampled_pos_inds_subset], size_average=False, beta=1)\n        box_loss = box_loss / labels.numel()\n        return (classification_loss, box_loss)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass FFTComplexScipyFFTpack:\n    '''\n    Initial implementation of fft_cmplx_scipy_fftpack task.\n    This will be evolved by OpenEvolve to improve performance and correctness.\n    '''\n\n    def __init__(self):\n        '''Initialize the FFTComplexScipyFFTpack.'''\n        pass\n\n    def solve(self, problem):\n        '''\n        Solve the fft_cmplx_scipy_fftpack problem.\n        Args:\n            problem: Dictionary containing problem data specific to fft_cmplx_scipy_fftpack\n        Returns:\n            The solution in the format expected by the task\n        '''\n        pass\n\n    def is_solution(self, problem, solution):\n        '''\n        Check if the provided solution is valid.\n        Args:\n            problem: The original problem\n            solution: The proposed solution\n        Returns:\n            True if the solution is valid, False otherwise\n        '''\n        pass"
  }
]