[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass UserSource(Source):\n    '''\n    UserSource\n    '''\n\n    class Config:\n        '''Pydantic configuration'''\n\n    def to_str(self) -> str:\n        '''Returns the string representation of the model using alias'''\n        pass\n\n    def to_json(self) -> str:\n        '''Returns the JSON representation of the model using alias'''\n        pass\n    @classmethod\n    def from_json(cls, json_str: str) -> UserSource:\n        '''Create an instance of UserSource from a JSON string'''\n        pass\n\n    def to_dict(self):\n        '''Returns the dictionary representation of the model using alias'''\n        pass\n    @classmethod\n    def from_dict(cls, obj: dict) -> UserSource:\n        '''Create an instance of UserSource from a dict'''\n        pass\nCorresponding class implementation:\n\nfrom pydantic.v1 import Field, StrictStr\nimport pprint\nfrom typing import Optional\nimport json\nfrom linebot.v3.webhooks.models.source import Source\n\nclass UserSource(Source):\n    \"\"\"\n    UserSource\n    \"\"\"\n    user_id: Optional[StrictStr] = Field(None, alias='userId', description='ID of the source user')\n    type: str = 'user'\n    __properties = ['type', 'userId']\n\n    class Config:\n        \"\"\"Pydantic configuration\"\"\"\n        allow_population_by_field_name = True\n        validate_assignment = True\n\n    def to_str(self) -> str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.dict(by_alias=True))\n\n    def to_json(self) -> str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -> UserSource:\n        \"\"\"Create an instance of UserSource from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self):\n        \"\"\"Returns the dictionary representation of the model using alias\"\"\"\n        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict) -> UserSource:\n        \"\"\"Create an instance of UserSource from a dict\"\"\"\n        if obj is None:\n            return None\n        if not isinstance(obj, dict):\n            return UserSource.parse_obj(obj)\n        _obj = UserSource.parse_obj({'type': obj.get('type'), 'user_id': obj.get('userId')})\n        return _obj\n\nExample skeleton:\n\n\nclass QuickReplyItem(BaseModel):\n    '''\n    QuickReplyItem\n    https://developers.line.biz/en/reference/messaging-api/#items-object\n    '''\n\n    class Config:\n        '''Pydantic configuration'''\n\n    def to_str(self) -> str:\n        '''Returns the string representation of the model using alias'''\n        pass\n\n    def to_json(self) -> str:\n        '''Returns the JSON representation of the model using alias'''\n        pass\n    @classmethod\n    def from_json(cls, json_str: str) -> QuickReplyItem:\n        '''Create an instance of QuickReplyItem from a JSON string'''\n        pass\n\n    def to_dict(self):\n        '''Returns the dictionary representation of the model using alias'''\n        pass\n    @classmethod\n    def from_dict(cls, obj: dict) -> QuickReplyItem:\n        '''Create an instance of QuickReplyItem from a dict'''\n        pass\nCorresponding class implementation:\n\nfrom pydantic.v1 import BaseModel, Field, StrictStr, constr\nimport pprint\nimport json\nfrom typing import Optional\nfrom linebot.v3.messaging.models.action import Action\n\nclass QuickReplyItem(BaseModel):\n    \"\"\"\n    QuickReplyItem\n    https://developers.line.biz/en/reference/messaging-api/#items-object\n    \"\"\"\n    image_url: Optional[constr(strict=True, max_length=2000)] = Field(None, alias='imageUrl', description='URL of the icon that is displayed at the beginning of the button')\n    action: Optional[Action] = None\n    type: Optional[StrictStr] = Field('action', description='`action`')\n    __properties = ['imageUrl', 'action', 'type']\n\n    class Config:\n        \"\"\"Pydantic configuration\"\"\"\n        allow_population_by_field_name = True\n        validate_assignment = True\n\n    def to_str(self) -> str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.dict(by_alias=True))\n\n    def to_json(self) -> str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -> QuickReplyItem:\n        \"\"\"Create an instance of QuickReplyItem from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self):\n        \"\"\"Returns the dictionary representation of the model using alias\"\"\"\n        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)\n        if self.action:\n            _dict['action'] = self.action.to_dict()\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict) -> QuickReplyItem:\n        \"\"\"Create an instance of QuickReplyItem from a dict\"\"\"\n        if obj is None:\n            return None\n        if not isinstance(obj, dict):\n            return QuickReplyItem.parse_obj(obj)\n        _obj = QuickReplyItem.parse_obj({'image_url': obj.get('imageUrl'), 'action': Action.from_dict(obj.get('action')) if obj.get('action') is not None else None, 'type': obj.get('type') if obj.get('type') is not None else 'action'})\n        return _obj\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n@dataclass\nclass SuperChatRecord:\n    '''SuperChat记录数据类'''\n\n    def is_expired(self) -> bool:\n        '''检查SuperChat是否已过期'''\n        pass\n\n    def remaining_time(self) -> float:\n        '''获取剩余时间（秒）'''\n        pass\n\n    def to_dict(self) -> dict:\n        '''转换为字典格式'''\n        pass"
  }
]