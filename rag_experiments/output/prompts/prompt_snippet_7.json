[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Request(Generic[sanic_type, ctx_type]):\n    '''State of HTTP request.\n    Args:\n        url_bytes (bytes): Raw URL bytes.\n        headers (Header): Request headers.\n        version (str): HTTP version.\n        method (str): HTTP method.\n        transport (TransportProtocol): Transport protocol.\n        app (Sanic): Sanic instance.\n        head (bytes, optional): Request head. Defaults to `b\"\"`.\n        stream_id (int, optional): HTTP/3 stream ID. Defaults to `0`.\n    '''\n\n    def __init__(self, url_bytes: bytes, headers: Header, version: str, method: str, transport: TransportProtocol, app: sanic_type, head: bytes=b'', stream_id: int=0):\n        pass\n\n    def __repr__(self):\n        pass\n    @staticmethod\n    def make_context() -> ctx_type:\n        '''Create a new context object.\n        This method is called when a new request context is pushed. It is\n        a great candidate for overriding in a subclass if you want to\n        control the type of context object that is created.\n        By default, it returns a `types.SimpleNamespace` instance.\n        Returns:\n            ctx_type: A new context object.\n        '''\n        pass\n    @classmethod\n    def get_current(cls) -> Request:\n        '''Retrieve the current request object\n        This implements [Context Variables](https://docs.python.org/3/library/contextvars.html)\n        to allow for accessing the current request from anywhere.\n        A typical usecase is when you want to access the current request\n        from a function that is not a handler, such as a logging function:\n        ```python\n        import logging\n        class LoggingFormater(logging.Formatter):\n            def format(self, record):\n                request = Request.get_current()\n                record.url = request.url\n                record.ip = request.ip\n                return super().format(record)\n        ```\n        Returns:\n            Request: The current request object\n        Raises:\n            sanic.exceptions.ServerError: If it is outside of a request\n                lifecycle.\n                        '''\n                        pass\n    @classmethod\n    def generate_id(*_) -> Union[uuid.UUID, str, int]:\n        '''Generate a unique ID for the request.\n        This method is called to generate a unique ID for each request.\n        By default, it returns a `uuid.UUID` instance.\n        Returns:\n            Union[uuid.UUID, str, int]: A unique ID for the request.\n        '''\n        pass\n    @property\n    def ctx(self) -> ctx_type:\n        '''The current request context.\n        This is a context object for the current request. It is created\n        by `Request.make_context` and is a great place to store data\n        that you want to be accessible during the request lifecycle.\n        Returns:\n            ctx_type: The current request context.\n        '''\n        pass\n    @property\n    def stream_id(self) -> int:\n        '''Access the HTTP/3 stream ID.\n        Raises:\n            sanic.exceptions.ServerError: If the request is not HTTP/3.\n        Returns:\n            int: The HTTP/3 stream ID.\n        '''\n        pass\n\n    def reset_response(self) -> None:\n        '''Reset the response object.\n        This clears much of the state of the object. It should\n        generally not be called directly, but is called automatically as\n        part of the request lifecycle.\n        Raises:\n            sanic.exceptions.ServerError: If the response has already been\n                sent.\n        '''\n        pass\n\n    async def respond(self, response: Optional[BaseHTTPResponse]=None, *, status: int=200, headers: Optional[Union[Header, dict[str, str]]]=None, content_type: Optional[str]=None):\n        '''Respond to the request without returning.\n        This method can only be called once, as you can only respond once.\n        If no ``response`` argument is passed, one will be created from the\n        ``status``, ``headers`` and ``content_type`` arguments.\n        **The first typical usecase** is if you wish to respond to the\n        request without returning from the handler:\n        ```python\n        @app.get(\"/\")\n        async def handler(request: Request):\n            data = ...  # Process something\n            json_response = json({\"data\": data})\n            await request.respond(json_response)\n        @app.on_response\n        async def add_header(_, response: HTTPResponse):\n            # Middlewares still get executed as expected\n            response.headers[\"one\"] = \"two\"\n        ```\n        **The second possible usecase** is for when you want to directly\n        respond to the request:\n        ```python\n        response = await request.respond(content_type=\"text/csv\")\n        await response.send(\"foo,\")\n        await response.send(\"bar\")\n        # You can control the completion of the response by calling\n        # the 'eof()' method:\n        await response.eof()\n        ```\n        Args:\n            response (ResponseType): Response instance to send.\n            status (int): Status code to return in the response.\n            headers (Optional[Dict[str, str]]): Headers to return in the response, defaults to None.\n            content_type (Optional[str]): Content-Type header of the response, defaults to None.\n        Returns:\n            FinalResponseType: Final response being sent (may be different from the\n                \"response\" parameter because of middlewares), which can be\n                used to manually send data.\n        '''\n        pass\n\n    async def receive_body(self):\n        '''Receive request.body, if not already received.\n        Streaming handlers may call this to receive the full body. Sanic calls\n        this function before running any handlers of non-streaming routes.\n        Custom request classes can override this for custom handling of both\n        streaming and non-streaming routes.\n        '''\n        pass\n    @property\n    def name(self) -> Optional[str]:\n        '''The route name\n        In the following pattern:\n        ```\n        <AppName>.[<BlueprintName>.]<HandlerName>\n        ```\n        Returns:\n            Optional[str]: The route name\n        '''\n        pass\n    @property\n    def endpoint(self) -> Optional[str]:\n        '''Alias of `sanic.request.Request.name`\n        Returns:\n            Optional[str]: The route name\n        '''\n        pass\n    @property\n    def uri_template(self) -> Optional[str]:\n        '''The defined URI template\n        Returns:\n            Optional[str]: The defined URI template\n        '''\n        pass\n    @property\n    def protocol(self) -> TransportProtocol:\n        '''The HTTP protocol instance\n        Returns:\n            Protocol: The HTTP protocol instance\n        '''\n        pass\n    @property\n    def raw_headers(self) -> bytes:\n        '''The unparsed HTTP headers\n        Returns:\n            bytes: The unparsed HTTP headers\n        '''\n        pass\n    @property\n    def request_line(self) -> bytes:\n        '''The first line of a HTTP request\n        Returns:\n            bytes: The first line of a HTTP request\n        '''\n        pass\n    @property\n    def id(self) -> Optional[Union[uuid.UUID, str, int]]:\n        '''A request ID passed from the client, or generated from the backend.\n        By default, this will look in a request header defined at:\n        `self.app.config.REQUEST_ID_HEADER`. It defaults to\n        `X-Request-ID`. Sanic will try to cast the ID into a `UUID` or an\n        `int`.\n        If there is not a UUID from the client, then Sanic will try\n        to generate an ID by calling `Request.generate_id()`. The default\n        behavior is to generate a `UUID`. You can customize this behavior\n        by subclassing `Request` and overwriting that method.\n        ```python\n        from sanic import Request, Sanic\n        from itertools import count\n        class IntRequest(Request):\n            counter = count()\n            def generate_id(self):\n                return next(self.counter)\n        app = Sanic(\"MyApp\", request_class=IntRequest)\n        ```\n        Returns:\n            Optional[Union[uuid.UUID, str, int]]: A request ID passed from the\n                client, or generated from the backend.\n                        '''\n                        pass\n    @property\n    def json(self) -> Any:\n        '''The request body parsed as JSON\n        Returns:\n            Any: The request body parsed as JSON\n        '''\n        pass\n\n    def load_json(self, loads=None) -> Any:\n        '''Load the request body as JSON\n        Args:\n            loads (Callable, optional): A custom JSON loader. Defaults to None.\n        Raises:\n            BadRequest: If the request body cannot be parsed as JSON\n        Returns:\n            Any: The request body parsed as JSON\n        '''\n        pass\n    @property\n    def accept(self) -> AcceptList:\n        '''Accepted response content types.\n        A convenience handler for easier RFC-compliant matching of MIME types,\n        parsed as a list that can match wildcards and includes */* by default.\n        Returns:\n            AcceptList: Accepted response content types\n        '''\n        pass\n    @property\n    def token(self) -> Optional[str]:\n        '''Attempt to return the auth header token.\n        Returns:\n            Optional[str]: The auth header token\n        '''\n        pass\n    @property\n    def credentials(self) -> Optional[Credentials]:\n        '''Attempt to return the auth header value.\n        Covers NoAuth, Basic Auth, Bearer Token, Api Token authentication\n        schemas.\n        Returns:\n            Optional[Credentials]: A Credentials object with token, or username\n                and password related to the request\n        '''\n        pass\n\n    def get_form(self, keep_blank_values: bool=False) -> Optional[RequestParameters]:\n        '''Method to extract and parse the form data from a request.\n        Args:\n            keep_blank_values (bool): Whether to discard blank values from the form data.\n        Returns:\n            Optional[RequestParameters]: The parsed form data.\n        '''\n        pass\n            @property\n            def format(self, record):\n                '''The request body parsed as form data\n        Returns:\n            Optional[RequestParameters]: The request body parsed as form data\n                        '''\n                        pass\n    @property\n    def files(self) -> Optional[RequestParameters]:\n        '''The request body parsed as uploaded files\n        Returns:\n            Optional[RequestParameters]: The request body parsed as uploaded files\n        '''\n        pass\n\n    def get_args(self, keep_blank_values: bool=False, strict_parsing: bool=False, encoding: str='utf-8', errors: str='replace') -> RequestParameters:\n        '''Parse `query_string` using `urllib.parse.parse_qs`.\n        This methods is used by the `args` property, but it also\n        can be used directly if you need to change default parameters.\n        Args:\n            keep_blank_values (bool): Flag indicating whether blank values in\n                percent-encoded queries should be treated as blank strings.\n                A `True` value indicates that blanks should be retained as\n                blank strings. The default `False` value indicates that\n                blank values are to be ignored and treated as if they were\n                not included.\n            strict_parsing (bool): Flag indicating what to do with parsing\n                errors. If `False` (the default), errors are silently ignored.\n                If `True`, errors raise a `ValueError` exception.\n            encoding (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n            errors (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n        Returns:\n            RequestParameters: A dictionary containing the parsed arguments.\n        '''\n        pass\n\n    def get_query_args(self, keep_blank_values: bool=False, strict_parsing: bool=False, encoding: str='utf-8', errors: str='replace') -> list:\n        '''Parse `query_string` using `urllib.parse.parse_qsl`.\n        This methods is used by `query_args` propertyn but can be used\n        directly if you need to change default parameters.\n        Args:\n            keep_blank_values (bool): Flag indicating whether blank values in\n                percent-encoded queries should be treated as blank strings.\n                A `True` value indicates that blanks should be retained as\n                blank strings. The default `False` value indicates that\n                blank values are to be ignored and treated as if they were\n                not included.\n            strict_parsing (bool): Flag indicating what to do with\n                parsing errors. If `False` (the default), errors are\n                silently ignored. If `True`, errors raise a\n                `ValueError` exception.\n            encoding (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n            errors (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n        Returns:\n            list: A list of tuples containing the parsed arguments.\n        '''\n        pass\n\n    def get_cookies(self) -> RequestParameters:\n        pass\n    @property\n    def cookies(self) -> RequestParameters:\n        '''Incoming cookies on the request\n        Returns:\n            RequestParameters: Incoming cookies on the request\n        '''\n        pass\n    @property\n    def content_type(self) -> str:\n        '''Content-Type header form the request\n        Returns:\n            str: Content-Type header form the request\n        '''\n        pass\n    @property\n    def match_info(self) -> dict[str, Any]:\n        '''Matched path parameters after resolving route\n        Returns:\n            Dict[str, Any]: Matched path parameters after resolving route\n        '''\n        pass\n    @match_info.setter\n    def match_info(self) -> dict[str, Any]:\n        pass\n    @property\n    def ip(self) -> str:\n        '''Peer ip of the socket\n        Returns:\n            str: Peer ip of the socket\n        '''\n        pass\n    @property\n    def port(self) -> int:\n        '''Peer port of the socket\n        Returns:\n            int: Peer port of the socket\n        '''\n        pass\n    @property\n    def socket(self) -> Union[tuple[str, int], tuple[None, None]]:\n        '''Information about the connected socket if available\n        Returns:\n            Tuple[Optional[str], Optional[int]]: Information about the\n                connected socket if available, in the form of a tuple of\n                (ip, port)\n        '''\n        pass\n    @property\n    def path(self) -> str:\n        '''Path of the local HTTP request\n        Returns:\n            str: Path of the local HTTP request\n        '''\n        pass\n    @property\n    def network_paths(self) -> Optional[list[Any]]:\n        '''Access the network paths if available\n        Returns:\n            Optional[List[Any]]: Access the network paths if available\n        '''\n        pass\n    @property\n    def forwarded(self) -> Options:\n        '''Active proxy information obtained from request headers, as specified in Sanic configuration.\n        Field names by, for, proto, host, port and path are normalized.\n        - for and by IPv6 addresses are bracketed\n        - port (int) is only set by port headers, not from host.\n        - path is url-unencoded\n        Additional values may be available from new style Forwarded headers.\n        Returns:\n            Options: proxy information from request headers\n        '''\n        pass\n    @property\n    def remote_addr(self) -> str:\n        '''Client IP address, if available from proxy.\n        Returns:\n            str: IPv4, bracketed IPv6, UNIX socket name or arbitrary string\n        '''\n        pass\n    @property\n    def client_ip(self) -> str:\n        '''\n        Client IP address.\n        1. proxied remote address `self.forwarded['for']`\n        2. local peer address `self.ip`\n        New in Sanic 23.6. Prefer this over `remote_addr` for determining the\n        client address regardless of whether the service runs behind a proxy\n        or not (proxy deployment needs separate configuration).\n        Returns:\n            str: IPv4, bracketed IPv6, UNIX socket name or arbitrary string\n        '''\n        pass\n    @property\n    def scheme(self) -> str:\n        '''Determine request scheme.\n        1. `config.SERVER_NAME` if in full URL format\n        2. proxied proto/scheme\n        3. local connection protocol\n        Returns:\n            str: http|https|ws|wss or arbitrary value given by the headers.\n        '''\n        pass\n    @property\n    def host(self) -> str:\n        '''The currently effective server 'host' (hostname or hostname:port).\n        1. `config.SERVER_NAME` overrides any client headers\n        2. proxied host of original request\n        3. request host header\n        hostname and port may be separated by\n        `sanic.headers.parse_host(request.host)`.\n        Returns:\n            str: the first matching host found, or empty string\n        '''\n        pass\n    @property\n    def server_name(self) -> str:\n        '''hostname the client connected to, by `request.host`\n        Returns:\n            str: hostname the client connected to, by `request.host`\n        '''\n        pass\n    @property\n    def server_port(self) -> int:\n        '''The port the client connected to, by forwarded `port` or `request.host`.\n        Default port is returned as 80 and 443 based on `request.scheme`.\n        Returns:\n            int: The port the client connected to, by forwarded `port` or `request.host`.\n        '''\n        pass\n    @property\n    def server_path(self) -> str:\n        '''Full path of current URL; uses proxied or local path\n        Returns:\n            str: Full path of current URL; uses proxied or local path\n        '''\n        pass\n    @property\n    def query_string(self) -> str:\n        '''Representation of the requested query\n        Returns:\n            str: Representation of the requested query\n        '''\n        pass\n    @property\n    def url(self) -> str:\n        '''The URL\n        Returns:\n            str: The URL\n        '''\n        pass\n\n    def url_for(self, view_name: str, **kwargs) -> str:\n        '''Retrieve a URL for a given view name.\n        Same as `sanic.Sanic.url_for`, but automatically determine `scheme`\n        and `netloc` base on the request. Since this method is aiming\n        to generate correct schema & netloc, `_external` is implied.\n        Args:\n            view_name (str): The view name to generate URL for.\n            **kwargs: Arbitrary keyword arguments to build URL query string.\n        Returns:\n            str: The generated URL.\n        '''\n        pass\n    @property\n    def scope(self) -> ASGIScope:\n        '''The ASGI scope of the request.\n        Returns:\n            ASGIScope: The ASGI scope of the request.\n        Raises:\n            NotImplementedError: If the app isn't an ASGI app.\n        '''\n        pass\n    @property\n    def is_safe(self) -> bool:\n        '''Whether the HTTP method is safe.\n        See https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.1\n        Returns:\n            bool: Whether the HTTP method is safe.\n        '''\n        pass\n    @property\n    def is_idempotent(self) -> bool:\n        '''Whether the HTTP method is iempotent.\n        See https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.2\n        Returns:\n            bool: Whether the HTTP method is iempotent.\n        '''\n        pass\n    @property\n    def is_cacheable(self) -> bool:\n        '''Whether the HTTP method is cacheable.\n        See https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.3\n        Returns:\n            bool: Whether the HTTP method is cacheable.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom types import SimpleNamespace\nfrom inspect import isawaitable\nfrom sanic.headers import AcceptList, Options, parse_accept, parse_content_header, parse_credentials, parse_forwarded, parse_host, parse_xforwarded\nfrom sanic_routing.route import Route\nimport uuid\nfrom sanic.models.asgi import ASGIScope\nfrom sanic.exceptions import BadRequest, BadURL, ServerError\nfrom .form import parse_multipart_form\nfrom sanic.http import Stage\nfrom sanic.cookies.request import CookieRequestParameters, parse_cookie\nfrom urllib.parse import parse_qs, parse_qsl, urlunparse\nfrom sanic.http.stream import Stream\nfrom httptools.parser.errors import HttpParserInvalidURLError\nfrom httptools import parse_url\nfrom contextvars import ContextVar\nfrom .parameters import RequestParameters\nfrom sanic.constants import CACHEABLE_HTTP_METHODS, DEFAULT_HTTP_CONTENT_TYPE, IDEMPOTENT_HTTP_METHODS, SAFE_HTTP_METHODS\nfrom sanic.compat import CancelledErrors, Header\nfrom sanic.models.http_types import Credentials\nfrom sanic.models.protocol_types import TransportProtocol\nfrom sanic.log import error_logger\nfrom sanic.http.constants import HTTP\nfrom sanic.response import BaseHTTPResponse, HTTPResponse\nfrom asyncio import BaseProtocol\nfrom collections import defaultdict\nfrom typing import TYPE_CHECKING, Any, DefaultDict, Generic, Optional, Union, cast\n\nclass Request(Generic[sanic_type, ctx_type]):\n    \"\"\"State of HTTP request.\n\n    Args:\n        url_bytes (bytes): Raw URL bytes.\n        headers (Header): Request headers.\n        version (str): HTTP version.\n        method (str): HTTP method.\n        transport (TransportProtocol): Transport protocol.\n        app (Sanic): Sanic instance.\n        head (bytes, optional): Request head. Defaults to `b\"\"`.\n        stream_id (int, optional): HTTP/3 stream ID. Defaults to `0`.\n    \"\"\"\n    _current: ContextVar[Request] = ContextVar('request')\n    _loads = json_loads\n    __slots__ = ('__weakref__', '_cookies', '_ctx', '_id', '_ip', '_parsed_url', '_port', '_protocol', '_remote_addr', '_request_middleware_started', '_response_middleware_started', '_scheme', '_socket', '_stream_id', '_match_info', '_name', 'app', 'body', 'conn_info', 'head', 'headers', 'method', 'parsed_accept', 'parsed_args', 'parsed_cookies', 'parsed_credentials', 'parsed_files', 'parsed_form', 'parsed_forwarded', 'parsed_json', 'parsed_not_grouped_args', 'parsed_token', 'raw_url', 'responded', 'route', 'stream', 'transport', 'version')\n\n    def __init__(self, url_bytes: bytes, headers: Header, version: str, method: str, transport: TransportProtocol, app: sanic_type, head: bytes=b'', stream_id: int=0):\n        self.raw_url = url_bytes\n        try:\n            self._parsed_url = parse_url(url_bytes)\n        except HttpParserInvalidURLError:\n            url = url_bytes.decode(errors='backslashreplace')\n            raise BadURL(f'Bad URL: {url}')\n        self._id: Optional[Union[uuid.UUID, str, int]] = None\n        self._name: Optional[str] = None\n        self._stream_id = stream_id\n        self.app = app\n        self.headers = Header(headers)\n        self.version = version\n        self.method = method\n        self.transport = transport\n        self.head = head\n        self.body = b''\n        self.conn_info: Optional[ConnInfo] = None\n        self._ctx: Optional[ctx_type] = None\n        self.parsed_accept: Optional[AcceptList] = None\n        self.parsed_args: DefaultDict[tuple[bool, bool, str, str], RequestParameters] = defaultdict(RequestParameters)\n        self.parsed_cookies: Optional[RequestParameters] = None\n        self.parsed_credentials: Optional[Credentials] = None\n        self.parsed_files: Optional[RequestParameters] = None\n        self.parsed_form: Optional[RequestParameters] = None\n        self.parsed_forwarded: Optional[Options] = None\n        self.parsed_json = None\n        self.parsed_not_grouped_args: DefaultDict[tuple[bool, bool, str, str], list[tuple[str, str]]] = defaultdict(list)\n        self.parsed_token: Optional[str] = None\n        self._request_middleware_started = False\n        self._response_middleware_started = False\n        self.responded: bool = False\n        self.route: Optional[Route] = None\n        self.stream: Optional[Stream] = None\n        self._match_info: dict[str, Any] = {}\n        self._protocol: Optional[BaseProtocol] = None\n\n    def __repr__(self):\n        class_name = self.__class__.__name__\n        return f'<{class_name}: {self.method} {self.path}>'\n\n    @staticmethod\n    def make_context() -> ctx_type:\n        \"\"\"Create a new context object.\n\n        This method is called when a new request context is pushed. It is\n        a great candidate for overriding in a subclass if you want to\n        control the type of context object that is created.\n\n        By default, it returns a `types.SimpleNamespace` instance.\n\n        Returns:\n            ctx_type: A new context object.\n        \"\"\"\n        return cast(ctx_type, SimpleNamespace())\n\n    @classmethod\n    def get_current(cls) -> Request:\n        \"\"\"Retrieve the current request object\n\n        This implements [Context Variables](https://docs.python.org/3/library/contextvars.html)\n        to allow for accessing the current request from anywhere.\n\n        A typical usecase is when you want to access the current request\n        from a function that is not a handler, such as a logging function:\n\n        ```python\n        import logging\n\n        class LoggingFormater(logging.Formatter):\n            def format(self, record):\n                request = Request.get_current()\n                record.url = request.url\n                record.ip = request.ip\n                return super().format(record)\n        ```\n\n        Returns:\n            Request: The current request object\n\n        Raises:\n            sanic.exceptions.ServerError: If it is outside of a request\n                lifecycle.\n        \"\"\"\n        request = cls._current.get(None)\n        if not request:\n            raise ServerError('No current request')\n        return request\n\n    @classmethod\n    def generate_id(*_) -> Union[uuid.UUID, str, int]:\n        \"\"\"Generate a unique ID for the request.\n\n        This method is called to generate a unique ID for each request.\n        By default, it returns a `uuid.UUID` instance.\n\n        Returns:\n            Union[uuid.UUID, str, int]: A unique ID for the request.\n        \"\"\"\n        return uuid.uuid4()\n\n    @property\n    def ctx(self) -> ctx_type:\n        \"\"\"The current request context.\n\n        This is a context object for the current request. It is created\n        by `Request.make_context` and is a great place to store data\n        that you want to be accessible during the request lifecycle.\n\n        Returns:\n            ctx_type: The current request context.\n        \"\"\"\n        if not self._ctx:\n            self._ctx = self.make_context()\n        return self._ctx\n\n    @property\n    def stream_id(self) -> int:\n        \"\"\"Access the HTTP/3 stream ID.\n\n        Raises:\n            sanic.exceptions.ServerError: If the request is not HTTP/3.\n\n        Returns:\n            int: The HTTP/3 stream ID.\n        \"\"\"\n        if self.protocol.version is not HTTP.VERSION_3:\n            raise ServerError('Stream ID is only a property of a HTTP/3 request')\n        return self._stream_id\n\n    def reset_response(self) -> None:\n        \"\"\"Reset the response object.\n\n        This clears much of the state of the object. It should\n        generally not be called directly, but is called automatically as\n        part of the request lifecycle.\n\n        Raises:\n            sanic.exceptions.ServerError: If the response has already been\n                sent.\n        \"\"\"\n        try:\n            if self.stream is not None and self.stream.stage is not Stage.HANDLER:\n                raise ServerError('Cannot reset response because previous response was sent.')\n            self.stream.response.stream = None\n            self.stream.response = None\n            self.responded = False\n        except AttributeError:\n            pass\n\n    async def respond(self, response: Optional[BaseHTTPResponse]=None, *, status: int=200, headers: Optional[Union[Header, dict[str, str]]]=None, content_type: Optional[str]=None):\n        \"\"\"Respond to the request without returning.\n\n        This method can only be called once, as you can only respond once.\n        If no ``response`` argument is passed, one will be created from the\n        ``status``, ``headers`` and ``content_type`` arguments.\n\n        **The first typical usecase** is if you wish to respond to the\n        request without returning from the handler:\n\n        ```python\n        @app.get(\"/\")\n        async def handler(request: Request):\n            data = ...  # Process something\n\n            json_response = json({\"data\": data})\n            await request.respond(json_response)\n\n        @app.on_response\n        async def add_header(_, response: HTTPResponse):\n            # Middlewares still get executed as expected\n            response.headers[\"one\"] = \"two\"\n        ```\n\n        **The second possible usecase** is for when you want to directly\n        respond to the request:\n\n        ```python\n        response = await request.respond(content_type=\"text/csv\")\n        await response.send(\"foo,\")\n        await response.send(\"bar\")\n\n        # You can control the completion of the response by calling\n        # the 'eof()' method:\n        await response.eof()\n        ```\n\n        Args:\n            response (ResponseType): Response instance to send.\n            status (int): Status code to return in the response.\n            headers (Optional[Dict[str, str]]): Headers to return in the response, defaults to None.\n            content_type (Optional[str]): Content-Type header of the response, defaults to None.\n\n        Returns:\n            FinalResponseType: Final response being sent (may be different from the\n                \"response\" parameter because of middlewares), which can be\n                used to manually send data.\n        \"\"\"\n        try:\n            if self.stream is not None and self.stream.response:\n                raise ServerError('Second respond call is not allowed.')\n        except AttributeError:\n            pass\n        if response is None:\n            response = HTTPResponse(status=status, headers=headers, content_type=content_type)\n        if isinstance(response, BaseHTTPResponse) and self.stream:\n            response = self.stream.respond(response)\n            if isawaitable(response):\n                response = await response\n        try:\n            middleware = self.route and self.route.extra.response_middleware or self.app.response_middleware\n            if middleware and (not self._response_middleware_started):\n                self._response_middleware_started = True\n                response = await self.app._run_response_middleware(self, response, middleware)\n        except CancelledErrors:\n            raise\n        except Exception:\n            error_logger.exception('Exception occurred in one of response middleware handlers')\n        self.responded = True\n        return response\n\n    async def receive_body(self):\n        \"\"\"Receive request.body, if not already received.\n\n        Streaming handlers may call this to receive the full body. Sanic calls\n        this function before running any handlers of non-streaming routes.\n\n        Custom request classes can override this for custom handling of both\n        streaming and non-streaming routes.\n        \"\"\"\n        if not self.body:\n            self.body = b''.join([data async for data in self.stream])\n\n    @property\n    def name(self) -> Optional[str]:\n        \"\"\"The route name\n\n        In the following pattern:\n\n        ```\n        <AppName>.[<BlueprintName>.]<HandlerName>\n        ```\n\n        Returns:\n            Optional[str]: The route name\n        \"\"\"\n        if self._name:\n            return self._name\n        elif self.route:\n            return self.route.name\n        return None\n\n    @property\n    def endpoint(self) -> Optional[str]:\n        \"\"\"Alias of `sanic.request.Request.name`\n\n        Returns:\n            Optional[str]: The route name\n        \"\"\"\n        return self.name\n\n    @property\n    def uri_template(self) -> Optional[str]:\n        \"\"\"The defined URI template\n\n        Returns:\n            Optional[str]: The defined URI template\n        \"\"\"\n        if self.route:\n            return f'/{self.route.path}'\n        return None\n\n    @property\n    def protocol(self) -> TransportProtocol:\n        \"\"\"The HTTP protocol instance\n\n        Returns:\n            Protocol: The HTTP protocol instance\n        \"\"\"\n        if not self._protocol:\n            self._protocol = self.transport.get_protocol()\n        return self._protocol\n\n    @property\n    def raw_headers(self) -> bytes:\n        \"\"\"The unparsed HTTP headers\n\n        Returns:\n            bytes: The unparsed HTTP headers\n        \"\"\"\n        _, headers = self.head.split(b'\\r\\n', 1)\n        return bytes(headers)\n\n    @property\n    def request_line(self) -> bytes:\n        \"\"\"The first line of a HTTP request\n\n        Returns:\n            bytes: The first line of a HTTP request\n        \"\"\"\n        reqline, _ = self.head.split(b'\\r\\n', 1)\n        return bytes(reqline)\n\n    @property\n    def id(self) -> Optional[Union[uuid.UUID, str, int]]:\n        \"\"\"A request ID passed from the client, or generated from the backend.\n\n        By default, this will look in a request header defined at:\n        `self.app.config.REQUEST_ID_HEADER`. It defaults to\n        `X-Request-ID`. Sanic will try to cast the ID into a `UUID` or an\n        `int`.\n\n        If there is not a UUID from the client, then Sanic will try\n        to generate an ID by calling `Request.generate_id()`. The default\n        behavior is to generate a `UUID`. You can customize this behavior\n        by subclassing `Request` and overwriting that method.\n\n        ```python\n        from sanic import Request, Sanic\n        from itertools import count\n\n        class IntRequest(Request):\n            counter = count()\n\n            def generate_id(self):\n                return next(self.counter)\n\n        app = Sanic(\"MyApp\", request_class=IntRequest)\n        ```\n\n        Returns:\n            Optional[Union[uuid.UUID, str, int]]: A request ID passed from the\n                client, or generated from the backend.\n        \"\"\"\n        if not self._id:\n            self._id = self.headers.getone(self.app.config.REQUEST_ID_HEADER, self.__class__.generate_id(self))\n            if isinstance(self._id, str):\n                try:\n                    self._id = uuid.UUID(self._id)\n                except ValueError:\n                    try:\n                        self._id = int(self._id)\n                    except ValueError:\n                        ...\n        return self._id\n\n    @property\n    def json(self) -> Any:\n        \"\"\"The request body parsed as JSON\n\n        Returns:\n            Any: The request body parsed as JSON\n        \"\"\"\n        if self.parsed_json is None:\n            self.load_json()\n        return self.parsed_json\n\n    def load_json(self, loads=None) -> Any:\n        \"\"\"Load the request body as JSON\n\n        Args:\n            loads (Callable, optional): A custom JSON loader. Defaults to None.\n\n        Raises:\n            BadRequest: If the request body cannot be parsed as JSON\n\n        Returns:\n            Any: The request body parsed as JSON\n        \"\"\"\n        try:\n            if not loads:\n                loads = self.__class__._loads\n            self.parsed_json = loads(self.body)\n        except Exception:\n            if not self.body:\n                return None\n            raise BadRequest('Failed when parsing body as json')\n        return self.parsed_json\n\n    @property\n    def accept(self) -> AcceptList:\n        \"\"\"Accepted response content types.\n\n        A convenience handler for easier RFC-compliant matching of MIME types,\n        parsed as a list that can match wildcards and includes */* by default.\n\n        Returns:\n            AcceptList: Accepted response content types\n        \"\"\"\n        if self.parsed_accept is None:\n            self.parsed_accept = parse_accept(self.headers.get('accept'))\n        return self.parsed_accept\n\n    @property\n    def token(self) -> Optional[str]:\n        \"\"\"Attempt to return the auth header token.\n\n        Returns:\n            Optional[str]: The auth header token\n        \"\"\"\n        if self.parsed_token is None:\n            prefixes = ('Bearer', 'Token')\n            _, token = parse_credentials(self.headers.getone('authorization', None), prefixes)\n            self.parsed_token = token\n        return self.parsed_token\n\n    @property\n    def credentials(self) -> Optional[Credentials]:\n        \"\"\"Attempt to return the auth header value.\n\n        Covers NoAuth, Basic Auth, Bearer Token, Api Token authentication\n        schemas.\n\n        Returns:\n            Optional[Credentials]: A Credentials object with token, or username\n                and password related to the request\n        \"\"\"\n        if self.parsed_credentials is None:\n            try:\n                prefix, credentials = parse_credentials(self.headers.getone('authorization', None))\n                if credentials:\n                    self.parsed_credentials = Credentials(auth_type=prefix, token=credentials)\n            except ValueError:\n                pass\n        return self.parsed_credentials\n\n    def get_form(self, keep_blank_values: bool=False) -> Optional[RequestParameters]:\n        \"\"\"Method to extract and parse the form data from a request.\n\n        Args:\n            keep_blank_values (bool): Whether to discard blank values from the form data.\n\n        Returns:\n            Optional[RequestParameters]: The parsed form data.\n        \"\"\"\n        self.parsed_form = RequestParameters()\n        self.parsed_files = RequestParameters()\n        content_type = self.headers.getone('content-type', DEFAULT_HTTP_CONTENT_TYPE)\n        content_type, parameters = parse_content_header(content_type)\n        try:\n            if content_type == 'application/x-www-form-urlencoded':\n                self.parsed_form = RequestParameters(parse_qs(self.body.decode('utf-8'), keep_blank_values=keep_blank_values))\n            elif content_type == 'multipart/form-data':\n                boundary = parameters['boundary'].encode('utf-8')\n                self.parsed_form, self.parsed_files = parse_multipart_form(self.body, boundary)\n        except Exception:\n            error_logger.exception('Failed when parsing form')\n        return self.parsed_form\n\n    @property\n    def form(self) -> Optional[RequestParameters]:\n        \"\"\"The request body parsed as form data\n\n        Returns:\n            Optional[RequestParameters]: The request body parsed as form data\n        \"\"\"\n        if self.parsed_form is None:\n            self.get_form()\n        return self.parsed_form\n\n    @property\n    def files(self) -> Optional[RequestParameters]:\n        \"\"\"The request body parsed as uploaded files\n\n        Returns:\n            Optional[RequestParameters]: The request body parsed as uploaded files\n        \"\"\"\n        if self.parsed_files is None:\n            self.form\n        return self.parsed_files\n\n    def get_args(self, keep_blank_values: bool=False, strict_parsing: bool=False, encoding: str='utf-8', errors: str='replace') -> RequestParameters:\n        \"\"\"Parse `query_string` using `urllib.parse.parse_qs`.\n\n        This methods is used by the `args` property, but it also\n        can be used directly if you need to change default parameters.\n\n        Args:\n            keep_blank_values (bool): Flag indicating whether blank values in\n                percent-encoded queries should be treated as blank strings.\n                A `True` value indicates that blanks should be retained as\n                blank strings. The default `False` value indicates that\n                blank values are to be ignored and treated as if they were\n                not included.\n            strict_parsing (bool): Flag indicating what to do with parsing\n                errors. If `False` (the default), errors are silently ignored.\n                If `True`, errors raise a `ValueError` exception.\n            encoding (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n            errors (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n\n        Returns:\n            RequestParameters: A dictionary containing the parsed arguments.\n        \"\"\"\n        if (keep_blank_values, strict_parsing, encoding, errors) not in self.parsed_args:\n            if self.query_string:\n                self.parsed_args[keep_blank_values, strict_parsing, encoding, errors] = RequestParameters(parse_qs(qs=self.query_string, keep_blank_values=keep_blank_values, strict_parsing=strict_parsing, encoding=encoding, errors=errors))\n        return self.parsed_args[keep_blank_values, strict_parsing, encoding, errors]\n    args = property(get_args)\n    'Convenience property to access `Request.get_args` with default values.\\n    '\n\n    def get_query_args(self, keep_blank_values: bool=False, strict_parsing: bool=False, encoding: str='utf-8', errors: str='replace') -> list:\n        \"\"\"Parse `query_string` using `urllib.parse.parse_qsl`.\n\n        This methods is used by `query_args` propertyn but can be used\n        directly if you need to change default parameters.\n\n        Args:\n            keep_blank_values (bool): Flag indicating whether blank values in\n                percent-encoded queries should be treated as blank strings.\n                A `True` value indicates that blanks should be retained as\n                blank strings. The default `False` value indicates that\n                blank values are to be ignored and treated as if they were\n                not included.\n            strict_parsing (bool): Flag indicating what to do with\n                parsing errors. If `False` (the default), errors are\n                silently ignored. If `True`, errors raise a\n                `ValueError` exception.\n            encoding (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n            errors (str): Specify how to decode percent-encoded sequences\n                into Unicode characters, as accepted by the\n                `bytes.decode()` method.\n\n        Returns:\n            list: A list of tuples containing the parsed arguments.\n        \"\"\"\n        if (keep_blank_values, strict_parsing, encoding, errors) not in self.parsed_not_grouped_args:\n            if self.query_string:\n                self.parsed_not_grouped_args[keep_blank_values, strict_parsing, encoding, errors] = parse_qsl(qs=self.query_string, keep_blank_values=keep_blank_values, strict_parsing=strict_parsing, encoding=encoding, errors=errors)\n        return self.parsed_not_grouped_args[keep_blank_values, strict_parsing, encoding, errors]\n    query_args = property(get_query_args)\n    'Convenience property to access `Request.get_query_args` with default values.\\n    '\n\n    def get_cookies(self) -> RequestParameters:\n        cookie = self.headers.getone('cookie', '')\n        self.parsed_cookies = CookieRequestParameters(parse_cookie(cookie))\n        return self.parsed_cookies\n\n    @property\n    def cookies(self) -> RequestParameters:\n        \"\"\"Incoming cookies on the request\n\n        Returns:\n            RequestParameters: Incoming cookies on the request\n        \"\"\"\n        if self.parsed_cookies is None:\n            self.get_cookies()\n        return cast(CookieRequestParameters, self.parsed_cookies)\n\n    @property\n    def content_type(self) -> str:\n        \"\"\"Content-Type header form the request\n\n        Returns:\n            str: Content-Type header form the request\n        \"\"\"\n        return self.headers.getone('content-type', DEFAULT_HTTP_CONTENT_TYPE)\n\n    @property\n    def match_info(self) -> dict[str, Any]:\n        \"\"\"Matched path parameters after resolving route\n\n        Returns:\n            Dict[str, Any]: Matched path parameters after resolving route\n        \"\"\"\n        return self._match_info\n\n    @match_info.setter\n    def match_info(self, value):\n        self._match_info = value\n\n    @property\n    def ip(self) -> str:\n        \"\"\"Peer ip of the socket\n\n        Returns:\n            str: Peer ip of the socket\n        \"\"\"\n        return self.conn_info.client_ip if self.conn_info else ''\n\n    @property\n    def port(self) -> int:\n        \"\"\"Peer port of the socket\n\n        Returns:\n            int: Peer port of the socket\n        \"\"\"\n        return self.conn_info.client_port if self.conn_info else 0\n\n    @property\n    def socket(self) -> Union[tuple[str, int], tuple[None, None]]:\n        \"\"\"Information about the connected socket if available\n\n        Returns:\n            Tuple[Optional[str], Optional[int]]: Information about the\n                connected socket if available, in the form of a tuple of\n                (ip, port)\n        \"\"\"\n        return self.conn_info.peername if self.conn_info and self.conn_info.peername else (None, None)\n\n    @property\n    def path(self) -> str:\n        \"\"\"Path of the local HTTP request\n\n        Returns:\n            str: Path of the local HTTP request\n        \"\"\"\n        return self._parsed_url.path.decode('utf-8')\n\n    @property\n    def network_paths(self) -> Optional[list[Any]]:\n        \"\"\"Access the network paths if available\n\n        Returns:\n            Optional[List[Any]]: Access the network paths if available\n        \"\"\"\n        if self.conn_info is None:\n            return None\n        return self.conn_info.network_paths\n\n    @property\n    def forwarded(self) -> Options:\n        \"\"\"Active proxy information obtained from request headers, as specified in Sanic configuration.\n\n        Field names by, for, proto, host, port and path are normalized.\n        - for and by IPv6 addresses are bracketed\n        - port (int) is only set by port headers, not from host.\n        - path is url-unencoded\n\n        Additional values may be available from new style Forwarded headers.\n\n        Returns:\n            Options: proxy information from request headers\n        \"\"\"\n        if self.parsed_forwarded is None:\n            self.parsed_forwarded = parse_forwarded(self.headers, self.app.config) or parse_xforwarded(self.headers, self.app.config) or {}\n        return self.parsed_forwarded\n\n    @property\n    def remote_addr(self) -> str:\n        \"\"\"Client IP address, if available from proxy.\n\n        Returns:\n            str: IPv4, bracketed IPv6, UNIX socket name or arbitrary string\n        \"\"\"\n        if not hasattr(self, '_remote_addr'):\n            self._remote_addr = str(self.forwarded.get('for', ''))\n        return self._remote_addr\n\n    @property\n    def client_ip(self) -> str:\n        \"\"\"\n        Client IP address.\n        1. proxied remote address `self.forwarded['for']`\n        2. local peer address `self.ip`\n\n        New in Sanic 23.6. Prefer this over `remote_addr` for determining the\n        client address regardless of whether the service runs behind a proxy\n        or not (proxy deployment needs separate configuration).\n\n        Returns:\n            str: IPv4, bracketed IPv6, UNIX socket name or arbitrary string\n        \"\"\"\n        return self.remote_addr or self.ip\n\n    @property\n    def scheme(self) -> str:\n        \"\"\"Determine request scheme.\n\n        1. `config.SERVER_NAME` if in full URL format\n        2. proxied proto/scheme\n        3. local connection protocol\n\n        Returns:\n            str: http|https|ws|wss or arbitrary value given by the headers.\n        \"\"\"\n        if not hasattr(self, '_scheme'):\n            if self.app.websocket_enabled and self.headers.upgrade.lower() == 'websocket':\n                scheme = 'ws'\n            else:\n                scheme = 'http'\n            proto = None\n            sp = self.app.config.get('SERVER_NAME', '').split('://', 1)\n            if len(sp) == 2:\n                proto = sp[0]\n            elif 'proto' in self.forwarded:\n                proto = str(self.forwarded['proto'])\n            if proto:\n                scheme = proto.replace('http', scheme)\n            elif self.conn_info and self.conn_info.ssl:\n                scheme += 's'\n            self._scheme = scheme\n        return self._scheme\n\n    @property\n    def host(self) -> str:\n        \"\"\"The currently effective server 'host' (hostname or hostname:port).\n\n        1. `config.SERVER_NAME` overrides any client headers\n        2. proxied host of original request\n        3. request host header\n        hostname and port may be separated by\n        `sanic.headers.parse_host(request.host)`.\n\n        Returns:\n            str: the first matching host found, or empty string\n        \"\"\"\n        server_name = self.app.config.get('SERVER_NAME')\n        if server_name:\n            return server_name.split('//', 1)[-1].split('/', 1)[0]\n        return str(self.forwarded.get('host') or self.headers.getone('host', ''))\n\n    @property\n    def server_name(self) -> str:\n        \"\"\"hostname the client connected to, by `request.host`\n\n        Returns:\n            str: hostname the client connected to, by `request.host`\n        \"\"\"\n        return parse_host(self.host)[0] or ''\n\n    @property\n    def server_port(self) -> int:\n        \"\"\"The port the client connected to, by forwarded `port` or `request.host`.\n\n        Default port is returned as 80 and 443 based on `request.scheme`.\n\n        Returns:\n            int: The port the client connected to, by forwarded `port` or `request.host`.\n        \"\"\"\n        port = self.forwarded.get('port') or parse_host(self.host)[1]\n        return int(port or (80 if self.scheme in ('http', 'ws') else 443))\n\n    @property\n    def server_path(self) -> str:\n        \"\"\"Full path of current URL; uses proxied or local path\n\n        Returns:\n            str: Full path of current URL; uses proxied or local path\n        \"\"\"\n        return str(self.forwarded.get('path') or self.path)\n\n    @property\n    def query_string(self) -> str:\n        \"\"\"Representation of the requested query\n\n        Returns:\n            str: Representation of the requested query\n        \"\"\"\n        if self._parsed_url.query:\n            return self._parsed_url.query.decode('utf-8')\n        else:\n            return ''\n\n    @property\n    def url(self) -> str:\n        \"\"\"The URL\n\n        Returns:\n            str: The URL\n        \"\"\"\n        return urlunparse((self.scheme, self.host, self.path, None, self.query_string, None))\n\n    def url_for(self, view_name: str, **kwargs) -> str:\n        \"\"\"Retrieve a URL for a given view name.\n\n        Same as `sanic.Sanic.url_for`, but automatically determine `scheme`\n        and `netloc` base on the request. Since this method is aiming\n        to generate correct schema & netloc, `_external` is implied.\n\n        Args:\n            view_name (str): The view name to generate URL for.\n            **kwargs: Arbitrary keyword arguments to build URL query string.\n\n        Returns:\n            str: The generated URL.\n        \"\"\"\n        try:\n            sp = self.app.config.get('SERVER_NAME', '').split('://', 1)\n            if len(sp) == 2:\n                return self.app.url_for(view_name, _external=True, **kwargs)\n        except AttributeError:\n            pass\n        scheme = self.scheme\n        host = self.server_name\n        port = self.server_port\n        if scheme.lower() in ('http', 'ws') and port == 80 or (scheme.lower() in ('https', 'wss') and port == 443):\n            netloc = host\n        else:\n            netloc = f'{host}:{port}'\n        return self.app.url_for(view_name, _external=True, _scheme=scheme, _server=netloc, **kwargs)\n\n    @property\n    def scope(self) -> ASGIScope:\n        \"\"\"The ASGI scope of the request.\n\n        Returns:\n            ASGIScope: The ASGI scope of the request.\n\n        Raises:\n            NotImplementedError: If the app isn't an ASGI app.\n        \"\"\"\n        if not self.app.asgi:\n            raise NotImplementedError(\"App isn't running in ASGI mode. Scope is only available for ASGI apps.\")\n        return self.transport.scope\n\n    @property\n    def is_safe(self) -> bool:\n        \"\"\"Whether the HTTP method is safe.\n\n        See https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.1\n\n        Returns:\n            bool: Whether the HTTP method is safe.\n        \"\"\"\n        return self.method in SAFE_HTTP_METHODS\n\n    @property\n    def is_idempotent(self) -> bool:\n        \"\"\"Whether the HTTP method is iempotent.\n\n        See https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.2\n\n        Returns:\n            bool: Whether the HTTP method is iempotent.\n        \"\"\"\n        return self.method in IDEMPOTENT_HTTP_METHODS\n\n    @property\n    def is_cacheable(self) -> bool:\n        \"\"\"Whether the HTTP method is cacheable.\n\n        See https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.3\n\n        Returns:\n            bool: Whether the HTTP method is cacheable.\n        \"\"\"\n        return self.method in CACHEABLE_HTTP_METHODS\n\nExample skeleton:\n\n\nclass DialogSuggestionValue:\n    '''\n    An object defining the message input to be sent to the assistant if the user selects\n    the corresponding disambiguation option.\n     **Note:** This entire message input object must be included in the request body of\n    the next message sent to the assistant. Do not modify or remove any of the included\n    properties.\n    :param MessageInput input: (optional) An input object that includes the input\n          text.\n    '''\n\n    def __init__(self, *, input: Optional['MessageInput']=None) -> None:\n        '''\n        Initialize a DialogSuggestionValue object.\n        :param MessageInput input: (optional) An input object that includes the\n               input text.\n        '''\n        pass\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'DialogSuggestionValue':\n        '''Initialize a DialogSuggestionValue object from a json dictionary.'''\n        pass\n    @classmethod\n    def _from_dict(cls, _dict):\n        '''Initialize a DialogSuggestionValue object from a json dictionary.'''\n        pass\n\n    def to_dict(self) -> Dict:\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def _to_dict(self):\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Return a `str` version of this DialogSuggestionValue object.'''\n        pass\n\n    def __eq__(self, other: 'DialogSuggestionValue') -> bool:\n        '''Return `true` when self and other are equal, false otherwise.'''\n        pass\n\n    def __ne__(self, other: 'DialogSuggestionValue') -> bool:\n        '''Return `true` when self and other are not equal, false otherwise.'''\n        pass\nCorresponding class implementation:\n\nfrom typing import BinaryIO, Dict, List, Optional\nimport json\n\nclass DialogSuggestionValue:\n    \"\"\"\n    An object defining the message input to be sent to the assistant if the user selects\n    the corresponding disambiguation option.\n     **Note:** This entire message input object must be included in the request body of\n    the next message sent to the assistant. Do not modify or remove any of the included\n    properties.\n\n    :param MessageInput input: (optional) An input object that includes the input\n          text.\n    \"\"\"\n\n    def __init__(self, *, input: Optional['MessageInput']=None) -> None:\n        \"\"\"\n        Initialize a DialogSuggestionValue object.\n\n        :param MessageInput input: (optional) An input object that includes the\n               input text.\n        \"\"\"\n        self.input = input\n\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'DialogSuggestionValue':\n        \"\"\"Initialize a DialogSuggestionValue object from a json dictionary.\"\"\"\n        args = {}\n        if (input := _dict.get('input')) is not None:\n            args['input'] = MessageInput.from_dict(input)\n        return cls(**args)\n\n    @classmethod\n    def _from_dict(cls, _dict):\n        \"\"\"Initialize a DialogSuggestionValue object from a json dictionary.\"\"\"\n        return cls.from_dict(_dict)\n\n    def to_dict(self) -> Dict:\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        _dict = {}\n        if hasattr(self, 'input') and self.input is not None:\n            if isinstance(self.input, dict):\n                _dict['input'] = self.input\n            else:\n                _dict['input'] = self.input.to_dict()\n        return _dict\n\n    def _to_dict(self):\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        return self.to_dict()\n\n    def __str__(self) -> str:\n        \"\"\"Return a `str` version of this DialogSuggestionValue object.\"\"\"\n        return json.dumps(self.to_dict(), indent=2)\n\n    def __eq__(self, other: 'DialogSuggestionValue') -> bool:\n        \"\"\"Return `true` when self and other are equal, false otherwise.\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other: 'DialogSuggestionValue') -> bool:\n        \"\"\"Return `true` when self and other are not equal, false otherwise.\"\"\"\n        return not self == other\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass ChatService:\n    '''Chat service for handling different types of chat interactions'''\n\n    def __init__(self):\n        '''Initialize chat service'''\n        pass\n\n    def _get_strategy_chain(self, request: ChatRequest, strategy_chain: Optional[List[Type[SystemPromptStrategy]]]=None) -> List[Type[SystemPromptStrategy]]:\n        '''\n        Get the strategy chain to use for message building\n        Args:\n            request: Chat request containing message and other parameters\n            strategy_chain: Optional list of strategy classes to use\n        Returns:\n            List of strategy classes to use\n        Raises:\n            ValueError: If strategy_chain is empty or None and no default chain is available\n        '''\n        pass\n\n    def _build_messages(self, request: ChatRequest, strategy_chain: Optional[List[Type[SystemPromptStrategy]]]=None) -> List[Dict[str, str]]:\n        '''\n        Build messages using the specified strategy chain\n        Args:\n            request: Chat request containing message and other parameters\n            strategy_chain: Optional list of strategy classes to use. If None, uses default chain\n        Returns:\n            List of message dictionaries\n        '''\n        pass\n\n    def _process_chat_response(self, chunk, full_response: Optional[Any], full_content: str) -> Tuple[Any, str, Optional[str]]:\n        '''\n        Process custom chat_response format data\n        Args:\n            chunk: Response data chunk\n            full_response: Current complete response object\n            full_content: Current accumulated content\n        Returns:\n            Tuple[Any, str, Optional[str]]: (Updated response object, Updated content, Finish reason)\n        '''\n        pass\n\n    def _process_openai_response(self, chunk, full_response: Optional[Any], full_content: str) -> Tuple[Any, str, Optional[str]]:\n        '''\n        Process OpenAI format response data\n        Args:\n            chunk: Response data chunk\n            full_response: Current complete response object\n            full_content: Current accumulated content\n        Returns:\n            Tuple[Any, str, Optional[str]]: (Updated response object, Updated content, Finish reason)\n        '''\n        pass\n\n    def collect_stream_response(self, response_iterator: Iterator[Dict[str, Any]]):\n        '''\n        Collect streaming response into a complete response\n        Args:\n            response_iterator: Streaming response iterator\n        Returns:\n            Complete response dictionary\n        '''\n        pass\n\n    def chat(self, request: ChatRequest, strategy_chain: Optional[List[Type[SystemPromptStrategy]]]=None, stream: bool=True, json_response: bool=False, client: Optional[Any]=None, model_params: Optional[Dict[str, Any]]=None, context: Optional[Any]=None) -> Union[Dict[str, Any], Iterator[Dict[str, Any]]]:\n        '''\n        Main chat method supporting both streaming and non-streaming responses\n        Args:\n            request: Chat request containing message and other parameters\n            strategy_chain: Optional list of strategy classes to use\n            stream: Whether to return a streaming response\n            json_response: Whether to request JSON formatted response from LLM\n            client: Optional OpenAI client to use. If None, uses local_llm_service.client\n            model_params: Optional model specific parameters to override defaults\n            context: Optional context to pass to strategies\n        Returns:\n            Either an iterator for streaming responses or a single response dictionary\n        '''\n        pass"
  }
]