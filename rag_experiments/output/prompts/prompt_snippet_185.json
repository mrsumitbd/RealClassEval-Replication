[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass SASKernel(MetaKernel):\n    '''\n    SAS Kernel for Jupyter implementation. This module relies on SASPy\n    '''\n\n    def __init__(self, **kwargs):\n        pass\n\n    def do_apply(self, content, bufs, msg_id, reply_metadata):\n        pass\n\n    def do_clear(self):\n        pass\n\n    def get_usage(self):\n        pass\n\n    def _get_config_names(self):\n        '''\n        get the config file used by SASPy\n        '''\n        pass\n\n    def _start_sas(self, **kwargs):\n        pass\n\n    def _colorize_log(self, log: str) -> str:\n        '''\n        takes a SAS log (str) and then looks for errors.\n        Returns a tuple of error count, list of error messages\n        '''\n        pass\n\n    def _is_error_log(self, log: str) -> Tuple:\n        '''\n        takes a SAS log (str) and then looks for errors.\n        Returns a tuple of error count, list of error messages\n        '''\n        pass\n\n    def _which_display(self, log: str, output: str='') -> str:\n        '''\n        Determines if the log or lst should be returned as the\n        results for the cell based on parsing the log\n        looking for errors and the presence of lst output.\n        :param log: str log from code submission\n        :param output: None or str lst output if there was any\n        :return: The correct results based on log and lst\n        :rtype: str\n        '''\n        pass\n\n    def do_execute_direct(self, code: str, silent: bool=False) -> Union[str, dict]:\n        '''\n        This is the main method that takes code from the Jupyter cell\n        and submits it to the SAS server.\n        :param code: code from the cell\n        :param silent:\n        :return: str with either the log or list\n        '''\n        pass\n\n    def get_completions(self, info):\n        '''\n        Get completions from kernel for procs and statements.\n        '''\n        pass\n    @staticmethod\n    def _get_right_list(s):\n        pass\n\n    def initialize_debug(self, code):\n        '''SAS does not have formal debug tools from this interface'''\n        pass\n\n    def do_shutdown(self, restart):\n        '''\n        Shut down the app gracefully, saving history.\n        '''\n        pass\nCorresponding class implementation:\n\nimport importlib.machinery\nimport types\nfrom IPython.display import HTML\nimport json\nimport re\nfrom typing import Tuple, Union\nfrom .version import __version__\nfrom metakernel import MetaKernel\nimport sys\nimport os\nimport saspy\n\nclass SASKernel(MetaKernel):\n    \"\"\"\n    SAS Kernel for Jupyter implementation. This module relies on SASPy\n    \"\"\"\n    implementation = 'sas_kernel'\n    implementation_version = __version__\n    language = 'sas'\n    language_version = ('9.4+',)\n    banner = 'SAS Kernel'\n    language_info = {'name': 'sas', 'mimetype': 'text/x-sas', 'codemirror_mode': 'sas', 'file_extension': '.sas'}\n\n    def __init__(self, **kwargs):\n        with open(os.path.dirname(os.path.realpath(__file__)) + '/data/' + 'sasproclist.json') as proclist:\n            self.proclist = json.load(proclist)\n        with open(os.path.dirname(os.path.realpath(__file__)) + '/data/' + 'sasgrammardictionary.json') as compglo:\n            self.compglo = json.load(compglo)\n        self.strproclist = '\\n'.join((str(x) for x in self.proclist))\n        self.promptDict = {}\n        MetaKernel.__init__(self, **kwargs)\n        self.lst_len = 0\n        self.mva = None\n        self.cachedlog = None\n        self._allow_stdin = False\n\n    def do_apply(self, content, bufs, msg_id, reply_metadata):\n        pass\n\n    def do_clear(self):\n        pass\n\n    def get_usage(self):\n        return 'This is the SAS kernel.'\n\n    def _get_config_names(self):\n        \"\"\"\n        get the config file used by SASPy\n        \"\"\"\n        loader = importlib.machinery.SourceFileLoader('foo', saspy.SAScfg)\n        cfg = types.ModuleType(loader.name)\n        loader.exec_module(cfg)\n        return cfg.SAS_config_names\n\n    def _start_sas(self, **kwargs):\n        session_params = kwargs\n        if session_params is not None:\n            for _, v in session_params.items():\n                assert isinstance(v, str)\n        try:\n            self.mva = saspy.SASsession(kernel=self, **kwargs)\n        except KeyError:\n            self.mva = None\n        except OSError:\n            msg = 'Failed to connect to SAS!\\n    Please check your connection configuration here:{0}\\n    Here are the valid configurations:{1}\\n    You can load the configuration file into a Jupyter Lab cell using this command:\\n        %load {0}\\n    If the URL/Path are correct the issue is likely your username and/or password\\n    '.format(saspy.list_configs()[0], ', '.join(self._get_config_names()))\n            self.Error_display(msg)\n            self.mva = None\n        except Exception:\n            self.Error_display(str([l for l in sys.exc_info()]))\n\n    def _colorize_log(self, log: str) -> str:\n        \"\"\"\n        takes a SAS log (str) and then looks for errors.\n        Returns a tuple of error count, list of error messages\n        \"\"\"\n        regex_note = '(?m)(^NOTE.*((\\\\n|\\\\t|\\\\n\\\\t)[ ]([^WEN].*)(.*))*)'\n        regex_warn = '(?m)(^WARNING.*((\\\\n|\\\\t|\\\\n\\\\t)[ ]([^WEN].*)(.*))*)'\n        regex_error = '(?m)(^ERROR.*((\\\\n|\\\\t|\\\\n\\\\t)[ ]([^WEN].*)(.*))*)'\n        sub_note = '\\x1b[38;5;21m\\\\1\\x1b[0m'\n        sub_warn = '\\x1b[38;5;2m\\\\1\\x1b[0m'\n        sub_error = '\\x1b[1m\\x1b[38;5;9m\\\\1\\x1b[0m\\x1b[0m'\n        color_pattern = [(regex_error, sub_error), (regex_note, sub_note), (regex_warn, sub_warn)]\n        colored_log = log\n        for pat, sub in color_pattern:\n            colored_log = re.sub(pat, sub, colored_log)\n        return colored_log\n\n    def _is_error_log(self, log: str) -> Tuple:\n        \"\"\"\n        takes a SAS log (str) and then looks for errors.\n        Returns a tuple of error count, list of error messages\n        \"\"\"\n        lines = re.split('[\\\\n]\\\\s*', log)\n        error_count = 0\n        error_log_msg_list = []\n        error_log_line_list = []\n        for index, line in enumerate(lines):\n            if line.startswith('ERROR'):\n                error_count += 1\n                error_log_msg_list.append(line)\n                error_log_line_list.append(index)\n        return (error_count, error_log_msg_list, error_log_line_list)\n\n    def _which_display(self, log: str, output: str='') -> str:\n        \"\"\"\n        Determines if the log or lst should be returned as the\n        results for the cell based on parsing the log\n        looking for errors and the presence of lst output.\n\n        :param log: str log from code submission\n        :param output: None or str lst output if there was any\n        :return: The correct results based on log and lst\n        :rtype: str\n        \"\"\"\n        error_count, msg_list, error_line_list = self._is_error_log(log)\n        if error_count == 0 and len(output) > self.lst_len:\n            return self.Display(HTML(output))\n        elif error_count > 0 and len(output) > self.lst_len:\n            regex_around_error = '(.*)(.*\\\\n){6}^ERROR(.*\\\\n){6}'\n            e_log = re.search(regex_around_error, log, re.MULTILINE).group()\n            assert error_count == len(error_line_list), \"Error count and count of line number don't match\"\n            return self.Error_display(msg_list[0], print(self._colorize_log(e_log)), HTML(output))\n        return self.Print(self._colorize_log(log))\n\n    def do_execute_direct(self, code: str, silent: bool=False) -> Union[str, dict]:\n        \"\"\"\n        This is the main method that takes code from the Jupyter cell\n        and submits it to the SAS server.\n\n        :param code: code from the cell\n        :param silent:\n        :return: str with either the log or list\n        \"\"\"\n        if not code.strip():\n            return {'status': 'ok', 'execution_count': self.execution_count, 'payload': [], 'user_expressions': {}}\n        if self.mva is None:\n            self._allow_stdin = True\n            self._start_sas()\n        if not code.startswith('showSASLog_11092015') and (not code.startswith('CompleteshowSASLog_11092015')):\n            if code.startswith('/*SASKernelTest*/'):\n                res = self.mva.submit(code, 'text')\n            else:\n                res = self.mva.submit(code, prompt=self.promptDict)\n                self.promptDict = {}\n            if res['LOG'].find('SAS process has terminated unexpectedly') > -1:\n                print(res['LOG'], '\\nRestarting SAS session on your behalf')\n                self.do_shutdown(True)\n                return res['LOG']\n            self.cachedlog = self._colorize_log(res['LOG'])\n            error_count, error_log_msg, _ = self._is_error_log(res['LOG'])\n            if error_count > 0 and len(res['LST']) <= self.lst_len:\n                return self.Error(error_log_msg[0], print(self._colorize_log(res['LOG'])))\n            return self._which_display(res['LOG'], res['LST'])\n        elif code.startswith('CompleteshowSASLog_11092015') and (not code.startswith('showSASLog_11092015')):\n            return self.Print(self._colorize_log(self.mva.saslog()))\n        else:\n            return self.Print(self._colorize_log(self.cachedlog))\n\n    def get_completions(self, info):\n        \"\"\"\n        Get completions from kernel for procs and statements.\n        \"\"\"\n        if info['line_num'] > 1:\n            relstart = info['column'] - (info['help_pos'] - info['start'])\n        else:\n            relstart = info['start']\n        seg = info['line'][:relstart]\n        try:\n            if relstart > 0 and re.match('(?i)proc', seg.rsplit(None, 1)[-1]):\n                potentials = re.findall('(?i)^' + info['obj'] + '.*', self.strproclist, re.MULTILINE)\n                return potentials\n        except:\n            pass\n        lastproc = info['code'].lower()[:info['help_pos']].rfind('proc')\n        lastdata = info['code'].lower()[:info['help_pos']].rfind('data ')\n        proc = False\n        data = False\n        if lastproc + lastdata == -2:\n            pass\n        elif lastproc > lastdata:\n            proc = True\n        else:\n            data = True\n        if proc:\n            lastsemi = info['code'].rfind(';')\n            mykey = 's'\n            if lastproc > lastsemi:\n                mykey = 'p'\n            procer = re.search('(?i)proc\\\\s\\\\w+', info['code'][lastproc:])\n            method = procer.group(0).split(' ')[-1].upper() + mykey\n            mylist = self.compglo[method][0]\n            potentials = re.findall('(?i)' + info['obj'] + '.+', '\\n'.join((str(x) for x in mylist)), re.MULTILINE)\n            return potentials\n        elif data:\n            lastsemi = info['code'].rfind(';')\n            mykey = 's'\n            if lastproc > lastsemi:\n                mykey = 'p'\n            mylist = self.compglo['DATA' + mykey][0]\n            potentials = re.findall('(?i)^' + info['obj'] + '.*', '\\n'.join((str(x) for x in mylist)), re.MULTILINE)\n            return potentials\n        else:\n            potentials = ['']\n            return potentials\n\n    @staticmethod\n    def _get_right_list(s):\n        proc_opt = re.search('proc\\\\s(\\\\w+).*?[^;]\\\\Z', s, re.IGNORECASE | re.MULTILINE)\n        proc_stmt = re.search('\\\\s*proc\\\\s*(\\\\w+).*;.*\\\\Z', s, re.IGNORECASE | re.MULTILINE)\n        data_opt = re.search('\\\\s*data\\\\s*[^=].*[^;]?.*$', s, re.IGNORECASE | re.MULTILINE)\n        data_stmt = re.search('\\\\s*data\\\\s*[^=].*[^;]?.*$', s, re.IGNORECASE | re.MULTILINE)\n        print(s)\n        if proc_opt:\n            return proc_opt.group(1).upper() + 'p'\n        elif proc_stmt:\n            return proc_stmt.group(1).upper() + 's'\n        elif data_opt:\n            return 'DATA' + 'p'\n        elif data_stmt:\n            return 'DATA' + 's'\n        else:\n            return None\n\n    def initialize_debug(self, code):\n        \"\"\"SAS does not have formal debug tools from this interface\"\"\"\n        print(code)\n        return None\n\n    def do_shutdown(self, restart):\n        \"\"\"\n        Shut down the app gracefully, saving history.\n        \"\"\"\n        print('in shutdown function')\n        if self.hist_file:\n            with open(self.hist_file, 'wb') as fid:\n                data = '\\n'.join(self.hist_cache[-self.max_hist_cache:])\n                fid.write(data.encode('utf-8'))\n        if self.mva:\n            self.mva._endsas()\n            self.mva = None\n        if restart:\n            self.Print('Restarting kernel...')\n            self.reload_magics()\n            self.restart_kernel()\n            self.Print('Done!')\n        return {'status': 'ok', 'restart': restart}\n\nExample skeleton:\n\n\nclass SearchSettingsConversationalSearch:\n    '''\n    Configuration settings for conversational search.\n    :param bool enabled: Whether to enable conversational search.\n    :param SearchSettingsConversationalSearchResponseLength response_length:\n          (optional)\n    :param SearchSettingsConversationalSearchSearchConfidence search_confidence:\n          (optional)\n    '''\n\n    def __init__(self, enabled: bool, *, response_length: Optional['SearchSettingsConversationalSearchResponseLength']=None, search_confidence: Optional['SearchSettingsConversationalSearchSearchConfidence']=None) -> None:\n        '''\n        Initialize a SearchSettingsConversationalSearch object.\n        :param bool enabled: Whether to enable conversational search.\n        :param SearchSettingsConversationalSearchResponseLength response_length:\n               (optional)\n        :param SearchSettingsConversationalSearchSearchConfidence\n               search_confidence: (optional)\n        '''\n        pass\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'SearchSettingsConversationalSearch':\n        '''Initialize a SearchSettingsConversationalSearch object from a json dictionary.'''\n        pass\n    @classmethod\n    def _from_dict(cls, _dict):\n        '''Initialize a SearchSettingsConversationalSearch object from a json dictionary.'''\n        pass\n\n    def to_dict(self) -> Dict:\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def _to_dict(self):\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Return a `str` version of this SearchSettingsConversationalSearch object.'''\n        pass\n\n    def __eq__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        '''Return `true` when self and other are equal, false otherwise.'''\n        pass\n\n    def __ne__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        '''Return `true` when self and other are not equal, false otherwise.'''\n        pass\nCorresponding class implementation:\n\nimport json\nfrom typing import BinaryIO, Dict, List, Optional\n\nclass SearchSettingsConversationalSearch:\n    \"\"\"\n    Configuration settings for conversational search.\n\n    :param bool enabled: Whether to enable conversational search.\n    :param SearchSettingsConversationalSearchResponseLength response_length:\n          (optional)\n    :param SearchSettingsConversationalSearchSearchConfidence search_confidence:\n          (optional)\n    \"\"\"\n\n    def __init__(self, enabled: bool, *, response_length: Optional['SearchSettingsConversationalSearchResponseLength']=None, search_confidence: Optional['SearchSettingsConversationalSearchSearchConfidence']=None) -> None:\n        \"\"\"\n        Initialize a SearchSettingsConversationalSearch object.\n\n        :param bool enabled: Whether to enable conversational search.\n        :param SearchSettingsConversationalSearchResponseLength response_length:\n               (optional)\n        :param SearchSettingsConversationalSearchSearchConfidence\n               search_confidence: (optional)\n        \"\"\"\n        self.enabled = enabled\n        self.response_length = response_length\n        self.search_confidence = search_confidence\n\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'SearchSettingsConversationalSearch':\n        \"\"\"Initialize a SearchSettingsConversationalSearch object from a json dictionary.\"\"\"\n        args = {}\n        if (enabled := _dict.get('enabled')) is not None:\n            args['enabled'] = enabled\n        else:\n            raise ValueError(\"Required property 'enabled' not present in SearchSettingsConversationalSearch JSON\")\n        if (response_length := _dict.get('response_length')) is not None:\n            args['response_length'] = SearchSettingsConversationalSearchResponseLength.from_dict(response_length)\n        if (search_confidence := _dict.get('search_confidence')) is not None:\n            args['search_confidence'] = SearchSettingsConversationalSearchSearchConfidence.from_dict(search_confidence)\n        return cls(**args)\n\n    @classmethod\n    def _from_dict(cls, _dict):\n        \"\"\"Initialize a SearchSettingsConversationalSearch object from a json dictionary.\"\"\"\n        return cls.from_dict(_dict)\n\n    def to_dict(self) -> Dict:\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        _dict = {}\n        if hasattr(self, 'enabled') and self.enabled is not None:\n            _dict['enabled'] = self.enabled\n        if hasattr(self, 'response_length') and self.response_length is not None:\n            if isinstance(self.response_length, dict):\n                _dict['response_length'] = self.response_length\n            else:\n                _dict['response_length'] = self.response_length.to_dict()\n        if hasattr(self, 'search_confidence') and self.search_confidence is not None:\n            if isinstance(self.search_confidence, dict):\n                _dict['search_confidence'] = self.search_confidence\n            else:\n                _dict['search_confidence'] = self.search_confidence.to_dict()\n        return _dict\n\n    def _to_dict(self):\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        return self.to_dict()\n\n    def __str__(self) -> str:\n        \"\"\"Return a `str` version of this SearchSettingsConversationalSearch object.\"\"\"\n        return json.dumps(self.to_dict(), indent=2)\n\n    def __eq__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        \"\"\"Return `true` when self and other are equal, false otherwise.\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        \"\"\"Return `true` when self and other are not equal, false otherwise.\"\"\"\n        return not self == other\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass TopKStringTracker:\n    '''\n    Efficient Top-K string tracking data structure\n    Core ideas:\n    1. Use hash table to record string counts\n    2. Use min-heap to maintain top-m strings (heap root is the m-th largest element)\n    3. Lazy cleanup: avoid frequent heap operations\n    '''\n\n    def __init__(self, m: int):\n        '''\n        Initialize the data structure\n        Args:\n            m: Maximum number of strings to retain\n        '''\n        pass\n\n    def add_strings(self, strings: List[str]) -> None:\n        '''\n        Add k strings to the data structure\n        Args:\n            strings: List of strings to add\n        '''\n        pass\n\n    def add_string_dict(self, string_counts: dict) -> None:\n        '''\n        Add strings with their counts from a dictionary\n        Args:\n            string_counts: Dictionary mapping strings to their occurrence counts\n        '''\n        pass\n\n    def _cleanup_heap(self) -> None:\n        '''\n        Clean up outdated counts in heap and rebuild heap structure\n        '''\n        pass\n\n    def get_top_k(self, k: int) -> Set[str]:\n        '''\n        Return the set of top-k strings by occurrence count\n        Args:\n            k: Number of strings to return\n        Returns:\n            Set containing the top-k strings\n        '''\n        pass\n\n    def trim_to_m(self) -> None:\n        '''\n        Keep only the top-m strings by occurrence count, delete others\n        '''\n        pass\n\n    def size(self) -> int:\n        '''Return the number of strings currently stored'''\n        pass\n\n    def get_count(self, string: str) -> int:\n        '''Get the occurrence count of a specific string'''\n        pass"
  }
]