[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Compiler:\n    '''A handlebars template compiler.\n    The compiler is not threadsafe: you need one per thread because of the\n    state in CodeBuilder.\n    '''\n\n    def __init__(self):\n        pass\n\n    def _extract_word(self, source, position):\n        '''\n        Extracts the word that falls at or around a specific position\n        :param source:\n            The template source as a unicode string\n        :param position:\n            The position where the word falls\n        :return:\n            The word\n        '''\n        pass\n\n    def _generate_code(self, source):\n        '''\n        Common compilation code shared between precompile() and compile()\n        :param source:\n            The template source as a unicode string\n        :return:\n            A tuple of (function, source_code)\n        '''\n        pass\n\n    def whitespace_control(self, source):\n        '''\n        Preprocess source to handle whitespace control and remove extra block\n        whitespaces.\n        :param source:\n            The template source as a unicode string\n        :return:\n            The processed template source as a unicode string\n        '''\n        pass\n\n    def precompile(self, source):\n        '''\n        Generates python source code that can be saved to a file for caching\n        :param source:\n            The template to generate source for - should be a unicode string\n        :return:\n            Python code as a unicode string\n        '''\n        pass\n\n    def compile(self, source, path=None):\n        '''Compile source to a ready to run template.\n        :param source:\n            The template to compile - should be a unicode string\n        :return:\n            A template function ready to execute\n        '''\n        pass\n\n        def make_module_name(name, suffix=None):\n                pass\n\n    def template(self, code):\n        pass\n\n        def _render(context, helpers=None, partials=None, root=None):\n                pass\nCorresponding class implementation:\n\nimport sys\nimport re\nfrom types import ModuleType\nimport linecache\nfrom pymeta.grammar import OMeta\n\nclass Compiler:\n    \"\"\"A handlebars template compiler.\n\n    The compiler is not threadsafe: you need one per thread because of the\n    state in CodeBuilder.\n    \"\"\"\n    _handlebars = OMeta.makeGrammar(handlebars_grammar, {}, 'handlebars')\n    _builder = CodeBuilder()\n    _compiler = OMeta.makeGrammar(compile_grammar, {'builder': _builder})\n\n    def __init__(self):\n        self._helpers = {}\n        self.template_counter = 1\n\n    def _extract_word(self, source, position):\n        \"\"\"\n        Extracts the word that falls at or around a specific position\n\n        :param source:\n            The template source as a unicode string\n        :param position:\n            The position where the word falls\n\n        :return:\n            The word\n        \"\"\"\n        boundry = re.search('{{|{|\\\\s|$', source[:position][::-1])\n        start_offset = boundry.end() if boundry.group(0).startswith('{') else boundry.start()\n        boundry = re.search('}}|}|\\\\s|$', source[position:])\n        end_offset = boundry.end() if boundry.group(0).startswith('}') else boundry.start()\n        return source[position - start_offset:position + end_offset]\n\n    def _generate_code(self, source):\n        \"\"\"\n        Common compilation code shared between precompile() and compile()\n\n        :param source:\n            The template source as a unicode string\n\n        :return:\n            A tuple of (function, source_code)\n        \"\"\"\n        if not isinstance(source, str_class):\n            raise PybarsError('Template source must be a unicode string')\n        source = self.whitespace_control(source)\n        tree, (position, _) = self._handlebars(source).apply('template')\n        if debug:\n            print('\\nAST')\n            print('---')\n            print(tree)\n            print('')\n        if position < len(source):\n            line_num = source.count('\\n') + 1\n            beginning_of_line = source.rfind('\\n', 0, position)\n            if beginning_of_line == -1:\n                char_num = position\n            else:\n                char_num = position - beginning_of_line\n            word = self._extract_word(source, position)\n            raise PybarsError('Error at character %s of line %s near %s' % (char_num, line_num, word))\n        self._compiler.globals['builder']._reset()\n        output = self._compiler(tree).apply('compile')[0]\n        return output\n\n    def whitespace_control(self, source):\n        \"\"\"\n        Preprocess source to handle whitespace control and remove extra block\n        whitespaces.\n\n        :param source:\n            The template source as a unicode string\n        :return:\n            The processed template source as a unicode string\n        \"\"\"\n        cleanup_sub = re.compile('(?<={{)~|~(?=}})|(?<=}})[ \\\\t]+(?={{)').sub\n        return re.sub('~}}\\\\s*|\\\\s*{{~|(?<=\\\\n)([ \\\\t]*{{(#[^{}]+|/[^{}]+|![^{}]+|else|else if [^{}]+)}}[ \\\\t]*)+\\\\r?\\\\n|^([ \\\\t]*{{(#[^{}]+|![^{}]+)}}[ \\\\t]*)+\\\\r?\\\\n|\\\\r?\\\\n([ \\\\t]*{{(/[^{}]+|![^{}]+)}}[ \\\\t]*)+$', lambda match: cleanup_sub('', match.group(0).strip()), source)\n\n    def precompile(self, source):\n        \"\"\"\n        Generates python source code that can be saved to a file for caching\n\n        :param source:\n            The template to generate source for - should be a unicode string\n\n        :return:\n            Python code as a unicode string\n        \"\"\"\n        return self._generate_code(source).full_code\n\n    def compile(self, source, path=None):\n        \"\"\"Compile source to a ready to run template.\n\n        :param source:\n            The template to compile - should be a unicode string\n\n        :return:\n            A template function ready to execute\n        \"\"\"\n        container = self._generate_code(source)\n\n        def make_module_name(name, suffix=None):\n            output = 'pybars._templates.%s' % name\n            if suffix:\n                output += '_%s' % suffix\n            return output\n        if not path:\n            path = '_template'\n            generate_name = True\n        else:\n            path = path.replace('\\\\', '/')\n            path = path.replace('/', '_')\n            mod_name = make_module_name(path)\n            generate_name = mod_name in sys.modules\n        if generate_name:\n            mod_name = make_module_name(path, self.template_counter)\n            while mod_name in sys.modules:\n                self.template_counter += 1\n                mod_name = make_module_name(path, self.template_counter)\n        mod = ModuleType(mod_name)\n        filename = '%s.py' % mod_name.replace('pybars.', '').replace('.', '/')\n        exec(compile(container.full_code, filename, 'exec', dont_inherit=True), mod.__dict__)\n        sys.modules[mod_name] = mod\n        linecache.getlines(filename, mod.__dict__)\n        return mod.__dict__[container.name]\n\n    def template(self, code):\n\n        def _render(context, helpers=None, partials=None, root=None):\n            ns = {'context': context, 'helpers': helpers, 'partials': partials, 'root': root}\n            exec(code + '\\nresult = render(context, helpers=helpers, partials=partials, root=root)', ns)\n            return ns['result']\n        return _render\n\nExample skeleton:\n\n\nclass WinLnkParser(interface.FileObjectParser):\n    '''Windows Shortcut (LNK) file parser.'''\n\n    def __init__(self):\n        '''Initializes a Windows Shortcut (LNK) file parser.'''\n        pass\n\n    def _GetDateTime(self, filetime):\n        '''Retrieves the date and time from a FILETIME timestamp.\n        Args:\n          filetime (int): FILETIME timestamp.\n        Returns:\n          dfdatetime.DateTimeValues: date and time or None if not set.\n        '''\n        pass\n\n    def _GetSanitizedPathString(self, path):\n        '''Retrieves a sanitize path string.\n        Args:\n          path (str): path.\n        Returns:\n          str: sanitized path string.\n        '''\n        pass\n    @classmethod\n    def GetFormatSpecification(cls):\n        '''Retrieves the format specification.\n        Returns:\n          FormatSpecification: format specification.\n        '''\n        pass\n\n    def _ParseDistributedTrackingIdentifier(self, parser_mediator, uuid_string, origin):\n        '''Extracts data from a Distributed Tracking identifier.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          uuid_string (str): UUID string of the Distributed Tracking identifier.\n          origin (str): origin of the event (event source).\n        '''\n        pass\n\n    def ParseFileObject(self, parser_mediator, file_object):\n        '''Parses a Windows Shortcut (LNK) file-like object.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): file-like object.\n        '''\n        pass\n\n    def ParseFileLNKFile(self, parser_mediator, file_object, display_name):\n        '''Parses a Windows Shortcut (LNK) file-like object.\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): file-like object.\n          display_name (str): display name.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom plaso.lib import specification\nfrom dfdatetime import filetime as dfdatetime_filetime\nfrom plaso.containers import windows_events\nimport uuid\nfrom plaso.parsers.shared import shell_items\nfrom plaso.parsers import interface\nfrom plaso.lib import definitions\nimport pylnk\n\nclass WinLnkParser(interface.FileObjectParser):\n    \"\"\"Windows Shortcut (LNK) file parser.\"\"\"\n    _INITIAL_FILE_OFFSET = None\n    _PATH_ESCAPE_CHARACTERS = {'\\\\': '\\\\\\\\'}\n    _PATH_ESCAPE_CHARACTERS.update(definitions.NON_PRINTABLE_CHARACTERS)\n    NAME = 'lnk'\n    DATA_FORMAT = 'Windows Shortcut (LNK) file'\n\n    def __init__(self):\n        \"\"\"Initializes a Windows Shortcut (LNK) file parser.\"\"\"\n        super(WinLnkParser, self).__init__()\n        self._path_escape_characters = str.maketrans(self._PATH_ESCAPE_CHARACTERS)\n\n    def _GetDateTime(self, filetime):\n        \"\"\"Retrieves the date and time from a FILETIME timestamp.\n\n        Args:\n          filetime (int): FILETIME timestamp.\n\n        Returns:\n          dfdatetime.DateTimeValues: date and time or None if not set.\n        \"\"\"\n        if not filetime:\n            return None\n        return dfdatetime_filetime.Filetime(timestamp=filetime)\n\n    def _GetSanitizedPathString(self, path):\n        \"\"\"Retrieves a sanitize path string.\n\n        Args:\n          path (str): path.\n\n        Returns:\n          str: sanitized path string.\n        \"\"\"\n        if not path:\n            return None\n        return path.translate(self._path_escape_characters)\n\n    @classmethod\n    def GetFormatSpecification(cls):\n        \"\"\"Retrieves the format specification.\n\n        Returns:\n          FormatSpecification: format specification.\n        \"\"\"\n        format_specification = specification.FormatSpecification(cls.NAME)\n        format_specification.AddNewSignature(b'\\x01\\x14\\x02\\x00\\x00\\x00\\x00\\x00\\xc0\\x00\\x00\\x00\\x00\\x00\\x00F', offset=4)\n        return format_specification\n\n    def _ParseDistributedTrackingIdentifier(self, parser_mediator, uuid_string, origin):\n        \"\"\"Extracts data from a Distributed Tracking identifier.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          uuid_string (str): UUID string of the Distributed Tracking identifier.\n          origin (str): origin of the event (event source).\n        \"\"\"\n        uuid_object = uuid.UUID(uuid_string)\n        if uuid_object.version == 1:\n            event_data = windows_events.WindowsDistributedLinkTrackingEventData(uuid_object, origin)\n            parser_mediator.ProduceEventData(event_data)\n\n    def ParseFileObject(self, parser_mediator, file_object):\n        \"\"\"Parses a Windows Shortcut (LNK) file-like object.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): file-like object.\n        \"\"\"\n        display_name = parser_mediator.GetDisplayName()\n        self.ParseFileLNKFile(parser_mediator, file_object, display_name)\n\n    def ParseFileLNKFile(self, parser_mediator, file_object, display_name):\n        \"\"\"Parses a Windows Shortcut (LNK) file-like object.\n\n        Args:\n          parser_mediator (ParserMediator): mediates interactions between parsers\n              and other components, such as storage and dfVFS.\n          file_object (dfvfs.FileIO): file-like object.\n          display_name (str): display name.\n        \"\"\"\n        code_page = parser_mediator.GetCodePage()\n        lnk_file = pylnk.file()\n        lnk_file.set_ascii_codepage(code_page)\n        try:\n            lnk_file.open_file_object(file_object)\n        except IOError as exception:\n            parser_mediator.ProduceExtractionWarning('unable to open file with error: {0!s}'.format(exception))\n            return\n        link_target = None\n        if lnk_file.link_target_identifier_data:\n            display_name = parser_mediator.GetFilename()\n            shell_items_parser = shell_items.ShellItemsParser(display_name)\n            shell_items_parser.ParseByteStream(parser_mediator, lnk_file.link_target_identifier_data, codepage=code_page)\n            link_target = shell_items_parser.CopyToPath()\n        access_time = lnk_file.get_file_access_time_as_integer()\n        creation_time = lnk_file.get_file_creation_time_as_integer()\n        modification_time = lnk_file.get_file_modification_time_as_integer()\n        event_data = WinLnkLinkEventData()\n        event_data.access_time = self._GetDateTime(access_time)\n        event_data.birth_droid_file_identifier = lnk_file.birth_droid_file_identifier\n        event_data.birth_droid_volume_identifier = lnk_file.birth_droid_volume_identifier\n        event_data.command_line_arguments = self._GetSanitizedPathString(lnk_file.command_line_arguments)\n        event_data.creation_time = self._GetDateTime(creation_time)\n        event_data.description = self._GetSanitizedPathString(lnk_file.description)\n        event_data.drive_serial_number = lnk_file.drive_serial_number\n        event_data.drive_type = lnk_file.drive_type\n        event_data.droid_file_identifier = lnk_file.droid_file_identifier\n        event_data.droid_volume_identifier = lnk_file.droid_volume_identifier\n        event_data.env_var_location = self._GetSanitizedPathString(lnk_file.environment_variables_location)\n        event_data.file_attribute_flags = lnk_file.file_attribute_flags\n        event_data.file_size = lnk_file.file_size\n        event_data.icon_location = self._GetSanitizedPathString(lnk_file.icon_location)\n        event_data.link_target = link_target\n        event_data.local_path = self._GetSanitizedPathString(lnk_file.local_path)\n        event_data.modification_time = self._GetDateTime(modification_time)\n        event_data.network_path = self._GetSanitizedPathString(lnk_file.network_path)\n        event_data.relative_path = self._GetSanitizedPathString(lnk_file.relative_path)\n        event_data.volume_label = lnk_file.volume_label\n        event_data.working_directory = self._GetSanitizedPathString(lnk_file.working_directory)\n        parser_mediator.ProduceEventData(event_data)\n        if lnk_file.droid_file_identifier:\n            try:\n                self._ParseDistributedTrackingIdentifier(parser_mediator, lnk_file.droid_file_identifier, display_name)\n            except (TypeError, ValueError) as exception:\n                parser_mediator.ProduceExtractionWarning('unable to read droid file identifier with error: {0!s}.'.format(exception))\n        if lnk_file.birth_droid_file_identifier and lnk_file.birth_droid_file_identifier != lnk_file.droid_file_identifier:\n            try:\n                self._ParseDistributedTrackingIdentifier(parser_mediator, lnk_file.birth_droid_file_identifier, display_name)\n            except (TypeError, ValueError) as exception:\n                parser_mediator.ProduceExtractionWarning('unable to read birth droid file identifier with error: {0!s}.'.format(exception))\n        lnk_file.close()\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass PatternUtils:\n    '''Common pattern matching utilities used across formatting rules.'''\n    @staticmethod\n    def contains_assignment(line: str) -> bool:\n        '''\n        Check if line contains an assignment operator.\n        Args:\n            line: The line to check\n        Returns:\n            True if line contains assignment operators\n        '''\n        pass\n    @staticmethod\n    def apply_assignment_spacing(line: str, use_spaces: bool=True) -> str:\n        '''\n        Apply consistent spacing around assignment operators.\n        Args:\n            line: The line to format\n            use_spaces: Whether to use spaces around operators\n        Returns:\n            The formatted line\n        '''\n        pass\n    @staticmethod\n    def format_target_colon(line: str, space_before: bool=False, space_after: bool=True) -> Optional[str]:\n        '''\n        Format colon spacing in target definitions.\n        Args:\n            line: The line to format\n            space_before: Whether to add space before colon\n            space_after: Whether to add space after colon\n        Returns:\n            Formatted line or None if no changes needed\n        '''\n        pass\n    @staticmethod\n    def format_pattern_rule(line: str, space_after_colon: bool=True) -> Optional[str]:\n        '''\n        Format spacing in pattern rules.\n        Args:\n            line: The line to format\n            space_after_colon: Whether to add space after colon\n        Returns:\n            Formatted line or None if no changes needed\n        '''\n        pass\n    @staticmethod\n    def is_conditional_directive(line: str) -> bool:\n        '''\n        Check if line is a conditional directive.\n        Args:\n            line: The line to check\n        Returns:\n            True if this is a conditional directive\n        '''\n        pass\n    @staticmethod\n    def get_conditional_indent_level(line: str) -> int:\n        '''\n        Get the appropriate indentation level for conditional directives.\n        Args:\n            line: The conditional directive line\n        Returns:\n            Number of spaces for indentation\n        '''\n        pass"
  }
]