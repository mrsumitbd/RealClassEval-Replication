[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass RawMetricsOperator(BaseOperator):\n    '''Raw Metrics Operator.'''\n\n    def __init__(self, config: WilyConfig, targets: Iterable[str]):\n        '''\n        Instantiate a new raw operator.\n        :param config: The wily configuration.\n        :param targets: An iterable of paths from which to harvest metrics.\n        '''\n        pass\n\n    def run(self, module: str, options: Dict[str, Any]) -> Dict[Any, Any]:\n        '''\n        Run the operator.\n        :param module: The target module path.\n        :param options: Any runtime options.\n        :return: The operator results.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom wily.lang import _\nfrom wily.operators import BaseOperator, Metric, MetricType\nfrom typing import Any, Dict, Iterable\nfrom wily.config.types import WilyConfig\nfrom radon.cli import Config\nfrom wily import logger\nimport radon.cli.harvest as harvesters\n\nclass RawMetricsOperator(BaseOperator):\n    \"\"\"Raw Metrics Operator.\"\"\"\n    name = 'raw'\n    defaults = {'exclude': None, 'ignore': None, 'summary': False, 'include_ipynb': True, 'ipynb_cells': True}\n    metrics = (Metric('loc', _('Lines of Code'), int, MetricType.Informational, sum), Metric('lloc', _('L Lines of Code'), int, MetricType.AimLow, sum), Metric('sloc', _('S Lines of Code'), int, MetricType.AimLow, sum), Metric('comments', _('Multi-line comments'), int, MetricType.AimHigh, sum), Metric('multi', _('Multi lines'), int, MetricType.Informational, sum), Metric('blank', _('blank lines'), int, MetricType.Informational, sum), Metric('single_comments', _('Single comment lines'), int, MetricType.Informational, sum))\n    default_metric_index = 0\n\n    def __init__(self, config: WilyConfig, targets: Iterable[str]):\n        \"\"\"\n        Instantiate a new raw operator.\n\n        :param config: The wily configuration.\n        :param targets: An iterable of paths from which to harvest metrics.\n        \"\"\"\n        logger.debug('Using %s with %s for Raw metrics', targets, self.defaults)\n        self.harvester = harvesters.RawHarvester(targets, config=Config(**self.defaults))\n\n    def run(self, module: str, options: Dict[str, Any]) -> Dict[Any, Any]:\n        \"\"\"\n        Run the operator.\n\n        :param module: The target module path.\n        :param options: Any runtime options.\n        :return: The operator results.\n        \"\"\"\n        logger.debug('Running raw harvester')\n        results = {}\n        for filename, metrics in dict(self.harvester.results).items():\n            results[filename] = {'total': metrics}\n        return results\n\nExample skeleton:\n\n\nclass Step:\n    '''State machine for executing generic actions related to stacks.\n    Attributes:\n        fn: Function to run to execute the step.\n            This function will be ran multiple times until the step is \"done\".\n        last_updated: Time when the step was last updated.\n        logger: Logger for logging messages about the step.\n        stack: the stack associated with this step\n        status: The status of step.\n        watch_func: Function that will be called to \"tail\" the step action.\n    '''\n\n    def __init__(self, stack: Stack, *, fn: Callable[..., Any] | None=None, watch_func: Callable[..., Any] | None=None) -> None:\n        '''Instantiate class.\n        Args:\n            stack: The stack associated\n                with this step\n            fn: Function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: Function that will be called to \"tail\" the step action.\n        '''\n        pass\n\n    def run(self) -> bool:\n        '''Run this step until it has completed or been skipped.'''\n        pass\n\n    def _run_once(self) -> Status:\n        '''Run a step exactly once.'''\n        pass\n    @property\n    def name(self) -> str:\n        '''Name of the step.\n        This is equal to the name of the stack it operates on.\n        '''\n        pass\n    @property\n    def requires(self) -> set[str]:\n        '''Return a list of step names this step depends on.'''\n        pass\n    @property\n    def required_by(self) -> set[str]:\n        '''Return a list of step names that depend on this step.'''\n        pass\n    @property\n    def completed(self) -> bool:\n        '''Return True if the step is in a COMPLETE state.'''\n        pass\n    @property\n    def skipped(self) -> bool:\n        '''Return True if the step is in a SKIPPED state.'''\n        pass\n    @property\n    def failed(self) -> bool:\n        '''Return True if the step is in a FAILED state.'''\n        pass\n    @property\n    def done(self) -> bool:\n        '''Return True if the step is finished.\n        To be ``True``, status must be either COMPLETE, SKIPPED or FAILED)\n        '''\n        pass\n    @property\n    def ok(self) -> bool:\n        '''Return True if the step is finished (either COMPLETE or SKIPPED).'''\n        pass\n    @property\n    def submitted(self) -> bool:\n        '''Return True if the step is SUBMITTED, COMPLETE, or SKIPPED.'''\n        pass\n\n    def set_status(self, status: Status) -> None:\n        '''Set the current step's status.\n        Args:\n            status: The status to set the step to.\n        '''\n        pass\n    def completed(self) -> bool:\n        '''Shortcut for ``set_status(COMPLETE)``.'''\n        pass\n\n    def log_step(self) -> None:\n        '''Construct a log message for a set and log it to the UI.'''\n        pass\n    def skipped(self) -> bool:\n        '''Shortcut for ``set_status(SKIPPED)``.'''\n        pass\n    def submitted(self) -> bool:\n        '''Shortcut for ``set_status(SUBMITTED)``.'''\n        pass\n    @classmethod\n    def from_stack_name(cls, stack_name: str, context: CfnginContext, requires: list[str] | set[str] | None=None, fn: Callable[..., Status] | None=None, watch_func: Callable[..., Any] | None=None) -> Step:\n        '''Create a step using only a stack name.\n        Args:\n            stack_name: Name of a CloudFormation stack.\n            context: Context object. Required to initialize a \"fake\"\n                :class:`runway.cfngin.stack.Stack`.\n            requires: Stacks that this stack depends on.\n            fn: The function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: an optional function that will be called to \"tail\" the\n                step action.\n        '''\n        pass\n    @classmethod\n    def from_persistent_graph(cls, graph_dict: dict[str, list[str]] | dict[str, set[str]] | OrderedDict[str, set[str]], context: CfnginContext, fn: Callable[..., Status] | None=None, watch_func: Callable[..., Any] | None=None) -> list[Step]:\n        '''Create a steps for a persistent graph dict.\n        Args:\n            graph_dict: A graph dict.\n            context: Context object. Required to initialize a \"fake\"\n                :class:`runway.cfngin.stack.Stack`.\n            requires: Stacks that this stack depends on.\n            fn: The function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: an optional function that will be called to \"tail\" the\n                step action.\n        '''\n        pass\n\n    def __repr__(self) -> str:\n        '''Object represented as a string.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Object displayed as a string.'''\n        pass\nCorresponding class implementation:\n\nfrom .status import COMPLETE, FAILED, PENDING, SKIPPED, SUBMITTED, FailedStatus, SkippedStatus\nimport time\nfrom .ui import ui\nfrom .._logging import LogLevels, PrefixAdaptor\nimport threading\nfrom .exceptions import CancelExecution, GraphError, PersistentGraphLocked, PlanFailed\nfrom .stack import Stack\nfrom typing import TYPE_CHECKING, Any, Callable, NoReturn, TypeVar, overload\n\nclass Step:\n    \"\"\"State machine for executing generic actions related to stacks.\n\n    Attributes:\n        fn: Function to run to execute the step.\n            This function will be ran multiple times until the step is \"done\".\n        last_updated: Time when the step was last updated.\n        logger: Logger for logging messages about the step.\n        stack: the stack associated with this step\n        status: The status of step.\n        watch_func: Function that will be called to \"tail\" the step action.\n\n    \"\"\"\n    fn: Callable[..., Any] | None\n    last_updated: float\n    logger: PrefixAdaptor\n    stack: Stack\n    status: Status\n    watch_func: Callable[..., Any] | None\n\n    def __init__(self, stack: Stack, *, fn: Callable[..., Any] | None=None, watch_func: Callable[..., Any] | None=None) -> None:\n        \"\"\"Instantiate class.\n\n        Args:\n            stack: The stack associated\n                with this step\n            fn: Function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: Function that will be called to \"tail\" the step action.\n\n        \"\"\"\n        self.stack = stack\n        self.status = PENDING\n        self.last_updated = time.time()\n        self.logger = PrefixAdaptor(self.stack.name, LOGGER)\n        self.fn = fn\n        self.watch_func = watch_func\n\n    def run(self) -> bool:\n        \"\"\"Run this step until it has completed or been skipped.\"\"\"\n        stop_watcher = threading.Event()\n        watcher = None\n        if self.watch_func:\n            watcher = threading.Thread(target=self.watch_func, args=(self.stack, stop_watcher))\n            watcher.start()\n        try:\n            while not self.done:\n                self._run_once()\n        finally:\n            if watcher:\n                stop_watcher.set()\n                watcher.join()\n        return self.ok\n\n    def _run_once(self) -> Status:\n        \"\"\"Run a step exactly once.\"\"\"\n        if not self.fn:\n            raise TypeError('Step.fn must be type Callable[..., Status] not None')\n        try:\n            status = self.fn(self.stack, status=self.status)\n        except CancelExecution:\n            status = SkippedStatus('canceled execution')\n        except Exception as err:\n            LOGGER.exception(err)\n            status = FailedStatus(reason=str(err))\n        self.set_status(status)\n        return status\n\n    @property\n    def name(self) -> str:\n        \"\"\"Name of the step.\n\n        This is equal to the name of the stack it operates on.\n\n        \"\"\"\n        return self.stack.name\n\n    @property\n    def requires(self) -> set[str]:\n        \"\"\"Return a list of step names this step depends on.\"\"\"\n        return self.stack.requires\n\n    @property\n    def required_by(self) -> set[str]:\n        \"\"\"Return a list of step names that depend on this step.\"\"\"\n        return self.stack.required_by\n\n    @property\n    def completed(self) -> bool:\n        \"\"\"Return True if the step is in a COMPLETE state.\"\"\"\n        return self.status == COMPLETE\n\n    @property\n    def skipped(self) -> bool:\n        \"\"\"Return True if the step is in a SKIPPED state.\"\"\"\n        return self.status == SKIPPED\n\n    @property\n    def failed(self) -> bool:\n        \"\"\"Return True if the step is in a FAILED state.\"\"\"\n        return self.status == FAILED\n\n    @property\n    def done(self) -> bool:\n        \"\"\"Return True if the step is finished.\n\n        To be ``True``, status must be either COMPLETE, SKIPPED or FAILED)\n\n        \"\"\"\n        return self.completed or self.skipped or self.failed\n\n    @property\n    def ok(self) -> bool:\n        \"\"\"Return True if the step is finished (either COMPLETE or SKIPPED).\"\"\"\n        return self.completed or self.skipped\n\n    @property\n    def submitted(self) -> bool:\n        \"\"\"Return True if the step is SUBMITTED, COMPLETE, or SKIPPED.\"\"\"\n        return self.status >= SUBMITTED\n\n    def set_status(self, status: Status) -> None:\n        \"\"\"Set the current step's status.\n\n        Args:\n            status: The status to set the step to.\n\n        \"\"\"\n        if status is not self.status:\n            LOGGER.debug('setting %s state to %s...', self.stack.name, status.name)\n            self.status = status\n            self.last_updated = time.time()\n            if self.stack.logging:\n                self.log_step()\n\n    def complete(self) -> None:\n        \"\"\"Shortcut for ``set_status(COMPLETE)``.\"\"\"\n        self.set_status(COMPLETE)\n\n    def log_step(self) -> None:\n        \"\"\"Construct a log message for a set and log it to the UI.\"\"\"\n        msg = self.status.name\n        if self.status.reason:\n            msg += f' ({self.status.reason})'\n        if self.status.code == SUBMITTED.code:\n            ui.log(LogLevels.NOTICE, msg, logger=self.logger)\n        elif self.status.code == COMPLETE.code:\n            ui.log(LogLevels.SUCCESS, msg, logger=self.logger)\n        elif self.status.code == FAILED.code:\n            ui.log(LogLevels.ERROR, msg, logger=self.logger)\n        else:\n            ui.info(msg, logger=self.logger)\n\n    def skip(self) -> None:\n        \"\"\"Shortcut for ``set_status(SKIPPED)``.\"\"\"\n        self.set_status(SKIPPED)\n\n    def submit(self) -> None:\n        \"\"\"Shortcut for ``set_status(SUBMITTED)``.\"\"\"\n        self.set_status(SUBMITTED)\n\n    @classmethod\n    def from_stack_name(cls, stack_name: str, context: CfnginContext, requires: list[str] | set[str] | None=None, fn: Callable[..., Status] | None=None, watch_func: Callable[..., Any] | None=None) -> Step:\n        \"\"\"Create a step using only a stack name.\n\n        Args:\n            stack_name: Name of a CloudFormation stack.\n            context: Context object. Required to initialize a \"fake\"\n                :class:`runway.cfngin.stack.Stack`.\n            requires: Stacks that this stack depends on.\n            fn: The function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: an optional function that will be called to \"tail\" the\n                step action.\n\n        \"\"\"\n        from runway.config.models.cfngin import CfnginStackDefinitionModel\n        stack_def = CfnginStackDefinitionModel.model_construct(name=stack_name, requires=requires or [])\n        stack = Stack(stack_def, context)\n        return cls(stack, fn=fn, watch_func=watch_func)\n\n    @classmethod\n    def from_persistent_graph(cls, graph_dict: dict[str, list[str]] | dict[str, set[str]] | OrderedDict[str, set[str]], context: CfnginContext, fn: Callable[..., Status] | None=None, watch_func: Callable[..., Any] | None=None) -> list[Step]:\n        \"\"\"Create a steps for a persistent graph dict.\n\n        Args:\n            graph_dict: A graph dict.\n            context: Context object. Required to initialize a \"fake\"\n                :class:`runway.cfngin.stack.Stack`.\n            requires: Stacks that this stack depends on.\n            fn: The function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: an optional function that will be called to \"tail\" the\n                step action.\n\n        \"\"\"\n        return [cls.from_stack_name(name, context, requires, fn, watch_func) for name, requires in graph_dict.items()]\n\n    def __repr__(self) -> str:\n        \"\"\"Object represented as a string.\"\"\"\n        return f'<CFNgin.plan.Step:{self.stack.name}>'\n\n    def __str__(self) -> str:\n        \"\"\"Object displayed as a string.\"\"\"\n        return self.stack.name\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass OutputMappingValidator:\n    '''Validates and fixes output mappings in Arazzo workflows.'''\n    @staticmethod\n    def validate_output_mappings(workflow: dict[str, Any], openapi_spec: dict[str, Any], endpoints: dict[str, dict[str, Any]]) -> dict[str, Any]:\n        '''Validate and fix output mappings in a workflow.\n        This function checks all output mappings in a workflow against the\n        corresponding response schemas from the OpenAPI spec and fixes any\n        inconsistencies.\n        Args:\n            workflow: The workflow to validate.\n            openapi_spec: The OpenAPI specification.\n            endpoints: Dictionary of endpoints from the OpenAPI parser.\n        Returns:\n            The validated and fixed workflow.\n        '''\n        pass\n    @staticmethod\n    def _get_endpoint_for_step(step: dict[str, Any], endpoints: dict[str, dict[str, Any]]) -> dict[str, Any] | None:\n        '''Get the endpoint data for a step.\n        Args:\n            step: The step to get the endpoint for.\n            endpoints: Dictionary of endpoints from the OpenAPI parser.\n        Returns:\n            The endpoint data or None if not found.\n        '''\n        pass\n    @staticmethod\n    def _extract_response_info(endpoint_data: dict[str, Any]) -> tuple[dict[str, Any], dict[str, Any]]:\n        '''Extract response schema and headers from endpoint data.\n        Args:\n            endpoint_data: The endpoint data from the OpenAPI parser.\n        Returns:\n            A tuple of (response_schema, response_headers).\n        '''\n        pass\n    @staticmethod\n    def _validate_step_outputs(outputs: dict[str, str], schema: dict[str, Any], headers: dict[str, Any]) -> dict[str, str]:\n        '''Validate and fix output mappings for a step.\n        Args:\n            outputs: The output mappings to validate.\n            schema: The response schema.\n            headers: The response headers.\n        Returns:\n            The validated and fixed output mappings.\n        '''\n        pass\n    @staticmethod\n    def _normalize_property_path(path: str) -> str:\n        '''Normalize a property path by removing array indices.\n        Args:\n            path: The property path to normalize.\n        Returns:\n            The normalized property path.\n        '''\n        pass\n    @staticmethod\n    def _find_best_match(target: str, candidates: list[str]) -> str | None:\n        '''Find the best matching string from a list of candidates using sequence matching.\n        Args:\n            target: The target string to match.\n            candidates: List of candidate strings.\n        Returns:\n            The best matching string or None if candidates is empty.\n        '''\n        pass\n    @staticmethod\n    def _find_best_property_match(output_name: str, flat_schema: dict[str, str]) -> str | None:\n        '''Find the best matching property in the schema for an output name.\n        Args:\n            output_name: The output name provided by the LLM.\n            flat_schema: The flattened schema with property paths.\n        Returns:\n            The path to the matching property, or None if no match is found.\n        '''\n        pass\n    @staticmethod\n    def _flatten_schema(properties: dict[str, Any], prefix: str='') -> dict[str, str]:\n        '''Flatten a nested schema into a dictionary of property paths.\n        Args:\n            properties: The properties object from the schema.\n            prefix: The prefix for nested properties.\n        Returns:\n            A dictionary mapping property names to their paths.\n        '''\n        pass"
  }
]