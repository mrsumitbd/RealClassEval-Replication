[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass CatalogueFunctionRegistry(dict):\n    '''\n    A collection of methods/functions working on catalogues.\n    The registry also holds information about the type of the input arguments\n    '''\n\n    def check_config(self, config, fields_spec):\n        '''\n        Check that `config` has each field in `fields_spec` if a default\n        has not been provided.\n        '''\n        pass\n\n    def set_defaults(self, config, fields_spec):\n        '''\n        Set default values got from `fields_spec` into the `config`\n        dictionary\n        '''\n        pass\n\n    def add(self, method_name, completeness=False, **fields):\n        '''\n        Class decorator.\n        Decorate `method_name` by adding a call to `set_defaults` and\n        `check_config`. Then, save into the registry a callable\n        function with the same signature of the original method.\n        :param str method_name:\n            the method to decorate\n        :param bool completeness:\n            True if the method accepts in input an optional parameter\n            for the completeness table\n        :param fields:\n            a dictionary of field spec corresponding to the\n            keys expected to be present in the config dictionary\n            for the decorated method, e.g.\n            time_bin=float,\n            b_value=1E-6\n        '''\n        pass\n\n        def class_decorator(class_obj):\n                pass\n\n            def caller(fn, obj, catalogue, config=None, *args, **kwargs):\n                        pass\n\n    def add_function(self, completeness=False, **fields):\n        '''\n        Function decorator.\n        Decorate a function by adding a call to `set_defaults` and\n        `check_config`. Then, save into the registry a callable\n        function with the same signature of the original method\n        :param fields:\n            a dictionary of field spec, e.g.\n            time_bin=float,\n            b_value=1E-6\n        '''\n        pass\n\n        def dec(fn):\n                pass\n\n                def fn_with_config_and_c(catalogue, config, completeness_table=None):\n                                pass\n\n                def fn_with_config_without_c(catalogue, config):\n                                pass\nCorresponding class implementation:\n\nimport sys\nfrom decorator import decorator\nimport functools\n\nclass CatalogueFunctionRegistry(dict):\n    \"\"\"\n    A collection of methods/functions working on catalogues.\n\n    The registry also holds information about the type of the input arguments\n    \"\"\"\n\n    def check_config(self, config, fields_spec):\n        \"\"\"\n        Check that `config` has each field in `fields_spec` if a default\n        has not been provided.\n        \"\"\"\n        for field, type_info in fields_spec.items():\n            has_default = not isinstance(type_info, type)\n            if field not in config and (not has_default):\n                raise RuntimeError('Configuration not complete. %s missing' % field)\n\n    def set_defaults(self, config, fields_spec):\n        \"\"\"\n        Set default values got from `fields_spec` into the `config`\n        dictionary\n        \"\"\"\n        defaults = dict([(f, d) for f, d in fields_spec.items() if not isinstance(d, type)])\n        for field, default_value in defaults.items():\n            if field not in config:\n                config[field] = default_value\n\n    def add(self, method_name, completeness=False, **fields):\n        \"\"\"\n        Class decorator.\n\n        Decorate `method_name` by adding a call to `set_defaults` and\n        `check_config`. Then, save into the registry a callable\n        function with the same signature of the original method.\n\n        :param str method_name:\n            the method to decorate\n        :param bool completeness:\n            True if the method accepts in input an optional parameter\n            for the completeness table\n        :param fields:\n            a dictionary of field spec corresponding to the\n            keys expected to be present in the config dictionary\n            for the decorated method, e.g.\n            time_bin=float,\n            b_value=1E-6\n        \"\"\"\n\n        def class_decorator(class_obj):\n            original_method = getattr(class_obj, method_name)\n            if sys.version[0] == '2':\n                original_method = original_method.im_func\n\n            def caller(fn, obj, catalogue, config=None, *args, **kwargs):\n                config = config or {}\n                self.set_defaults(config, fields)\n                self.check_config(config, fields)\n                return fn(obj, catalogue, config, *args, **kwargs)\n            new_method = decorator(caller, original_method)\n            setattr(class_obj, method_name, new_method)\n            instance = class_obj()\n            func = functools.partial(new_method, instance)\n            func.fields = fields\n            func.model = instance\n            func.completeness = completeness\n            functools.update_wrapper(func, new_method)\n            self[class_obj.__name__] = func\n            return class_obj\n        return class_decorator\n\n    def add_function(self, completeness=False, **fields):\n        \"\"\"\n        Function decorator.\n\n        Decorate a function by adding a call to `set_defaults` and\n        `check_config`. Then, save into the registry a callable\n        function with the same signature of the original method\n\n        :param fields:\n            a dictionary of field spec, e.g.\n            time_bin=float,\n            b_value=1E-6\n        \"\"\"\n\n        def dec(fn):\n            if completeness:\n\n                def fn_with_config_and_c(catalogue, config, completeness_table=None):\n                    return fn(catalogue, completeness_table, **config)\n                fn_with_config = fn_with_config_and_c\n            else:\n\n                def fn_with_config_without_c(catalogue, config):\n                    return fn(catalogue, **config)\n                fn_with_config = fn_with_config_without_c\n            fn_with_config.fields = fields\n            fn_with_config.completeness = completeness\n            fn.fields = fields\n            self[fn.__name__] = fn_with_config\n            return fn\n        return dec\n\nExample skeleton:\n\n\nclass DefaultsInformation(primitives.Struct):\n    '''\n    '''\n\n    def __init__(self, object_defaults=None):\n        '''\n        '''\n        pass\n    @property\n    def object_defaults(self):\n        pass\n    @object_defaults.setter\n    def object_defaults(self):\n        pass\n\n    def read(self, input_buffer, kmip_version=enums.KMIPVersion.KMIP_2_0):\n        '''\n        Read the data encoding the DefaultsInformation structure and decode it\n        into its constituent parts.\n        Args:\n            input_buffer (stream): A data stream containing encoded object\n                data, supporting a read method; usually a BytearrayStream\n                object.\n            kmip_version (KMIPVersion): An enumeration defining the KMIP\n                version with which the object will be decoded. Optional,\n                defaults to KMIP 2.0.\n        Raises:\n            InvalidKmipEncoding: Raised if the object defaults are missing\n                from the encoding.\n            VersionNotSupported: Raised when a KMIP version is provided that\n                does not support the DefaultsInformation structure.\n                                '''\n                                pass\n\n    def write(self, output_buffer, kmip_version=enums.KMIPVersion.KMIP_2_0):\n        '''\n        Write the DefaultsInformation structure encoding to the data stream.\n        Args:\n            output_buffer (stream): A data stream in which to encode\n                Attributes structure data, supporting a write method.\n            kmip_version (enum): A KMIPVersion enumeration defining the KMIP\n                version with which the object will be encoded. Optional,\n                defaults to KMIP 2.0.\n        Raises:\n            InvalidField: Raised if the object defaults field is not defined.\n            VersionNotSupported: Raised when a KMIP version is provided that\n                does not support the DefaultsInformation structure.\n                                '''\n                                pass\n\n    def __repr__(self):\n        pass\n\n    def __str__(self):\n        pass\n\n    def __eq__(self, other):\n        pass\n\n    def __ne__(self, other):\n        pass\nCorresponding class implementation:\n\nfrom kmip.core import primitives\nfrom kmip.core import enums\nfrom kmip.core import exceptions\nfrom kmip.core.utils import BytearrayStream\nfrom kmip.core import utils\n\nclass DefaultsInformation(primitives.Struct):\n    \"\"\"\n    \"\"\"\n\n    def __init__(self, object_defaults=None):\n        \"\"\"\n        \"\"\"\n        super(DefaultsInformation, self).__init__(tag=enums.Tags.DEFAULTS_INFORMATION)\n        self._object_defaults = None\n        self.object_defaults = object_defaults\n\n    @property\n    def object_defaults(self):\n        return self._object_defaults\n\n    @object_defaults.setter\n    def object_defaults(self, value):\n        if value is None:\n            self._object_defaults = None\n        elif isinstance(value, list):\n            object_defaults = []\n            for v in value:\n                if not isinstance(v, ObjectDefaults):\n                    raise TypeError('Object defaults must be a list of ObjectDefaults structures.')\n                else:\n                    object_defaults.append(v)\n            self._object_defaults = object_defaults\n        else:\n            raise TypeError('Object defaults must be a list of ObjectDefaults structures.')\n\n    def read(self, input_buffer, kmip_version=enums.KMIPVersion.KMIP_2_0):\n        \"\"\"\n        Read the data encoding the DefaultsInformation structure and decode it\n        into its constituent parts.\n\n        Args:\n            input_buffer (stream): A data stream containing encoded object\n                data, supporting a read method; usually a BytearrayStream\n                object.\n            kmip_version (KMIPVersion): An enumeration defining the KMIP\n                version with which the object will be decoded. Optional,\n                defaults to KMIP 2.0.\n\n        Raises:\n            InvalidKmipEncoding: Raised if the object defaults are missing\n                from the encoding.\n            VersionNotSupported: Raised when a KMIP version is provided that\n                does not support the DefaultsInformation structure.\n        \"\"\"\n        if kmip_version < enums.KMIPVersion.KMIP_2_0:\n            raise exceptions.VersionNotSupported('KMIP {} does not support the DefaultsInformation object.'.format(kmip_version.value))\n        super(DefaultsInformation, self).read(input_buffer, kmip_version=kmip_version)\n        local_buffer = utils.BytearrayStream(input_buffer.read(self.length))\n        object_defaults = []\n        while self.is_tag_next(enums.Tags.OBJECT_DEFAULTS, local_buffer):\n            object_default = ObjectDefaults()\n            object_default.read(local_buffer, kmip_version=kmip_version)\n            object_defaults.append(object_default)\n        if len(object_defaults) == 0:\n            raise exceptions.InvalidKmipEncoding('The DefaultsInformation encoding is missing the object defaults structure.')\n        else:\n            self._object_defaults = object_defaults\n        self.is_oversized(local_buffer)\n\n    def write(self, output_buffer, kmip_version=enums.KMIPVersion.KMIP_2_0):\n        \"\"\"\n        Write the DefaultsInformation structure encoding to the data stream.\n\n        Args:\n            output_buffer (stream): A data stream in which to encode\n                Attributes structure data, supporting a write method.\n            kmip_version (enum): A KMIPVersion enumeration defining the KMIP\n                version with which the object will be encoded. Optional,\n                defaults to KMIP 2.0.\n\n        Raises:\n            InvalidField: Raised if the object defaults field is not defined.\n            VersionNotSupported: Raised when a KMIP version is provided that\n                does not support the DefaultsInformation structure.\n        \"\"\"\n        if kmip_version < enums.KMIPVersion.KMIP_2_0:\n            raise exceptions.VersionNotSupported('KMIP {} does not support the DefaultsInformation object.'.format(kmip_version.value))\n        local_buffer = BytearrayStream()\n        if self._object_defaults:\n            for object_default in self._object_defaults:\n                object_default.write(local_buffer, kmip_version=kmip_version)\n        else:\n            raise exceptions.InvalidField('The DefaultsInformation structure is missing the object defaults field.')\n        self.length = local_buffer.length()\n        super(DefaultsInformation, self).write(output_buffer, kmip_version=kmip_version)\n        output_buffer.write(local_buffer.buffer)\n\n    def __repr__(self):\n        d = 'object_defaults={}'.format('{}'.format(repr(self.object_defaults)) if self.object_defaults else None)\n        return 'DefaultsInformation({})'.format(d)\n\n    def __str__(self):\n        d = '\"object_defaults\": {}'.format('[{}]'.format(', '.join([str(x) for x in self.object_defaults])) if self.object_defaults else None)\n        return '{' + d + '}'\n\n    def __eq__(self, other):\n        if isinstance(other, DefaultsInformation):\n            if self.object_defaults == other.object_defaults:\n                return True\n            else:\n                return False\n        else:\n            return NotImplemented\n\n    def __ne__(self, other):\n        if isinstance(other, DefaultsInformation):\n            return not self == other\n        else:\n            return NotImplemented\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass CheckFactory:\n    '''\n    Factory for dynamic check instantiation from configuration dictionaries.\n    Orchestrates the complete process of transforming raw configuration data into\n    executable check instances, including type resolution, parameter validation,\n    and proper instantiation. The factory leverages the CheckConfigRegistry to\n    maintain loose coupling between check implementations and their configurations.\n    This design enables flexible deployment scenarios where validation rules can\n    be externally defined and dynamically loaded from various sources including\n    configuration files, databases, or API endpoints.\n    '''\n    @staticmethod\n    def _from_dict(config_data: Dict[str, Any]) -> BaseCheck:\n        '''\n        Instantiate a check from a raw configuration dictionary.\n        Processes a configuration dictionary through the complete validation and\n        instantiation pipeline, including check type resolution, parameter validation,\n        and severity normalization. This method serves as the core transformation\n        point between external configuration sources and executable check instances.\n        Args:\n            config_data (Dict[str, Any]): Raw configuration dictionary containing\n                check type specification and all required parameters.\n        Returns:\n            BaseCheck: Fully validated and configured check instance ready for execution.\n        Raises:\n            MissingCheckTypeError: When the configuration lacks the required\n                'check' field for type identification.\n            ValidationError: When the configuration parameters fail validation\n                against the resolved check configuration schema.\n        '''\n        pass\n    @staticmethod\n    def from_list(config_list: List[Dict[str, Any]]) -> List[BaseCheck]:\n        '''\n        Instantiate multiple checks from a collection of configuration dictionaries.\n        Processes a collection of configuration dictionaries through the complete\n        validation and instantiation pipeline, enabling efficient bulk loading\n        from external configuration sources. This method ensures all check\n        implementations are properly registered before processing begins.\n        Args:\n            config_list (List[Dict[str, Any]]): Collection of configuration\n                dictionaries, each defining a complete check specification.\n        Returns:\n            List[BaseCheck]: Collection of fully validated and configured check\n                instances ready for execution.\n        '''\n        pass"
  }
]