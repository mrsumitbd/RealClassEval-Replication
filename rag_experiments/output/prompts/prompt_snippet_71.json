[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Step:\n    '''State machine for executing generic actions related to stacks.\n    Attributes:\n        fn: Function to run to execute the step.\n            This function will be ran multiple times until the step is \"done\".\n        last_updated: Time when the step was last updated.\n        logger: Logger for logging messages about the step.\n        stack: the stack associated with this step\n        status: The status of step.\n        watch_func: Function that will be called to \"tail\" the step action.\n    '''\n\n    def __init__(self, stack: Stack, *, fn: Callable[..., Any] | None=None, watch_func: Callable[..., Any] | None=None) -> None:\n        '''Instantiate class.\n        Args:\n            stack: The stack associated\n                with this step\n            fn: Function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: Function that will be called to \"tail\" the step action.\n        '''\n        pass\n\n    def run(self) -> bool:\n        '''Run this step until it has completed or been skipped.'''\n        pass\n\n    def _run_once(self) -> Status:\n        '''Run a step exactly once.'''\n        pass\n    @property\n    def name(self) -> str:\n        '''Name of the step.\n        This is equal to the name of the stack it operates on.\n        '''\n        pass\n    @property\n    def requires(self) -> set[str]:\n        '''Return a list of step names this step depends on.'''\n        pass\n    @property\n    def required_by(self) -> set[str]:\n        '''Return a list of step names that depend on this step.'''\n        pass\n    @property\n    def completed(self) -> bool:\n        '''Return True if the step is in a COMPLETE state.'''\n        pass\n    @property\n    def skipped(self) -> bool:\n        '''Return True if the step is in a SKIPPED state.'''\n        pass\n    @property\n    def failed(self) -> bool:\n        '''Return True if the step is in a FAILED state.'''\n        pass\n    @property\n    def done(self) -> bool:\n        '''Return True if the step is finished.\n        To be ``True``, status must be either COMPLETE, SKIPPED or FAILED)\n        '''\n        pass\n    @property\n    def ok(self) -> bool:\n        '''Return True if the step is finished (either COMPLETE or SKIPPED).'''\n        pass\n    @property\n    def submitted(self) -> bool:\n        '''Return True if the step is SUBMITTED, COMPLETE, or SKIPPED.'''\n        pass\n\n    def set_status(self, status: Status) -> None:\n        '''Set the current step's status.\n        Args:\n            status: The status to set the step to.\n        '''\n        pass\n    def completed(self) -> bool:\n        '''Shortcut for ``set_status(COMPLETE)``.'''\n        pass\n\n    def log_step(self) -> None:\n        '''Construct a log message for a set and log it to the UI.'''\n        pass\n    def skipped(self) -> bool:\n        '''Shortcut for ``set_status(SKIPPED)``.'''\n        pass\n    def submitted(self) -> bool:\n        '''Shortcut for ``set_status(SUBMITTED)``.'''\n        pass\n    @classmethod\n    def from_stack_name(cls, stack_name: str, context: CfnginContext, requires: list[str] | set[str] | None=None, fn: Callable[..., Status] | None=None, watch_func: Callable[..., Any] | None=None) -> Step:\n        '''Create a step using only a stack name.\n        Args:\n            stack_name: Name of a CloudFormation stack.\n            context: Context object. Required to initialize a \"fake\"\n                :class:`runway.cfngin.stack.Stack`.\n            requires: Stacks that this stack depends on.\n            fn: The function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: an optional function that will be called to \"tail\" the\n                step action.\n        '''\n        pass\n    @classmethod\n    def from_persistent_graph(cls, graph_dict: dict[str, list[str]] | dict[str, set[str]] | OrderedDict[str, set[str]], context: CfnginContext, fn: Callable[..., Status] | None=None, watch_func: Callable[..., Any] | None=None) -> list[Step]:\n        '''Create a steps for a persistent graph dict.\n        Args:\n            graph_dict: A graph dict.\n            context: Context object. Required to initialize a \"fake\"\n                :class:`runway.cfngin.stack.Stack`.\n            requires: Stacks that this stack depends on.\n            fn: The function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: an optional function that will be called to \"tail\" the\n                step action.\n        '''\n        pass\n\n    def __repr__(self) -> str:\n        '''Object represented as a string.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Object displayed as a string.'''\n        pass\nCorresponding class implementation:\n\nfrom .status import COMPLETE, FAILED, PENDING, SKIPPED, SUBMITTED, FailedStatus, SkippedStatus\nimport time\nfrom .ui import ui\nfrom .._logging import LogLevels, PrefixAdaptor\nimport threading\nfrom .exceptions import CancelExecution, GraphError, PersistentGraphLocked, PlanFailed\nfrom .stack import Stack\nfrom typing import TYPE_CHECKING, Any, Callable, NoReturn, TypeVar, overload\n\nclass Step:\n    \"\"\"State machine for executing generic actions related to stacks.\n\n    Attributes:\n        fn: Function to run to execute the step.\n            This function will be ran multiple times until the step is \"done\".\n        last_updated: Time when the step was last updated.\n        logger: Logger for logging messages about the step.\n        stack: the stack associated with this step\n        status: The status of step.\n        watch_func: Function that will be called to \"tail\" the step action.\n\n    \"\"\"\n    fn: Callable[..., Any] | None\n    last_updated: float\n    logger: PrefixAdaptor\n    stack: Stack\n    status: Status\n    watch_func: Callable[..., Any] | None\n\n    def __init__(self, stack: Stack, *, fn: Callable[..., Any] | None=None, watch_func: Callable[..., Any] | None=None) -> None:\n        \"\"\"Instantiate class.\n\n        Args:\n            stack: The stack associated\n                with this step\n            fn: Function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: Function that will be called to \"tail\" the step action.\n\n        \"\"\"\n        self.stack = stack\n        self.status = PENDING\n        self.last_updated = time.time()\n        self.logger = PrefixAdaptor(self.stack.name, LOGGER)\n        self.fn = fn\n        self.watch_func = watch_func\n\n    def run(self) -> bool:\n        \"\"\"Run this step until it has completed or been skipped.\"\"\"\n        stop_watcher = threading.Event()\n        watcher = None\n        if self.watch_func:\n            watcher = threading.Thread(target=self.watch_func, args=(self.stack, stop_watcher))\n            watcher.start()\n        try:\n            while not self.done:\n                self._run_once()\n        finally:\n            if watcher:\n                stop_watcher.set()\n                watcher.join()\n        return self.ok\n\n    def _run_once(self) -> Status:\n        \"\"\"Run a step exactly once.\"\"\"\n        if not self.fn:\n            raise TypeError('Step.fn must be type Callable[..., Status] not None')\n        try:\n            status = self.fn(self.stack, status=self.status)\n        except CancelExecution:\n            status = SkippedStatus('canceled execution')\n        except Exception as err:\n            LOGGER.exception(err)\n            status = FailedStatus(reason=str(err))\n        self.set_status(status)\n        return status\n\n    @property\n    def name(self) -> str:\n        \"\"\"Name of the step.\n\n        This is equal to the name of the stack it operates on.\n\n        \"\"\"\n        return self.stack.name\n\n    @property\n    def requires(self) -> set[str]:\n        \"\"\"Return a list of step names this step depends on.\"\"\"\n        return self.stack.requires\n\n    @property\n    def required_by(self) -> set[str]:\n        \"\"\"Return a list of step names that depend on this step.\"\"\"\n        return self.stack.required_by\n\n    @property\n    def completed(self) -> bool:\n        \"\"\"Return True if the step is in a COMPLETE state.\"\"\"\n        return self.status == COMPLETE\n\n    @property\n    def skipped(self) -> bool:\n        \"\"\"Return True if the step is in a SKIPPED state.\"\"\"\n        return self.status == SKIPPED\n\n    @property\n    def failed(self) -> bool:\n        \"\"\"Return True if the step is in a FAILED state.\"\"\"\n        return self.status == FAILED\n\n    @property\n    def done(self) -> bool:\n        \"\"\"Return True if the step is finished.\n\n        To be ``True``, status must be either COMPLETE, SKIPPED or FAILED)\n\n        \"\"\"\n        return self.completed or self.skipped or self.failed\n\n    @property\n    def ok(self) -> bool:\n        \"\"\"Return True if the step is finished (either COMPLETE or SKIPPED).\"\"\"\n        return self.completed or self.skipped\n\n    @property\n    def submitted(self) -> bool:\n        \"\"\"Return True if the step is SUBMITTED, COMPLETE, or SKIPPED.\"\"\"\n        return self.status >= SUBMITTED\n\n    def set_status(self, status: Status) -> None:\n        \"\"\"Set the current step's status.\n\n        Args:\n            status: The status to set the step to.\n\n        \"\"\"\n        if status is not self.status:\n            LOGGER.debug('setting %s state to %s...', self.stack.name, status.name)\n            self.status = status\n            self.last_updated = time.time()\n            if self.stack.logging:\n                self.log_step()\n\n    def complete(self) -> None:\n        \"\"\"Shortcut for ``set_status(COMPLETE)``.\"\"\"\n        self.set_status(COMPLETE)\n\n    def log_step(self) -> None:\n        \"\"\"Construct a log message for a set and log it to the UI.\"\"\"\n        msg = self.status.name\n        if self.status.reason:\n            msg += f' ({self.status.reason})'\n        if self.status.code == SUBMITTED.code:\n            ui.log(LogLevels.NOTICE, msg, logger=self.logger)\n        elif self.status.code == COMPLETE.code:\n            ui.log(LogLevels.SUCCESS, msg, logger=self.logger)\n        elif self.status.code == FAILED.code:\n            ui.log(LogLevels.ERROR, msg, logger=self.logger)\n        else:\n            ui.info(msg, logger=self.logger)\n\n    def skip(self) -> None:\n        \"\"\"Shortcut for ``set_status(SKIPPED)``.\"\"\"\n        self.set_status(SKIPPED)\n\n    def submit(self) -> None:\n        \"\"\"Shortcut for ``set_status(SUBMITTED)``.\"\"\"\n        self.set_status(SUBMITTED)\n\n    @classmethod\n    def from_stack_name(cls, stack_name: str, context: CfnginContext, requires: list[str] | set[str] | None=None, fn: Callable[..., Status] | None=None, watch_func: Callable[..., Any] | None=None) -> Step:\n        \"\"\"Create a step using only a stack name.\n\n        Args:\n            stack_name: Name of a CloudFormation stack.\n            context: Context object. Required to initialize a \"fake\"\n                :class:`runway.cfngin.stack.Stack`.\n            requires: Stacks that this stack depends on.\n            fn: The function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: an optional function that will be called to \"tail\" the\n                step action.\n\n        \"\"\"\n        from runway.config.models.cfngin import CfnginStackDefinitionModel\n        stack_def = CfnginStackDefinitionModel.model_construct(name=stack_name, requires=requires or [])\n        stack = Stack(stack_def, context)\n        return cls(stack, fn=fn, watch_func=watch_func)\n\n    @classmethod\n    def from_persistent_graph(cls, graph_dict: dict[str, list[str]] | dict[str, set[str]] | OrderedDict[str, set[str]], context: CfnginContext, fn: Callable[..., Status] | None=None, watch_func: Callable[..., Any] | None=None) -> list[Step]:\n        \"\"\"Create a steps for a persistent graph dict.\n\n        Args:\n            graph_dict: A graph dict.\n            context: Context object. Required to initialize a \"fake\"\n                :class:`runway.cfngin.stack.Stack`.\n            requires: Stacks that this stack depends on.\n            fn: The function to run to execute the step.\n                This function will be ran multiple times until the step is \"done\".\n            watch_func: an optional function that will be called to \"tail\" the\n                step action.\n\n        \"\"\"\n        return [cls.from_stack_name(name, context, requires, fn, watch_func) for name, requires in graph_dict.items()]\n\n    def __repr__(self) -> str:\n        \"\"\"Object represented as a string.\"\"\"\n        return f'<CFNgin.plan.Step:{self.stack.name}>'\n\n    def __str__(self) -> str:\n        \"\"\"Object displayed as a string.\"\"\"\n        return self.stack.name\n\nExample skeleton:\n\n\nclass RefLog(List[RefLogEntry], Serializable):\n    '''A reflog contains :class:`RefLogEntry`\\s, each of which defines a certain state\n    of the head in question. Custom query methods allow to retrieve log entries by date\n    or by other criteria.\n    Reflog entries are ordered. The first added entry is first in the list. The last\n    entry, i.e. the last change of the head or reference, is last in the list.\n    '''\n\n    def __new__(cls, filepath: Union[PathLike, None]=None) -> 'RefLog':\n        pass\n\n    def __init__(self, filepath: Union[PathLike, None]=None) -> None:\n        '''Initialize this instance with an optional filepath, from which we will\n        initialize our data. The path is also used to write changes back using the\n        :meth:`write` method.'''\n        pass\n\n    def _read_from_file(self) -> None:\n        pass\n    @classmethod\n    def from_file(cls, filepath: PathLike) -> 'RefLog':\n        '''\n        :return:\n            A new :class:`RefLog` instance containing all entries from the reflog at the\n            given `filepath`.\n        :param filepath:\n            Path to reflog.\n        :raise ValueError:\n            If the file could not be read or was corrupted in some way.\n        '''\n        pass\n    @classmethod\n    def path(cls, ref: 'SymbolicReference') -> str:\n        '''\n        :return:\n            String to absolute path at which the reflog of the given ref instance would\n            be found. The path is not guaranteed to point to a valid file though.\n        :param ref:\n            :class:`~git.refs.symbolic.SymbolicReference` instance\n        '''\n        pass\n    @classmethod\n    def iter_entries(cls, stream: Union[str, 'BytesIO', mmap]) -> Iterator[RefLogEntry]:\n        '''\n        :return:\n            Iterator yielding :class:`RefLogEntry` instances, one for each line read\n            from the given stream.\n        :param stream:\n            File-like object containing the revlog in its native format or string\n            instance pointing to a file to read.\n        '''\n        pass\n    @classmethod\n    def entry_at(cls, filepath: PathLike, index: int) -> 'RefLogEntry':\n        '''\n        :return:\n            :class:`RefLogEntry` at the given index.\n        :param filepath:\n            Full path to the index file from which to read the entry.\n        :param index:\n            Python list compatible index, i.e. it may be negative to specify an entry\n            counted from the end of the list.\n        :raise IndexError:\n            If the entry didn't exist.\n        :note:\n            This method is faster as it only parses the entry at index, skipping all\n            other lines. Nonetheless, the whole file has to be read if the index is\n            negative.\n        '''\n        pass\n\n    def to_file(self, filepath: PathLike) -> None:\n        '''Write the contents of the reflog instance to a file at the given filepath.\n        :param filepath:\n            Path to file. Parent directories are assumed to exist.\n        '''\n        pass\n    @classmethod\n    def append_entry(cls, config_reader: Union[Actor, 'GitConfigParser', 'SectionConstraint', None], filepath: PathLike, oldbinsha: bytes, newbinsha: bytes, message: str, write: bool=True) -> 'RefLogEntry':\n        '''Append a new log entry to the revlog at filepath.\n        :param config_reader:\n            Configuration reader of the repository - used to obtain user information.\n            May also be an :class:`~git.util.Actor` instance identifying the committer\n            directly or ``None``.\n        :param filepath:\n            Full path to the log file.\n        :param oldbinsha:\n            Binary sha of the previous commit.\n        :param newbinsha:\n            Binary sha of the current commit.\n        :param message:\n            Message describing the change to the reference.\n        :param write:\n            If ``True``, the changes will be written right away.\n            Otherwise the change will not be written.\n        :return:\n            :class:`RefLogEntry` objects which was appended to the log.\n        :note:\n            As we are append-only, concurrent access is not a problem as we do not\n            interfere with readers.\n        '''\n        pass\n\n    def write(self) -> 'RefLog':\n        '''Write this instance's data to the file we are originating from.\n        :return:\n            self\n        '''\n        pass\n\n    def _serialize(self, stream: 'BytesIO') -> 'RefLog':\n        pass\n\n    def _deserialize(self, stream: 'BytesIO') -> 'RefLog':\n        pass\nCorresponding class implementation:\n\nfrom git.types import PathLike\nfrom mmap import mmap\nfrom typing import Iterator, List, Tuple, TYPE_CHECKING, Union\nfrom git.compat import defenc\nfrom git.util import Actor, LockedFD, LockFile, assure_directory_exists, bin_to_hex, file_contents_ro_filepath, to_native_path\nimport time as _time\nimport os.path as osp\nfrom git.objects.util import Serializable, altz_to_utctz_str, parse_date\n\nclass RefLog(List[RefLogEntry], Serializable):\n    \"\"\"A reflog contains :class:`RefLogEntry`\\\\s, each of which defines a certain state\n    of the head in question. Custom query methods allow to retrieve log entries by date\n    or by other criteria.\n\n    Reflog entries are ordered. The first added entry is first in the list. The last\n    entry, i.e. the last change of the head or reference, is last in the list.\n    \"\"\"\n    __slots__ = ('_path',)\n\n    def __new__(cls, filepath: Union[PathLike, None]=None) -> 'RefLog':\n        inst = super().__new__(cls)\n        return inst\n\n    def __init__(self, filepath: Union[PathLike, None]=None) -> None:\n        \"\"\"Initialize this instance with an optional filepath, from which we will\n        initialize our data. The path is also used to write changes back using the\n        :meth:`write` method.\"\"\"\n        self._path = filepath\n        if filepath is not None:\n            self._read_from_file()\n\n    def _read_from_file(self) -> None:\n        try:\n            fmap = file_contents_ro_filepath(self._path, stream=True, allow_mmap=True)\n        except OSError:\n            return\n        try:\n            self._deserialize(fmap)\n        finally:\n            fmap.close()\n\n    @classmethod\n    def from_file(cls, filepath: PathLike) -> 'RefLog':\n        \"\"\"\n        :return:\n            A new :class:`RefLog` instance containing all entries from the reflog at the\n            given `filepath`.\n\n        :param filepath:\n            Path to reflog.\n\n        :raise ValueError:\n            If the file could not be read or was corrupted in some way.\n        \"\"\"\n        return cls(filepath)\n\n    @classmethod\n    def path(cls, ref: 'SymbolicReference') -> str:\n        \"\"\"\n        :return:\n            String to absolute path at which the reflog of the given ref instance would\n            be found. The path is not guaranteed to point to a valid file though.\n\n        :param ref:\n            :class:`~git.refs.symbolic.SymbolicReference` instance\n        \"\"\"\n        return osp.join(ref.repo.git_dir, 'logs', to_native_path(ref.path))\n\n    @classmethod\n    def iter_entries(cls, stream: Union[str, 'BytesIO', mmap]) -> Iterator[RefLogEntry]:\n        \"\"\"\n        :return:\n            Iterator yielding :class:`RefLogEntry` instances, one for each line read\n            from the given stream.\n\n        :param stream:\n            File-like object containing the revlog in its native format or string\n            instance pointing to a file to read.\n        \"\"\"\n        new_entry = RefLogEntry.from_line\n        if isinstance(stream, str):\n            _stream = file_contents_ro_filepath(stream)\n            assert isinstance(_stream, mmap)\n        else:\n            _stream = stream\n        while True:\n            line = _stream.readline()\n            if not line:\n                return\n            yield new_entry(line.strip())\n\n    @classmethod\n    def entry_at(cls, filepath: PathLike, index: int) -> 'RefLogEntry':\n        \"\"\"\n        :return:\n            :class:`RefLogEntry` at the given index.\n\n        :param filepath:\n            Full path to the index file from which to read the entry.\n\n        :param index:\n            Python list compatible index, i.e. it may be negative to specify an entry\n            counted from the end of the list.\n\n        :raise IndexError:\n            If the entry didn't exist.\n\n        :note:\n            This method is faster as it only parses the entry at index, skipping all\n            other lines. Nonetheless, the whole file has to be read if the index is\n            negative.\n        \"\"\"\n        with open(filepath, 'rb') as fp:\n            if index < 0:\n                return RefLogEntry.from_line(fp.readlines()[index].strip())\n            for i in range(index + 1):\n                line = fp.readline()\n                if not line:\n                    raise IndexError(f'Index file ended at line {i + 1}, before given index was reached')\n            return RefLogEntry.from_line(line.strip())\n\n    def to_file(self, filepath: PathLike) -> None:\n        \"\"\"Write the contents of the reflog instance to a file at the given filepath.\n\n        :param filepath:\n            Path to file. Parent directories are assumed to exist.\n        \"\"\"\n        lfd = LockedFD(filepath)\n        assure_directory_exists(filepath, is_file=True)\n        fp = lfd.open(write=True, stream=True)\n        try:\n            self._serialize(fp)\n            lfd.commit()\n        except BaseException:\n            lfd.rollback()\n            raise\n\n    @classmethod\n    def append_entry(cls, config_reader: Union[Actor, 'GitConfigParser', 'SectionConstraint', None], filepath: PathLike, oldbinsha: bytes, newbinsha: bytes, message: str, write: bool=True) -> 'RefLogEntry':\n        \"\"\"Append a new log entry to the revlog at filepath.\n\n        :param config_reader:\n            Configuration reader of the repository - used to obtain user information.\n            May also be an :class:`~git.util.Actor` instance identifying the committer\n            directly or ``None``.\n\n        :param filepath:\n            Full path to the log file.\n\n        :param oldbinsha:\n            Binary sha of the previous commit.\n\n        :param newbinsha:\n            Binary sha of the current commit.\n\n        :param message:\n            Message describing the change to the reference.\n\n        :param write:\n            If ``True``, the changes will be written right away.\n            Otherwise the change will not be written.\n\n        :return:\n            :class:`RefLogEntry` objects which was appended to the log.\n\n        :note:\n            As we are append-only, concurrent access is not a problem as we do not\n            interfere with readers.\n        \"\"\"\n        if len(oldbinsha) != 20 or len(newbinsha) != 20:\n            raise ValueError('Shas need to be given in binary format')\n        assure_directory_exists(filepath, is_file=True)\n        first_line = message.split('\\n')[0]\n        if isinstance(config_reader, Actor):\n            committer = config_reader\n        else:\n            committer = Actor.committer(config_reader)\n        entry = RefLogEntry((bin_to_hex(oldbinsha).decode('ascii'), bin_to_hex(newbinsha).decode('ascii'), committer, (int(_time.time()), _time.altzone), first_line))\n        if write:\n            lf = LockFile(filepath)\n            lf._obtain_lock_or_raise()\n            fd = open(filepath, 'ab')\n            try:\n                fd.write(entry.format().encode(defenc))\n            finally:\n                fd.close()\n                lf._release_lock()\n        return entry\n\n    def write(self) -> 'RefLog':\n        \"\"\"Write this instance's data to the file we are originating from.\n\n        :return:\n            self\n        \"\"\"\n        if self._path is None:\n            raise ValueError('Instance was not initialized with a path, use to_file(...) instead')\n        self.to_file(self._path)\n        return self\n\n    def _serialize(self, stream: 'BytesIO') -> 'RefLog':\n        write = stream.write\n        for e in self:\n            write(e.format().encode(defenc))\n        return self\n\n    def _deserialize(self, stream: 'BytesIO') -> 'RefLog':\n        self.extend(self.iter_entries(stream))\n        return self\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n@dataclass\nclass HookEvent:\n    '''Base class for all hook events.\n    Attributes:\n        agent: The agent instance that triggered this event.\n    '''\n    @property\n    def should_reverse_callbacks(self) -> bool:\n        '''Determine if callbacks for this event should be invoked in reverse order.\n        Returns:\n            False by default. Override to return True for events that should\n            invoke callbacks in reverse order (e.g., cleanup/teardown events).\n        '''\n        pass\n\n    def _can_write(self, name: str) -> bool:\n        '''Check if the given property can be written to.\n        Args:\n            name: The name of the property to check.\n        Returns:\n            True if the property can be written to, False otherwise.\n        '''\n        pass\n\n    def __post_init__(self) -> None:\n        '''Disallow writes to non-approved properties.'''\n        pass\n\n    def __setattr__(self, name: str, value: Any) -> None:\n        '''Prevent setting attributes on hook events.\n        Raises:\n            AttributeError: Always raised to prevent setting attributes on hook events.\n        '''\n        pass"
  }
]