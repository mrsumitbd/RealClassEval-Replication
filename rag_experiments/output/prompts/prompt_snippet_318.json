[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass MockEngine:\n    '''\n    ``MockEngine`` represents the low-level mocking engine abstraction\n    layer between ``pook`` and the underlying mocking mechanism\n    responsible of intercepting and trigger outgoing HTTP traffic within\n    the Python runtime.\n    ``MockEngine`` implements the built-in `pook` mock engine based on HTTP\n    interceptors strategy.\n    Developers can implement and plug in their own ``MockEngine`` in order\n    to fit custom mocking logic needs.\n    You can see a custom ``MockEngine`` implementation here:\n    http://bit.ly/2EymMro\n    Custom mock engines must implementent at least the following methods:\n    - `engine.__init__(self, engine)`\n    - `engine.activate(self)`\n    - `engine.disable(self)`\n    Custom mock engines can optionally implement the following methods:\n    - `engine.add_interceptors(self, *interceptors)`\n    - `engine.flush_interceptors(self)`\n    - `engine.disable_interceptor(self, name) -> bool`\n    Arguments:\n        engine (pook.Engine): injected pook engine to be used.\n    Attributes:\n        engine (pook.Engine): stores pook engine to be used.\n        interceptors (list[pook.BaseInterceptor]): stores engine-level HTTP\n            traffic interceptors.\n    '''\n\n    def __init__(self, engine):\n        pass\n\n    def add_interceptor(self, *interceptors):\n        '''\n        Adds one or multiple HTTP traffic interceptors to the current\n        mocking engine.\n        Interceptors are typically HTTP client specific wrapper classes that\n        implements the pook interceptor interface.\n        Arguments:\n            interceptors (pook.interceptors.BaseInterceptor)\n        '''\n        pass\n\n    def flush_interceptors(self):\n        '''\n        Flushes registered interceptors in the current mocking engine.\n        This method is low-level. Only call it if you know what you are doing.\n        '''\n        pass\n\n    def remove_interceptor(self, name):\n        '''\n        Removes a specific interceptor by name.\n        Arguments:\n            name (str): interceptor name to disable.\n        Returns:\n            bool: `True` if the interceptor was disabled, otherwise `False`.\n        '''\n        pass\n\n    def activate(self):\n        '''\n        Activates the registered interceptors in the mocking engine.\n        This means any HTTP traffic captures by those interceptors will\n        trigger the HTTP mock matching engine in order to determine if a given\n        HTTP transaction should be mocked out or not.\n        '''\n        pass\n\n    def disable(self):\n        '''\n        Disables interceptors and stops intercepting any outgoing HTTP traffic.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom .interceptors import interceptors\n\nclass MockEngine:\n    \"\"\"\n    ``MockEngine`` represents the low-level mocking engine abstraction\n    layer between ``pook`` and the underlying mocking mechanism\n    responsible of intercepting and trigger outgoing HTTP traffic within\n    the Python runtime.\n\n    ``MockEngine`` implements the built-in `pook` mock engine based on HTTP\n    interceptors strategy.\n\n    Developers can implement and plug in their own ``MockEngine`` in order\n    to fit custom mocking logic needs.\n\n    You can see a custom ``MockEngine`` implementation here:\n    http://bit.ly/2EymMro\n\n    Custom mock engines must implementent at least the following methods:\n\n    - `engine.__init__(self, engine)`\n    - `engine.activate(self)`\n    - `engine.disable(self)`\n\n    Custom mock engines can optionally implement the following methods:\n\n    - `engine.add_interceptors(self, *interceptors)`\n    - `engine.flush_interceptors(self)`\n    - `engine.disable_interceptor(self, name) -> bool`\n\n    Arguments:\n        engine (pook.Engine): injected pook engine to be used.\n\n    Attributes:\n        engine (pook.Engine): stores pook engine to be used.\n        interceptors (list[pook.BaseInterceptor]): stores engine-level HTTP\n            traffic interceptors.\n    \"\"\"\n\n    def __init__(self, engine):\n        self.engine = engine\n        self.interceptors = []\n        self.add_interceptor(*interceptors)\n\n    def add_interceptor(self, *interceptors):\n        \"\"\"\n        Adds one or multiple HTTP traffic interceptors to the current\n        mocking engine.\n\n        Interceptors are typically HTTP client specific wrapper classes that\n        implements the pook interceptor interface.\n\n        Arguments:\n            interceptors (pook.interceptors.BaseInterceptor)\n        \"\"\"\n        for interceptor in interceptors:\n            self.interceptors.append(interceptor(self.engine))\n\n    def flush_interceptors(self):\n        \"\"\"\n        Flushes registered interceptors in the current mocking engine.\n\n        This method is low-level. Only call it if you know what you are doing.\n        \"\"\"\n        self.interceptors = []\n\n    def remove_interceptor(self, name):\n        \"\"\"\n        Removes a specific interceptor by name.\n\n        Arguments:\n            name (str): interceptor name to disable.\n\n        Returns:\n            bool: `True` if the interceptor was disabled, otherwise `False`.\n        \"\"\"\n        for index, interceptor in enumerate(self.interceptors):\n            matches = type(interceptor).__name__ == name or interceptor.name == name\n            if matches:\n                self.interceptors.pop(index)\n                return True\n        return False\n\n    def activate(self):\n        \"\"\"\n        Activates the registered interceptors in the mocking engine.\n\n        This means any HTTP traffic captures by those interceptors will\n        trigger the HTTP mock matching engine in order to determine if a given\n        HTTP transaction should be mocked out or not.\n        \"\"\"\n        [interceptor.activate() for interceptor in self.interceptors]\n\n    def disable(self):\n        \"\"\"\n        Disables interceptors and stops intercepting any outgoing HTTP traffic.\n        \"\"\"\n        for interceptor in self.interceptors:\n            try:\n                interceptor.disable()\n            except RuntimeError:\n                pass\n\nExample skeleton:\n\nclass SessionManager(object):\n    '''Base class for session management for RiveScript.\n    The session manager keeps track of getting and setting user variables,\n    for example when the ``<set>`` or ``<get>`` tags are used in RiveScript\n    or when the API functions like ``set_uservar()`` are called.\n    By default RiveScript stores user sessions in memory and provides methods\n    to export and import them (e.g. to persist them when the bot shuts down\n    so they can be reloaded). If you'd prefer a more 'active' session storage,\n    for example one that puts user variables into a database or cache, you can\n    create your own session manager that extends this class and implements its\n    functions.\n    See the ``eg/sessions`` example from the source of rivescript-python at\n    https://github.com/aichaos/rivescript-python for an example.\n    The constructor takes no required parameters. You can feel free to define\n    ``__init__()`` however you need to.\n    '''\n\n    def set(self, username, args):\n        '''Set variables for a user.\n        Args:\n            username (str): The username to set variables for.\n            args (dict): Key/value pairs of variables to set for the user.\n                The values are usually strings, but they can be other types\n                as well (e.g. arrays or other dicts) for some internal data\n                structures such as input/reply history. A value of ``NoneType``\n                should indicate that the key should be deleted from the session\n                store.\n        '''\n        pass\n\n    def get(self, username, key):\n        '''Retrieve a stored variable for a user.\n        If the user doesn't exist, this should return ``None``. If the user\n        *does* exist, but the key does not, this should return the\n        string value ``\"undefined\"``.\n        Args:\n            username (str): The username to retrieve variables for.\n            key (str): The specific variable name to retrieve.\n        Returns:\n            str: The value of the requested key, \"undefined\", or ``NoneType``.\n        '''\n        pass\n\n    def get_any(self, username):\n        '''Retrieve all stored variables for a user.\n        If the user doesn't exist, this should return ``None``.\n        Args:\n            username (str): The username to retrieve variables for.\n        Returns:\n            dict: Key/value pairs of all stored data for the user, or ``NoneType``.\n        '''\n        pass\n\n    def get_all(self):\n        '''Retrieve all variables about all users.\n        This should return a dict of dicts, where the top level keys are the\n        usernames of every user your bot has data for, and the values are dicts\n        of key/value pairs of those users. For example::\n            { \"user1\": {\n                \"topic\": \"random\",\n                \"name\": \"Alice\",\n                },\n              \"user2\": {\n                \"topic\": \"random\",\n                \"name\": \"Bob\",\n                },\n            }\n        Returns:\n            dict\n        '''\n        pass\n\n    def reset(self, username):\n        '''Reset all variables stored about a particular user.\n        Args:\n            username (str): The username to flush all data for.\n        '''\n        pass\n\n    def reset_all(self):\n        '''Reset all variables for all users.'''\n        pass\n\n    def freeze(self, username):\n        '''Make a snapshot of the user's variables.\n        This should clone and store a snapshot of all stored variables for the\n        user, so that they can later be restored with ``thaw()``. This\n        implements the RiveScript ``freeze_uservars()`` method.\n        Args:\n            username (str): The username to freeze variables for.\n        '''\n        pass\n\n    def thaw(self, username, action='thaw'):\n        '''Restore the frozen snapshot of variables for a user.\n        This should replace *all* of a user's variables with the frozen copy\n        that was snapshotted with ``freeze()``. If there are no frozen\n        variables, this function should be a no-op (maybe issue a warning?)\n        Args:\n            username (str): The username to restore variables for.\n            action (str):\n                An action to perform on the variables. Valid options are:\n                * ``thaw``: Restore the variables and delete the frozen copy (default).\n                * ``discard``: Don't restore the variables, just delete the frozen copy.\n                * ``keep``: Restore the variables and keep the copy still.\n        '''\n        pass\n\n    def default_session(self):\n        '''The default session data for a new user.\n        You do not need to override this function. This returns a ``dict`` with\n        the default key/value pairs for new sessions. By default, the\n        session variables are as follows::\n            {\n                \"topic\": \"random\"\n            }\n        Returns:\n            dict: A dict of default key/value pairs for new user sessions.\n        '''\n        pass\nCorresponding class implementation:\n\nclass SessionManager(object):\n    \"\"\"Base class for session management for RiveScript.\n\n    The session manager keeps track of getting and setting user variables,\n    for example when the ``<set>`` or ``<get>`` tags are used in RiveScript\n    or when the API functions like ``set_uservar()`` are called.\n\n    By default RiveScript stores user sessions in memory and provides methods\n    to export and import them (e.g. to persist them when the bot shuts down\n    so they can be reloaded). If you'd prefer a more 'active' session storage,\n    for example one that puts user variables into a database or cache, you can\n    create your own session manager that extends this class and implements its\n    functions.\n\n    See the ``eg/sessions`` example from the source of rivescript-python at\n    https://github.com/aichaos/rivescript-python for an example.\n\n    The constructor takes no required parameters. You can feel free to define\n    ``__init__()`` however you need to.\n    \"\"\"\n\n    def set(self, username, args):\n        \"\"\"Set variables for a user.\n\n        Args:\n            username (str): The username to set variables for.\n            args (dict): Key/value pairs of variables to set for the user.\n                The values are usually strings, but they can be other types\n                as well (e.g. arrays or other dicts) for some internal data\n                structures such as input/reply history. A value of ``NoneType``\n                should indicate that the key should be deleted from the session\n                store.\n        \"\"\"\n        raise NotImplementedError\n\n    def get(self, username, key):\n        \"\"\"Retrieve a stored variable for a user.\n\n        If the user doesn't exist, this should return ``None``. If the user\n        *does* exist, but the key does not, this should return the\n        string value ``\"undefined\"``.\n\n        Args:\n            username (str): The username to retrieve variables for.\n            key (str): The specific variable name to retrieve.\n\n        Returns:\n            str: The value of the requested key, \"undefined\", or ``NoneType``.\n        \"\"\"\n        raise NotImplementedError\n\n    def get_any(self, username):\n        \"\"\"Retrieve all stored variables for a user.\n\n        If the user doesn't exist, this should return ``None``.\n\n        Args:\n            username (str): The username to retrieve variables for.\n\n        Returns:\n            dict: Key/value pairs of all stored data for the user, or ``NoneType``.\n        \"\"\"\n        raise NotImplementedError\n\n    def get_all(self):\n        \"\"\"Retrieve all variables about all users.\n\n        This should return a dict of dicts, where the top level keys are the\n        usernames of every user your bot has data for, and the values are dicts\n        of key/value pairs of those users. For example::\n\n            { \"user1\": {\n                \"topic\": \"random\",\n                \"name\": \"Alice\",\n                },\n              \"user2\": {\n                \"topic\": \"random\",\n                \"name\": \"Bob\",\n                },\n            }\n\n        Returns:\n            dict\n        \"\"\"\n        raise NotImplementedError\n\n    def reset(self, username):\n        \"\"\"Reset all variables stored about a particular user.\n\n        Args:\n            username (str): The username to flush all data for.\n        \"\"\"\n        raise NotImplementedError\n\n    def reset_all(self):\n        \"\"\"Reset all variables for all users.\"\"\"\n        raise NotImplementedError\n\n    def freeze(self, username):\n        \"\"\"Make a snapshot of the user's variables.\n\n        This should clone and store a snapshot of all stored variables for the\n        user, so that they can later be restored with ``thaw()``. This\n        implements the RiveScript ``freeze_uservars()`` method.\n\n        Args:\n            username (str): The username to freeze variables for.\n        \"\"\"\n        raise NotImplementedError\n\n    def thaw(self, username, action='thaw'):\n        \"\"\"Restore the frozen snapshot of variables for a user.\n\n        This should replace *all* of a user's variables with the frozen copy\n        that was snapshotted with ``freeze()``. If there are no frozen\n        variables, this function should be a no-op (maybe issue a warning?)\n\n        Args:\n            username (str): The username to restore variables for.\n            action (str):\n                An action to perform on the variables. Valid options are:\n\n                * ``thaw``: Restore the variables and delete the frozen copy (default).\n                * ``discard``: Don't restore the variables, just delete the frozen copy.\n                * ``keep``: Restore the variables and keep the copy still.\n        \"\"\"\n        raise NotImplementedError\n\n    def default_session(self):\n        \"\"\"The default session data for a new user.\n\n        You do not need to override this function. This returns a ``dict`` with\n        the default key/value pairs for new sessions. By default, the\n        session variables are as follows::\n\n            {\n                \"topic\": \"random\"\n            }\n\n        Returns:\n            dict: A dict of default key/value pairs for new user sessions.\n        \"\"\"\n        return dict(topic='random')\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass PluginAPI:\n    '''Provides a safe, dynamic, and decoupled interface for plugins to access core APIs.\n    An instance of this class is passed to each plugin upon its initialization\n    by the `PluginManager`. Plugins use this instance (typically `self.api`)\n    to call registered core functions (e.g., `self.api.start_server(...)`)\n    without needing to import them directly, thus avoiding circular dependencies\n    and promoting a cleaner architecture.\n    This class also provides methods for plugins to interact with the custom\n    plugin event system, allowing them to listen for and send events to\n    other plugins.\n    '''\n\n    def __init__(self, plugin_name: str, plugin_manager: 'PluginManager', app_context: Optional['AppContext']):\n        '''Initializes the PluginAPI instance for a specific plugin.\n        This constructor is called by the `PluginManager` when a plugin is\n        being loaded and instantiated.\n        Args:\n            plugin_name (str): The name of the plugin for which this API\n                instance is being created. This is used for logging and context.\n            plugin_manager (PluginManager): A reference to the `PluginManager`\n                instance. This is used to delegate custom event operations\n                (listening and sending) to the manager.\n            app_context (Optional[AppContext]): A reference to the global\n                application context, providing access to shared application state\n                and managers. This can be `None` during initial setup phases.\n        '''\n        pass\n    @property\n    def app_context(self) -> 'AppContext':\n        '''Provides direct access to the application's context.\n        This property returns the central `AppContext` object, which holds\n        instances of key application components like the `Settings` manager,\n        the `BedrockServerManager`, and the `PluginManager` itself.\n        Example:\n            ```python\n            # In a plugin method:\n            settings = self.api.app_context.settings\n            server_manager = self.api.app_context.manager\n            all_servers = server_manager.get_all_servers()\n            ```\n        Returns:\n            AppContext: The application context instance.\n        Raises:\n            RuntimeError: If the application context has not been set on this\n                `PluginAPI` instance yet. This would indicate an improper\n                initialization sequence in the application startup.\n        '''\n        pass\n\n    def __getattr__(self, name: str) -> Callable[..., Any]:\n        '''Dynamically retrieves a registered core API function when accessed as an attribute.\n        This magic method is the cornerstone of the API bridge's functionality.\n        When a plugin executes code like `self.api.some_function_name()`, Python\n        internally calls this `__getattr__` method with `name` set to\n        `'some_function_name'`. This method then looks up `name` in the\n        `_api_registry`.\n        It also inspects the signature of the retrieved function. If the function\n        has a parameter named `app_context`, this method automatically provides\n        the `AppContext` to it, simplifying the function's implementation for\n        both the core API and the plugin calling it.\n        Args:\n            name (str): The name of the attribute (API function) being accessed\n                by the plugin.\n        Returns:\n            Callable[..., Any]: The callable API function retrieved from the\n            `_api_registry` corresponding to the given `name`. If the function\n            expects an `app_context`, a partial function with the context already\n            bound is returned.\n        Raises:\n            AttributeError: If the function `name` has not been registered in\n                the `_api_registry`, indicating the plugin is trying to access\n                a non-existent or unavailable API function.\n        '''\n        pass\n\n    def list_available_apis(self) -> List[Dict[str, Any]]:\n        '''\n        Returns a detailed list of all registered API functions, including\n        their names, parameters, and documentation.\n        This method can be useful for plugins that need to introspect the\n        available core functionalities at runtime, or for debugging purposes\n        to verify which APIs are exposed and how to call them.\n        Returns:\n            List[Dict[str, Any]]: A list of dictionaries, where each dictionary\n            describes a registered API function.\n        '''\n        pass\n\n    def listen_for_event(self, event_name: str, callback: Callable[..., None]):\n        '''Registers a callback to be executed when a specific custom plugin event occurs.\n        This method allows a plugin to subscribe to custom events that may be\n        triggered by other plugins via `send_event()`. The `PluginManager`\n        handles the actual registration and dispatch of these events.\n        Args:\n            event_name (str): The unique name of the custom event to listen for\n                (e.g., \"myplugin:my_custom_event\"). It is a recommended practice\n                to namespace event names with the originating plugin's name or\n                a unique prefix to avoid collisions.\n            callback (Callable[..., None]): The function or method within the\n                listening plugin that should be called when the specified event\n                is triggered. This callback will receive any `*args` and\n                `**kwargs` passed during the `send_event` call, plus an\n                additional `_triggering_plugin` keyword argument (str)\n                indicating the name of the plugin that sent the event.\n        '''\n        pass\n\n    def send_event(self, event_name: str, *args: Any, **kwargs: Any):\n        '''Triggers a custom plugin event, notifying all registered listeners.\n        This method allows a plugin to broadcast a custom event to other plugins\n        that have registered a listener for it using `listen_for_event()`.\n        The `PluginManager` handles the dispatch of this event to all\n        subscribed callbacks.\n        Args:\n            event_name (str): The unique name of the custom event to trigger.\n                This should match the `event_name` used by listening plugins.\n            *args (Any): Positional arguments to pass to the event listeners'\n                callback functions.\n            **kwargs (Any): Keyword arguments to pass to the event listeners'\n                callback functions.\n        '''\n        pass\n\n    def get_plugin_html_pages(self) -> List[Dict[str, str]]:\n        '''\n        Retrieves a list of plugin routes that are tagged for HTML rendering.\n        This allows the main application (or other plugins, if appropriate)\n        to discover web pages provided by plugins that are intended to be\n        directly accessible or linked in a UI.\n        Returns:\n            List[Dict[str, str]]: A list of dictionaries, where each dictionary\n            contains 'name' and 'path' for a route tagged for HTML rendering.\n            The 'name' is a user-friendly display name for the link, and 'path'\n            is the URL path for the route.\n        '''\n        pass"
  }
]