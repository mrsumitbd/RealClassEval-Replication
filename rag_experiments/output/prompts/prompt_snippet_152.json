[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Trie(object):\n    '''\n    Trie/Aho-Corasick automaton.\n    '''\n\n    def __init__(self):\n        '''\n        Construct an empty trie\n        '''\n        pass\n\n    def __get_node(self, word):\n        '''\n        Private function retrieving a final node of trie\n        for given word\n        Returns node or None, if the trie doesn't contain the word.\n        '''\n        pass\n\n    def get(self, word, default=nil):\n        '''\n        Retrieves output value associated with word.\n        If there is no word returns default value,\n        and if default is not given rises KeyError.\n        '''\n        pass\n\n    def keys(self):\n        '''\n        Generator returning all keys (i.e. word) stored in trie\n        '''\n        pass\n\n    def values(self):\n        '''\n        Generator returning all values associated with words stored in a trie.\n        '''\n        pass\n\n    def items(self):\n        '''\n        Generator returning all keys and values stored in a trie.\n        '''\n        pass\n\n        def aux(node, s):\n                pass\n\n    def __len__(self):\n        '''\n        Calculates number of words in a trie.\n        '''\n        pass\n\n    def add_word(self, word, value):\n        '''\n        Adds word and associated value.\n        If word already exists, its value is replaced.\n        '''\n        pass\n\n    def clear(self):\n        '''\n        Clears trie.\n        '''\n        pass\n\n    def exists(self, word):\n        '''\n        Checks if whole word is present in the trie.\n        '''\n        pass\n\n    def match(self, word):\n        '''\n        Checks if word is a prefix of any existing word in the trie.\n        '''\n        pass\n\n    def make_automaton(self):\n        '''\n        Converts trie to Aho-Corasick automaton.\n        '''\n        pass\n\n    def iter(self, string):\n        '''\n        Generator performs Aho-Corasick search string algorithm, yielding\n        tuples containing two values:\n        - position in string\n        - outputs associated with matched strings\n        '''\n        pass\n\n    def iter_long(self, string):\n        '''\n        Generator performs a modified Aho-Corasick search string algorithm,\n        which maches only the longest word.\n        '''\n        pass\n\n    def find_all(self, string, callback):\n        '''\n        Wrapper on iter method, callback gets an iterator result\n        '''\n        pass\nCorresponding class implementation:\n\nfrom collections import deque\n\nclass Trie(object):\n    \"\"\"\n    Trie/Aho-Corasick automaton.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Construct an empty trie\n        \"\"\"\n        self.root = TrieNode('')\n\n    def __get_node(self, word):\n        \"\"\"\n        Private function retrieving a final node of trie\n        for given word\n\n        Returns node or None, if the trie doesn't contain the word.\n        \"\"\"\n        node = self.root\n        for c in word:\n            try:\n                node = node.children[c]\n            except KeyError:\n                return None\n        return node\n\n    def get(self, word, default=nil):\n        \"\"\"\n        Retrieves output value associated with word.\n\n        If there is no word returns default value,\n        and if default is not given rises KeyError.\n        \"\"\"\n        node = self.__get_node(word)\n        output = nil\n        if node:\n            output = node.output\n        if output is nil:\n            if default is nil:\n                raise KeyError(\"no key '%s'\" % word)\n            else:\n                return default\n        else:\n            return output\n\n    def keys(self):\n        \"\"\"\n        Generator returning all keys (i.e. word) stored in trie\n        \"\"\"\n        for key, _ in self.items():\n            yield key\n\n    def values(self):\n        \"\"\"\n        Generator returning all values associated with words stored in a trie.\n        \"\"\"\n        for _, value in self.items():\n            yield value\n\n    def items(self):\n        \"\"\"\n        Generator returning all keys and values stored in a trie.\n        \"\"\"\n        L = []\n\n        def aux(node, s):\n            s = s + node.char\n            if node.output is not nil:\n                L.append((s, node.output))\n            for child in node.children.values():\n                if child is not node:\n                    aux(child, s)\n        aux(self.root, '')\n        return iter(L)\n\n    def __len__(self):\n        \"\"\"\n        Calculates number of words in a trie.\n        \"\"\"\n        stack = deque()\n        stack.append(self.root)\n        n = 0\n        while stack:\n            node = stack.pop()\n            if node.output is not nil:\n                n += 1\n            for child in node.children.values():\n                stack.append(child)\n        return n\n\n    def add_word(self, word, value):\n        \"\"\"\n        Adds word and associated value.\n\n        If word already exists, its value is replaced.\n        \"\"\"\n        if not word:\n            return\n        node = self.root\n        for c in word:\n            try:\n                node = node.children[c]\n            except KeyError:\n                n = TrieNode(c)\n                node.children[c] = n\n                node = n\n        node.output = value\n\n    def clear(self):\n        \"\"\"\n        Clears trie.\n        \"\"\"\n        self.root = TrieNode('')\n\n    def exists(self, word):\n        \"\"\"\n        Checks if whole word is present in the trie.\n        \"\"\"\n        node = self.__get_node(word)\n        if node:\n            return bool(node.output != nil)\n        else:\n            return False\n\n    def match(self, word):\n        \"\"\"\n        Checks if word is a prefix of any existing word in the trie.\n        \"\"\"\n        return self.__get_node(word) is not None\n\n    def make_automaton(self):\n        \"\"\"\n        Converts trie to Aho-Corasick automaton.\n        \"\"\"\n        queue = deque()\n        for i in range(256):\n            c = chr(i)\n            if c in self.root.children:\n                node = self.root.children[c]\n                node.fail = self.root\n                queue.append(node)\n            else:\n                self.root.children[c] = self.root\n        while queue:\n            r = queue.popleft()\n            for node in r.children.values():\n                queue.append(node)\n                state = r.fail\n                while node.char not in state.children:\n                    state = state.fail\n                node.fail = state.children.get(node.char, self.root)\n\n    def iter(self, string):\n        \"\"\"\n        Generator performs Aho-Corasick search string algorithm, yielding\n        tuples containing two values:\n        - position in string\n        - outputs associated with matched strings\n        \"\"\"\n        state = self.root\n        for index, c in enumerate(string):\n            while c not in state.children:\n                state = state.fail\n            state = state.children.get(c, self.root)\n            tmp = state\n            output = []\n            while tmp is not nil:\n                if tmp.output is not nil:\n                    output.append(tmp.output)\n                tmp = tmp.fail\n            if output:\n                yield (index, output)\n\n    def iter_long(self, string):\n        \"\"\"\n        Generator performs a modified Aho-Corasick search string algorithm,\n        which maches only the longest word.\n\n        \"\"\"\n        state = self.root\n        last = None\n        index = 0\n        while index < len(string):\n            c = string[index]\n            if c in state.children:\n                state = state.children[c]\n                if state.output is not nil:\n                    last = (state.output, index)\n                index += 1\n            elif last:\n                yield last\n                index = last[1] + 1\n                state = self.root\n                last = None\n            else:\n                while c not in state.children:\n                    state = state.fail\n        if last:\n            yield last\n\n    def find_all(self, string, callback):\n        \"\"\"\n        Wrapper on iter method, callback gets an iterator result\n        \"\"\"\n        for index, output in self.iter(string):\n            callback(index, output)\n\nExample skeleton:\n\n\nclass Tag:\n    '''\n    Base Tag class for parsing and handling MT940 tag contents.\n        '''\n\n    def __init__(self) -> None:\n        pass\n\n    def parse(self, transactions: models.Transactions, value: str) -> dict[str, str | None]:\n        '''\n        Parses the given value using the Tag's pattern.\n        :param transactions: The transactions model instance.\n        :param value: The string value to parse.\n        :return: A dictionary of matched group values.\n        :raises RuntimeError: If parsing fails.\n        '''\n        pass\n\n    def _debug_partial_match(self, value: str) -> None:\n        '''\n        Helper function to debug partial matches against the pattern.\n        '''\n        pass\n\n    def __call__(self, transactions: models.Transactions, value: dict[str, typing.Any]) -> dict[str, typing.Any]:\n        '''\n        Processes the tag value and returns parsed content.\n        :param transactions: The transactions model instance.\n        :param value: The string value to process.\n        :return: The processed value, which can be a string or dict.\n        '''\n        pass\n\n    def __new__(cls, *args: typing.Any, **kwargs: typing.Any) -> Tag:\n        '''\n        Creates a new Tag instance and sets up logging details.\n        '''\n        pass\n\n    def __hash__(self) -> int:\n        '''\n        Returns a hash based on the tag's ID.\n        :return: The integer hash of the tag.\n        '''\n        pass\nCorresponding class implementation:\n\nimport logging\nimport re\nimport typing\nfrom . import models\n\nclass Tag:\n    \"\"\"\n    Base Tag class for parsing and handling MT940 tag contents.\n    \"\"\"\n    id: str | int = 0\n    RE_FLAGS = re.IGNORECASE | re.VERBOSE | re.UNICODE\n    scope: type[models.Transactions | models.Transaction] = models.Transactions\n    pattern: str\n    slug: str\n    logger: logging.Logger\n\n    def __init__(self) -> None:\n        self.re = re.compile(self.pattern, self.RE_FLAGS)\n\n    def parse(self, transactions: models.Transactions, value: str) -> dict[str, str | None]:\n        \"\"\"\n        Parses the given value using the Tag's pattern.\n\n        :param transactions: The transactions model instance.\n        :param value: The string value to parse.\n        :return: A dictionary of matched group values.\n        :raises RuntimeError: If parsing fails.\n        \"\"\"\n        match = self.re.match(value)\n        if match:\n            self.logger.debug('matched (%d) %r against \"%s\", got: %s', len(value), value, self.pattern, match.groupdict())\n            return match.groupdict()\n        else:\n            self.logger.error('matching id=%s (len=%d) \"%s\" against\\n    %s', self.id, len(value), value, self.pattern)\n            self._debug_partial_match(value)\n            raise RuntimeError(f'Unable to parse {self!r} from {value!r}', self, value)\n\n    def _debug_partial_match(self, value: str) -> None:\n        \"\"\"\n        Helper function to debug partial matches against the pattern.\n        \"\"\"\n        part_value = value\n        for pattern in self.pattern.split('\\n'):\n            match = re.match(pattern, part_value, self.RE_FLAGS)\n            if match:\n                self.logger.info('matched %r against %r, got: %s', pattern, match.group(0), match.groupdict())\n                part_value = part_value[len(match.group(0)):]\n            else:\n                self.logger.error('no match for %r against %r', pattern, part_value)\n\n    def __call__(self, transactions: models.Transactions, value: dict[str, typing.Any]) -> dict[str, typing.Any]:\n        \"\"\"\n        Processes the tag value and returns parsed content.\n\n        :param transactions: The transactions model instance.\n        :param value: The string value to process.\n        :return: The processed value, which can be a string or dict.\n        \"\"\"\n        return value\n\n    def __new__(cls, *args: typing.Any, **kwargs: typing.Any) -> Tag:\n        \"\"\"\n        Creates a new Tag instance and sets up logging details.\n        \"\"\"\n        cls.name = cls.__name__\n        words = re.findall('([A-Z][a-z]+)', cls.__name__)\n        cls.slug = '_'.join((w.lower() for w in words))\n        cls.logger = logger.getChild(cls.name)\n        return object.__new__(cls)\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Returns a hash based on the tag's ID.\n\n        :return: The integer hash of the tag.\n        \"\"\"\n        return hash(self.id) if isinstance(self.id, str) else self.id\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\nclass Trie:\n    '''\n    Trie data structure for efficient word and prefix lookups, optimized for the Word Hunt game.\n    '''\n\n    def __init__(self):\n        '''Initializes the Trie with an empty root node.'''\n        pass\n\n    def insert(self, word: str):\n        '''\n        Inserts a word into the Trie. Assumes word is already uppercase.\n        '''\n        pass\n\n    def is_word(self, word: str) -> bool:\n        '''\n        Searches for a complete word in the Trie. Assumes word is already uppercase.\n        '''\n        pass\n\n    def is_prefix(self, prefix: str) -> bool:\n        '''\n        Checks if a string is a prefix of any word in the Trie. Assumes prefix is already uppercase.\n        '''\n        pass"
  }
]