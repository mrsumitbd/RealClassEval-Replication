[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass _BaseOrderHelper:\n    '''Base class for ordering helpers.'''\n\n    def __init__(self, rows_dimension, measures, format=ORDER_FORMAT.SIGNED_INDEXES):\n        pass\n    @classmethod\n    def display_order(cls, rows_dimension, measures, format):\n        '''1D np.int64 ndarray of signed int idx for each row of stripe.\n        Negative values represent inserted-vector locations. Returned sequence reflects\n        insertion, hiding, pruning, and ordering transforms specified in the\n        rows-dimension.\n        '''\n        pass\n    @lazyproperty\n    def _display_order(self):\n        '''tuple of signed int idx for each row of stripe.\n        Negative values represent inserted-vector locations. Returned sequence reflects\n        insertion, hiding, pruning, and ordering transforms specified in the\n        rows-dimension.\n        '''\n        pass\n    @lazyproperty\n    def _empty_row_idxs(self):\n        '''tuple of int index for each row with N = 0.\n        These rows are subject to pruning, depending on a user setting in the dimension.\n        '''\n        pass\n    @lazyproperty\n    def _order_spec(self):\n        '''_OrderSpec object for the stripe dimension.\n        Provides access to ordering details like measure and sort-direction.\n        '''\n        pass\nCorresponding class implementation:\n\nfrom cr.cube.util import lazyproperty\nfrom cr.cube.enums import COLLATION_METHOD as CM, ORDER_FORMAT\n\nclass _BaseOrderHelper:\n    \"\"\"Base class for ordering helpers.\"\"\"\n\n    def __init__(self, rows_dimension, measures, format=ORDER_FORMAT.SIGNED_INDEXES):\n        self._rows_dimension = rows_dimension\n        self._measures = measures\n        self._format = format\n\n    @classmethod\n    def display_order(cls, rows_dimension, measures, format):\n        \"\"\"1D np.int64 ndarray of signed int idx for each row of stripe.\n\n        Negative values represent inserted-vector locations. Returned sequence reflects\n        insertion, hiding, pruning, and ordering transforms specified in the\n        rows-dimension.\n        \"\"\"\n        order_spec = rows_dimension.order_spec\n        HelperCls = _SortByMeasureHelper if order_spec.collation_method == CM.UNIVARIATE_MEASURE else _SortByLabelHelper if order_spec.collation_method == CM.LABEL else _OrderHelper\n        return HelperCls(rows_dimension, measures, format)._display_order\n\n    @lazyproperty\n    def _display_order(self):\n        \"\"\"tuple of signed int idx for each row of stripe.\n\n        Negative values represent inserted-vector locations. Returned sequence reflects\n        insertion, hiding, pruning, and ordering transforms specified in the\n        rows-dimension.\n        \"\"\"\n        raise NotImplementedError(f'`{type(self).__name__}` must implement `._display_order`')\n\n    @lazyproperty\n    def _empty_row_idxs(self):\n        \"\"\"tuple of int index for each row with N = 0.\n\n        These rows are subject to pruning, depending on a user setting in the dimension.\n        \"\"\"\n        return tuple((i for i, N in enumerate(self._measures.pruning_base) if N == 0))\n\n    @lazyproperty\n    def _order_spec(self):\n        \"\"\"_OrderSpec object for the stripe dimension.\n\n        Provides access to ordering details like measure and sort-direction.\n        \"\"\"\n        return self._rows_dimension.order_spec\n\nExample skeleton:\n\n@dataclass\nclass PressureSensor(ThresholdSensorType):\n    '''A pressure sensor type.'''\n    @classmethod\n    def build(cls, sensor_id: SensorId, node_id: NodeId, offset: float=0.0, zero_threshold: float=0.0, stop_threshold: float=0.0) -> 'PressureSensor':\n        '''Build a pressure sensor class.'''\n        pass\n\n    def set_sensor_data(self, sensor_data: List[SensorDataType]) -> SensorDataType:\n        '''Set the sensor data on the class and return the new data.'''\n        pass\nCorresponding class implementation:\n\nfrom typing import List, Union\nfrom opentrons_hardware.firmware_bindings.constants import NodeId, SensorId, SensorType\nfrom opentrons_hardware.firmware_bindings.messages.fields import SensorTypeField\nfrom opentrons_hardware.sensors.types import SensorDataType, EnvironmentSensorDataType\nfrom dataclasses import dataclass\n\n@dataclass\nclass PressureSensor(ThresholdSensorType):\n    \"\"\"A pressure sensor type.\"\"\"\n    data: SensorDataType\n\n    @classmethod\n    def build(cls, sensor_id: SensorId, node_id: NodeId, offset: float=0.0, zero_threshold: float=0.0, stop_threshold: float=0.0) -> 'PressureSensor':\n        \"\"\"Build a pressure sensor class.\"\"\"\n        info = SensorInformation(SensorType.pressure, sensor_id, node_id)\n        sensor_data = SensorDataType.build(0, SensorTypeField(SensorType.pressure))\n        return cls(info, offset, 1, zero_threshold, stop_threshold, sensor_data)\n\n    def set_sensor_data(self, sensor_data: List[SensorDataType]) -> SensorDataType:\n        \"\"\"Set the sensor data on the class and return the new data.\"\"\"\n        self.data = sensor_data[0]\n        return self.data\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n@dataclass(kw_only=True)\nclass DeformGradMixin:\n    '''Mixin for states that support deformation gradients.'''\n    @property\n    def reference_row_vector_cell(self) -> torch.Tensor:\n        '''Get the original unit cell in terms of row vectors.'''\n        pass\n    @reference_row_vector_cell.setter\n    def reference_row_vector_cell(self) -> torch.Tensor:\n        '''Set the original unit cell in terms of row vectors.'''\n        pass\n    @staticmethod\n    def _deform_grad(reference_row_vector_cell: torch.Tensor, row_vector_cell: torch.Tensor) -> torch.Tensor:\n        '''Calculate the deformation gradient from original cell to current cell.\n        Returns:\n            The deformation gradient\n        '''\n        pass\n\n    def deform_grad(self) -> torch.Tensor:\n        '''Calculate the deformation gradient from original cell to current cell.\n        Returns:\n            The deformation gradient\n        '''\n        pass"
  }
]