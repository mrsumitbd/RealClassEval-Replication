[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass CachedFeatureSet(CachedArtifactMixin, FeatureSetCore):\n    '''CachedFeatureSet: Caches the method results for Workbench FeatureSets\n    Note: Cached method values may lag underlying FeatureSet changes.\n    Common Usage:\n        ```python\n        my_features = CachedFeatureSet(name)\n        my_features.details()\n        my_features.health_check()\n        my_features.workbench_meta()\n        ```\n    '''\n\n    def __init__(self, feature_set_name: str, database: str='workbench'):\n        '''CachedFeatureSet Initialization'''\n        pass\n    @CachedArtifactMixin.cache_result\n    def summary(self, **kwargs) -> dict:\n        '''Retrieve the FeatureSet Details.\n        Returns:\n            dict: A dictionary of details about the FeatureSet\n        '''\n        pass\n    @CachedArtifactMixin.cache_result\n    def details(self, **kwargs) -> dict:\n        '''Retrieve the FeatureSet Details.\n        Returns:\n            dict: A dictionary of details about the FeatureSet\n        '''\n        pass\n    @CachedArtifactMixin.cache_result\n    def health_check(self, **kwargs) -> dict:\n        '''Retrieve the FeatureSet Health Check.\n        Returns:\n            dict: A dictionary of health check details for the FeatureSet\n        '''\n        pass\n    @CachedArtifactMixin.cache_result\n    def workbench_meta(self) -> Union[str, None]:\n        '''Retrieve the Workbench Metadata for this DataSource.\n        Returns:\n            Union[dict, None]: Dictionary of Workbench metadata for this Artifact\n        '''\n        pass\n    @CachedArtifactMixin.cache_result\n    def smart_sample(self) -> pd.DataFrame:\n        '''Retrieve the Smart Sample for this FeatureSet.\n        Returns:\n            pd.DataFrame: The Smart Sample DataFrame\n        '''\n        pass\nCorresponding class implementation:\n\nimport pandas as pd\nfrom typing import Union\nfrom workbench.core.artifacts.feature_set_core import FeatureSetCore\nfrom workbench.core.artifacts.cached_artifact_mixin import CachedArtifactMixin\n\nclass CachedFeatureSet(CachedArtifactMixin, FeatureSetCore):\n    \"\"\"CachedFeatureSet: Caches the method results for Workbench FeatureSets\n\n    Note: Cached method values may lag underlying FeatureSet changes.\n\n    Common Usage:\n        ```python\n        my_features = CachedFeatureSet(name)\n        my_features.details()\n        my_features.health_check()\n        my_features.workbench_meta()\n        ```\n    \"\"\"\n\n    def __init__(self, feature_set_name: str, database: str='workbench'):\n        \"\"\"CachedFeatureSet Initialization\"\"\"\n        FeatureSetCore.__init__(self, feature_set_name=feature_set_name, use_cached_meta=True)\n\n    @CachedArtifactMixin.cache_result\n    def summary(self, **kwargs) -> dict:\n        \"\"\"Retrieve the FeatureSet Details.\n\n        Returns:\n            dict: A dictionary of details about the FeatureSet\n        \"\"\"\n        return super().summary(**kwargs)\n\n    @CachedArtifactMixin.cache_result\n    def details(self, **kwargs) -> dict:\n        \"\"\"Retrieve the FeatureSet Details.\n\n        Returns:\n            dict: A dictionary of details about the FeatureSet\n        \"\"\"\n        return super().details(**kwargs)\n\n    @CachedArtifactMixin.cache_result\n    def health_check(self, **kwargs) -> dict:\n        \"\"\"Retrieve the FeatureSet Health Check.\n\n        Returns:\n            dict: A dictionary of health check details for the FeatureSet\n        \"\"\"\n        return super().health_check(**kwargs)\n\n    @CachedArtifactMixin.cache_result\n    def workbench_meta(self) -> Union[str, None]:\n        \"\"\"Retrieve the Workbench Metadata for this DataSource.\n\n        Returns:\n            Union[dict, None]: Dictionary of Workbench metadata for this Artifact\n        \"\"\"\n        return super().workbench_meta()\n\n    @CachedArtifactMixin.cache_result\n    def smart_sample(self) -> pd.DataFrame:\n        \"\"\"Retrieve the Smart Sample for this FeatureSet.\n\n        Returns:\n            pd.DataFrame: The Smart Sample DataFrame\n        \"\"\"\n        return super().smart_sample()\n\nExample skeleton:\n\nclass AnalyzersManager(object):\n    '''Class that implements the analyzers manager.'''\n    @classmethod\n    def DeregisterAnalyzer(cls, analyzer_class):\n        '''Deregisters a analyzer class.\n        The analyzer classes are identified based on their lower case name.\n        Args:\n          analyzer_class (type): class object of the analyzer.\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzersInformation(cls):\n        '''Retrieves the analyzers information.\n        Returns:\n          list[tuple]: containing:\n            str: analyzer name.\n            str: analyzer description.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzerInstance(cls, analyzer_name):\n        '''Retrieves an instance of a specific analyzer.\n        Args:\n          analyzer_name (str): name of the analyzer to retrieve.\n        Returns:\n          BaseAnalyzer: analyzer instance.\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzerInstances(cls, analyzer_names):\n        '''Retrieves instances for all the specified analyzers.\n        Args:\n          analyzer_names (list[str]): names of the analyzers to retrieve.\n        Returns:\n          list[BaseAnalyzer]: analyzer instances.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzerNames(cls):\n        '''Retrieves the names of all loaded analyzers.\n        Returns:\n          list[str]: of analyzer names.\n        '''\n        pass\n    @classmethod\n    def GetAnalyzersInformation(cls):\n        '''Retrieves the registered analyzers.\n        Yields:\n          tuple: containing:\n            str: the uniquely identifying name of the analyzer\n            type: the analyzer class.\n        '''\n        pass\n    @classmethod\n    def RegisterAnalyzer(cls, analyzer_class):\n        '''Registers a analyzer class.\n        The analyzer classes are identified by their lower case name.\n        Args:\n          analyzer_class (type): the analyzer class to register.\n        Raises:\n          KeyError: if analyzer class is already set for the corresponding name.\n        '''\n        pass\nCorresponding class implementation:\n\nclass AnalyzersManager(object):\n    \"\"\"Class that implements the analyzers manager.\"\"\"\n    _analyzer_classes = {}\n\n    @classmethod\n    def DeregisterAnalyzer(cls, analyzer_class):\n        \"\"\"Deregisters a analyzer class.\n\n        The analyzer classes are identified based on their lower case name.\n\n        Args:\n          analyzer_class (type): class object of the analyzer.\n\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        \"\"\"\n        analyzer_name = analyzer_class.NAME.lower()\n        if analyzer_name not in cls._analyzer_classes:\n            raise KeyError(f'analyzer class not set for name: {analyzer_class.NAME:s}')\n        del cls._analyzer_classes[analyzer_name]\n\n    @classmethod\n    def GetAnalyzersInformation(cls):\n        \"\"\"Retrieves the analyzers information.\n\n        Returns:\n          list[tuple]: containing:\n\n            str: analyzer name.\n            str: analyzer description.\n        \"\"\"\n        analyzer_information = []\n        for _, analyzer_class in cls.GetAnalyzers():\n            description = getattr(analyzer_class, 'DESCRIPTION', '')\n            analyzer_information.append((analyzer_class.NAME, description))\n        return analyzer_information\n\n    @classmethod\n    def GetAnalyzerInstance(cls, analyzer_name):\n        \"\"\"Retrieves an instance of a specific analyzer.\n\n        Args:\n          analyzer_name (str): name of the analyzer to retrieve.\n\n        Returns:\n          BaseAnalyzer: analyzer instance.\n\n        Raises:\n          KeyError: if analyzer class is not set for the corresponding name.\n        \"\"\"\n        analyzer_name = analyzer_name.lower()\n        if analyzer_name not in cls._analyzer_classes:\n            raise KeyError(f'analyzer class not set for name: {analyzer_name:s}.')\n        analyzer_class = cls._analyzer_classes[analyzer_name]\n        return analyzer_class()\n\n    @classmethod\n    def GetAnalyzerInstances(cls, analyzer_names):\n        \"\"\"Retrieves instances for all the specified analyzers.\n\n        Args:\n          analyzer_names (list[str]): names of the analyzers to retrieve.\n\n        Returns:\n          list[BaseAnalyzer]: analyzer instances.\n        \"\"\"\n        analyzer_instances = []\n        for analyzer_name, analyzer_class in cls.GetAnalyzers():\n            if analyzer_name in analyzer_names:\n                analyzer_instances.append(analyzer_class())\n        return analyzer_instances\n\n    @classmethod\n    def GetAnalyzerNames(cls):\n        \"\"\"Retrieves the names of all loaded analyzers.\n\n        Returns:\n          list[str]: of analyzer names.\n        \"\"\"\n        return cls._analyzer_classes.keys()\n\n    @classmethod\n    def GetAnalyzers(cls):\n        \"\"\"Retrieves the registered analyzers.\n\n        Yields:\n          tuple: containing:\n\n            str: the uniquely identifying name of the analyzer\n            type: the analyzer class.\n        \"\"\"\n        for analyzer_name, analyzer_class in cls._analyzer_classes.items():\n            yield (analyzer_name, analyzer_class)\n\n    @classmethod\n    def RegisterAnalyzer(cls, analyzer_class):\n        \"\"\"Registers a analyzer class.\n\n        The analyzer classes are identified by their lower case name.\n\n        Args:\n          analyzer_class (type): the analyzer class to register.\n\n        Raises:\n          KeyError: if analyzer class is already set for the corresponding name.\n        \"\"\"\n        analyzer_name = analyzer_class.NAME.lower()\n        if analyzer_name in cls._analyzer_classes:\n            raise KeyError(f'analyzer class already set for name: {analyzer_class.NAME:s}.')\n        cls._analyzer_classes[analyzer_name] = analyzer_class\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass CompetitionTemplate:\n    '''\n    CompetitionTemplate class for generating baseline competition attack prompts\n    across different competition categories: competitor mention, market manipulation,\n    discreditation, and confidential strategies.\n    '''\n    @staticmethod\n    def generate_baseline_attacks(vulnerability_type: CompetitionType, max_goldens: int, purpose: Optional[str]) -> str:\n        '''\n        Generate baseline attacks for the given competition vulnerability type.\n        Args:\n            vulnerability_type: Type of competition vulnerability\n            max_goldens: Maximum number of examples to generate\n            purpose: Context or purpose for generating the prompts\n        Returns:\n            Formatted prompt template string\n        '''\n        pass\n    @staticmethod\n    def generate_competitor_mention_baseline_attacks(max_goldens: int, purpose: Optional[str]) -> str:\n        '''\n        Generate a prompt for Competitor-mention vulnerabilities.\n        '''\n        pass\n    @staticmethod\n    def generate_market_manipulation_baseline_attacks(max_goldens: int, purpose: Optional[str]) -> str:\n        '''\n        Generate a prompt for Market-manipulation vulnerabilities.\n        '''\n        pass\n    @staticmethod\n    def generate_discreditation_baseline_attacks(max_goldens: int, purpose: Optional[str]) -> str:\n        '''\n        Generate a prompt for Discreditation vulnerabilities.\n        '''\n        pass\n    @staticmethod\n    def generate_confidential_strategies_baseline_attacks(max_goldens: int, purpose: Optional[str]) -> str:\n        '''\n        Generate a prompt for Confidential-strategy vulnerabilities.\n        '''\n        pass"
  }
]