[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass DefaultsInformation(primitives.Struct):\n    '''\n    '''\n\n    def __init__(self, object_defaults=None):\n        '''\n        '''\n        pass\n    @property\n    def object_defaults(self):\n        pass\n    @object_defaults.setter\n    def object_defaults(self):\n        pass\n\n    def read(self, input_buffer, kmip_version=enums.KMIPVersion.KMIP_2_0):\n        '''\n        Read the data encoding the DefaultsInformation structure and decode it\n        into its constituent parts.\n        Args:\n            input_buffer (stream): A data stream containing encoded object\n                data, supporting a read method; usually a BytearrayStream\n                object.\n            kmip_version (KMIPVersion): An enumeration defining the KMIP\n                version with which the object will be decoded. Optional,\n                defaults to KMIP 2.0.\n        Raises:\n            InvalidKmipEncoding: Raised if the object defaults are missing\n                from the encoding.\n            VersionNotSupported: Raised when a KMIP version is provided that\n                does not support the DefaultsInformation structure.\n                                '''\n                                pass\n\n    def write(self, output_buffer, kmip_version=enums.KMIPVersion.KMIP_2_0):\n        '''\n        Write the DefaultsInformation structure encoding to the data stream.\n        Args:\n            output_buffer (stream): A data stream in which to encode\n                Attributes structure data, supporting a write method.\n            kmip_version (enum): A KMIPVersion enumeration defining the KMIP\n                version with which the object will be encoded. Optional,\n                defaults to KMIP 2.0.\n        Raises:\n            InvalidField: Raised if the object defaults field is not defined.\n            VersionNotSupported: Raised when a KMIP version is provided that\n                does not support the DefaultsInformation structure.\n                                '''\n                                pass\n\n    def __repr__(self):\n        pass\n\n    def __str__(self):\n        pass\n\n    def __eq__(self, other):\n        pass\n\n    def __ne__(self, other):\n        pass\nCorresponding class implementation:\n\nfrom kmip.core import primitives\nfrom kmip.core import enums\nfrom kmip.core import exceptions\nfrom kmip.core.utils import BytearrayStream\nfrom kmip.core import utils\n\nclass DefaultsInformation(primitives.Struct):\n    \"\"\"\n    \"\"\"\n\n    def __init__(self, object_defaults=None):\n        \"\"\"\n        \"\"\"\n        super(DefaultsInformation, self).__init__(tag=enums.Tags.DEFAULTS_INFORMATION)\n        self._object_defaults = None\n        self.object_defaults = object_defaults\n\n    @property\n    def object_defaults(self):\n        return self._object_defaults\n\n    @object_defaults.setter\n    def object_defaults(self, value):\n        if value is None:\n            self._object_defaults = None\n        elif isinstance(value, list):\n            object_defaults = []\n            for v in value:\n                if not isinstance(v, ObjectDefaults):\n                    raise TypeError('Object defaults must be a list of ObjectDefaults structures.')\n                else:\n                    object_defaults.append(v)\n            self._object_defaults = object_defaults\n        else:\n            raise TypeError('Object defaults must be a list of ObjectDefaults structures.')\n\n    def read(self, input_buffer, kmip_version=enums.KMIPVersion.KMIP_2_0):\n        \"\"\"\n        Read the data encoding the DefaultsInformation structure and decode it\n        into its constituent parts.\n\n        Args:\n            input_buffer (stream): A data stream containing encoded object\n                data, supporting a read method; usually a BytearrayStream\n                object.\n            kmip_version (KMIPVersion): An enumeration defining the KMIP\n                version with which the object will be decoded. Optional,\n                defaults to KMIP 2.0.\n\n        Raises:\n            InvalidKmipEncoding: Raised if the object defaults are missing\n                from the encoding.\n            VersionNotSupported: Raised when a KMIP version is provided that\n                does not support the DefaultsInformation structure.\n        \"\"\"\n        if kmip_version < enums.KMIPVersion.KMIP_2_0:\n            raise exceptions.VersionNotSupported('KMIP {} does not support the DefaultsInformation object.'.format(kmip_version.value))\n        super(DefaultsInformation, self).read(input_buffer, kmip_version=kmip_version)\n        local_buffer = utils.BytearrayStream(input_buffer.read(self.length))\n        object_defaults = []\n        while self.is_tag_next(enums.Tags.OBJECT_DEFAULTS, local_buffer):\n            object_default = ObjectDefaults()\n            object_default.read(local_buffer, kmip_version=kmip_version)\n            object_defaults.append(object_default)\n        if len(object_defaults) == 0:\n            raise exceptions.InvalidKmipEncoding('The DefaultsInformation encoding is missing the object defaults structure.')\n        else:\n            self._object_defaults = object_defaults\n        self.is_oversized(local_buffer)\n\n    def write(self, output_buffer, kmip_version=enums.KMIPVersion.KMIP_2_0):\n        \"\"\"\n        Write the DefaultsInformation structure encoding to the data stream.\n\n        Args:\n            output_buffer (stream): A data stream in which to encode\n                Attributes structure data, supporting a write method.\n            kmip_version (enum): A KMIPVersion enumeration defining the KMIP\n                version with which the object will be encoded. Optional,\n                defaults to KMIP 2.0.\n\n        Raises:\n            InvalidField: Raised if the object defaults field is not defined.\n            VersionNotSupported: Raised when a KMIP version is provided that\n                does not support the DefaultsInformation structure.\n        \"\"\"\n        if kmip_version < enums.KMIPVersion.KMIP_2_0:\n            raise exceptions.VersionNotSupported('KMIP {} does not support the DefaultsInformation object.'.format(kmip_version.value))\n        local_buffer = BytearrayStream()\n        if self._object_defaults:\n            for object_default in self._object_defaults:\n                object_default.write(local_buffer, kmip_version=kmip_version)\n        else:\n            raise exceptions.InvalidField('The DefaultsInformation structure is missing the object defaults field.')\n        self.length = local_buffer.length()\n        super(DefaultsInformation, self).write(output_buffer, kmip_version=kmip_version)\n        output_buffer.write(local_buffer.buffer)\n\n    def __repr__(self):\n        d = 'object_defaults={}'.format('{}'.format(repr(self.object_defaults)) if self.object_defaults else None)\n        return 'DefaultsInformation({})'.format(d)\n\n    def __str__(self):\n        d = '\"object_defaults\": {}'.format('[{}]'.format(', '.join([str(x) for x in self.object_defaults])) if self.object_defaults else None)\n        return '{' + d + '}'\n\n    def __eq__(self, other):\n        if isinstance(other, DefaultsInformation):\n            if self.object_defaults == other.object_defaults:\n                return True\n            else:\n                return False\n        else:\n            return NotImplemented\n\n    def __ne__(self, other):\n        if isinstance(other, DefaultsInformation):\n            return not self == other\n        else:\n            return NotImplemented\n\nExample skeleton:\n\n\nclass ABI:\n    '''\n    This class contains methods to handle the ABI.\n    The Application Binary Interface is the standard way to interact with\n    contracts in the Ethereum ecosystem, both from outside the blockchain\n    and for contract-to-contract interaction.\n    '''\n    @staticmethod\n    def _type_size(ty):\n        '''Calculate `static` type size'''\n        pass\n    @staticmethod\n    def _check_and_warn_num_args(type_spec, *args):\n        pass\n    @staticmethod\n    def function_call(type_spec, *args):\n        '''\n        Build transaction data from function signature and arguments\n        '''\n        pass\n    @staticmethod\n    def serialize(ty, *values, **kwargs):\n        '''\n        Serialize value using type specification in ty.\n        ABI.serialize('int256', 1000)\n        ABI.serialize('(int, int256)', 1000, 2000)\n        '''\n        pass\n    @staticmethod\n    def _serialize(ty, value, dyn_offset=None):\n        pass\n    @staticmethod\n    def _serialize_bytes(value):\n        '''\n        Serializes the value and pads to multiple of 32 bytes\n        :param value:\n        :type value: str or bytearray or Array\n        '''\n        pass\n    @staticmethod\n    def _serialize_tuple(types, value, dyn_offset=None):\n        pass\n    @staticmethod\n    def _serialize_array(rep, base_type, value, dyn_offset=None):\n        pass\n    @staticmethod\n    def function_selector(method_name_and_signature):\n        '''\n        Makes a function hash id from a method signature\n        '''\n        pass\n    @staticmethod\n    def deserialize(type_spec, data):\n        pass\n    @staticmethod\n    def _deserialize(ty, buf: typing.Union[bytearray, bytes, Array], offset=0):\n        pass\n    @staticmethod\n    def _serialize_uint(value, size=32, padding=0):\n        '''\n        Translates a python integral or a BitVec into a 32 byte string, MSB first\n        '''\n        pass\n    @staticmethod\n    def _serialize_int(value: typing.Union[int, BitVec], size=32, padding=0):\n        '''\n        Translates a signed python integral or a BitVec into a 32 byte string, MSB first\n        '''\n        pass\n    @staticmethod\n    def _readBE(data, nbytes, padding=False, offset=0):\n        '''\n        :param data:\n        :param nbytes:\n        :param padding: If True, treat data as padded at the beginning to multiple of 32\n        :param offset:\n        :return:\n        '''\n        pass\n    @staticmethod\n    def _deserialize_uint(data: typing.Union[bytearray, bytes, Array], nbytes=32, padding=0, offset=0):\n        '''\n        Read a `nbytes` bytes long big endian unsigned integer from `data` starting at `offset`\n        :param data: sliceable buffer; symbolic buffer of Eth ABI encoded data\n        :param nbytes: number of bytes to read starting from least significant byte\n        :rtype: int or Expression\n        '''\n        pass\n    @staticmethod\n    def _deserialize_int(data: typing.Union[bytearray, bytes, Array], nbytes=32, padding=0):\n        '''\n        Read a `nbytes` bytes long big endian signed integer from `data` starting at `offset`\n        :param data: sliceable buffer; symbolic buffer of Eth ABI encoded data\n        :param nbytes: number of bytes to read starting from least significant byte\n        :rtype: int or Expression\n        '''\n        pass\nCorresponding class implementation:\n\nimport uuid\nimport sha3\nimport typing\nimport re\nfrom ..exceptions import EthereumError\nfrom ..core.smtlib import Array, Operators, BitVec, ArrayVariable, ArrayProxy, to_constant, issymbolic\nfrom . import abitypes\n\nclass ABI:\n    \"\"\"\n    This class contains methods to handle the ABI.\n    The Application Binary Interface is the standard way to interact with\n    contracts in the Ethereum ecosystem, both from outside the blockchain\n    and for contract-to-contract interaction.\n\n    \"\"\"\n\n    @staticmethod\n    def _type_size(ty):\n        \"\"\"Calculate `static` type size\"\"\"\n        if ty[0] in ('int', 'uint', 'bytesM', 'function'):\n            return 32\n        elif ty[0] in 'tuple':\n            result = 0\n            for ty_i in ty[1]:\n                result += ABI._type_size(ty_i)\n            return result\n        elif ty[0] in 'array':\n            rep = ty[1]\n            result = 32\n            return result\n        elif ty[0] in ('bytes', 'string'):\n            result = 32\n            return result\n        raise ValueError\n\n    @staticmethod\n    def _check_and_warn_num_args(type_spec, *args):\n        num_args = len(args)\n        no_declared_args = '()' in type_spec\n        if no_declared_args:\n            num_sig_args = 0\n        else:\n            num_sig_args = len(type_spec.split(','))\n        if num_args != num_sig_args:\n            logger.warning(f'Number of provided arguments ({num_args}) does not match number of arguments in signature: {type_spec}')\n\n    @staticmethod\n    def function_call(type_spec, *args):\n        \"\"\"\n        Build transaction data from function signature and arguments\n        \"\"\"\n        m = re.match('(?P<name>[a-zA-Z_][a-zA-Z_0-9]*)(?P<type>\\\\(.*\\\\))', type_spec)\n        if not m:\n            raise EthereumError('Function signature expected')\n        ABI._check_and_warn_num_args(type_spec, *args)\n        result = ABI.function_selector(type_spec)\n        result += ABI.serialize(m.group('type'), *args)\n        return result\n\n    @staticmethod\n    def serialize(ty, *values, **kwargs):\n        \"\"\"\n        Serialize value using type specification in ty.\n        ABI.serialize('int256', 1000)\n        ABI.serialize('(int, int256)', 1000, 2000)\n        \"\"\"\n        try:\n            parsed_ty = abitypes.parse(ty)\n        except Exception as e:\n            raise EthereumError(str(e))\n        if parsed_ty[0] != 'tuple':\n            if len(values) > 1:\n                raise ValueError('too many values passed for non-tuple')\n            values = values[0]\n            if isinstance(values, str):\n                values = values.encode()\n        else:\n            values = tuple((val.encode() if isinstance(val, str) else val for val in values))\n        result, dyn_result = ABI._serialize(parsed_ty, values)\n        return result + dyn_result\n\n    @staticmethod\n    def _serialize(ty, value, dyn_offset=None):\n        if dyn_offset is None:\n            dyn_offset = ABI._type_size(ty)\n        result = bytearray()\n        dyn_result = bytearray()\n        if ty[0] == 'int':\n            result += ABI._serialize_int(value, size=ty[1] // 8, padding=32 - ty[1] // 8)\n        elif ty[0] == 'uint':\n            result += ABI._serialize_uint(value, size=ty[1] // 8, padding=32 - ty[1] // 8)\n        elif ty[0] == 'bytesM':\n            nbytes = ty[1]\n            if len(value) > nbytes:\n                raise EthereumError('bytesM: value length exceeds size of bytes{} type'.format(nbytes))\n            result += ABI._serialize_bytes(value)\n        elif ty[0] in ('bytes', 'string'):\n            result += ABI._serialize_uint(dyn_offset)\n            dyn_result += ABI._serialize_uint(len(value))\n            dyn_result += ABI._serialize_bytes(value)\n        elif ty[0] == 'function':\n            result = ABI._serialize_uint(value[0], 20)\n            result += value[1] + bytearray('\\x00' * 8)\n            assert len(result) == 32\n        elif ty[0] == 'tuple':\n            sub_result, sub_dyn_result = ABI._serialize_tuple(ty[1], value, dyn_offset)\n            result += sub_result\n            dyn_result += sub_dyn_result\n        elif ty[0] == 'array':\n            rep = ty[1]\n            base_type = ty[2]\n            sub_result, sub_dyn_result = ABI._serialize_array(rep, base_type, value, dyn_offset)\n            result += sub_result\n            dyn_result += sub_dyn_result\n        assert len(result) == ABI._type_size(ty)\n        return (result, dyn_result)\n\n    @staticmethod\n    def _serialize_bytes(value):\n        \"\"\"\n        Serializes the value and pads to multiple of 32 bytes\n\n        :param value:\n        :type value: str or bytearray or Array\n        \"\"\"\n        return value + bytearray(b'\\x00' * (32 - len(value)))\n\n    @staticmethod\n    def _serialize_tuple(types, value, dyn_offset=None):\n        result = bytearray()\n        dyn_result = bytearray()\n        if len(types) != len(value):\n            raise ValueError(f\"The number of values to serialize is {('less' if len(value) < len(types) else 'greater')} than the number of types\")\n        for ty_i, value_i in zip(types, value):\n            result_i, dyn_result_i = ABI._serialize(ty_i, value_i, dyn_offset + len(dyn_result))\n            result += result_i\n            dyn_result += dyn_result_i\n        return (result, dyn_result)\n\n    @staticmethod\n    def _serialize_array(rep, base_type, value, dyn_offset=None):\n        result = ABI._serialize_uint(dyn_offset)\n        dyn_result = bytearray()\n        sub_result = bytearray()\n        sub_dyn_result = bytearray()\n        if rep is not None and len(value) != rep:\n            raise ValueError('More reps than values')\n        sub_result += ABI._serialize_uint(len(value))\n        for value_i in value:\n            result_i, dyn_result_i = ABI._serialize(base_type, value_i, dyn_offset + len(dyn_result))\n            sub_result += result_i\n            sub_dyn_result += dyn_result_i\n        dyn_result += sub_result\n        dyn_result += sub_dyn_result\n        return (result, dyn_result)\n\n    @staticmethod\n    def function_selector(method_name_and_signature):\n        \"\"\"\n        Makes a function hash id from a method signature\n        \"\"\"\n        s = sha3.keccak_256()\n        s.update(method_name_and_signature.encode())\n        return bytes(s.digest()[:4])\n\n    @staticmethod\n    def deserialize(type_spec, data):\n        try:\n            if isinstance(data, str):\n                data = bytearray(data.encode())\n            elif isinstance(data, bytes):\n                data = bytearray(data)\n            assert isinstance(data, (bytearray, Array))\n            m = re.match('(?P<name>[a-zA-Z_0-9]+)(?P<type>\\\\(.*\\\\))', type_spec)\n            if m and m.group('name'):\n                result = (data[:4],)\n                ty = m.group('type')\n                result += (ABI._deserialize(abitypes.parse(ty), data[4:]),)\n            else:\n                ty = type_spec\n                result = ABI._deserialize(abitypes.parse(ty), data)\n            return result\n        except Exception as e:\n            raise EthereumError('Error {} deserializing type {:s}'.format(str(e), type_spec))\n\n    @staticmethod\n    def _deserialize(ty, buf: typing.Union[bytearray, bytes, Array], offset=0):\n        assert isinstance(buf, (bytearray, bytes, Array))\n        result = None\n        if ty[0] == 'int':\n            result = ABI._deserialize_int(buf[offset:offset + 32], nbytes=ty[1] // 8)\n        elif ty[0] == 'uint':\n            result = ABI._deserialize_uint(buf[offset:offset + 32], nbytes=ty[1] // 8)\n        elif ty[0] == 'bytesM':\n            result = buf[offset:offset + ty[1]]\n        elif ty[0] == 'function':\n            address = Operators.ZEXTEND(ABI._readBE(buf[offset:offset + 20], 20), 256)\n            func_id = buf[offset + 20:offset + 24]\n            result = (address, func_id)\n        elif ty[0] in ('bytes', 'string'):\n            dyn_offset = ABI._deserialize_int(buf[offset:offset + 32])\n            dyn_offset = to_constant(dyn_offset)\n            size = ABI._deserialize_int(buf[dyn_offset:dyn_offset + 32])\n            result = buf[dyn_offset + 32:dyn_offset + 32 + size]\n        elif ty[0] in 'tuple':\n            result = ()\n            for ty_i in ty[1]:\n                result += (ABI._deserialize(ty_i, buf, offset),)\n                offset += ABI._type_size(ty_i)\n        elif ty[0] in 'array':\n            result = []\n            dyn_offset = ABI._deserialize_int(buf[offset:offset + 32])\n            dyn_offset = to_constant(dyn_offset)\n            rep = ty[1]\n            ty_size = ABI._type_size(ty[2])\n            if rep is None:\n                rep = ABI._deserialize_int(buf[dyn_offset:dyn_offset + 32])\n                dyn_offset += 32\n            for _ in range(rep):\n                result.append(ABI._deserialize(ty[2], buf, dyn_offset))\n                dyn_offset += ty_size\n        else:\n            raise NotImplementedError(f'Could not deserialize type: {ty[0]}')\n        return result\n\n    @staticmethod\n    def _serialize_uint(value, size=32, padding=0):\n        \"\"\"\n        Translates a python integral or a BitVec into a 32 byte string, MSB first\n        \"\"\"\n        if size <= 0 or size > 32:\n            raise ValueError\n        from .account import EVMAccount\n        if not isinstance(value, (int, BitVec, EVMAccount)):\n            raise ValueError\n        if issymbolic(value):\n            assert isinstance(value, BitVec)\n            buffer = ArrayVariable(index_bits=256, index_max=32, value_bits=8, name='temp{}'.format(uuid.uuid1()))\n            if value.size <= size * 8:\n                value = Operators.ZEXTEND(value, size * 8)\n            else:\n                value = Operators.EXTRACT(value, 0, size * 8)\n            buffer = buffer.write_BE(padding, value, size)\n        else:\n            value = int(value)\n            buffer = bytearray()\n            for _ in range(padding):\n                buffer.append(0)\n            for position in reversed(range(size)):\n                buffer.append(Operators.EXTRACT(value, position * 8, 8))\n            buffer = bytes(buffer)\n        assert len(buffer) == size + padding\n        return buffer\n\n    @staticmethod\n    def _serialize_int(value: typing.Union[int, BitVec], size=32, padding=0):\n        \"\"\"\n        Translates a signed python integral or a BitVec into a 32 byte string, MSB first\n        \"\"\"\n        if size <= 0 or size > 32:\n            raise ValueError\n        if not isinstance(value, (int, BitVec)):\n            raise ValueError\n        if issymbolic(value):\n            assert isinstance(value, BitVec)\n            buf = ArrayVariable(index_bits=256, index_max=32, value_bits=8, name='temp{}'.format(uuid.uuid1()))\n            value = Operators.SEXTEND(value, value.size, size * 8)\n            return ArrayProxy(array=buf.write_BE(padding, value, size))\n        else:\n            buf_arr = bytearray()\n            for _ in range(padding):\n                buf_arr.append(0)\n            for position in reversed(range(size)):\n                buf_arr.append(Operators.EXTRACT(value, position * 8, 8))\n            return bytes(buf_arr)\n\n    @staticmethod\n    def _readBE(data, nbytes, padding=False, offset=0):\n        \"\"\"\n\n        :param data:\n        :param nbytes:\n        :param padding: If True, treat data as padded at the beginning to multiple of 32\n        :param offset:\n        :return:\n        \"\"\"\n        start = offset\n        size = nbytes\n        if padding:\n            start += 32 - nbytes\n        pos = start\n        values = []\n        while pos < start + size:\n            if pos >= len(data):\n                values.append(0)\n            else:\n                values.append(data[pos])\n            pos += 1\n        return Operators.CONCAT(nbytes * 8, *values)\n\n    @staticmethod\n    def _deserialize_uint(data: typing.Union[bytearray, bytes, Array], nbytes=32, padding=0, offset=0):\n        \"\"\"\n        Read a `nbytes` bytes long big endian unsigned integer from `data` starting at `offset`\n\n        :param data: sliceable buffer; symbolic buffer of Eth ABI encoded data\n        :param nbytes: number of bytes to read starting from least significant byte\n        :rtype: int or Expression\n        \"\"\"\n        assert isinstance(data, (bytearray, bytes, Array))\n        value = ABI._readBE(data, nbytes, padding=True, offset=offset)\n        value = Operators.ZEXTEND(value, (nbytes + padding) * 8)\n        return value\n\n    @staticmethod\n    def _deserialize_int(data: typing.Union[bytearray, bytes, Array], nbytes=32, padding=0):\n        \"\"\"\n        Read a `nbytes` bytes long big endian signed integer from `data` starting at `offset`\n\n        :param data: sliceable buffer; symbolic buffer of Eth ABI encoded data\n        :param nbytes: number of bytes to read starting from least significant byte\n        :rtype: int or Expression\n        \"\"\"\n        assert isinstance(data, (bytearray, bytes, Array))\n        value = ABI._readBE(data, nbytes, padding=True)\n        value = Operators.SEXTEND(value, nbytes * 8, (nbytes + padding) * 8)\n        if not issymbolic(value):\n            if value & 1 << nbytes * 8 - 1:\n                value = -(~value + 1 & (1 << nbytes * 8) - 1)\n        return value\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass BarSizeConverter:\n    '''Handles conversion between BAR addresses and size encodings.'''\n    @staticmethod\n    def address_to_size(base_address: int, bar_type: str='memory') -> int:\n        '''\n        Convert a BAR base address to its size in bytes.\n        According to PCIe spec, the size is determined by writing all 1s to the BAR\n        and reading back. The device will return 0s in the bits that are hardwired\n        to 0 (representing the size) and 1s in the bits that can be programmed.\n        Args:\n            base_address: The BAR base address value\n            bar_type: Type of BAR (\"memory\" or \"io\")\n        Returns:\n            Size of the BAR in bytes\n        Raises:\n            ValueError: If the address format is invalid\n        '''\n        pass\n    @staticmethod\n    def size_to_encoding(size: int, bar_type: str='memory', is_64bit: bool=False, prefetchable: bool=False) -> int:\n        '''\n        Convert a BAR size to its proper encoding for the configuration space.\n        The encoding sets all bits to 1 except for the size bits which are 0,\n        and the type bits in the lower nibble.\n        Args:\n            size: Size of the BAR in bytes\n            bar_type: Type of BAR (\"memory\" or \"io\")\n            is_64bit: Whether this is a 64-bit memory BAR\n            prefetchable: Whether this is a prefetchable memory BAR\n        Returns:\n            Encoded BAR value for the configuration space\n        Raises:\n            ValueError: If the size is invalid according to PCIe spec\n        '''\n        pass\n    @staticmethod\n    def decode_bar_register(bar_value: int) -> Tuple[str, int, bool, bool]:\n        '''\n        Decode a BAR register value to extract type and properties.\n        Args:\n            bar_value: The BAR register value\n        Returns:\n            Tuple of (bar_type, address, is_64bit, prefetchable)\n        '''\n        pass\n    @staticmethod\n    def validate_bar_size(size: int, bar_type: str='memory') -> bool:\n        '''\n        Validate if a BAR size meets PCIe specification requirements.\n        Args:\n            size: Size to validate in bytes\n            bar_type: Type of BAR (\"memory\" or \"io\")\n        Returns:\n            True if size is valid, False otherwise\n        '''\n        pass\n    @staticmethod\n    def get_size_from_encoding(encoded_value: int, bar_type: str='memory') -> int:\n        '''\n        Extract the size from an encoded BAR value.\n        This is the reverse of size_to_encoding - it extracts the size\n        from a BAR value that has all 1s except for the size bits.\n        Args:\n            encoded_value: The encoded BAR value\n            bar_type: Type of BAR (\"memory\" or \"io\")\n        Returns:\n            Size of the BAR in bytes\n        '''\n        pass\n    @staticmethod\n    def format_size(size: int) -> str:\n        '''\n        Format a size value for human-readable display.\n        Args:\n            size: Size in bytes\n        Returns:\n            Formatted string (e.g., \"4KB\", \"256MB\")\n        '''\n        pass\n    @classmethod\n    def convert_bar_for_shadow_space(cls, bar_info: dict) -> dict:\n        '''\n            Convert BAR information for use in shadow configuration space.\n            Args:\n                bar_info: Dictionary containing BAR information with keys:\n                    - base_address: Current BAR base address\n                    - size: BAR size in bytes\n                    - bar_type: \"memory\" or \"io\"\n                    - is_64bit: Whether this is a 64-bit BAR\n                    - prefetchable: Whether this is prefetchable\n        return bar_size  # Ensure all code paths return an int\n            Returns:\n                Dictionary with:\n                    - encoded_value: The encoded BAR value for shadow space\n                    - size: The size in bytes\n                    - size_str: Human-readable size string\n        '''\n        pass"
  }
]