[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\nnan\nCorresponding class implementation:\n\nimport re\nfrom typing import NamedTuple, TypeVar, Generic, overload\nfrom tabulate import tabulate\nfrom operator import mul, add\nimport csv\nimport json\nimport typing\nfrom functional.execution import ExecutionEngine\nfrom functional.util import is_iterable, is_primitive, is_namedtuple, is_tabulatable, identity, default_value\nfrom functional.io import WRITE_MODE, universal_write_open\nfrom functional import transformations\nfrom functools import reduce, wraps, partial\nimport collections\nfrom functional.lineage import Lineage\nimport sqlite3\n\nclass Sequence(Generic[_T_co]):\n    \"\"\"\n    Sequence is a wrapper around any type of sequence which provides access to common\n    functional transformations and reductions in a data pipeline style\n    \"\"\"\n\n    def __init__(self, sequence: Iterable[_T_co], transform=None, engine: ExecutionEngine | None=None, max_repr_items: int | None=None, no_wrap: bool | None=None):\n        \"\"\"\n        Takes a Sequence, list, tuple. or iterable sequence and wraps it around a Sequence object.\n        If the sequence is already an instance of Sequence, it will in total be wrapped exactly\n        once. A TypeError is raised if sequence is none of these.\n\n        :param sequence: sequence of items to wrap in a Sequence\n        :param transform: transformation to apply\n        :param engine: execution engine\n        :param max_repr_items: maximum number of items to print with repr\n        :param no_wrap: default value of no_wrap for functions like first() or last()\n        :return: sequence wrapped in a Sequence\n        \"\"\"\n        self.engine = engine or ExecutionEngine()\n        if isinstance(sequence, Sequence):\n            self._max_repr_items: int | None = max_repr_items or sequence._max_repr_items\n            self._base_sequence: Iterable | list | tuple = sequence._base_sequence\n            self._lineage: Lineage = Lineage(prior_lineage=sequence._lineage, engine=engine)\n        elif isinstance(sequence, (list, tuple)) or is_iterable(sequence):\n            self._max_repr_items = max_repr_items\n            self._base_sequence = sequence\n            self._lineage = Lineage(engine=engine)\n        else:\n            raise TypeError('Given sequence must be an iterable value')\n        if transform is not None:\n            self._lineage.apply(transform)\n        self.no_wrap = no_wrap\n\n    def __iter__(self) -> Iterator[_T_co]:\n        \"\"\"\n        Return iterator of sequence.\n\n        :return: iterator of sequence\n        \"\"\"\n        return self._evaluate()\n\n    def __eq__(self, other) -> bool:\n        \"\"\"\n        Checks for equality with the sequence's equality operator.\n\n        :param other: object to compare to\n        :return: true if the underlying sequence is equal to other\n        \"\"\"\n        return self.sequence == other\n\n    def __ne__(self, other) -> bool:\n        \"\"\"\n        Checks for inequality with the sequence's inequality operator.\n\n        :param other: object to compare to\n        :return: true if the underlying sequence is not equal to other\n        \"\"\"\n        return self.sequence != other\n\n    def __hash__(self) -> NoReturn:\n        \"\"\"\n        Return the hash of the sequence.\n\n        :return: hash of sequence\n        \"\"\"\n        raise TypeError('unhashable type: Sequence')\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Return repr using sequence's repr function.\n\n        :return: sequence's repr\n        \"\"\"\n        items = self.to_list()\n        if self._max_repr_items is None or len(items) <= self._max_repr_items:\n            return repr(items)\n        else:\n            return repr(items[:self._max_repr_items])[:-1] + ', ...]'\n\n    def __str__(self) -> str:\n        \"\"\"\n        Return string using sequence's string function.\n\n        :return: sequence's string\n        \"\"\"\n        return str(self.to_list())\n\n    def __bool__(self) -> bool:\n        \"\"\"\n        Returns True if size is not zero.\n\n        :return: True if size is not zero\n        \"\"\"\n        return self.size() != 0\n\n    def __nonzero__(self) -> bool:\n        \"\"\"\n        Returns True if size is not zero.\n\n        :return: True if size is not zero\n        \"\"\"\n        return self.size() != 0\n\n    def __getitem__(self, item) -> _T_co:\n        \"\"\"\n        Gets item at given index.\n\n        :param item: key to use for getitem\n        :return: item at index key\n        \"\"\"\n        self.cache()\n        return _wrap(self.sequence[item])\n\n    def __reversed__(self) -> Sequence[_T_co]:\n        \"\"\"\n        Return reversed sequence using sequence's reverse function\n\n        :return: reversed sequence\n        \"\"\"\n        return self._transform(transformations.reversed_t())\n\n    def __contains__(self: Sequence[_T], item: _T) -> bool:\n        \"\"\"\n        Checks if item is in sequence.\n\n        :param item: item to check\n        :return: True if item is in sequence\n        \"\"\"\n        return self.sequence.__contains__(item)\n\n    def __add__(self, other: Sequence[_T]) -> Sequence[_T_co | _T]:\n        \"\"\"\n        Concatenates sequence with other.\n\n        :param other: sequence to concatenate\n        :return: concatenated sequence with other\n        \"\"\"\n        if isinstance(other, Sequence):\n            return Sequence(self.sequence + other.sequence, no_wrap=self.no_wrap)\n        else:\n            return Sequence(self.sequence + other, no_wrap=self.no_wrap)\n\n    def _evaluate(self) -> Iterator[_T_co]:\n        \"\"\"\n        Creates and returns an iterator which applies all the transformations in the lineage\n\n        :return: iterator over the transformed sequence\n        \"\"\"\n        return self._lineage.evaluate(self._base_sequence)\n\n    def _transform(self, *transforms: transformations.Transformation) -> Sequence[Any]:\n        \"\"\"\n        Copies the given Sequence and appends new transformation\n        :param transform: transform to apply or list of transforms to apply\n        :return: transformed sequence\n        \"\"\"\n        sequence = self\n        for transform in transforms:\n            sequence = Sequence(sequence, transform=transform, no_wrap=self.no_wrap)\n        return sequence\n\n    @property\n    def sequence(self) -> list[_T_co]:\n        \"\"\"\n        Alias for to_list used internally for brevity\n\n        :return: result of to_list() on sequence\n        \"\"\"\n        return self.to_list()\n\n    def cache(self, delete_lineage: bool=False) -> Self:\n        \"\"\"\n        Caches the result of the Sequence so far. This means that any functions applied on the\n        pipeline before cache() are evaluated, and the result is stored in the Sequence. This is\n        primarily used internally and is no more helpful than to_list() externally. delete_lineage\n        allows for cache() to be used in internal initialization calls without the caller having\n        knowledge of the internals via the lineage\n\n        :param delete_lineage: If set to True, it will cache then erase the lineage\n        \"\"\"\n        if len(self._lineage) == 0 or self._lineage[-1] == transformations.CACHE_T:\n            if not isinstance(self._base_sequence, list):\n                self._base_sequence = list(self._base_sequence)\n                self._lineage.apply(transformations.CACHE_T)\n        else:\n            self._base_sequence = list(self._evaluate())\n            self._lineage.apply(transformations.CACHE_T)\n        if delete_lineage:\n            self._lineage = Lineage(engine=self.engine)\n        return self\n\n    def head(self, no_wrap: bool | None=None) -> _T_co:\n        \"\"\"\n        Returns the first element of the sequence.\n\n        >>> seq([1, 2, 3]).head()\n        1\n\n        Raises IndexError when the sequence is empty.\n\n        >>> seq([]).head()\n        Traceback (most recent call last):\n         ...\n        IndexError: list index out of range\n\n        :param no_wrap: If set to True, the returned value will never be wrapped with Sequence\n        :return: first element of sequence\n        \"\"\"\n        if default_value(no_wrap, self.no_wrap, False):\n            return self.sequence[0]\n        else:\n            return _wrap(self.take(1)[0])\n\n    def first(self, no_wrap: bool | None=None) -> _T_co:\n        \"\"\"\n        Returns the first element of the sequence.\n\n        >>> seq([1, 2, 3]).first()\n        1\n\n        Raises IndexError when the sequence is empty.\n\n        >>> seq([]).first()\n        Traceback (most recent call last):\n         ...\n        IndexError: list index out of range\n\n        :param no_wrap: If set to True, the returned value will never be wrapped with Sequence\n        :return: first element of sequence\n        \"\"\"\n        return self.head(no_wrap=no_wrap)\n\n    def head_option(self, no_wrap: bool | None=None) -> _T_co | None:\n        \"\"\"\n        Returns the first element of the sequence or None, if the sequence is empty.\n\n        >>> seq([1, 2, 3]).head_option()\n        1\n\n        >>> seq([]).head_option()\n        None\n\n        :param no_wrap: If set to True, the returned value will never be wrapped with Sequence\n        :return: first element of sequence or None if sequence is empty\n        \"\"\"\n        if not self.sequence:\n            return None\n        return self.head(no_wrap=no_wrap)\n\n    def last(self, no_wrap: bool | None=None) -> _T_co:\n        \"\"\"\n        Returns the last element of the sequence.\n\n        >>> seq([1, 2, 3]).last()\n        3\n\n        Raises IndexError when the sequence is empty.\n\n        >>> seq([]).last()\n        Traceback (most recent call last):\n         ...\n        IndexError: list index out of range\n\n        :param no_wrap: If set to True, the returned value will never be wrapped with Sequence\n        :return: last element of sequence\n        \"\"\"\n        if default_value(no_wrap, self.no_wrap, False):\n            return self.sequence[-1]\n        else:\n            return _wrap(self.sequence[-1])\n\n    def last_option(self, no_wrap: bool | None=None) -> _T_co | None:\n        \"\"\"\n        Returns the last element of the sequence or None, if the sequence is empty.\n\n        >>> seq([1, 2, 3]).last_option()\n        3\n\n        >>> seq([]).last_option()\n        None\n\n        :param no_wrap: If set to True, the returned value will never be wrapped with Sequence\n        :return: last element of sequence or None if sequence is empty\n        \"\"\"\n        if not self.sequence:\n            return None\n        return self.last(no_wrap=no_wrap)\n\n    def init(self) -> Sequence[_T_co]:\n        \"\"\"\n        Returns the sequence, without its last element.\n\n        >>> seq([1, 2, 3]).init()\n        [1, 2]\n\n        :return: sequence without last element\n        \"\"\"\n        return self._transform(transformations.init_t())\n\n    def tail(self) -> Sequence[_T_co]:\n        \"\"\"\n        Returns the sequence, without its first element.\n\n        >>> seq([1, 2, 3]).tail()\n        [2, 3]\n\n        :return: sequence without first element\n        \"\"\"\n        return self._transform(transformations.tail_t())\n\n    def inits(self) -> Sequence[Self]:\n        \"\"\"\n        Returns consecutive inits of the sequence.\n\n        >>> seq([1, 2, 3]).inits()\n        [[1, 2, 3], [1, 2], [1], []]\n\n        :return: consecutive init()s on sequence\n        \"\"\"\n        return self._transform(transformations.inits_t(_wrap))\n\n    def tails(self) -> Sequence[Self]:\n        \"\"\"\n        Returns consecutive tails of the sequence.\n\n        >>> seq([1, 2, 3]).tails()\n        [[1, 2, 3], [2, 3], [3], []]\n\n        :return: consecutive tail()s of the sequence\n        \"\"\"\n        return self._transform(transformations.tails_t(_wrap))\n\n    @overload\n    def cartesian(self, /) -> Sequence[tuple[_T_co]]:\n        ...\n\n    @overload\n    def cartesian(self, iter1: Iterable[_T1], /) -> Sequence[tuple[_T_co, _T1]]:\n        ...\n\n    @overload\n    def cartesian(self, iter1: Iterable[_T1], iter2: Iterable[_T2], /) -> Sequence[tuple[_T_co, _T1, _T2]]:\n        ...\n\n    @overload\n    def cartesian(self, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /) -> Sequence[tuple[_T_co, _T1, _T2, _T3]]:\n        ...\n\n    @overload\n    def cartesian(self, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], /) -> Sequence[tuple[_T_co, _T1, _T2, _T3, _T4]]:\n        ...\n\n    @overload\n    def cartesian(self, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], iter5: Iterable[_T5], /) -> Sequence[tuple[_T_co, _T1, _T2, _T3, _T4, _T5]]:\n        ...\n\n    @overload\n    def cartesian(self, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], iter5: Iterable[_T5], iter6: Iterable[_T6], /) -> Sequence[tuple[_T_co, _T1, _T2, _T3, _T4, _T5, _T6]]:\n        ...\n\n    def cartesian(self, *iterables, **kwargs):\n        \"\"\"\n        Returns the cartesian product of the passed iterables with the specified number of\n        repetitions.\n\n        The keyword argument `repeat` is read from kwargs to pass to itertools.cartesian.\n\n        >>> seq.range(2).cartesian(range(2))\n        [(0, 0), (0, 1), (1, 0), (1, 1)]\n\n        :param iterables: elements for cartesian product\n        :param kwargs: the variable `repeat` is read from kwargs\n        :return: cartesian product\n        \"\"\"\n        return self._transform(transformations.cartesian_t(iterables, kwargs.get('repeat', 1)))\n\n    def drop(self, n: int) -> Sequence[_T_co]:\n        \"\"\"\n        Drop the first n elements of the sequence.\n\n        >>> seq([1, 2, 3, 4, 5]).drop(2)\n        [3, 4, 5]\n\n        :param n: number of elements to drop\n        :return: sequence without first n elements\n        \"\"\"\n        if n <= 0:\n            return self._transform(transformations.drop_t(0))\n        else:\n            return self._transform(transformations.drop_t(n))\n\n    def drop_right(self, n: int) -> Sequence[_T_co]:\n        \"\"\"\n        Drops the last n elements of the sequence.\n\n        >>> seq([1, 2, 3, 4, 5]).drop_right(2)\n        [1, 2, 3]\n\n        :param n: number of elements to drop\n        :return: sequence with last n elements dropped\n        \"\"\"\n        return self._transform(transformations.drop_right_t(n))\n\n    def drop_while(self, func: Callable[[_T_co], Any]) -> Sequence[_T_co]:\n        \"\"\"\n        Drops elements in the sequence while func evaluates to True, then returns the rest.\n\n        >>> seq([1, 2, 3, 4, 5, 1, 2]).drop_while(lambda x: x < 3)\n        [3, 4, 5, 1, 2]\n\n        :param func: truth returning function\n        :return: elements including and after func evaluates to False\n        \"\"\"\n        return self._transform(transformations.drop_while_t(func))\n\n    def take(self, n: int) -> Sequence[_T_co]:\n        \"\"\"\n        Take the first n elements of the sequence.\n\n        >>> seq([1, 2, 3, 4]).take(2)\n        [1, 2]\n\n        :param n: number of elements to take\n        :return: first n elements of sequence\n        \"\"\"\n        if n <= 0:\n            return self._transform(transformations.take_t(0))\n        else:\n            return self._transform(transformations.take_t(n))\n\n    def take_while(self, func: Callable[[_T_co], Any]) -> Sequence[_T_co]:\n        \"\"\"\n        Take elements in the sequence until func evaluates to False, then return them.\n\n        >>> seq([1, 2, 3, 4, 5, 1, 2]).take_while(lambda x: x < 3)\n        [1, 2]\n\n        :param func: truth returning function\n        :return: elements taken until func evaluates to False\n        \"\"\"\n        return self._transform(transformations.take_while_t(func))\n\n    def union(self, other: Iterable[_T]) -> Sequence[_T_co | _T]:\n        \"\"\"\n        New sequence with unique elements from self and other.\n\n        >>> seq([1, 1, 2, 3, 3]).union([1, 4, 5])\n        [1, 2, 3, 4, 5]\n\n        :param other: sequence to union with\n        :return: union of sequence and other\n        \"\"\"\n        return self._transform(transformations.union_t(other))\n\n    def intersection(self, other: Iterable[_T]) -> Sequence[_T_co]:\n        \"\"\"\n        New sequence with unique elements present in sequence and other.\n\n        >>> seq([1, 1, 2, 3]).intersection([2, 3, 4])\n        [2, 3]\n\n        :param other: sequence to perform intersection with\n        :return: intersection of sequence and other\n        \"\"\"\n        return self._transform(transformations.intersection_t(other))\n\n    def difference(self, other: Iterable[_T]) -> Sequence[_T_co]:\n        \"\"\"\n        New sequence with unique elements present in sequence but not in other.\n\n        >>> seq([1, 2, 3]).difference([2, 3, 4])\n        [1]\n\n        :param other: sequence to perform difference with\n        :return: difference of sequence and other\n        \"\"\"\n        return self._transform(transformations.difference_t(other))\n\n    def symmetric_difference(self, other: Iterable[_T]) -> Sequence[_T_co | _T]:\n        \"\"\"\n        New sequence with elements in either sequence or other, but not both.\n\n        >>> seq([1, 2, 3, 3]).symmetric_difference([2, 4, 5])\n        [1, 3, 4, 5]\n\n        :param other: sequence to perform symmetric difference with\n        :return: symmetric difference of sequence and other\n        \"\"\"\n        return self._transform(transformations.symmetric_difference_t(other))\n\n    def map(self, func: Callable[[_T_co], _T]) -> Sequence[_T]:\n        \"\"\"\n        Maps f onto the elements of the sequence.\n\n        >>> seq([1, 2, 3, 4]).map(lambda x: x * -1)\n        [-1, -2, -3, -4]\n\n        :param func: function to map with\n        :return: sequence with func mapped onto it\n        \"\"\"\n        return self._transform(transformations.map_t(func))\n\n    def select(self, func: Callable[[_T_co], _T]) -> Sequence[_T]:\n        \"\"\"\n        Selects f from the elements of the sequence.\n\n        >>> seq([1, 2, 3, 4]).select(lambda x: x * -1)\n        [-1, -2, -3, -4]\n\n        :param func: function to select with\n        :return: sequence with func mapped onto it\n        \"\"\"\n        return self._transform(transformations.select_t(func))\n\n    @overload\n    def starmap(self: Sequence[tuple[_T1]], func: Callable[[_T1], _R]) -> Sequence[_R]:\n        ...\n\n    @overload\n    def starmap(self: Sequence[tuple[_T1, _T2]], func: Callable[[_T1, _T2], _R]) -> Sequence[_R]:\n        ...\n\n    @overload\n    def starmap(self: Sequence[tuple[_T1, _T2, _T3]], func: Callable[[_T1, _T2, _T3], _R]) -> Sequence[_R]:\n        ...\n\n    @overload\n    def starmap(self: Sequence[tuple[_T1, _T2, _T3, _T4]], func: Callable[[_T1, _T2, _T3, _T4], _R]) -> Sequence[_R]:\n        ...\n\n    @overload\n    def starmap(self: Sequence[tuple[_T1, _T2, _T3, _T4, _T5]], func: Callable[[_T1, _T2, _T3, _T4, _T5], _R]) -> Sequence[_R]:\n        ...\n\n    @overload\n    def starmap(self, func: Callable[..., _R]) -> Sequence[_R]:\n        ...\n\n    def starmap(self, func):\n        \"\"\"\n        starmaps f onto the sequence as itertools.starmap does.\n\n        >>> seq([(2, 3), (-2, 1), (0, 10)]).starmap(lambda x, y: x + y)\n        [5, -1, 10]\n\n        :param func: function to starmap with\n        :return: sequence with func starmapped onto it\n        \"\"\"\n        return self._transform(transformations.starmap_t(func))\n\n    @overload\n    def smap(self: Sequence[tuple[_T1]], func: Callable[[_T1], _R]) -> Sequence[_R]:\n        ...\n\n    @overload\n    def smap(self: Sequence[tuple[_T1, _T2]], func: Callable[[_T1, _T2], _R]) -> Sequence[_R]:\n        ...\n\n    @overload\n    def smap(self: Sequence[tuple[_T1, _T2, _T3]], func: Callable[[_T1, _T2, _T3], _R]) -> Sequence[_R]:\n        ...\n\n    @overload\n    def smap(self: Sequence[tuple[_T1, _T2, _T3, _T4]], func: Callable[[_T1, _T2, _T3, _T4], _R]) -> Sequence[_R]:\n        ...\n\n    @overload\n    def smap(self: Sequence[tuple[_T1, _T2, _T3, _T4, _T5]], func: Callable[[_T1, _T2, _T3, _T4, _T5], _R]) -> Sequence[_R]:\n        ...\n\n    @overload\n    def smap(self, func: Callable[..., _R]) -> Sequence[_R]:\n        ...\n\n    def smap(self, func):\n        \"\"\"\n        Alias to Sequence.starmap\n\n        starmaps f onto the sequence as itertools.starmap does.\n\n        >>> seq([(2, 3), (-2, 1), (0, 10)]).smap(lambda x, y: x + y)\n        [5, -1, 10]\n\n        :param func: function to starmap with\n        :return: sequence with func starmapped onto it\n        \"\"\"\n        return self._transform(transformations.starmap_t(func))\n\n    def for_each(self, func: Callable[[_T_co], Any]) -> None:\n        \"\"\"\n        Executes func on each element of the sequence.\n\n        >>> l = []\n        >>> seq([1, 2, 3, 4]).for_each(l.append)\n        >>> l\n        [1, 2, 3, 4]\n\n        :param func: function to execute\n        \"\"\"\n        for e in self:\n            func(e)\n\n    def peek(self, func: Callable[[_T_co], Any]) -> Sequence[_T_co]:\n        \"\"\"\n        Executes func on each element of the sequence and returns the element\n\n        >>> seq([1, 2, 3, 4]).peek(print).map(lambda x: x ** 2).to_list()\n        1\n        2\n        3\n        4\n        [1, 4, 9, 16]\n\n        :param func: function to execute\n        \"\"\"\n        return self._transform(transformations.peek_t(func))\n\n    def remove_none(self: Sequence[_T | None]) -> Sequence[_T]:\n        \"\"\"\n        Removes all `None` values from the sequence.\n\n        Returns:\n            A new sequence with all `None` values removed.\n        \"\"\"\n        return self.filter(lambda x: x is not None)\n\n    @overload\n    def filter(self, func: Callable[[_T_co], TypeGuard[_T]]) -> Sequence[_T]:\n        ...\n\n    @overload\n    def filter(self, func: Callable[[_T_co], Any]) -> Sequence[_T_co]:\n        ...\n\n    def filter(self, func):\n        \"\"\"\n        Filters sequence to include only elements where func is True.\n\n        >>> seq([-1, 1, -2, 2]).filter(lambda x: x > 0)\n        [1, 2]\n\n        :param func: function to filter on\n        :return: filtered sequence\n        \"\"\"\n        return self._transform(transformations.filter_t(func))\n\n    def filter_not(self, func: Callable[[_T_co], Any]) -> Sequence[_T_co]:\n        \"\"\"\n        Filters sequence to include only elements where func is False.\n\n        >>> seq([-1, 1, -2, 2]).filter_not(lambda x: x > 0)\n        [-1, -2]\n\n        :param func: function to filter_not on\n        :return: filtered sequence\n        \"\"\"\n        return self._transform(transformations.filter_not_t(func))\n\n    def where(self, func: Callable[[_T_co], Any]) -> Sequence[_T_co]:\n        \"\"\"\n        Selects elements where func evaluates to True.\n\n        >>> seq([-1, 1, -2, 2]).where(lambda x: x > 0)\n        [1, 2]\n\n        :param func: function to filter on\n        :return: filtered sequence\n        \"\"\"\n        return self._transform(transformations.where_t(func))\n\n    def count(self, func: Callable[[_T_co], Any]) -> int:\n        \"\"\"\n        Counts the number of elements in the sequence which satisfy the predicate func.\n\n        >>> seq([-1, -2, 1, 2]).count(lambda x: x > 0)\n        2\n\n        :param func: predicate to count elements on\n        :return: count of elements that satisfy predicate\n        \"\"\"\n        return sum((bool(func(element)) for element in self))\n\n    def len(self) -> int:\n        \"\"\"\n        Return length of sequence using its length function.\n\n        >>> seq([1, 2, 3]).len()\n        3\n\n        :return: length of sequence\n        \"\"\"\n        self.cache()\n        return len(self._base_sequence)\n\n    def size(self) -> int:\n        \"\"\"\n        Return size of sequence using its length function.\n\n        :return: size of sequence\n        \"\"\"\n        return self.len()\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns True if the sequence has length zero.\n\n        >>> seq([]).empty()\n        True\n\n        >>> seq([1]).empty()\n        False\n\n        :return: True if sequence length is zero\n        \"\"\"\n        return self.size() == 0\n\n    def non_empty(self) -> bool:\n        \"\"\"\n        Returns True if the sequence does not have length zero.\n\n        >>> seq([]).non_empty()\n        False\n\n        >>> seq([1]).non_empty()\n        True\n\n        :return: True if sequence length is not zero\n        \"\"\"\n        return self.size() != 0\n\n    def any(self) -> bool:\n        \"\"\"\n        Returns True if any element in the sequence has truth value True\n\n        >>> seq([True, False]).any()\n        True\n\n        >>> seq([False, False]).any()\n        False\n\n        :return: True if any element is True\n        \"\"\"\n        return any(self)\n\n    def all(self) -> bool:\n        \"\"\"\n        Returns True if the truth value of all items in the sequence true.\n\n        >>> seq([True, True]).all()\n        True\n\n        >>> seq([True, False]).all()\n        False\n\n        :return: True if all items truth value evaluates to True\n        \"\"\"\n        return all(self)\n\n    def exists(self, func: Callable[[_T_co], Any]) -> bool:\n        \"\"\"\n        Returns True if an element in the sequence makes func evaluate to True.\n\n        >>> seq([1, 2, 3, 4]).exists(lambda x: x == 2)\n        True\n\n        >>> seq([1, 2, 3, 4]).exists(lambda x: x < 0)\n        False\n\n        :param func: existence check function\n        :return: True if any element satisfies func\n        \"\"\"\n        return any((func(element) for element in self))\n\n    def for_all(self, func: Callable[[_T_co], Any]) -> bool:\n        \"\"\"\n        Returns True if all elements in sequence make func evaluate to True.\n\n        >>> seq([1, 2, 3]).for_all(lambda x: x > 0)\n        True\n\n        >>> seq([1, 2, -1]).for_all(lambda x: x > 0)\n        False\n\n        :param func: function to check truth value of all elements with\n        :return: True if all elements make func evaluate to True\n        \"\"\"\n        return all((func(element) for element in self))\n\n    def max(self: Sequence[SupportsRichComparisonT]) -> SupportsRichComparisonT:\n        \"\"\"\n        Returns the largest element in the sequence.\n        If the sequence has multiple maximal elements, only the first one is returned.\n\n        The compared objects must have defined comparison methods.\n        Raises TypeError when the objects are not comparable.\n\n        The sequence can not be empty.\n        Raises ValueError when the sequence is empty.\n\n        >>> seq([2, 4, 5, 1, 3]).max()\n        5\n\n        >>> seq('aa', 'xyz', 'abcd', 'xyy').max()\n        'xyz'\n\n        >>> seq([1, \"a\"]).max()\n        Traceback (most recent call last):\n         ...\n        TypeError: unorderable types: int() < str()\n\n        >>> seq([]).max()\n        Traceback (most recent call last):\n         ...\n        ValueError: max() arg is an empty sequence\n\n        :return: Maximal value of sequence\n        \"\"\"\n        return _wrap(max(self))\n\n    def min(self: Sequence[SupportsRichComparisonT]) -> SupportsRichComparisonT:\n        \"\"\"\n        Returns the smallest element in the sequence.\n        If the sequence has multiple minimal elements, only the first one is returned.\n\n        The compared objects must have defined comparison methods.\n        Raises TypeError when the objects are not comparable.\n\n        The sequence can not be empty.\n        Raises ValueError when the sequence is empty.\n\n        >>> seq([2, 4, 5, 1, 3]).min()\n        1\n\n        >>> seq('aa', 'xyz', 'abcd', 'xyy').min()\n        'aa'\n\n        >>> seq([1, \"a\"]).min()\n        Traceback (most recent call last):\n         ...\n        TypeError: unorderable types: int() < str()\n\n        >>> seq([]).min()\n        Traceback (most recent call last):\n         ...\n        ValueError: min() arg is an empty sequence\n\n        :return: Minimal value of sequence\n        \"\"\"\n        return _wrap(min(self))\n\n    def max_by(self, func: Callable[[_T_co], SupportsRichComparison]) -> _T_co:\n        \"\"\"\n        Returns the largest element in the sequence.\n        Provided function is used to generate key used to compare the elements.\n        If the sequence has multiple maximal elements, only the first one is returned.\n\n        The sequence can not be empty.\n        Raises ValueError when the sequence is empty.\n\n        >>> seq([2, 4, 5, 1, 3]).max_by(lambda num: num % 4)\n        3\n\n        >>> seq('aa', 'xyz', 'abcd', 'xyy').max_by(len)\n        'abcd'\n\n        >>> seq([]).max_by(lambda x: x)\n        Traceback (most recent call last):\n         ...\n        ValueError: max() arg is an empty sequence\n\n        :param func: function to compute max by\n        :return: Maximal element by func(element)\n        \"\"\"\n        return _wrap(max(self, key=func))\n\n    def min_by(self, func: Callable[[_T_co], SupportsRichComparison]) -> _T_co:\n        \"\"\"\n        Returns the smallest element in the sequence.\n        Provided function is used to generate key used to compare the elements.\n        If the sequence has multiple minimal elements, only the first one is returned.\n\n        The sequence can not be empty.\n        Raises ValueError when the sequence is empty.\n\n        >>> seq([2, 4, 5, 1, 3]).min_by(lambda num: num % 6)\n        5\n\n        >>> seq('aa', 'xyz', 'abcd', 'xyy').min_by(len)\n        'aa'\n\n        >>> seq([]).min_by(lambda x: x)\n        Traceback (most recent call last):\n         ...\n        ValueError: min() arg is an empty sequence\n\n        :param func: function to compute min by\n        :return: Maximal element by func(element)\n        \"\"\"\n        return _wrap(min(self, key=func))\n\n    def find(self, func: Callable[[_T_co], Any]) -> _T_co | None:\n        \"\"\"\n        Finds the first element of the sequence that satisfies func. If no such element exists,\n        then return None.\n\n        >>> seq([\"abc\", \"ab\", \"bc\"]).find(lambda x: len(x) == 2)\n        'ab'\n\n        :param func: function to find with\n        :return: first element to satisfy func or None\n        \"\"\"\n        return next((element for element in self if func(element)), None)\n\n    def flatten(self: Sequence[Iterable[_T]]) -> Sequence[_T]:\n        \"\"\"\n        Flattens a sequence of sequences to a single sequence of elements.\n\n        >>> seq([[1, 2], [3, 4], [5, 6]])\n        [1, 2, 3, 4, 5, 6]\n\n        :return: flattened sequence\n        \"\"\"\n        return self._transform(transformations.flatten_t())\n\n    def flat_map(self, func: Callable[[_T_co], Iterable[_T]]) -> Sequence[_T]:\n        \"\"\"\n        Applies func to each element of the sequence, which themselves should be sequences.\n        Then appends each element of each sequence to a final result\n\n        >>> seq([[1, 2], [3, 4], [5, 6]]).flat_map(lambda x: x)\n        [1, 2, 3, 4, 5, 6]\n\n        >>> seq([\"a\", \"bc\", \"def\"]).flat_map(list)\n        ['a', 'b', 'c', 'd', 'e', 'f']\n\n        >>> seq([[1], [2], [3]]).flat_map(lambda x: x * 2)\n        [1, 1, 2, 2, 3, 3]\n\n        :param func: function to apply to each sequence in the sequence\n        :return: application of func to elements followed by flattening\n        \"\"\"\n        return self._transform(transformations.flat_map_t(func))\n\n    def group_by(self, func: Callable[[_T_co], _T]) -> Sequence[tuple[_T, Sequence[_T_co]]]:\n        \"\"\"\n        Group elements into a list of (Key, Value) tuples where func creates the key and maps\n        to values matching that key.\n\n        >>> seq([\"abc\", \"ab\", \"z\", \"f\", \"qw\"]).group_by(len)\n        [(1, ['z', 'f']), (2, ['ab', 'qw']), (3, ['abc'])]\n\n        :param func: group by result of this function\n        :return: grouped sequence\n        \"\"\"\n        return self._transform(transformations.group_by_t(func))\n\n    @overload\n    def group_by_key(self: Sequence[tuple[_U, _V]]) -> Sequence[tuple[_U, list[_V]]]:\n        ...\n\n    @overload\n    def group_by_key(self: Sequence[Iterable[_U]]) -> Sequence[tuple[_U, list[_U]]]:\n        ...\n\n    def group_by_key(self):\n        \"\"\"\n        Group sequence of (Key, Value) elements by Key.\n\n        >>> seq([('a', 1), ('b', 2), ('b', 3), ('b', 4), ('c', 3), ('c', 0)]).group_by_key()\n        [('a', [1]), ('c', [3, 0]), ('b', [2, 3, 4])]\n\n        :return: sequence grouped by key\n        \"\"\"\n        return self._transform(transformations.group_by_key_t())\n\n    def reduce_by_key(self: Sequence[tuple[_U, _V]], func: Callable[[_V, _V], _R]) -> Sequence[tuple[_U, _R]]:\n        \"\"\"\n        Reduces a sequence of (Key, Value) using func on each sequence of values.\n\n        >>> seq([('a', 1), ('b', 2), ('b', 3), ('b', 4), ('c', 3), ('c', 0)])                 .reduce_by_key(lambda x, y: x + y)\n        [('a', 1), ('c', 3), ('b', 9)]\n\n        :param func: reduce each list of values using two parameter, associative func\n        :return: Sequence of tuples where the value is reduced with func\n        \"\"\"\n        return self._transform(transformations.reduce_by_key_t(func))\n\n    def count_by_key(self: Sequence[tuple[_T, Any]]) -> Sequence[tuple[_T, int]]:\n        \"\"\"\n        Reduces a sequence of (Key, Value) by counting each key\n\n        >>> seq([('a', 1), ('b', 2), ('b', 3), ('b', 4), ('c', 3), ('c', 0)]).count_by_key()\n        [('a', 1), ('b', 3), ('c', 2)]\n        :return: Sequence of tuples where value is the count of each key\n        \"\"\"\n        return self._transform(transformations.count_by_key_t())\n\n    def count_by_value(self) -> Sequence[tuple[_T_co, int]]:\n        \"\"\"\n        Reduces a sequence of items by counting each unique item\n\n        >>> seq(['a', 'a', 'a', 'b', 'b', 'c', 'd']).count_by_value()\n        [('a', 3), ('b', 2), ('c', 1), ('d', 1)]\n        :return: Sequence of tuples where value is the count of each key\n        \"\"\"\n        return self._transform(transformations.count_by_value_t())\n\n    @overload\n    def reduce(self, function: Callable[[_P, _T_co], _P], initial: _P, /) -> _P:\n        ...\n\n    @overload\n    def reduce(self, func: Callable[[_T_co, _T_co], _T_co], /) -> _T_co:\n        ...\n\n    def reduce(self, func, *initial):\n        \"\"\"\n        Reduce sequence of elements using func. API mirrors functools.reduce\n\n        >>> seq([1, 2, 3]).reduce(lambda x, y: x + y)\n        6\n\n        :param func: two parameter, associative reduce function\n        :param initial: single optional argument acting as initial value\n        :return: reduced value using func\n        \"\"\"\n        if len(initial) == 0:\n            return _wrap(reduce(func, self))\n        elif len(initial) == 1:\n            return _wrap(reduce(func, self, initial[0]))\n        else:\n            raise ValueError('reduce takes exactly one optional parameter for initial value')\n\n    def accumulate(self, func: Callable[[_T_co, _T_co], _T_co]=add) -> Sequence[_T_co]:\n        \"\"\"\n        Accumulate sequence of elements using func. API mirrors itertools.accumulate\n\n        >>> seq([1, 2, 3]).accumulate(lambda x, y: x + y)\n        [1, 3, 6]\n\n        >>> seq(['a', 'b', 'c']).accumulate()\n        ['a', 'ab', 'abc']\n\n        :param func: two parameter, associative accumulate function\n        :return: accumulated values using func in sequence\n        \"\"\"\n        return self._transform(transformations.accumulate_t(func))\n\n    def make_string(self, separator: str) -> str:\n        \"\"\"\n        Concatenate the elements of the sequence into a string separated by separator.\n\n        >>> seq([1, 2, 3]).make_string(\"@\")\n        '1@2@3'\n\n        :param separator: string separating elements in string\n        :return: concatenated string separated by separator\n        \"\"\"\n        return separator.join((str(e) for e in self))\n\n    def product(self, projection: Callable[[_T_co], float] | None=None) -> float:\n        \"\"\"\n        Takes product of elements in sequence.\n\n        >>> seq([1, 2, 3, 4]).product()\n        24\n\n        >>> seq([]).product()\n        1\n\n        >>> seq([(1, 2), (1, 3), (1, 4)]).product(lambda x: x[0])\n        1\n\n        :param projection: function to project on the sequence before taking the product\n        :return: product of elements in sequence\n        \"\"\"\n        if self.empty():\n            if projection:\n                return projection(1)\n            else:\n                return 1\n        if self.size() == 1:\n            if projection:\n                return projection(self.first())\n            else:\n                return self.first()\n        if projection:\n            return self.map(projection).reduce(mul)\n        else:\n            return self.reduce(mul)\n\n    def sum(self, projection: Callable[[_T_co], float] | None=None) -> float:\n        \"\"\"\n        Takes sum of elements in sequence.\n\n        >>> seq([1, 2, 3, 4]).sum()\n        10\n\n        >>> seq([(1, 2), (1, 3), (1, 4)]).sum(lambda x: x[0])\n        3\n\n        :param projection: function to project on the sequence before taking the sum\n        :return: sum of elements in sequence\n        \"\"\"\n        if projection:\n            return sum(self.map(projection))\n        else:\n            return sum(self)\n\n    def average(self, projection: Callable[[_T_co], float] | None=None) -> float:\n        \"\"\"\n        Takes the average of elements in the sequence\n\n        >>> seq([1, 2]).average()\n        1.5\n\n        >>> seq([('a', 1), ('b', 2)]).average(lambda x: x[1])\n\n        :param projection: function to project on the sequence before taking the average\n        :return: average of elements in the sequence\n        \"\"\"\n        length = self.size()\n        if projection:\n            return sum(self.map(projection)) / length\n        else:\n            return sum(self) / length\n\n    @overload\n    def aggregate(self, func: Callable[[Sequence[_T], _T], _T], /) -> _T:\n        ...\n\n    @overload\n    def aggregate(self, seed: _T, func: Callable[[_T, _T], _T], /) -> _T:\n        ...\n\n    @overload\n    def aggregate(self, seed: _T, func: Callable[[_T, _T], _T], result_map: Callable[[_T], _R], /) -> _R:\n        ...\n\n    def aggregate(self, *args):\n        \"\"\"\n        Aggregates the sequence by specified arguments. Its behavior varies depending on if one,\n        two, or three arguments are passed. Assuming the type of the sequence is A:\n\n        One Argument: argument specifies a function of the type f(current: B, next: A => result: B.\n        current represents results computed so far, and next is the next element to aggregate into\n        current in order to return result.\n\n        Two Argument: the first argument is the seed value for the aggregation. The second argument\n        is the same as for the one argument case.\n\n        Three Argument: the first two arguments are the same as for one and two argument calls. The\n        additional third parameter is a function applied to the result of the aggregation before\n        returning the value.\n\n        :param args: options for how to execute the aggregation\n        :return: aggregated value\n        \"\"\"\n        seed = None\n        result_lambda = identity\n        if len(args) == 1:\n            func = args[0]\n        elif len(args) == 2:\n            seed = args[0]\n            func = args[1]\n        elif len(args) == 3:\n            seed = args[0]\n            func = args[1]\n            result_lambda = args[2]\n        else:\n            raise ValueError(f'aggregate takes 1-3 arguments, {len(args)} were given')\n        if len(args) == 1:\n            return result_lambda(self.drop(1).fold_left(self.first(), func))\n        else:\n            return result_lambda(self.fold_left(seed, func))\n\n    def fold_left(self, zero_value: _P, func: Callable[[_P, _T_co], _P]) -> _P:\n        \"\"\"\n        Assuming that the sequence elements are of type A, folds from left to right starting with\n        the seed value given by zero_value (of type A) using a function of type\n        func(current: B, next: A) => B. current represents the folded value so far and next is the\n        next element from the sequence to fold into current.\n\n        >>> seq('a', 'b', 'c').fold_left(['start'], lambda current, next: current + [next]))\n        ['start', 'a', 'b', 'c']\n\n        :param zero_value: zero value to reduce into\n        :param func: Two parameter function as described by function docs\n        :return: value from folding values with func into zero_value from left to right.\n        \"\"\"\n        result = zero_value\n        for element in self:\n            result = func(result, element)\n        return _wrap(result)\n\n    def fold_right(self, zero_value: _T, func: Callable[[_T_co, _T], _T]) -> _T:\n        \"\"\"\n        Assuming that the sequence elements are of type A, folds from right to left starting with\n        the seed value given by zero_value (of type A) using a function of type\n        func(next: A, current: B) => B. current represents the folded value so far and next is the\n        next element from the sequence to fold into current.\n\n        >>> seq('a', 'b', 'c').fold_left(['start'], lambda next, current: current + [next])\n        ['start', 'c', 'b', a']\n\n        :param zero_value: zero value to reduce into\n        :param func: Two parameter function as described by function docs\n        :return: value from folding values with func into zero_value from right to left\n        \"\"\"\n        result = zero_value\n        for element in self.reverse():\n            result = func(element, result)\n        return _wrap(result)\n\n    def zip(self, sequence: Iterable[_T]) -> Sequence[tuple[_T_co, _T]]:\n        \"\"\"\n        Zips the stored sequence with the given sequence.\n\n        >>> seq([1, 2, 3]).zip([4, 5, 6])\n        [(1, 4), (2, 5), (3, 6)]\n\n        :param sequence: second sequence to zip\n        :return: stored sequence zipped with given sequence\n        \"\"\"\n        return self._transform(transformations.zip_t(sequence))\n\n    def zip_with_index(self, start: int=0) -> Sequence[tuple[_T_co, int]]:\n        \"\"\"\n        Zips the sequence to its index, with the index being the second element of each tuple.\n\n        >>> seq(['a', 'b', 'c']).zip_with_index()\n        [('a', 0), ('b', 1), ('c', 2)]\n\n        :return: sequence zipped to its index\n        \"\"\"\n        return self._transform(transformations.zip_with_index_t(start))\n\n    def zip_with_next(self) -> Sequence[tuple[_T_co, _T_co]]:\n        \"\"\"\n        Zips this sequence minus last element with itself minus first element,\n        resulting in sequence of each element paired with the next.\n\n        >>> seq([1, 2, 3, 4]).zip_with_next()\n        [(1, 2), (2, 3), (3, 4)]\n\n        :return: sequence of adjacent elements paired\n        \"\"\"\n        return self._transform(transformations.zip_with_next_t())\n\n    def enumerate(self, start: int=0) -> Sequence[tuple[int, _T_co]]:\n        \"\"\"\n        Uses python enumerate to to zip the sequence with indexes starting at start.\n\n        >>> seq(['a', 'b', 'c']).enumerate(start=1)\n        [(1, 'a'), (2, 'b'), (3, 'c')]\n\n        :param start: Beginning of zip\n        :return: enumerated sequence starting at start\n        \"\"\"\n        return self._transform(transformations.enumerate_t(start))\n\n    def inner_join(self, other):\n        \"\"\"\n        Sequence and other must be composed of (Key, Value) pairs.\n        If self.sequence contains (K, V) pairs and other contains (K, W) pairs, the return result\n        is a sequence of (K, (V, W)) pairs. Will return only elements\n        where the key exists in both sequences.\n\n        >>> seq([('a', 1), ('b', 2), ('c', 3)]).inner_join([('a', 2), ('c', 5)])\n        [('a', (1, 2)), ('c', (3, 5))]\n\n        :param other: sequence to join with\n        :return: joined sequence of (K, (V, W)) pairs\n        \"\"\"\n        return self.join(other, 'inner')\n\n    def join(self, other, join_type='inner'):\n        \"\"\"\n        Sequence and other must be composed of (Key, Value) pairs. If self.sequence contains (K, V)\n        pairs and other contains (K, W) pairs, the return result is a sequence of (K, (V, W)) pairs.\n        If join_type is \"left\", V values will always be present, W values may be present or None.\n        If join_type is \"right\", W values will always be present, W values may be present or None.\n        If join_type is \"outer\", V or W may be present or None,\n        but never at the same time.\n\n        >>> seq([('a', 1), ('b', 2), ('c', 3)]).join([('a', 2), ('c', 5)], \"inner\")\n        [('a', (1, 2)), ('c', (3, 5))]\n\n        >>> seq([('a', 1), ('b', 2), ('c', 3)]).join([('a', 2), ('c', 5)])\n        [('a', (1, 2)), ('c', (3, 5))]\n\n        >>> seq([('a', 1), ('b', 2)]).join([('a', 3), ('c', 4)], \"left\")\n        [('a', (1, 3)), ('b', (2, None)]\n\n        >>> seq([('a', 1), ('b', 2)]).join([('a', 3), ('c', 4)], \"right\")\n        [('a', (1, 3)), ('c', (None, 4)]\n\n        >>> seq([('a', 1), ('b', 2)]).join([('a', 3), ('c', 4)], \"outer\")\n        [('a', (1, 3)), ('b', (2, None)), ('c', (None, 4))]\n\n        :param other: sequence to join with\n        :param join_type: specifies join_type, may be \"left\", \"right\", or \"outer\"\n        :return: side joined sequence of (K, (V, W)) pairs\n        \"\"\"\n        return self._transform(transformations.join_t(other, join_type))\n\n    def left_join(self, other):\n        \"\"\"\n        Sequence and other must be composed of (Key, Value) pairs. If self.sequence contains (K, V)\n        pairs and other contains (K, W) pairs, the return result is a sequence of (K, (V, W)) pairs.\n        V values will always be present, W values may be present or None.\n\n        >>> seq([('a', 1), ('b', 2)]).join([('a', 3), ('c', 4)])\n        [('a', (1, 3)), ('b', (2, None)]\n\n        :param other: sequence to join with\n        :return: left joined sequence of (K, (V, W)) pairs\n        \"\"\"\n        return self.join(other, 'left')\n\n    def right_join(self, other):\n        \"\"\"\n        Sequence and other must be composed of (Key, Value) pairs. If self.sequence contains (K, V)\n        pairs and other contains (K, W) pairs, the return result is a sequence of (K, (V, W)) pairs.\n        W values will always bepresent, V values may be present or None.\n\n        >>> seq([('a', 1), ('b', 2)]).join([('a', 3), ('c', 4)])\n        [('a', (1, 3)), ('b', (2, None)]\n\n        :param other: sequence to join with\n        :return: right joined sequence of (K, (V, W)) pairs\n        \"\"\"\n        return self.join(other, 'right')\n\n    def outer_join(self, other):\n        \"\"\"\n        Sequence and other must be composed of (Key, Value) pairs. If self.sequence contains (K, V)\n        pairs and other contains (K, W) pairs, the return result is a sequence of (K, (V, W)) pairs.\n        One of V or W will always be not None, but the other may be None\n\n        >>> seq([('a', 1), ('b', 2)]).outer_join([('a', 3), ('c', 4)], \"outer\")\n        [('a', (1, 3)), ('b', (2, None)), ('c', (None, 4))]\n\n        :param other: sequence to join with\n        :return: outer joined sequence of (K, (V, W)) pairs\n        \"\"\"\n        return self.join(other, 'outer')\n\n    def partition(self, func: Callable[[_T_co], Any]) -> tuple[Sequence[_T_co], Sequence[_T_co]]:\n        \"\"\"\n        Partition the sequence based on satisfying the predicate func.\n\n        >>> seq([-1, 1, -2, 2]).partition(lambda x: x < 0)\n        ([-1, -2], [1, 2])\n\n        :param func: predicate to partition on\n        :return: tuple of partitioned sequences\n        \"\"\"\n        return self._transform(transformations.partition_t(_wrap, func))\n\n    def grouped(self, size: int) -> Sequence[Self]:\n        \"\"\"\n        Partitions the elements into groups of length size.\n\n        >>> seq([1, 2, 3, 4, 5, 6, 7, 8]).grouped(2)\n        [[1, 2], [3, 4], [5, 6], [7, 8]]\n\n        >>> seq([1, 2, 3, 4, 5, 6, 7, 8]).grouped(3)\n        [[1, 2, 3], [4, 5, 6], [7, 8]]\n\n        The last partition has at least one element but may have less than size elements.\n\n        :param size: size of the partitions\n        :return: sequence partitioned into groups of length size\n        \"\"\"\n        return self._transform(transformations.grouped_t(size))\n\n    def sliding(self, size: int, step: int=1) -> Sequence[Self]:\n        \"\"\"\n        Groups elements in fixed size blocks by passing a sliding window over them.\n\n        The last window has at least one element but may have less than size elements\n\n        :param size: size of sliding window\n        :param step: step size between windows\n        :return: sequence of sliding windows\n        \"\"\"\n        return self._transform(transformations.sliding_t(_wrap, size, step))\n\n    def sorted(self, key: Callable[[_T_co], SupportsRichComparison] | None=None, reverse: bool=False) -> Sequence[_T_co]:\n        \"\"\"\n        Uses python sort and its passed arguments to sort the input.\n\n        >>> seq([2, 1, 4, 3]).sorted()\n        [1, 2, 3, 4]\n\n        :param key: sort using key function\n        :param reverse: return list reversed or not\n        :return: sorted sequence\n        \"\"\"\n        return self._transform(transformations.sorted_t(key=key, reverse=reverse))\n\n    def order_by(self, func: Callable[[_T_co], SupportsRichComparison]) -> Sequence[_T_co]:\n        \"\"\"\n        Orders the input according to func\n\n        >>> seq([(2, 'a'), (1, 'b'), (4, 'c'), (3, 'd')]).order_by(lambda x: x[0])\n        [1, 2, 3, 4]\n\n        :param func: order by function\n        :return: ordered sequence\n        \"\"\"\n        return self._transform(transformations.order_by_t(func))\n\n    def reverse(self) -> Sequence[_T_co]:\n        \"\"\"\n        Returns the reversed sequence.\n\n        >>> seq([1, 2, 3]).reverse()\n        [3, 2, 1]\n\n        :return: reversed sequence\n        \"\"\"\n        return reversed(self)\n\n    def distinct(self) -> Sequence[_T_co]:\n        \"\"\"\n        Returns sequence of distinct elements. Elements must be hashable.\n\n        >>> seq([1, 1, 2, 3, 3, 3, 4]).distinct()\n        [1, 2, 3, 4]\n\n        :return: sequence of distinct elements\n        \"\"\"\n        return self._transform(transformations.distinct_t())\n\n    def distinct_by(self, func: Callable[[_T_co], Hashable]) -> Sequence[_T_co]:\n        \"\"\"\n        Returns sequence of elements who are distinct by the passed function. The return\n        value of func must be hashable. When two elements are distinct by func, the first is taken.\n\n        :param func: function to use for determining distinctness\n        :return: elements distinct by func\n        \"\"\"\n        return self._transform(transformations.distinct_by_t(func))\n\n    def slice(self, start: int, until: int) -> Sequence[_T_co]:\n        \"\"\"\n        Takes a slice of the sequence starting at start and until but not including until.\n\n        >>> seq([1, 2, 3, 4]).slice(1, 2)\n        [2]\n        >>> seq([1, 2, 3, 4]).slice(1, 3)\n        [2, 3]\n\n        :param start: starting index\n        :param until: ending index\n        :return: slice including start until but not including until\n        \"\"\"\n        return self._transform(transformations.slice_t(start, until))\n\n    def to_list(self, n: int | None=None) -> list[_T_co]:\n        \"\"\"\n        Converts sequence to list of elements.\n\n        >>> type(seq([]).to_list())\n        list\n\n        >>> type(seq([]))\n        functional.pipeline.Sequence\n\n        >>> seq([1, 2, 3]).to_list()\n        [1, 2, 3]\n\n        :param n: Take n elements of sequence if not None\n        :return: list of elements in sequence\n        \"\"\"\n        if n is None:\n            self.cache()\n            return self._base_sequence\n        else:\n            return self.cache().take(n).list()\n\n    def list(self, n: int | None=None) -> list[_T_co]:\n        \"\"\"\n        Converts sequence to list of elements.\n\n        >>> type(seq([]).list())\n        list\n\n        >>> type(seq([]))\n        functional.pipeline.Sequence\n\n        >>> seq([1, 2, 3]).list()\n        [1, 2, 3]\n\n        :param n: Take n elements of sequence if not None\n        :return: list of elements in sequence\n        \"\"\"\n        return self.to_list(n=n)\n\n    def to_set(self) -> set[_T_co]:\n        \"\"\"\n        Converts sequence to a set of elements.\n\n        >>> type(seq([])).to_set()\n        set\n\n        >>> type(seq([]))\n        functional.pipeline.Sequence\n\n        >>> seq([1, 1, 2, 2]).to_set()\n        {1, 2}\n\n        :return:set of elements in sequence\n        \"\"\"\n        return set(self.sequence)\n\n    def set(self) -> set[_T_co]:\n        \"\"\"\n        Converts sequence to a set of elements.\n\n        >>> type(seq([])).to_set()\n        set\n\n        >>> type(seq([]))\n        functional.pipeline.Sequence\n\n        >>> seq([1, 1, 2, 2]).set()\n        {1, 2}\n\n        :return:set of elements in sequence\n        \"\"\"\n        return self.to_set()\n\n    @overload\n    def to_dict(self: Sequence[tuple[_K, _V]]) -> dict[_K, _V]:\n        ...\n\n    @overload\n    def to_dict(self: Sequence[tuple[_K, _V]], default: Callable[[], _V]) -> collections.defaultdict[_K, _V]:\n        ...\n\n    @overload\n    def to_dict(self: Sequence[tuple[_K, _V]], default: _V) -> collections.defaultdict[_K, _V]:\n        ...\n\n    def to_dict(self, default=None):\n        \"\"\"\n        Converts sequence of (Key, Value) pairs to a dictionary.\n\n        >>> type(seq([('a', 1)]).to_dict())\n        dict\n\n        >>> seq([('a', 1), ('b', 2)]).to_dict()\n        {'a': 1, 'b': 2}\n\n        :param default: Can be a callable zero argument function. When not None, the returned\n            dictionary is a collections.defaultdict with default as value for missing keys. If the\n            value is not callable, then a zero argument lambda function is created returning the\n            value and used for collections.defaultdict\n        :return: dictionary from sequence of (Key, Value) elements\n        \"\"\"\n        dictionary = dict(self.sequence)\n        if default is None:\n            return dictionary\n        elif hasattr(default, '__call__'):\n            return collections.defaultdict(default, dictionary)\n        else:\n            return collections.defaultdict(lambda: default, dictionary)\n\n    @overload\n    def dict(self: Sequence[tuple[_K, _V]]) -> dict[_K, _V]:\n        ...\n\n    @overload\n    def dict(self: Sequence[tuple[_K, _V]], default: Callable[[], _V]) -> collections.defaultdict[_K, _V]:\n        ...\n\n    @overload\n    def dict(self: Sequence[tuple[_K, _V]], default: _V) -> collections.defaultdict[_K, _V]:\n        ...\n\n    def dict(self, default=None):\n        \"\"\"\n        Converts sequence of (Key, Value) pairs to a dictionary.\n\n        >>> type(seq([('a', 1)]).dict())\n        dict\n\n        >>> seq([('a', 1), ('b', 2)]).dict()\n        {'a': 1, 'b': 2}\n\n        :param default: Can be a callable zero argument function. When not None, the returned\n            dictionary is a collections.defaultdict with default as value for missing keys. If the\n            value is not callable, then a zero argument lambda function is created returning the\n            value and used for collections.defaultdict\n        :return: dictionary from sequence of (Key, Value) elements\n        \"\"\"\n        return self.to_dict(default=default)\n\n    def to_file(self, path: str, delimiter: str | None=None, mode: str='wt', buffering: int=-1, encoding: str | None=None, errors: str | None=None, newline: str | None=None, compresslevel: int=9, format: int | None=None, check: int=-1, preset: int | None=None, filters: _FilterChain | None=None, compression: str | None=None) -> None:\n        \"\"\"\n        Saves the sequence to a file by executing str(self) which becomes str(self.to_list()). If\n        delimiter is defined will instead execute self.make_string(delimiter)\n\n        :param path: path to write file\n        :param delimiter: if defined, will call make_string(delimiter) and save that to file.\n        :param mode: file open mode\n        :param buffering: passed to builtins.open\n        :param encoding: passed to builtins.open\n        :param errors: passed to builtins.open\n        :param newline: passed to builtins.open\n        :param compression: compression format\n        :param compresslevel: passed to gzip.open\n        :param format: passed to lzma.open\n        :param check: passed to lzma.open\n        :param preset: passed to lzma.open\n        :param filters: passed to lzma.open\n        \"\"\"\n        with universal_write_open(path, mode=mode, buffering=buffering, encoding=encoding, errors=errors, newline=newline, compression=compression, compresslevel=compresslevel, format=format, check=check, preset=preset, filters=filters) as output:\n            if delimiter:\n                output.write(self.make_string(delimiter))\n            else:\n                output.write(str(self))\n\n    def to_jsonl(self, path: str, mode: str='wb', compression: str | None=None) -> None:\n        \"\"\"\n        Saves the sequence to a jsonl file. Each element is mapped using json.dumps then written\n        with a newline separating each element.\n\n        :param path: path to write file\n        :param mode: mode to write in, defaults to 'w' to overwrite contents\n        :param compression: compression format\n        \"\"\"\n        with universal_write_open(path, mode=mode, compression=compression) as output:\n            output.write((self.map(json.dumps).make_string('\\n') + '\\n').encode('utf-8'))\n\n    def to_json(self, path: str, root_array: bool=True, mode: str=WRITE_MODE, compression: str | None=None) -> None:\n        \"\"\"\n        Saves the sequence to a json file. If root_array is True, then the sequence will be written\n        to json with an array at the root. If it is False, then the sequence will be converted from\n        a sequence of (Key, Value) pairs to a dictionary so that the json root is a dictionary.\n\n        :param path: path to write file\n        :param root_array: write json root as an array or dictionary\n        :param mode: file open mode\n        \"\"\"\n        with universal_write_open(path, mode=mode, compression=compression) as output:\n            if root_array:\n                json.dump(self.to_list(), output)\n            else:\n                json.dump(self.to_dict(), output)\n\n    def to_csv(self, path: str, mode: str=WRITE_MODE, dialect: str='excel', compression: str | None=None, newline: str | None='', **fmtparams) -> None:\n        \"\"\"\n        Saves the sequence to a csv file. Each element should be an iterable which will be expanded\n        to the elements of each row.\n\n        :param path: path to write file\n        :param mode: file open mode\n        :param dialect: passed to csv.writer\n        :param fmtparams: passed to csv.writer\n        \"\"\"\n        if 'b' in mode:\n            newline = None\n        with universal_write_open(path, mode=mode, compression=compression, newline=newline) as output:\n            csv_writer = csv.writer(output, dialect=dialect, **fmtparams)\n            for row in self:\n                csv_writer.writerow([str(element) for element in row])\n\n    def _to_sqlite3_by_query(self, conn: sqlite3.Connection | sqlite3.Cursor, sql) -> None:\n        \"\"\"\n        Saves the sequence to sqlite3 database by supplied query.\n        Each element should be an iterable which will be expanded\n        to the elements of each row. Target table must be created in advance.\n\n        :param conn: path or sqlite connection, cursor\n        :param sql: SQL query string\n        \"\"\"\n        conn.executemany(sql, self)\n\n    def _to_sqlite3_by_table(self, conn: sqlite3.Connection | sqlite3.Cursor, table_name: str) -> None:\n        \"\"\"\n        Saves the sequence to the specified table of sqlite3 database.\n        Each element can be a dictionary, namedtuple, tuple or list.\n        Target table must be created in advance.\n\n        :param conn: path or sqlite connection, cursor\n        :param table_name: table name string\n        \"\"\"\n\n        def _insert_item(item):\n            if isinstance(item, dict):\n                cols = ', '.join(item.keys())\n                placeholders = ', '.join('?' * len(item))\n                sql = f'INSERT INTO {table_name} ({cols}) VALUES ({placeholders})'\n                conn.execute(sql, tuple(item.values()))\n            elif is_namedtuple(item):\n                cols = ', '.join(item._fields)\n                placeholders = ', '.join('?' * len(item))\n                sql = f'INSERT INTO {table_name} ({cols}) VALUES ({placeholders})'\n                conn.execute(sql, item)\n            elif isinstance(item, (list, tuple)):\n                placeholders = ', '.join('?' * len(item))\n                sql = f'INSERT INTO {table_name} VALUES ({placeholders})'\n                conn.execute(sql, item)\n            else:\n                raise TypeError(f'item must be one of dict, namedtuple, tuple or list got {type(item)}')\n        self.for_each(_insert_item)\n\n    def to_sqlite3(self, conn: sqlite3.Connection | sqlite3.Cursor | str, target: str, *args, **kwargs) -> None:\n        \"\"\"\n        Saves the sequence to sqlite3 database.\n        Target table must be created in advance.\n        The table schema is inferred from the elements in the sequence\n        if only target table name is supplied.\n\n        >>> seq([(1, 'Tom'), (2, 'Jack')])                .to_sqlite3('users.db', 'INSERT INTO user (id, name) VALUES (?, ?)')\n\n        >>> seq([{'id': 1, 'name': 'Tom'}, {'id': 2, 'name': 'Jack'}]).to_sqlite3(conn, 'user')\n\n        :param conn: path or sqlite connection, cursor\n        :param target: SQL query string or table name\n        :param args: passed to sqlite3.connect\n        :param kwargs: passed to sqlite3.connect\n        \"\"\"\n        insert_regex = re.compile('(insert|update)\\\\s+into', flags=re.IGNORECASE)\n        if insert_regex.match(target):\n            insert_f = self._to_sqlite3_by_query\n        else:\n            insert_f = self._to_sqlite3_by_table\n        if isinstance(conn, (sqlite3.Connection, sqlite3.Cursor)):\n            insert_f(conn, target)\n            conn.commit()\n        elif isinstance(conn, str):\n            with sqlite3.connect(conn, *args, **kwargs) as input_conn:\n                insert_f(input_conn, target)\n                input_conn.commit()\n        else:\n            raise ValueError('conn must be a must be a file path or sqlite3 Connection/Cursor')\n\n    def to_pandas(self, columns: tuple[str, ...] | None=None) -> DataFrame:\n        \"\"\"\n        Converts sequence to a pandas DataFrame using pandas.DataFrame.from_records\n\n        :param columns: columns for pandas to use\n        :return: DataFrame of sequence\n        \"\"\"\n        import pandas\n        return pandas.DataFrame.from_records(self.to_list(), columns=columns)\n\n    def show(self, n: int=10, headers: typing.Sequence[str]=(), tablefmt: str='simple', floatfmt: str='g', numalign: str='decimal', stralign: str='left', missingval: str='') -> None:\n        \"\"\"\n        Pretty print first n rows of sequence as a table. See\n        https://bitbucket.org/astanin/python-tabulate for details on tabulate parameters\n\n        :param n: Number of rows to show\n        :param headers: Passed to tabulate\n        :param tablefmt: Passed to tabulate\n        :param floatfmt: Passed to tabulate\n        :param numalign: Passed to tabulate\n        :param stralign: Passed to tabulate\n        :param missingval: Passed to tabulate\n        \"\"\"\n        formatted_seq = self.tabulate(n=n, headers=headers, tablefmt=tablefmt, floatfmt=floatfmt, numalign=numalign, stralign=stralign, missingval=missingval)\n        print(formatted_seq)\n\n    def _repr_html_(self) -> str | None:\n        \"\"\"\n        Allows  IPython render HTML tables\n        :return: First 10 rows of data as an HTML table\n        \"\"\"\n        return self.tabulate(10, tablefmt='html')\n\n    def tabulate(self, n: int | None=None, headers: typing.Sequence[str]=(), tablefmt: str='simple', floatfmt: str='g', numalign: str='decimal', stralign: str='left', missingval: str='') -> str | None:\n        \"\"\"\n        Return pretty string table of first n rows of sequence or everything if n is None. See\n        https://bitbucket.org/astanin/python-tabulate for details on tabulate parameters\n\n        :param n: Number of rows to show, if set to None return all rows\n        :param headers: Passed to tabulate\n        :param tablefmt: Passed to tabulate\n        :param floatfmt: Passed to tabulate\n        :param numalign: Passed to tabulate\n        :param stralign: Passed to tabulate\n        :param missingval: Passed to tabulate\n        \"\"\"\n        self.cache()\n        length = self.len()\n        if length == 0 or not is_tabulatable(self[0]):\n            return None\n        if n is None or n >= length:\n            rows = self.list()\n            message = ''\n        else:\n            rows = self.take(n).list()\n            if tablefmt == 'simple':\n                message = f'\\nShowing {n} of {length} rows'\n            elif tablefmt == 'html':\n                message = f'<p>Showing {n} of {length} rows'\n            else:\n                message = ''\n        if len(headers) == 0 and is_namedtuple(rows[0]):\n            headers = rows[0]._fields\n        return tabulate(rows, headers=headers, tablefmt=tablefmt, floatfmt=floatfmt, numalign=numalign, stralign=stralign, missingval=missingval) + message\n\nExample skeleton:\n\nnan\nCorresponding class implementation:\n\nfrom scipy.optimize import minimize\nfrom functools import partial\nfrom qiskit.transpiler.passes.synthesis import AQCSynthesisPlugin\nfrom qiskit import QuantumCircuit\nfrom qiskit.converters import dag_to_circuit, circuit_to_dag\nfrom qiskit.transpiler.passes import UnitarySynthesis\nfrom test import QiskitTestCase\nfrom qiskit.transpiler import PassManager\nfrom qiskit.quantum_info import Operator\nimport numpy as np\n\nclass TestAQCSynthesisPlugin(QiskitTestCase):\n    \"\"\"Basic tests of the AQC synthesis plugin.\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self._qc = QuantumCircuit(3)\n        self._qc.mcx([0, 1], 2)\n        self._target_unitary = Operator(self._qc).data\n        self._seed_config = {'seed': 12345}\n\n    def test_aqc_plugin(self):\n        \"\"\"Basic test of the plugin.\"\"\"\n        plugin = AQCSynthesisPlugin()\n        dag = plugin.run(self._target_unitary, config=self._seed_config)\n        approx_circuit = dag_to_circuit(dag)\n        approx_unitary = Operator(approx_circuit).data\n        np.testing.assert_array_almost_equal(self._target_unitary, approx_unitary, 3)\n\n    def test_plugin_setup(self):\n        \"\"\"Tests the plugin via unitary synthesis pass\"\"\"\n        transpiler_pass = UnitarySynthesis(basis_gates=['rx', 'ry', 'rz', 'cx'], method='aqc', plugin_config=self._seed_config)\n        dag = circuit_to_dag(self._qc)\n        dag = transpiler_pass.run(dag)\n        approx_circuit = dag_to_circuit(dag)\n        approx_unitary = Operator(approx_circuit).data\n        np.testing.assert_array_almost_equal(self._target_unitary, approx_unitary, 3)\n\n    def test_plugin_configuration(self):\n        \"\"\"Tests plugin with a custom configuration.\"\"\"\n        optimizer = partial(minimize, args=(), method='SLSQP')\n        config = {'network_layout': 'sequ', 'connectivity_type': 'full', 'depth': 0, 'seed': 12345, 'optimizer': optimizer}\n        transpiler_pass = UnitarySynthesis(basis_gates=['rx', 'ry', 'rz', 'cx'], method='aqc', plugin_config=config)\n        dag = circuit_to_dag(self._qc)\n        dag = transpiler_pass.run(dag)\n        approx_circuit = dag_to_circuit(dag)\n        approx_unitary = Operator(approx_circuit).data\n        np.testing.assert_array_almost_equal(self._target_unitary, approx_unitary, 3)\n\n    def test_with_pass_manager(self):\n        \"\"\"Tests the plugin via pass manager\"\"\"\n        qc = QuantumCircuit(3)\n        qc.unitary(np.eye(8), [0, 1, 2])\n        aqc = PassManager([UnitarySynthesis(basis_gates=['u', 'cx'], method='aqc', plugin_config=self._seed_config)]).run(qc)\n        approx_unitary = Operator(aqc).data\n        np.testing.assert_array_almost_equal(np.eye(8), approx_unitary, 3)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\nnan"
  }
]