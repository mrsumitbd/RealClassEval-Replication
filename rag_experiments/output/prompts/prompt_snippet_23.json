[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass ExasolHook(DbApiHook):\n    '''\n    Interact with Exasol.\n    You can specify the pyexasol ``compression``, ``encryption``, ``json_lib``\n    and ``client_name``  parameters in the extra field of your connection\n    as ``{\"compression\": True, \"json_lib\": \"rapidjson\", etc}``.\n    See `pyexasol reference\n    <https://github.com/badoo/pyexasol/blob/master/docs/REFERENCE.md#connect>`_\n    for more details.\n    '''\n\n    def __init__(self, *args, sqlalchemy_scheme: str | None=None, **kwargs) -> None:\n        pass\n\n    def get_conn(self) -> ExaConnection:\n        pass\n    @property\n    def sqlalchemy_scheme(self) -> str:\n        '''Sqlalchemy scheme either from constructor, connection extras or default.'''\n        pass\n    @property\n    def sqlalchemy_url(self) -> URL:\n        '''\n        Return a Sqlalchemy.engine.URL object from the connection.\n        :return: the extracted sqlalchemy.engine.URL object.\n        '''\n        pass\n\n    def get_uri(self) -> str:\n        '''\n        Extract the URI from the connection.\n        :return: the extracted uri.\n        '''\n        pass\n\n    def _get_pandas_df(self, sql, parameters: Iterable | Mapping[str, Any] | None=None, **kwargs) -> pd.DataFrame:\n        '''\n        Execute the SQL and return a Pandas dataframe.\n        :param sql: The sql statement to be executed (str) or a list of\n            sql statements to execute.\n        :param parameters: The parameters to render the SQL query with.\n        Other keyword arguments are all forwarded into\n        ``pyexasol.ExaConnection.export_to_pandas``.\n        '''\n        pass\n    @deprecated(reason='Replaced by function `get_df`.', category=AirflowProviderDeprecationWarning, action='ignore')\n    def get_pandas_df(self, sql, parameters: list | tuple | Mapping[str, Any] | None=None, **kwargs) -> pd.DataFrame:\n        '''\n        Execute the sql and returns a pandas dataframe.\n        :param sql: the sql statement to be executed (str) or a list of sql statements to execute\n        :param parameters: The parameters to render the SQL query with.\n        :param kwargs: (optional) passed into pandas.io.sql.read_sql method\n        '''\n        pass\n\n    def _get_polars_df(self, sql, parameters: list | tuple | Mapping[str, Any] | None=None, **kwargs):\n        pass\n\n    def get_records(self, sql: str | list[str], parameters: Iterable | Mapping[str, Any] | None=None) -> list[dict | tuple[Any, ...]]:\n        '''\n        Execute the SQL and return a set of records.\n        :param sql: the sql statement to be executed (str) or a list of\n            sql statements to execute\n        :param parameters: The parameters to render the SQL query with.\n        '''\n        pass\n\n    def get_first(self, sql: str | list[str], parameters: Iterable | Mapping[str, Any] | None=None) -> Any:\n        '''\n        Execute the SQL and return the first resulting row.\n        :param sql: the sql statement to be executed (str) or a list of\n            sql statements to execute\n        :param parameters: The parameters to render the SQL query with.\n        '''\n        pass\n\n    def export_to_file(self, filename: str, query_or_table: str, query_params: dict | None=None, export_params: dict | None=None) -> None:\n        '''\n        Export data to a file.\n        :param filename: Path to the file to which the data has to be exported\n        :param query_or_table: the sql statement to be executed or table name to export\n        :param query_params: Query parameters passed to underlying ``export_to_file``\n            method of :class:`~pyexasol.connection.ExaConnection`.\n        :param export_params: Extra parameters passed to underlying ``export_to_file``\n            method of :class:`~pyexasol.connection.ExaConnection`.\n        '''\n        pass\n    @staticmethod\n    def get_description(statement: ExaStatement) -> Sequence[Sequence]:\n        '''\n        Get description; copied implementation from DB2-API wrapper.\n        For more info, see\n        https://github.com/exasol/pyexasol/blob/master/docs/DBAPI_COMPAT.md#db-api-20-wrapper\n        :param statement: Exasol statement\n        :return: description sequence of t\n        '''\n        pass\n    @overload\n    def run(self, sql: str | Iterable[str], autocommit: bool=..., parameters: Iterable | Mapping[str, Any] | None=..., handler: None=..., split_statements: bool=..., return_last: bool=...) -> None:\n        pass\n    @overload\n    def run(self, sql: str | Iterable[str], autocommit: bool=..., parameters: Iterable | Mapping[str, Any] | None=..., handler: None=..., split_statements: bool=..., return_last: bool=...) -> None:\n        pass\n    def run(self, sql: str | Iterable[str], autocommit: bool=..., parameters: Iterable | Mapping[str, Any] | None=..., handler: None=..., split_statements: bool=..., return_last: bool=...) -> None:\n        '''\n        Run a command or a list of commands.\n        Pass a list of SQL statements to the SQL parameter to get them to\n        execute sequentially.\n        :param sql: the sql statement to be executed (str) or a list of\n            sql statements to execute\n        :param autocommit: What to set the connection's autocommit setting to\n            before executing the query.\n        :param parameters: The parameters to render the SQL query with.\n        :param handler: The result handler which is called with the result of each statement.\n        :param split_statements: Whether to split a single SQL string into statements and run separately\n        :param return_last: Whether to return result for only last statement or for all after split\n        :return: return only result of the LAST SQL expression if handler was provided.\n        '''\n        pass\n\n    def set_autocommit(self, conn, autocommit: bool) -> None:\n        '''\n        Set the autocommit flag on the connection.\n        :param conn: Connection to set autocommit setting to.\n        :param autocommit: The autocommit setting to set.\n        '''\n        pass\n\n    def get_autocommit(self, conn) -> bool:\n        '''\n        Get autocommit setting for the provided connection.\n        :param conn: Connection to get autocommit setting from.\n        :return: connection autocommit setting. True if ``autocommit`` is set\n            to True on the connection. False if it is either not set, set to\n            False, or the connection does not support auto-commit.\n        '''\n        pass\n    @staticmethod\n    def _serialize_cell(cell, conn=None) -> Any:\n        '''\n        Override to disable cell serialization.\n        Exasol will adapt all arguments to the ``execute()`` method internally,\n        hence we return cell without any conversion.\n        :param cell: The cell to insert into the table\n        :param conn: The database connection\n        :return: The cell\n        '''\n        pass\nCorresponding class implementation:\n\nimport pyexasol\nfrom collections.abc import Callable, Iterable, Mapping, Sequence\nfrom pyexasol import ExaConnection, ExaStatement\nfrom typing import TYPE_CHECKING, Any, TypeVar, overload\nfrom airflow.providers.common.sql.hooks.handlers import return_single_query_results\nfrom airflow.providers.common.sql.hooks.sql import DbApiHook\nfrom deprecated import deprecated\nfrom sqlalchemy.engine import URL\nfrom airflow.exceptions import AirflowProviderDeprecationWarning\nfrom contextlib import closing\n\nclass ExasolHook(DbApiHook):\n    \"\"\"\n    Interact with Exasol.\n\n    You can specify the pyexasol ``compression``, ``encryption``, ``json_lib``\n    and ``client_name``  parameters in the extra field of your connection\n    as ``{\"compression\": True, \"json_lib\": \"rapidjson\", etc}``.\n\n    See `pyexasol reference\n    <https://github.com/badoo/pyexasol/blob/master/docs/REFERENCE.md#connect>`_\n    for more details.\n    \"\"\"\n    conn_name_attr = 'exasol_conn_id'\n    default_conn_name = 'exasol_default'\n    conn_type = 'exasol'\n    hook_name = 'Exasol'\n    supports_autocommit = True\n    DEFAULT_SQLALCHEMY_SCHEME = 'exa+websocket'\n\n    def __init__(self, *args, sqlalchemy_scheme: str | None=None, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self.schema = kwargs.pop('schema', None)\n        self._sqlalchemy_scheme = sqlalchemy_scheme\n\n    def get_conn(self) -> ExaConnection:\n        conn = self.get_connection(self.get_conn_id())\n        conn_args = {'dsn': f'{conn.host}:{conn.port}', 'user': conn.login, 'password': conn.password, 'schema': self.schema or conn.schema}\n        for arg_name, arg_val in conn.extra_dejson.items():\n            if arg_name in ['compression', 'encryption', 'json_lib', 'client_name']:\n                conn_args[arg_name] = arg_val\n        conn = pyexasol.connect(**conn_args)\n        return conn\n\n    @property\n    def sqlalchemy_scheme(self) -> str:\n        \"\"\"Sqlalchemy scheme either from constructor, connection extras or default.\"\"\"\n        extra_scheme = self.connection is not None and self.connection_extra_lower.get('sqlalchemy_scheme')\n        sqlalchemy_scheme = self._sqlalchemy_scheme or extra_scheme or self.DEFAULT_SQLALCHEMY_SCHEME\n        if sqlalchemy_scheme not in ['exa+websocket', 'exa+pyodbc', 'exa+turbodbc']:\n            raise ValueError(f\"sqlalchemy_scheme in connection extra should be one of 'exa+websocket', 'exa+pyodbc' or 'exa+turbodbc', but got '{sqlalchemy_scheme}'. See https://github.com/exasol/sqlalchemy-exasol?tab=readme-ov-file#using-sqlalchemy-with-exasol-db for more details.\")\n        return sqlalchemy_scheme\n\n    @property\n    def sqlalchemy_url(self) -> URL:\n        \"\"\"\n        Return a Sqlalchemy.engine.URL object from the connection.\n\n        :return: the extracted sqlalchemy.engine.URL object.\n        \"\"\"\n        connection = self.connection\n        query = connection.extra_dejson\n        query = {k: v for k, v in query.items() if k.lower() != 'sqlalchemy_scheme'}\n        return URL.create(drivername=self.sqlalchemy_scheme, username=connection.login, password=connection.password, host=connection.host, port=connection.port, database=self.schema or connection.schema, query=query)\n\n    def get_uri(self) -> str:\n        \"\"\"\n        Extract the URI from the connection.\n\n        :return: the extracted uri.\n        \"\"\"\n        return self.sqlalchemy_url.render_as_string(hide_password=False)\n\n    def _get_pandas_df(self, sql, parameters: Iterable | Mapping[str, Any] | None=None, **kwargs) -> pd.DataFrame:\n        \"\"\"\n        Execute the SQL and return a Pandas dataframe.\n\n        :param sql: The sql statement to be executed (str) or a list of\n            sql statements to execute.\n        :param parameters: The parameters to render the SQL query with.\n\n        Other keyword arguments are all forwarded into\n        ``pyexasol.ExaConnection.export_to_pandas``.\n        \"\"\"\n        with closing(self.get_conn()) as conn:\n            df = conn.export_to_pandas(sql, query_params=parameters, **kwargs)\n            return df\n\n    @deprecated(reason='Replaced by function `get_df`.', category=AirflowProviderDeprecationWarning, action='ignore')\n    def get_pandas_df(self, sql, parameters: list | tuple | Mapping[str, Any] | None=None, **kwargs) -> pd.DataFrame:\n        \"\"\"\n        Execute the sql and returns a pandas dataframe.\n\n        :param sql: the sql statement to be executed (str) or a list of sql statements to execute\n        :param parameters: The parameters to render the SQL query with.\n        :param kwargs: (optional) passed into pandas.io.sql.read_sql method\n        \"\"\"\n        return self._get_pandas_df(sql, parameters, **kwargs)\n\n    def _get_polars_df(self, sql, parameters: list | tuple | Mapping[str, Any] | None=None, **kwargs):\n        raise NotImplementedError('Polars is not supported for Exasol')\n\n    def get_records(self, sql: str | list[str], parameters: Iterable | Mapping[str, Any] | None=None) -> list[dict | tuple[Any, ...]]:\n        \"\"\"\n        Execute the SQL and return a set of records.\n\n        :param sql: the sql statement to be executed (str) or a list of\n            sql statements to execute\n        :param parameters: The parameters to render the SQL query with.\n        \"\"\"\n        with closing(self.get_conn()) as conn, closing(conn.execute(sql, parameters)) as cur:\n            return cur.fetchall()\n\n    def get_first(self, sql: str | list[str], parameters: Iterable | Mapping[str, Any] | None=None) -> Any:\n        \"\"\"\n        Execute the SQL and return the first resulting row.\n\n        :param sql: the sql statement to be executed (str) or a list of\n            sql statements to execute\n        :param parameters: The parameters to render the SQL query with.\n        \"\"\"\n        with closing(self.get_conn()) as conn, closing(conn.execute(sql, parameters)) as cur:\n            return cur.fetchone()\n\n    def export_to_file(self, filename: str, query_or_table: str, query_params: dict | None=None, export_params: dict | None=None) -> None:\n        \"\"\"\n        Export data to a file.\n\n        :param filename: Path to the file to which the data has to be exported\n        :param query_or_table: the sql statement to be executed or table name to export\n        :param query_params: Query parameters passed to underlying ``export_to_file``\n            method of :class:`~pyexasol.connection.ExaConnection`.\n        :param export_params: Extra parameters passed to underlying ``export_to_file``\n            method of :class:`~pyexasol.connection.ExaConnection`.\n        \"\"\"\n        self.log.info('Getting data from exasol')\n        with closing(self.get_conn()) as conn:\n            conn.export_to_file(dst=filename, query_or_table=query_or_table, query_params=query_params, export_params=export_params)\n        self.log.info('Data saved to %s', filename)\n\n    @staticmethod\n    def get_description(statement: ExaStatement) -> Sequence[Sequence]:\n        \"\"\"\n        Get description; copied implementation from DB2-API wrapper.\n\n        For more info, see\n        https://github.com/exasol/pyexasol/blob/master/docs/DBAPI_COMPAT.md#db-api-20-wrapper\n\n        :param statement: Exasol statement\n        :return: description sequence of t\n        \"\"\"\n        cols = []\n        for k, v in statement.columns().items():\n            cols.append((k, v.get('type', None), v.get('size', None), v.get('size', None), v.get('precision', None), v.get('scale', None), True))\n        return cols\n\n    @overload\n    def run(self, sql: str | Iterable[str], autocommit: bool=..., parameters: Iterable | Mapping[str, Any] | None=..., handler: None=..., split_statements: bool=..., return_last: bool=...) -> None:\n        ...\n\n    @overload\n    def run(self, sql: str | Iterable[str], autocommit: bool=..., parameters: Iterable | Mapping[str, Any] | None=..., handler: Callable[[Any], T]=..., split_statements: bool=..., return_last: bool=...) -> tuple | list[tuple] | list[list[tuple] | tuple] | None:\n        ...\n\n    def run(self, sql: str | Iterable[str], autocommit: bool=False, parameters: Iterable | Mapping[str, Any] | None=None, handler: Callable[[Any], T] | None=None, split_statements: bool=False, return_last: bool=True) -> tuple | list[tuple] | list[list[tuple] | tuple] | None:\n        \"\"\"\n        Run a command or a list of commands.\n\n        Pass a list of SQL statements to the SQL parameter to get them to\n        execute sequentially.\n\n        :param sql: the sql statement to be executed (str) or a list of\n            sql statements to execute\n        :param autocommit: What to set the connection's autocommit setting to\n            before executing the query.\n        :param parameters: The parameters to render the SQL query with.\n        :param handler: The result handler which is called with the result of each statement.\n        :param split_statements: Whether to split a single SQL string into statements and run separately\n        :param return_last: Whether to return result for only last statement or for all after split\n        :return: return only result of the LAST SQL expression if handler was provided.\n        \"\"\"\n        self.descriptions = []\n        if isinstance(sql, str):\n            if split_statements:\n                sql_list: Iterable[str] = self.split_sql_string(sql)\n            else:\n                statement = self.strip_sql_string(sql)\n                sql_list = [statement] if statement.strip() else []\n        else:\n            sql_list = sql\n        if sql_list:\n            self.log.debug('Executing following statements against Exasol DB: %s', list(sql_list))\n        else:\n            raise ValueError('List of SQL statements is empty')\n        _last_result = None\n        with closing(self.get_conn()) as conn:\n            self.set_autocommit(conn, autocommit)\n            results = []\n            for sql_statement in sql_list:\n                self.log.info('Running statement: %s, parameters: %s', sql_statement, parameters)\n                with closing(conn.execute(sql_statement, parameters)) as exa_statement:\n                    if handler is not None:\n                        result = self._make_common_data_structure(handler(exa_statement))\n                        if return_single_query_results(sql, return_last, split_statements):\n                            _last_result = result\n                            _last_columns = self.get_description(exa_statement)\n                        else:\n                            results.append(result)\n                            self.descriptions.append(self.get_description(exa_statement))\n                    self.log.info('Rows affected: %s', exa_statement.rowcount())\n            if not self.get_autocommit(conn):\n                conn.commit()\n        if handler is None:\n            return None\n        if return_single_query_results(sql, return_last, split_statements):\n            self.descriptions = [_last_columns]\n            return _last_result\n        return results\n\n    def set_autocommit(self, conn, autocommit: bool) -> None:\n        \"\"\"\n        Set the autocommit flag on the connection.\n\n        :param conn: Connection to set autocommit setting to.\n        :param autocommit: The autocommit setting to set.\n        \"\"\"\n        if not self.supports_autocommit and autocommit:\n            self.log.warning(\"%s connection doesn't support autocommit but autocommit activated.\", self.get_conn_id())\n        conn.set_autocommit(autocommit)\n\n    def get_autocommit(self, conn) -> bool:\n        \"\"\"\n        Get autocommit setting for the provided connection.\n\n        :param conn: Connection to get autocommit setting from.\n        :return: connection autocommit setting. True if ``autocommit`` is set\n            to True on the connection. False if it is either not set, set to\n            False, or the connection does not support auto-commit.\n        \"\"\"\n        autocommit = conn.attr.get('autocommit')\n        if autocommit is None:\n            autocommit = super().get_autocommit(conn)\n        return autocommit\n\n    @staticmethod\n    def _serialize_cell(cell, conn=None) -> Any:\n        \"\"\"\n        Override to disable cell serialization.\n\n        Exasol will adapt all arguments to the ``execute()`` method internally,\n        hence we return cell without any conversion.\n\n        :param cell: The cell to insert into the table\n        :param conn: The database connection\n        :return: The cell\n        \"\"\"\n        return cell\n\nExample skeleton:\n\n\nclass UserSource(Source):\n    '''\n    UserSource\n    '''\n\n    class Config:\n        '''Pydantic configuration'''\n\n    def to_str(self) -> str:\n        '''Returns the string representation of the model using alias'''\n        pass\n\n    def to_json(self) -> str:\n        '''Returns the JSON representation of the model using alias'''\n        pass\n    @classmethod\n    def from_json(cls, json_str: str) -> UserSource:\n        '''Create an instance of UserSource from a JSON string'''\n        pass\n\n    def to_dict(self):\n        '''Returns the dictionary representation of the model using alias'''\n        pass\n    @classmethod\n    def from_dict(cls, obj: dict) -> UserSource:\n        '''Create an instance of UserSource from a dict'''\n        pass\nCorresponding class implementation:\n\nfrom pydantic.v1 import Field, StrictStr\nimport pprint\nfrom typing import Optional\nimport json\nfrom linebot.v3.webhooks.models.source import Source\n\nclass UserSource(Source):\n    \"\"\"\n    UserSource\n    \"\"\"\n    user_id: Optional[StrictStr] = Field(None, alias='userId', description='ID of the source user')\n    type: str = 'user'\n    __properties = ['type', 'userId']\n\n    class Config:\n        \"\"\"Pydantic configuration\"\"\"\n        allow_population_by_field_name = True\n        validate_assignment = True\n\n    def to_str(self) -> str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.dict(by_alias=True))\n\n    def to_json(self) -> str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -> UserSource:\n        \"\"\"Create an instance of UserSource from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self):\n        \"\"\"Returns the dictionary representation of the model using alias\"\"\"\n        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict) -> UserSource:\n        \"\"\"Create an instance of UserSource from a dict\"\"\"\n        if obj is None:\n            return None\n        if not isinstance(obj, dict):\n            return UserSource.parse_obj(obj)\n        _obj = UserSource.parse_obj({'type': obj.get('type'), 'user_id': obj.get('userId')})\n        return _obj\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass GitHubURLExtractor:\n    '''提取GitHub URL的工具类'''\n    @staticmethod\n    def extract_github_urls(text: str) -> List[str]:\n        '''从文本中提取GitHub URLs'''\n        pass\n    @staticmethod\n    def extract_target_path(text: str) -> Optional[str]:\n        '''从文本中提取目标路径'''\n        pass\n    @staticmethod\n    def infer_repo_name(url: str) -> str:\n        '''从URL推断仓库名称'''\n        pass"
  }
]