[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass SubprocessHook(BaseHook):\n    '''Hook for running processes with the ``subprocess`` module.'''\n\n    def __init__(self, **kwargs) -> None:\n        pass\n\n    def run_command(self, command: list[str], env: dict[str, str] | None=None, output_encoding: str='utf-8', cwd: str | None=None) -> SubprocessResult:\n        '''\n        Execute the command.\n        If ``cwd`` is None, execute the command in a temporary directory which will be cleaned afterwards.\n        If ``env`` is not supplied, ``os.environ`` is passed\n        :param command: the command to run\n        :param env: Optional dict containing environment variables to be made available to the shell\n            environment in which ``command`` will be executed.  If omitted, ``os.environ`` will be used.\n            Note, that in case you have Sentry configured, original variables from the environment\n            will also be passed to the subprocess with ``SUBPROCESS_`` prefix. See:\n            https://airflow.apache.org/docs/apache-airflow/stable/administration-and-deployment/logging-monitoring/errors.html for details.\n        :param output_encoding: encoding to use for decoding stdout\n        :param cwd: Working directory to run the command in.\n            If None (default), the command is run in a temporary directory.\n        :return: :class:`namedtuple` containing ``exit_code`` and ``output``, the last line from stderr\n            or stdout\n        '''\n        pass\n\n            def pre_exec():\n                        pass\n\n    def send_sigterm(self):\n        '''Send SIGTERM signal to ``self.sub_process`` if one exists.'''\n        pass\nCorresponding class implementation:\n\nimport signal\nfrom airflow.providers.standard.version_compat import BaseHook\nfrom tempfile import TemporaryDirectory, gettempdir\nimport os\nfrom subprocess import PIPE, STDOUT, Popen\n\nclass SubprocessHook(BaseHook):\n    \"\"\"Hook for running processes with the ``subprocess`` module.\"\"\"\n\n    def __init__(self, **kwargs) -> None:\n        self.sub_process: Popen[bytes] | None = None\n        super().__init__(**kwargs)\n\n    def run_command(self, command: list[str], env: dict[str, str] | None=None, output_encoding: str='utf-8', cwd: str | None=None) -> SubprocessResult:\n        \"\"\"\n        Execute the command.\n\n        If ``cwd`` is None, execute the command in a temporary directory which will be cleaned afterwards.\n        If ``env`` is not supplied, ``os.environ`` is passed\n\n        :param command: the command to run\n        :param env: Optional dict containing environment variables to be made available to the shell\n            environment in which ``command`` will be executed.  If omitted, ``os.environ`` will be used.\n            Note, that in case you have Sentry configured, original variables from the environment\n            will also be passed to the subprocess with ``SUBPROCESS_`` prefix. See:\n            https://airflow.apache.org/docs/apache-airflow/stable/administration-and-deployment/logging-monitoring/errors.html for details.\n        :param output_encoding: encoding to use for decoding stdout\n        :param cwd: Working directory to run the command in.\n            If None (default), the command is run in a temporary directory.\n        :return: :class:`namedtuple` containing ``exit_code`` and ``output``, the last line from stderr\n            or stdout\n        \"\"\"\n        self.log.info('Tmp dir root location: %s', gettempdir())\n        with working_directory(cwd=cwd) as cwd:\n\n            def pre_exec():\n                for sig in ('SIGPIPE', 'SIGXFZ', 'SIGXFSZ'):\n                    if hasattr(signal, sig):\n                        signal.signal(getattr(signal, sig), signal.SIG_DFL)\n                os.setsid()\n            self.log.info('Running command: %s', command)\n            self.sub_process = Popen(command, stdout=PIPE, stderr=STDOUT, cwd=cwd, env=env if env or env == {} else os.environ, preexec_fn=pre_exec)\n            self.log.info('Output:')\n            line = ''\n            if self.sub_process is None:\n                raise RuntimeError('The subprocess should be created here and is None!')\n            if self.sub_process.stdout is not None:\n                for raw_line in iter(self.sub_process.stdout.readline, b''):\n                    line = raw_line.decode(output_encoding, errors='backslashreplace').rstrip()\n                    self.log.info('%s', line)\n            self.sub_process.wait()\n            self.log.info('Command exited with return code %s', self.sub_process.returncode)\n            return_code: int = self.sub_process.returncode\n        return SubprocessResult(exit_code=return_code, output=line)\n\n    def send_sigterm(self):\n        \"\"\"Send SIGTERM signal to ``self.sub_process`` if one exists.\"\"\"\n        self.log.info('Sending SIGTERM signal to process group')\n        if self.sub_process and hasattr(self.sub_process, 'pid'):\n            os.killpg(os.getpgid(self.sub_process.pid), signal.SIGTERM)\n\nExample skeleton:\n\n\nclass Runner:\n    '''\n    HTTP service runner.\n    :param tornado.web.Application app: the application to serve\n    This class implements the logic necessary to safely run a\n    Tornado HTTP service inside of a docker container.\n    .. rubric:: Usage Example\n    .. code-block:: python\n       def make_app():\n           return web.Application(...)\n       def run():\n           server = runner.Runner(make_app())\n           server.start_server()\n           ioloop.IOLoop.instance().start()\n    The :meth:`.start_server` method sets up the necessary signal handling\n    to ensure that we have a clean shutdown in the face of signals.\n    '''\n\n    def __init__(self, app, before_run=None, on_start=None, shutdown=None):\n        '''Create a new instance of the runner.\n        :param tornado.web.Application app: The application instance to run\n        :param list before_run: Callbacks to invoke before starting\n        :param list on_start: Callbacks to invoke after starting the IOLoop\n        :param list shutdown: Callbacks to invoke on shutdown\n        '''\n        pass\n\n    def start_server(self, port_number, number_of_procs=0):\n        '''\n        Create a HTTP server and start it.\n        :param int port_number: the port number to bind the server to\n        :param int number_of_procs: number of processes to pass to\n            Tornado's ``httpserver.HTTPServer.start``.\n        If the application's ``debug`` setting is ``True``, then we are\n        going to run in a single-process mode; otherwise, we'll let\n        tornado decide how many sub-processes to spawn.\n        The following additional configuration parameters can be set on the\n        ``httpserver.HTTPServer`` instance by setting them in the application\n        settings: ``xheaders``, ``max_body_size``, ``max_buffer_size``.\n        '''\n        pass\n\n    def stop_server(self):\n        '''Stop the HTTP Server'''\n        pass\n\n       def run():\n           '''\n        Create the server and run the IOLoop.\n        :param int port_number: the port number to bind the server to\n        :param int number_of_procs: number of processes to pass to\n            Tornado's ``httpserver.HTTPServer.start``.\n        If the application's ``debug`` setting is ``True``, then we are\n        going to run in a single-process mode; otherwise, we'll let\n        tornado decide how many sub-processes based on the value of the\n        ``number_of_procs`` argument.  In any case, the application's\n        *before_run* callbacks are invoked.  If a callback raises an exception,\n        then the application is terminated by calling :func:`sys.exit`.\n        If any ``on_start`` callbacks are registered, they will be added to\n        the Tornado IOLoop for execution after the IOLoop is started.\n        The following additional configuration parameters can be set on the\n        ``httpserver.HTTPServer`` instance by setting them in the application\n        settings: ``xheaders``, ``max_body_size``, ``max_buffer_size``.\n              '''\n              pass\n\n    def _on_signal(self, signo, frame):\n        pass\n\n    def _shutdown(self):\n        pass\nCorresponding class implementation:\n\nimport sprockets.http.app\nimport logging\nimport sys\nfrom tornado import httpserver, ioloop\nimport signal\n\nclass Runner:\n    \"\"\"\n    HTTP service runner.\n\n    :param tornado.web.Application app: the application to serve\n\n    This class implements the logic necessary to safely run a\n    Tornado HTTP service inside of a docker container.\n\n    .. rubric:: Usage Example\n\n    .. code-block:: python\n\n       def make_app():\n           return web.Application(...)\n\n       def run():\n           server = runner.Runner(make_app())\n           server.start_server()\n           ioloop.IOLoop.instance().start()\n\n    The :meth:`.start_server` method sets up the necessary signal handling\n    to ensure that we have a clean shutdown in the face of signals.\n\n    \"\"\"\n\n    def __init__(self, app, before_run=None, on_start=None, shutdown=None):\n        \"\"\"Create a new instance of the runner.\n\n        :param tornado.web.Application app: The application instance to run\n        :param list before_run: Callbacks to invoke before starting\n        :param list on_start: Callbacks to invoke after starting the IOLoop\n        :param list shutdown: Callbacks to invoke on shutdown\n\n        \"\"\"\n        self.application = sprockets.http.app.wrap_application(app, before_run, on_start, shutdown)\n        self.logger = logging.getLogger('Runner')\n        self.server = None\n        self.shutdown_limit = 5.0\n        self.wait_timeout = 1.0\n\n    def start_server(self, port_number, number_of_procs=0):\n        \"\"\"\n        Create a HTTP server and start it.\n\n        :param int port_number: the port number to bind the server to\n        :param int number_of_procs: number of processes to pass to\n            Tornado's ``httpserver.HTTPServer.start``.\n\n        If the application's ``debug`` setting is ``True``, then we are\n        going to run in a single-process mode; otherwise, we'll let\n        tornado decide how many sub-processes to spawn.\n\n        The following additional configuration parameters can be set on the\n        ``httpserver.HTTPServer`` instance by setting them in the application\n        settings: ``xheaders``, ``max_body_size``, ``max_buffer_size``.\n\n        \"\"\"\n        signal.signal(signal.SIGTERM, self._on_signal)\n        signal.signal(signal.SIGINT, self._on_signal)\n        xheaders = self.application.settings.get('xheaders', True)\n        max_body_size = self.application.settings.get('max_body_size', None)\n        max_buffer_size = self.application.settings.get('max_buffer_size', None)\n        self.server = httpserver.HTTPServer(self.application.tornado_application, xheaders=xheaders, max_body_size=max_body_size, max_buffer_size=max_buffer_size)\n        if self.application.settings.get('debug', False):\n            self.logger.info('starting 1 process on port %d', port_number)\n            self.server.listen(port_number)\n        else:\n            self.logger.info('starting processes on port %d', port_number)\n            self.server.bind(port_number, reuse_port=True)\n            self.server.start(number_of_procs)\n\n    def stop_server(self):\n        \"\"\"Stop the HTTP Server\"\"\"\n        self.server.stop()\n\n    def run(self, port_number, number_of_procs=0):\n        \"\"\"\n        Create the server and run the IOLoop.\n\n        :param int port_number: the port number to bind the server to\n        :param int number_of_procs: number of processes to pass to\n            Tornado's ``httpserver.HTTPServer.start``.\n\n        If the application's ``debug`` setting is ``True``, then we are\n        going to run in a single-process mode; otherwise, we'll let\n        tornado decide how many sub-processes based on the value of the\n        ``number_of_procs`` argument.  In any case, the application's\n        *before_run* callbacks are invoked.  If a callback raises an exception,\n        then the application is terminated by calling :func:`sys.exit`.\n\n        If any ``on_start`` callbacks are registered, they will be added to\n        the Tornado IOLoop for execution after the IOLoop is started.\n\n        The following additional configuration parameters can be set on the\n        ``httpserver.HTTPServer`` instance by setting them in the application\n        settings: ``xheaders``, ``max_body_size``, ``max_buffer_size``.\n\n        \"\"\"\n        self.start_server(port_number, number_of_procs)\n        iol = ioloop.IOLoop.instance()\n        try:\n            self.application.start(iol)\n        except Exception:\n            self.logger.exception('application terminated during start, exiting')\n            sys.exit(70)\n        iol.start()\n\n    def _on_signal(self, signo, frame):\n        ioloop.IOLoop.instance().add_callback_from_signal(self._shutdown)\n\n    def _shutdown(self):\n        self.logger.debug('Shutting down')\n        self.stop_server()\n        self.application.stop(ioloop.IOLoop.instance(), self.shutdown_limit, self.wait_timeout)\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass WebProcessMixin:\n    '''\n    Mixin class for BedrockServerManager that handles direct Web UI process management.\n        '''\n\n    def start_web_ui_direct(self, app_context: AppContext, host: Optional[Union[str, List[str]]]=None, debug: bool=False, threads: Optional[int]=None) -> None:\n        '''Starts the Web UI application directly in the current process (blocking).\n        This method is intended for scenarios where the Web UI is launched with\n        the ``--mode direct`` command-line argument. It dynamically imports and\n        calls the :func:`~.web.app.run_web_server` function, which in turn\n        starts the Uvicorn server hosting the FastAPI application.\n        .. note::\n            This is a blocking call and will occupy the current process until the\n            web server is shut down.\n        Args:\n            host (Optional[Union[str, List[str]]]): The host address or list of\n                addresses for the web server to bind to. Passed directly to\n                :func:`~.web.app.run_web_server`. Defaults to ``None``.\n            debug (bool): If ``True``, runs the underlying Uvicorn/FastAPI app\n                in debug mode (e.g., with auto-reload). Passed directly to\n                :func:`~.web.app.run_web_server`. Defaults to ``False``.\n            threads (Optional[int]): Specifies the number of worker processes for Uvicorn\n                Only used for Windows Service\n        Raises:\n            RuntimeError: If :func:`~.web.app.run_web_server` raises a RuntimeError\n                (e.g., missing authentication environment variables).\n            ImportError: If the web application components (e.g.,\n                :func:`~.web.app.run_web_server`) cannot be imported.\n            Exception: Re-raises other exceptions from :func:`~.web.app.run_web_server`\n                if Uvicorn fails to start.\n        '''\n        pass\n\n    def get_web_ui_pid_path(self) -> str:\n        '''Returns the absolute path to the PID file for the detached Web UI server.\n        The PID file is typically stored in the application's configuration directory\n        (:attr:`._config_dir`) with the filename defined by\n        :attr:`._WEB_SERVER_PID_FILENAME`.\n        Returns:\n            str: The absolute path to the Web UI's PID file.\n        '''\n        pass\n\n    def get_web_ui_expected_start_arg(self) -> List[str]:\n        '''Returns the list of arguments used to identify a detached Web UI server process.\n        These arguments (defined by :attr:`._WEB_SERVER_START_ARG`) are typically\n        used by process management utilities to find and identify the correct\n        Web UI server process when it's run in a detached or background mode.\n        Returns:\n            List[str]: A list of command-line arguments.\n        '''\n        pass\n\n    def get_web_ui_executable_path(self) -> str:\n        '''Returns the path to the main application executable used for starting the Web UI.\n        This path, stored in :attr:`._expath`, is essential for constructing\n        commands to start the Web UI, especially for system services.\n        Returns:\n            str: The path to the application executable.\n        Raises:\n            ConfigurationError: If the application executable path (:attr:`._expath`)\n                is not configured or is empty.\n        '''\n        pass"
  }
]