[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass SearchSettingsConversationalSearch:\n    '''\n    Configuration settings for conversational search.\n    :param bool enabled: Whether to enable conversational search.\n    :param SearchSettingsConversationalSearchResponseLength response_length:\n          (optional)\n    :param SearchSettingsConversationalSearchSearchConfidence search_confidence:\n          (optional)\n    '''\n\n    def __init__(self, enabled: bool, *, response_length: Optional['SearchSettingsConversationalSearchResponseLength']=None, search_confidence: Optional['SearchSettingsConversationalSearchSearchConfidence']=None) -> None:\n        '''\n        Initialize a SearchSettingsConversationalSearch object.\n        :param bool enabled: Whether to enable conversational search.\n        :param SearchSettingsConversationalSearchResponseLength response_length:\n               (optional)\n        :param SearchSettingsConversationalSearchSearchConfidence\n               search_confidence: (optional)\n        '''\n        pass\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'SearchSettingsConversationalSearch':\n        '''Initialize a SearchSettingsConversationalSearch object from a json dictionary.'''\n        pass\n    @classmethod\n    def _from_dict(cls, _dict):\n        '''Initialize a SearchSettingsConversationalSearch object from a json dictionary.'''\n        pass\n\n    def to_dict(self) -> Dict:\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def _to_dict(self):\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Return a `str` version of this SearchSettingsConversationalSearch object.'''\n        pass\n\n    def __eq__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        '''Return `true` when self and other are equal, false otherwise.'''\n        pass\n\n    def __ne__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        '''Return `true` when self and other are not equal, false otherwise.'''\n        pass\nCorresponding class implementation:\n\nimport json\nfrom typing import BinaryIO, Dict, List, Optional\n\nclass SearchSettingsConversationalSearch:\n    \"\"\"\n    Configuration settings for conversational search.\n\n    :param bool enabled: Whether to enable conversational search.\n    :param SearchSettingsConversationalSearchResponseLength response_length:\n          (optional)\n    :param SearchSettingsConversationalSearchSearchConfidence search_confidence:\n          (optional)\n    \"\"\"\n\n    def __init__(self, enabled: bool, *, response_length: Optional['SearchSettingsConversationalSearchResponseLength']=None, search_confidence: Optional['SearchSettingsConversationalSearchSearchConfidence']=None) -> None:\n        \"\"\"\n        Initialize a SearchSettingsConversationalSearch object.\n\n        :param bool enabled: Whether to enable conversational search.\n        :param SearchSettingsConversationalSearchResponseLength response_length:\n               (optional)\n        :param SearchSettingsConversationalSearchSearchConfidence\n               search_confidence: (optional)\n        \"\"\"\n        self.enabled = enabled\n        self.response_length = response_length\n        self.search_confidence = search_confidence\n\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'SearchSettingsConversationalSearch':\n        \"\"\"Initialize a SearchSettingsConversationalSearch object from a json dictionary.\"\"\"\n        args = {}\n        if (enabled := _dict.get('enabled')) is not None:\n            args['enabled'] = enabled\n        else:\n            raise ValueError(\"Required property 'enabled' not present in SearchSettingsConversationalSearch JSON\")\n        if (response_length := _dict.get('response_length')) is not None:\n            args['response_length'] = SearchSettingsConversationalSearchResponseLength.from_dict(response_length)\n        if (search_confidence := _dict.get('search_confidence')) is not None:\n            args['search_confidence'] = SearchSettingsConversationalSearchSearchConfidence.from_dict(search_confidence)\n        return cls(**args)\n\n    @classmethod\n    def _from_dict(cls, _dict):\n        \"\"\"Initialize a SearchSettingsConversationalSearch object from a json dictionary.\"\"\"\n        return cls.from_dict(_dict)\n\n    def to_dict(self) -> Dict:\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        _dict = {}\n        if hasattr(self, 'enabled') and self.enabled is not None:\n            _dict['enabled'] = self.enabled\n        if hasattr(self, 'response_length') and self.response_length is not None:\n            if isinstance(self.response_length, dict):\n                _dict['response_length'] = self.response_length\n            else:\n                _dict['response_length'] = self.response_length.to_dict()\n        if hasattr(self, 'search_confidence') and self.search_confidence is not None:\n            if isinstance(self.search_confidence, dict):\n                _dict['search_confidence'] = self.search_confidence\n            else:\n                _dict['search_confidence'] = self.search_confidence.to_dict()\n        return _dict\n\n    def _to_dict(self):\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        return self.to_dict()\n\n    def __str__(self) -> str:\n        \"\"\"Return a `str` version of this SearchSettingsConversationalSearch object.\"\"\"\n        return json.dumps(self.to_dict(), indent=2)\n\n    def __eq__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        \"\"\"Return `true` when self and other are equal, false otherwise.\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other: 'SearchSettingsConversationalSearch') -> bool:\n        \"\"\"Return `true` when self and other are not equal, false otherwise.\"\"\"\n        return not self == other\n\nExample skeleton:\n\n\nclass StateTransitionWrapper(Generic[_P, _R, _T]):\n    '''\n    Wraps :class:`StateTransition` with the context of the object it is accessed from.\n    Automatically constructed by :class:`StateTransition`.\n        '''\n\n    def __init__(self, statetransition: StateTransition[_P, _R], obj: _T) -> None:\n        pass\n    @property\n    def data(self) -> dict[str, Any]:\n        '''Return data as provided to the :meth:`~StateManager.transition` decorator.'''\n        pass\n\n    def _validate_available(self) -> Optional[tuple[StateManager, Any, Any]]:\n        '''\n        If the state is invalid for the transition, return details on what didn't match.\n        :return: Tuple of (state manager, current state, label for current state)\n        '''\n        pass\n    @property\n    def is_available(self) -> bool:\n        '''Property that indicates whether this transition is currently available.'''\n        pass\n\n    def __getattr__(self, name: str) -> Any:\n        pass\n\n    def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -> _R:\n        '''Perform the state transition.'''\n        pass\nCorresponding class implementation:\n\nfrom typing import TYPE_CHECKING, Any, Callable, Generic, NoReturn, Optional, Union, cast, overload\nfrom ..utils import LabeledEnum, NameTitle, is_collection\n\nclass StateTransitionWrapper(Generic[_P, _R, _T]):\n    \"\"\"\n    Wraps :class:`StateTransition` with the context of the object it is accessed from.\n\n    Automatically constructed by :class:`StateTransition`.\n    \"\"\"\n\n    def __init__(self, statetransition: StateTransition[_P, _R], obj: _T) -> None:\n        self.statetransition = statetransition\n        self.obj = obj\n\n    @property\n    def data(self) -> dict[str, Any]:\n        \"\"\"Return data as provided to the :meth:`~StateManager.transition` decorator.\"\"\"\n        return self.statetransition.data\n\n    def _validate_available(self) -> Optional[tuple[StateManager, Any, Any]]:\n        \"\"\"\n        If the state is invalid for the transition, return details on what didn't match.\n\n        :return: Tuple of (state manager, current state, label for current state)\n        \"\"\"\n        for statemanager, conditions in self.statetransition.transitions.items():\n            current_state_value = statemanager._get_state_value(self.obj)\n            if conditions.from_ is None:\n                state_valid = True\n            else:\n                mstate = conditions.from_.get(current_state_value)\n                state_valid = mstate is not None and mstate.is_current_in(self.obj)\n            if not state_valid:\n                return (statemanager, current_state_value, statemanager.lenum.get(current_state_value))\n        return None\n\n    @property\n    def is_available(self) -> bool:\n        \"\"\"Property that indicates whether this transition is currently available.\"\"\"\n        return not self._validate_available()\n\n    def __getattr__(self, name: str) -> Any:\n        return getattr(self.statetransition, name)\n\n    def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -> _R:\n        \"\"\"Perform the state transition.\"\"\"\n        state_invalid = self._validate_available()\n        if state_invalid:\n            transition_error.send(self.obj, transition=self.statetransition, statemanager=state_invalid[0])\n            label = state_invalid[2]\n            if isinstance(label, NameTitle):\n                label = label.title\n            raise StateTransitionError(f'Invalid state for transition {self.statetransition.name}: {state_invalid[0]!r} = {label}')\n        transition_before.send(self.obj, transition=self.statetransition)\n        try:\n            result = self.statetransition.func(self.obj, *args, **kwargs)\n        except AbortTransition as e:\n            transition_exception.send(self.obj, transition=self.statetransition, exception=e)\n            return e.result\n        except Exception as e:\n            transition_exception.send(self.obj, transition=self.statetransition, exception=e)\n            raise\n        for statemanager, conditions in self.statetransition.transitions.items():\n            if conditions.to is not None:\n                statemanager._set_state_value(self.obj, conditions.to.value)\n        transition_after.send(self.obj, transition=self.statetransition)\n        return result\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass ServiceManager:\n    '''Singleton manager for LLM service instances.'''\n    @classmethod\n    def get_instance(cls):\n        '''Get the singleton instance of ServiceManager.'''\n        pass\n\n    def __init__(self):\n        '''Initialize the service manager with empty service instances.'''\n        pass\n\n    def _load_custom_provider_configs(self):\n        '''Loads configurations for custom LLM providers.'''\n        pass\n\n    def initialize_standalone_service(self, provider: str) -> BaseLLMService:\n        '''\n        Initializes and returns a new service instance for the specified provider.\n        This does not cache the service instance in self.services.\n        '''\n        pass\n\n    def get_service(self, provider: str) -> BaseLLMService:\n        '''\n        Get or create a service instance for the specified provider.\n        Caches the instance for subsequent calls.\n        Args:\n            provider: The provider name\n        Returns:\n            An instance of the appropriate LLM service\n        '''\n        pass\n\n    def set_model(self, provider: str, model_id: str) -> bool:\n        '''\n        Set the model for a specific provider.\n        Args:\n            provider: The provider name\n            model_id: The model ID to use\n        Returns:\n            True if successful, False otherwise\n        '''\n        pass"
  }
]