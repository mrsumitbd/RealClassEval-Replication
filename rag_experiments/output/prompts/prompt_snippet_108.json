[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass AttributeTypes(ObjectCollectionABC):\n    '''AttributeTypes Collection.\n    # Example of params input\n    {\n        \"result_limit\": 100,  # Limit the retrieved results.\n        \"result_start\": 10,  # Starting count used for pagination.\n        \"fields\": [\"caseId\", \"summary\"]  # Select additional return fields.\n    }\n    Args:\n        session (Session): Session object configured with TC API Auth.\n        tql_filters (list): List of TQL filters.\n        params (dict): Additional query params (see example above).\n    '''\n\n    def __init__(self, **kwargs):\n        '''Initialize instance properties.'''\n        pass\n\n    def __iter__(self) -> Iterator[AttributeType]:\n        '''Return CM objects.'''\n        pass\n    @property\n    def _api_endpoint(self) -> str:\n        '''Return the type specific API endpoint.'''\n        pass\n    @property\n    def filter(self) -> AttributeTypeFilter:\n        '''Return the type specific filter object.'''\n        pass\nCorresponding class implementation:\n\nfrom tcex.api.tc.v3.object_collection_abc import ObjectCollectionABC\nfrom tcex.api.tc.v3.attribute_types.attribute_type_filter import AttributeTypeFilter\nfrom tcex.api.tc.v3.api_endpoints import ApiEndpoints\nfrom tcex.api.tc.v3.attribute_types.attribute_type_model import AttributeTypeModel, AttributeTypesModel\nfrom collections.abc import Iterator\n\nclass AttributeTypes(ObjectCollectionABC):\n    \"\"\"AttributeTypes Collection.\n\n    # Example of params input\n    {\n        \"result_limit\": 100,  # Limit the retrieved results.\n        \"result_start\": 10,  # Starting count used for pagination.\n        \"fields\": [\"caseId\", \"summary\"]  # Select additional return fields.\n    }\n\n    Args:\n        session (Session): Session object configured with TC API Auth.\n        tql_filters (list): List of TQL filters.\n        params (dict): Additional query params (see example above).\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize instance properties.\"\"\"\n        super().__init__(kwargs.pop('session', None), kwargs.pop('tql_filter', None), kwargs.pop('params', None))\n        self._model = AttributeTypesModel(**kwargs)\n        self.type_ = 'attribute_types'\n\n    def __iter__(self) -> Iterator[AttributeType]:\n        \"\"\"Return CM objects.\"\"\"\n        return self.iterate(base_class=AttributeType)\n\n    @property\n    def _api_endpoint(self) -> str:\n        \"\"\"Return the type specific API endpoint.\"\"\"\n        return ApiEndpoints.ATTRIBUTE_TYPES.value\n\n    @property\n    def filter(self) -> AttributeTypeFilter:\n        \"\"\"Return the type specific filter object.\"\"\"\n        return AttributeTypeFilter(self.tql)\n\nExample skeleton:\n\n\nclass DialogSuggestionValue:\n    '''\n    An object defining the message input to be sent to the assistant if the user selects\n    the corresponding disambiguation option.\n     **Note:** This entire message input object must be included in the request body of\n    the next message sent to the assistant. Do not modify or remove any of the included\n    properties.\n    :param MessageInput input: (optional) An input object that includes the input\n          text.\n    '''\n\n    def __init__(self, *, input: Optional['MessageInput']=None) -> None:\n        '''\n        Initialize a DialogSuggestionValue object.\n        :param MessageInput input: (optional) An input object that includes the\n               input text.\n        '''\n        pass\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'DialogSuggestionValue':\n        '''Initialize a DialogSuggestionValue object from a json dictionary.'''\n        pass\n    @classmethod\n    def _from_dict(cls, _dict):\n        '''Initialize a DialogSuggestionValue object from a json dictionary.'''\n        pass\n\n    def to_dict(self) -> Dict:\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def _to_dict(self):\n        '''Return a json dictionary representing this model.'''\n        pass\n\n    def __str__(self) -> str:\n        '''Return a `str` version of this DialogSuggestionValue object.'''\n        pass\n\n    def __eq__(self, other: 'DialogSuggestionValue') -> bool:\n        '''Return `true` when self and other are equal, false otherwise.'''\n        pass\n\n    def __ne__(self, other: 'DialogSuggestionValue') -> bool:\n        '''Return `true` when self and other are not equal, false otherwise.'''\n        pass\nCorresponding class implementation:\n\nfrom typing import BinaryIO, Dict, List, Optional\nimport json\n\nclass DialogSuggestionValue:\n    \"\"\"\n    An object defining the message input to be sent to the assistant if the user selects\n    the corresponding disambiguation option.\n     **Note:** This entire message input object must be included in the request body of\n    the next message sent to the assistant. Do not modify or remove any of the included\n    properties.\n\n    :param MessageInput input: (optional) An input object that includes the input\n          text.\n    \"\"\"\n\n    def __init__(self, *, input: Optional['MessageInput']=None) -> None:\n        \"\"\"\n        Initialize a DialogSuggestionValue object.\n\n        :param MessageInput input: (optional) An input object that includes the\n               input text.\n        \"\"\"\n        self.input = input\n\n    @classmethod\n    def from_dict(cls, _dict: Dict) -> 'DialogSuggestionValue':\n        \"\"\"Initialize a DialogSuggestionValue object from a json dictionary.\"\"\"\n        args = {}\n        if (input := _dict.get('input')) is not None:\n            args['input'] = MessageInput.from_dict(input)\n        return cls(**args)\n\n    @classmethod\n    def _from_dict(cls, _dict):\n        \"\"\"Initialize a DialogSuggestionValue object from a json dictionary.\"\"\"\n        return cls.from_dict(_dict)\n\n    def to_dict(self) -> Dict:\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        _dict = {}\n        if hasattr(self, 'input') and self.input is not None:\n            if isinstance(self.input, dict):\n                _dict['input'] = self.input\n            else:\n                _dict['input'] = self.input.to_dict()\n        return _dict\n\n    def _to_dict(self):\n        \"\"\"Return a json dictionary representing this model.\"\"\"\n        return self.to_dict()\n\n    def __str__(self) -> str:\n        \"\"\"Return a `str` version of this DialogSuggestionValue object.\"\"\"\n        return json.dumps(self.to_dict(), indent=2)\n\n    def __eq__(self, other: 'DialogSuggestionValue') -> bool:\n        \"\"\"Return `true` when self and other are equal, false otherwise.\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other: 'DialogSuggestionValue') -> bool:\n        \"\"\"Return `true` when self and other are not equal, false otherwise.\"\"\"\n        return not self == other\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n@dataclass\nclass RecursiveLevel:\n    '''RecursiveLevels express the chunking rules at a specific level for the recursive chunker.\n    Attributes:\n        whitespace (bool): Whether to use whitespace as a delimiter.\n        delimiters (Optional[Union[str, List[str]]]): Custom delimiters for chunking.\n        include_delim (Optional[Literal[\"prev\", \"next\"]]): Whether to include the delimiter at all, or in the previous chunk, or the next chunk.\n        pattern (Optional[str]): Regex pattern for advanced splitting/extraction.\n        pattern_mode (Literal[\"split\", \"extract\"]): Whether to split on pattern matches or extract pattern matches.\n    '''\n\n    def _validate_fields(self) -> None:\n        '''Validate all fields have legal values.'''\n        pass\n\n    def __post_init__(self) -> None:\n        '''Validate attributes.'''\n        pass\n\n    def __repr__(self) -> str:\n        '''Return a string representation of the RecursiveLevel.'''\n        pass\n\n    def to_dict(self) -> dict:\n        '''Return the RecursiveLevel as a dictionary.'''\n        pass\n    @classmethod\n    def from_dict(cls, data: dict) -> 'RecursiveLevel':\n        '''Create RecursiveLevel object from a dictionary.'''\n        pass\n    @classmethod\n    def from_recipe(cls, name: str, lang: Optional[str]='en') -> 'RecursiveLevel':\n        '''Create RecursiveLevel object from a recipe.\n        The recipes are registered in the [Chonkie Recipe Store](https://huggingface.co/datasets/chonkie-ai/recipes). If the recipe is not there, you can create your own recipe and share it with the community!\n        Args:\n            name (str): The name of the recipe.\n            lang (Optional[str]): The language of the recipe.\n        Returns:\n            RecursiveLevel: The RecursiveLevel object.\n        Raises:\n            ValueError: If the recipe is not found.\n        '''\n        pass"
  }
]