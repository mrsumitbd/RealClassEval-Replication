[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass Metadata(UNTLElement):\n\n    def __init__(self, **kwargs):\n        pass\n\n    def create_xml_string(self):\n        '''Create a UNTL document in a string from a UNTL metadata\n        root object.\n        untl_xml_string = metadata_root_object.create_xml_string()\n        '''\n        pass\n\n    def create_xml_string(self):\n        '''Create an ElementTree representation of the object.'''\n        pass\n\n    def create_element_dict(self):\n        '''Convert a UNTL Python object into a UNTL Python dictionary.'''\n        pass\n\n    def create_xml_file(self, untl_filename):\n        '''Create a UNTL file.\n        Writes file to supplied file path.\n        '''\n        pass\n\n    def sort_untl(self, sort_structure):\n        '''Sort the UNTL Python object by the index\n        of a sort structure pre-ordered list.\n        '''\n        pass\n\n    def validate(self):\n        ''' Validate all of the UNTL elements.'''\n        pass\n\n    def generate_form_data(self, **kwargs):\n        '''Create a form dictionary with the key being the element name\n        and the value being a list of form element objects.\n        '''\n        pass\n\n    def make_hidden(self):\n        '''Make an unhidden record hidden.'''\n        pass\n\n    def make_unhidden(self):\n        '''Make a hidden record unhidden.'''\n        pass\n    @property\n    def is_hidden(self):\n        '''Return True if a UNTL element is hidden.'''\n        pass\nCorresponding class implementation:\n\nfrom lxml.etree import Element, SubElement, tostring\nimport sys\nfrom pyuntl import UNTL_XML_ORDER, VOCABULARIES_URL\n\nclass Metadata(UNTLElement):\n\n    def __init__(self, **kwargs):\n        self.tag = 'metadata'\n        self.allows_content = False\n        self.allows_qualifier = False\n        self.contained_children = ['title', 'identifier', 'note', 'institution', 'collection', 'subject', 'creator', 'primarySource', 'description', 'date', 'publisher', 'contributor', 'source', 'language', 'coverage', 'resourceType', 'relation', 'format', 'rights', 'degree', 'meta', 'citation']\n        super(Metadata, self).__init__(**kwargs)\n\n    def create_xml_string(self):\n        \"\"\"Create a UNTL document in a string from a UNTL metadata\n        root object.\n\n        untl_xml_string = metadata_root_object.create_xml_string()\n        \"\"\"\n        root = self.create_xml()\n        return b'<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' + tostring(root, encoding='UTF-8', xml_declaration=False, pretty_print=True)\n\n    def create_xml(self, useNamespace=False):\n        \"\"\"Create an ElementTree representation of the object.\"\"\"\n        UNTL_NAMESPACE = 'http://digital2.library.unt.edu/untl/'\n        UNTL = '{%s}' % UNTL_NAMESPACE\n        NSMAP = {'untl': UNTL_NAMESPACE}\n        if useNamespace:\n            root = Element(UNTL + self.tag, nsmap=NSMAP)\n        else:\n            root = Element(self.tag)\n        self.sort_untl(UNTL_XML_ORDER)\n        for element in self.children:\n            if useNamespace:\n                create_untl_xml_subelement(root, element, UNTL)\n            else:\n                create_untl_xml_subelement(root, element)\n        return root\n\n    def create_element_dict(self):\n        \"\"\"Convert a UNTL Python object into a UNTL Python dictionary.\"\"\"\n        untl_dict = {}\n        for element in self.children:\n            if element.tag not in untl_dict:\n                untl_dict[element.tag] = []\n            element_dict = {}\n            if element.qualifier is not None:\n                element_dict['qualifier'] = element.qualifier\n            if len(element.contained_children) > 0:\n                child_dict = {}\n                for child in element.children:\n                    if child.content is not None:\n                        child_dict[child.tag] = child.content\n                element_dict['content'] = child_dict\n            elif element.content is not None:\n                element_dict['content'] = element.content\n            untl_dict[element.tag].append(element_dict)\n        return untl_dict\n\n    def create_xml_file(self, untl_filename):\n        \"\"\"Create a UNTL file.\n\n        Writes file to supplied file path.\n        \"\"\"\n        try:\n            f = open(untl_filename, 'wb')\n            f.write(self.create_xml_string())\n            f.close()\n        except:\n            raise UNTLStructureException('Failed to create UNTL XML file. File: %s' % untl_filename)\n\n    def sort_untl(self, sort_structure):\n        \"\"\"Sort the UNTL Python object by the index\n        of a sort structure pre-ordered list.\n        \"\"\"\n        self.children.sort(key=lambda obj: sort_structure.index(obj.tag))\n\n    def validate(self):\n        \"\"\" Validate all of the UNTL elements.\"\"\"\n        pass\n\n    def generate_form_data(self, **kwargs):\n        \"\"\"Create a form dictionary with the key being the element name\n        and the value being a list of form element objects.\n        \"\"\"\n        self.children = add_missing_children(self.contained_children, self.children)\n        kwargs['children'] = self.children\n        return FormGenerator(**kwargs)\n\n    def make_hidden(self):\n        \"\"\"Make an unhidden record hidden.\"\"\"\n        for element in self.children:\n            if element.tag == 'meta' and element.qualifier == 'hidden':\n                if element.content == 'False':\n                    element.content = 'True'\n                return None\n        hidden_element = PYUNTL_DISPATCH['meta'](qualifier='hidden', content='True')\n        self.children.append(hidden_element)\n\n    def make_unhidden(self):\n        \"\"\"Make a hidden record unhidden.\"\"\"\n        for element in self.children:\n            if element.tag == 'meta' and element.qualifier == 'hidden':\n                if element.content == 'True':\n                    element.content = 'False'\n                return None\n        hidden_element = PYUNTL_DISPATCH['meta'](qualifier='hidden', content='False')\n        self.children.append(hidden_element)\n\n    @property\n    def is_hidden(self):\n        \"\"\"Return True if a UNTL element is hidden.\"\"\"\n        for element in self.children:\n            if element.tag == 'meta' and element.qualifier == 'hidden':\n                if element.content == 'True':\n                    return True\n                else:\n                    return False\n        sys.stderr.write('A hidden meta element does not exist.')\n        return False\n\nExample skeleton:\n\n\nclass Tag:\n    '''\n    Base Tag class for parsing and handling MT940 tag contents.\n        '''\n\n    def __init__(self) -> None:\n        pass\n\n    def parse(self, transactions: models.Transactions, value: str) -> dict[str, str | None]:\n        '''\n        Parses the given value using the Tag's pattern.\n        :param transactions: The transactions model instance.\n        :param value: The string value to parse.\n        :return: A dictionary of matched group values.\n        :raises RuntimeError: If parsing fails.\n        '''\n        pass\n\n    def _debug_partial_match(self, value: str) -> None:\n        '''\n        Helper function to debug partial matches against the pattern.\n        '''\n        pass\n\n    def __call__(self, transactions: models.Transactions, value: dict[str, typing.Any]) -> dict[str, typing.Any]:\n        '''\n        Processes the tag value and returns parsed content.\n        :param transactions: The transactions model instance.\n        :param value: The string value to process.\n        :return: The processed value, which can be a string or dict.\n        '''\n        pass\n\n    def __new__(cls, *args: typing.Any, **kwargs: typing.Any) -> Tag:\n        '''\n        Creates a new Tag instance and sets up logging details.\n        '''\n        pass\n\n    def __hash__(self) -> int:\n        '''\n        Returns a hash based on the tag's ID.\n        :return: The integer hash of the tag.\n        '''\n        pass\nCorresponding class implementation:\n\nimport logging\nimport re\nimport typing\nfrom . import models\n\nclass Tag:\n    \"\"\"\n    Base Tag class for parsing and handling MT940 tag contents.\n    \"\"\"\n    id: str | int = 0\n    RE_FLAGS = re.IGNORECASE | re.VERBOSE | re.UNICODE\n    scope: type[models.Transactions | models.Transaction] = models.Transactions\n    pattern: str\n    slug: str\n    logger: logging.Logger\n\n    def __init__(self) -> None:\n        self.re = re.compile(self.pattern, self.RE_FLAGS)\n\n    def parse(self, transactions: models.Transactions, value: str) -> dict[str, str | None]:\n        \"\"\"\n        Parses the given value using the Tag's pattern.\n\n        :param transactions: The transactions model instance.\n        :param value: The string value to parse.\n        :return: A dictionary of matched group values.\n        :raises RuntimeError: If parsing fails.\n        \"\"\"\n        match = self.re.match(value)\n        if match:\n            self.logger.debug('matched (%d) %r against \"%s\", got: %s', len(value), value, self.pattern, match.groupdict())\n            return match.groupdict()\n        else:\n            self.logger.error('matching id=%s (len=%d) \"%s\" against\\n    %s', self.id, len(value), value, self.pattern)\n            self._debug_partial_match(value)\n            raise RuntimeError(f'Unable to parse {self!r} from {value!r}', self, value)\n\n    def _debug_partial_match(self, value: str) -> None:\n        \"\"\"\n        Helper function to debug partial matches against the pattern.\n        \"\"\"\n        part_value = value\n        for pattern in self.pattern.split('\\n'):\n            match = re.match(pattern, part_value, self.RE_FLAGS)\n            if match:\n                self.logger.info('matched %r against %r, got: %s', pattern, match.group(0), match.groupdict())\n                part_value = part_value[len(match.group(0)):]\n            else:\n                self.logger.error('no match for %r against %r', pattern, part_value)\n\n    def __call__(self, transactions: models.Transactions, value: dict[str, typing.Any]) -> dict[str, typing.Any]:\n        \"\"\"\n        Processes the tag value and returns parsed content.\n\n        :param transactions: The transactions model instance.\n        :param value: The string value to process.\n        :return: The processed value, which can be a string or dict.\n        \"\"\"\n        return value\n\n    def __new__(cls, *args: typing.Any, **kwargs: typing.Any) -> Tag:\n        \"\"\"\n        Creates a new Tag instance and sets up logging details.\n        \"\"\"\n        cls.name = cls.__name__\n        words = re.findall('([A-Z][a-z]+)', cls.__name__)\n        cls.slug = '_'.join((w.lower() for w in words))\n        cls.logger = logger.getChild(cls.name)\n        return object.__new__(cls)\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Returns a hash based on the tag's ID.\n\n        :return: The integer hash of the tag.\n        \"\"\"\n        return hash(self.id) if isinstance(self.id, str) else self.id\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n\nclass Wheel:\n    '''A wheel file'''\n\n    def __init__(self, filename: str) -> None:\n        '''\n        :raises InvalidWheelFilename: when the filename is invalid for a wheel\n        '''\n        pass\n\n    def get_formatted_file_tags(self) -> List[str]:\n        '''Return the wheel's tags as a sorted list of strings.'''\n        pass\n\n    def support_index_min(self, tags: List[Tag]) -> int:\n        '''Return the lowest index that one of the wheel's file_tag combinations\n        achieves in the given list of supported tags.\n        For example, if there are 8 supported tags and one of the file tags\n        is first in the list, then return 0.\n        :param tags: the PEP 425 tags to check the wheel against, in order\n            with most preferred first.\n        :raises ValueError: If none of the wheel's file tags match one of\n            the supported tags.\n        '''\n        pass\n\n    def find_most_preferred_tag(self, tags: List[Tag], tag_to_priority: Dict[Tag, int]) -> int:\n        '''Return the priority of the most preferred tag that one of the wheel's file\n        tag combinations achieves in the given list of supported tags using the given\n        tag_to_priority mapping, where lower priorities are more-preferred.\n        This is used in place of support_index_min in some cases in order to avoid\n        an expensive linear scan of a large list of tags.\n        :param tags: the PEP 425 tags to check the wheel against.\n        :param tag_to_priority: a mapping from tag to priority of that tag, where\n            lower is more preferred.\n        :raises ValueError: If none of the wheel's file tags match one of\n            the supported tags.\n        '''\n        pass\n\n    def supported(self, tags: Iterable[Tag]) -> bool:\n        '''Return whether the wheel is compatible with one of the given tags.\n        :param tags: the PEP 425 tags to check the wheel against.\n        '''\n        pass"
  }
]