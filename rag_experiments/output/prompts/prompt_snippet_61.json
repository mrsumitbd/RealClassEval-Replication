[
  {
    "role": "assistant",
    "content": "You are an expert Python programmer who can correctly implement complete Python classes based on the provided class skeleton."
  },
  {
    "role": "user",
    "content": "For your understanding, following are some (skeleton, code) examples:\n\nExample skeleton:\n\n\nclass UserSource(Source):\n    '''\n    UserSource\n    '''\n\n    class Config:\n        '''Pydantic configuration'''\n\n    def to_str(self) -> str:\n        '''Returns the string representation of the model using alias'''\n        pass\n\n    def to_json(self) -> str:\n        '''Returns the JSON representation of the model using alias'''\n        pass\n    @classmethod\n    def from_json(cls, json_str: str) -> UserSource:\n        '''Create an instance of UserSource from a JSON string'''\n        pass\n\n    def to_dict(self):\n        '''Returns the dictionary representation of the model using alias'''\n        pass\n    @classmethod\n    def from_dict(cls, obj: dict) -> UserSource:\n        '''Create an instance of UserSource from a dict'''\n        pass\nCorresponding class implementation:\n\nfrom pydantic.v1 import Field, StrictStr\nimport pprint\nfrom typing import Optional\nimport json\nfrom linebot.v3.webhooks.models.source import Source\n\nclass UserSource(Source):\n    \"\"\"\n    UserSource\n    \"\"\"\n    user_id: Optional[StrictStr] = Field(None, alias='userId', description='ID of the source user')\n    type: str = 'user'\n    __properties = ['type', 'userId']\n\n    class Config:\n        \"\"\"Pydantic configuration\"\"\"\n        allow_population_by_field_name = True\n        validate_assignment = True\n\n    def to_str(self) -> str:\n        \"\"\"Returns the string representation of the model using alias\"\"\"\n        return pprint.pformat(self.dict(by_alias=True))\n\n    def to_json(self) -> str:\n        \"\"\"Returns the JSON representation of the model using alias\"\"\"\n        return json.dumps(self.to_dict())\n\n    @classmethod\n    def from_json(cls, json_str: str) -> UserSource:\n        \"\"\"Create an instance of UserSource from a JSON string\"\"\"\n        return cls.from_dict(json.loads(json_str))\n\n    def to_dict(self):\n        \"\"\"Returns the dictionary representation of the model using alias\"\"\"\n        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)\n        return _dict\n\n    @classmethod\n    def from_dict(cls, obj: dict) -> UserSource:\n        \"\"\"Create an instance of UserSource from a dict\"\"\"\n        if obj is None:\n            return None\n        if not isinstance(obj, dict):\n            return UserSource.parse_obj(obj)\n        _obj = UserSource.parse_obj({'type': obj.get('type'), 'user_id': obj.get('userId')})\n        return _obj\n\nExample skeleton:\n\n@dataclass\nclass CallFrame:\n    '''\n    Stack entry for runtime errors and assertions.\n    '''\n\n    def to_json(self) -> T_JSON_DICT:\n        pass\n    @classmethod\n    def from_json(cls, json: T_JSON_DICT) -> CallFrame:\n        pass\nCorresponding class implementation:\n\nfrom streamlink.webbrowser.cdp.devtools.util import T_JSON_DICT, event_class\nfrom dataclasses import dataclass\n\n@dataclass\nclass CallFrame:\n    \"\"\"\n    Stack entry for runtime errors and assertions.\n    \"\"\"\n    function_name: str\n    script_id: ScriptId\n    url: str\n    line_number: int\n    column_number: int\n\n    def to_json(self) -> T_JSON_DICT:\n        json: T_JSON_DICT = {}\n        json['functionName'] = self.function_name\n        json['scriptId'] = self.script_id.to_json()\n        json['url'] = self.url\n        json['lineNumber'] = self.line_number\n        json['columnNumber'] = self.column_number\n        return json\n\n    @classmethod\n    def from_json(cls, json: T_JSON_DICT) -> CallFrame:\n        return cls(function_name=str(json['functionName']), script_id=ScriptId.from_json(json['scriptId']), url=str(json['url']), line_number=int(json['lineNumber']), column_number=int(json['columnNumber']))\n\nNow, implement the following class. Do not explain the code. The given class skeleton is as follows:\n@dataclass\nclass Program:\n    '''Represents a program in the database'''\n\n    def to_dict(self) -> Dict[str, Any]:\n        '''Convert to dictionary representation'''\n        pass\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'Program':\n        '''Create from dictionary representation'''\n        pass"
  }
]